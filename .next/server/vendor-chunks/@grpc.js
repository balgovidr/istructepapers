"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@grpc";
exports.ids = ["vendor-chunks/@grpc"];
exports.modules = {

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/admin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addAdminServicesToServer = exports.registerAdminService = void 0;\nconst registeredAdminServices = [];\nfunction registerAdminService(getServiceDefinition, getHandlers) {\n    registeredAdminServices.push({\n        getServiceDefinition,\n        getHandlers\n    });\n}\nexports.registerAdminService = registerAdminService;\nfunction addAdminServicesToServer(server) {\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices){\n        server.addService(getServiceDefinition(), getHandlers());\n    }\n}\nexports.addAdminServicesToServer = addAdminServicesToServer; //# sourceMappingURL=admin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdDQUFnQyxHQUFHQSw0QkFBNEIsR0FBRyxLQUFLO0FBQ3ZFLE1BQU1JLDBCQUEwQixFQUFFO0FBQ2xDLFNBQVNELHFCQUFxQkUsb0JBQW9CLEVBQUVDLFdBQVc7SUFDM0RGLHdCQUF3QkcsSUFBSSxDQUFDO1FBQUVGO1FBQXNCQztJQUFZO0FBQ3JFO0FBQ0FOLDRCQUE0QixHQUFHRztBQUMvQixTQUFTRCx5QkFBeUJNLE1BQU07SUFDcEMsS0FBSyxNQUFNLEVBQUVILG9CQUFvQixFQUFFQyxXQUFXLEVBQUUsSUFBSUYsd0JBQXlCO1FBQ3pFSSxPQUFPQyxVQUFVLENBQUNKLHdCQUF3QkM7SUFDOUM7QUFDSjtBQUNBTixnQ0FBZ0MsR0FBR0UsMEJBQ25DLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2FkbWluLmpzPzk4NGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyID0gZXhwb3J0cy5yZWdpc3RlckFkbWluU2VydmljZSA9IHZvaWQgMDtcbmNvbnN0IHJlZ2lzdGVyZWRBZG1pblNlcnZpY2VzID0gW107XG5mdW5jdGlvbiByZWdpc3RlckFkbWluU2VydmljZShnZXRTZXJ2aWNlRGVmaW5pdGlvbiwgZ2V0SGFuZGxlcnMpIHtcbiAgICByZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcy5wdXNoKHsgZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzIH0pO1xufVxuZXhwb3J0cy5yZWdpc3RlckFkbWluU2VydmljZSA9IHJlZ2lzdGVyQWRtaW5TZXJ2aWNlO1xuZnVuY3Rpb24gYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyKHNlcnZlcikge1xuICAgIGZvciAoY29uc3QgeyBnZXRTZXJ2aWNlRGVmaW5pdGlvbiwgZ2V0SGFuZGxlcnMgfSBvZiByZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcykge1xuICAgICAgICBzZXJ2ZXIuYWRkU2VydmljZShnZXRTZXJ2aWNlRGVmaW5pdGlvbigpLCBnZXRIYW5kbGVycygpKTtcbiAgICB9XG59XG5leHBvcnRzLmFkZEFkbWluU2VydmljZXNUb1NlcnZlciA9IGFkZEFkbWluU2VydmljZXNUb1NlcnZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkbWluLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZEFkbWluU2VydmljZXNUb1NlcnZlciIsInJlZ2lzdGVyQWRtaW5TZXJ2aWNlIiwicmVnaXN0ZXJlZEFkbWluU2VydmljZXMiLCJnZXRTZXJ2aWNlRGVmaW5pdGlvbiIsImdldEhhbmRsZXJzIiwicHVzaCIsInNlcnZlciIsImFkZFNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */ function uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options){\n        this.callback = callback;\n        /**\n         * The delay time at the start, and after each reset.\n         */ this.initialDelay = INITIAL_BACKOFF_MS;\n        /**\n         * The exponential backoff multiplier.\n         */ this.multiplier = BACKOFF_MULTIPLIER;\n        /**\n         * The maximum delay time\n         */ this.maxDelay = MAX_BACKOFF_MS;\n        /**\n         * The maximum fraction by which the delay time can randomly vary after\n         * applying the multiplier.\n         */ this.jitter = BACKOFF_JITTER;\n        /**\n         * Indicates whether the timer is currently running.\n         */ this.running = false;\n        /**\n         * Indicates whether the timer should keep the Node process running if no\n         * other async operation is doing so.\n         */ this.hasRef = true;\n        /**\n         * The time that the currently running timer was started. Only valid if\n         * running is true.\n         */ this.startTime = new Date();\n        /**\n         * The approximate time that the currently running timer will end. Only valid\n         * if running is true.\n         */ this.endTime = new Date();\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(()=>{}, 0);\n        clearTimeout(this.timerId);\n    }\n    runTimer(delay) {\n        var _a, _b;\n        this.endTime = this.startTime;\n        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);\n        clearTimeout(this.timerId);\n        this.timerId = setTimeout(()=>{\n            this.callback();\n            this.running = false;\n        }, delay);\n        if (!this.hasRef) {\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */ runOnce() {\n        this.running = true;\n        this.startTime = new Date();\n        this.runTimer(this.nextDelay);\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */ stop() {\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value. If the timer is still running,\n     * retroactively apply that reset to the current timer.\n     */ reset() {\n        this.nextDelay = this.initialDelay;\n        if (this.running) {\n            const now = new Date();\n            const newEndTime = this.startTime;\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n            clearTimeout(this.timerId);\n            if (now < newEndTime) {\n                this.runTimer(newEndTime.getTime() - now.getTime());\n            } else {\n                this.running = false;\n            }\n        }\n    }\n    /**\n     * Check whether the timer is currently running.\n     */ isRunning() {\n        return this.running;\n    }\n    /**\n     * Set that while the timer is running, it should keep the Node process\n     * running.\n     */ ref() {\n        var _a, _b;\n        this.hasRef = true;\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Set that while the timer is running, it should not keep the Node process\n     * running.\n     */ unref() {\n        var _a, _b;\n        this.hasRef = false;\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Get the approximate timestamp of when the timer will fire. Only valid if\n     * this.isRunning() is true.\n     */ getEndTime() {\n        return this.endTime;\n    }\n}\nexports.BackoffTimeout = BackoffTimeout; //# sourceMappingURL=backoff-timeout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLE1BQU1HLHFCQUFxQjtBQUMzQixNQUFNQyxxQkFBcUI7QUFDM0IsTUFBTUMsaUJBQWlCO0FBQ3ZCLE1BQU1DLGlCQUFpQjtBQUN2Qjs7OztDQUlDLEdBQ0QsU0FBU0MsY0FBY0MsR0FBRyxFQUFFQyxHQUFHO0lBQzNCLE9BQU9DLEtBQUtDLE1BQU0sS0FBTUYsQ0FBQUEsTUFBTUQsR0FBRSxJQUFLQTtBQUN6QztBQUNBLE1BQU1OO0lBQ0ZVLFlBQVlDLFFBQVEsRUFBRUMsT0FBTyxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQjs7U0FFQyxHQUNELElBQUksQ0FBQ0UsWUFBWSxHQUFHWjtRQUNwQjs7U0FFQyxHQUNELElBQUksQ0FBQ2EsVUFBVSxHQUFHWjtRQUNsQjs7U0FFQyxHQUNELElBQUksQ0FBQ2EsUUFBUSxHQUFHWjtRQUNoQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNhLE1BQU0sR0FBR1o7UUFDZDs7U0FFQyxHQUNELElBQUksQ0FBQ2EsT0FBTyxHQUFHO1FBQ2Y7OztTQUdDLEdBQ0QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZDs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJQztRQUNyQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJRDtRQUNuQixJQUFJUixTQUFTO1lBQ1QsSUFBSUEsUUFBUUMsWUFBWSxFQUFFO2dCQUN0QixJQUFJLENBQUNBLFlBQVksR0FBR0QsUUFBUUMsWUFBWTtZQUM1QztZQUNBLElBQUlELFFBQVFFLFVBQVUsRUFBRTtnQkFDcEIsSUFBSSxDQUFDQSxV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QUlDO1FBQ1IsSUFBSSxDQUFDWCxNQUFNLEdBQUc7UUFDYlcsQ0FBQUEsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ0wsT0FBTyxFQUFFUyxLQUFLLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxJQUFJLENBQUNMO0lBQ2xGO0lBQ0E7OztLQUdDLEdBQ0RnQixhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUN2QixPQUFPO0lBQ3ZCO0FBQ0o7QUFDQXZCLHNCQUFzQixHQUFHRSxnQkFDekIsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzP2ZlNDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFja29mZlRpbWVvdXQgPSB2b2lkIDA7XG5jb25zdCBJTklUSUFMX0JBQ0tPRkZfTVMgPSAxMDAwO1xuY29uc3QgQkFDS09GRl9NVUxUSVBMSUVSID0gMS42O1xuY29uc3QgTUFYX0JBQ0tPRkZfTVMgPSAxMjAwMDA7XG5jb25zdCBCQUNLT0ZGX0pJVFRFUiA9IDAuMjtcbi8qKlxuICogR2V0IGEgbnVtYmVyIHVuaWZvcm1seSBhdCByYW5kb20gaW4gdGhlIHJhbmdlIFttaW4sIG1heClcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqL1xuZnVuY3Rpb24gdW5pZm9ybVJhbmRvbShtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG59XG5jbGFzcyBCYWNrb2ZmVGltZW91dCB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlbGF5IHRpbWUgYXQgdGhlIHN0YXJ0LCBhbmQgYWZ0ZXIgZWFjaCByZXNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbERlbGF5ID0gSU5JVElBTF9CQUNLT0ZGX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGV4cG9uZW50aWFsIGJhY2tvZmYgbXVsdGlwbGllci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXVsdGlwbGllciA9IEJBQ0tPRkZfTVVMVElQTElFUjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIGRlbGF5IHRpbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4RGVsYXkgPSBNQVhfQkFDS09GRl9NUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIGZyYWN0aW9uIGJ5IHdoaWNoIHRoZSBkZWxheSB0aW1lIGNhbiByYW5kb21seSB2YXJ5IGFmdGVyXG4gICAgICAgICAqIGFwcGx5aW5nIHRoZSBtdWx0aXBsaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5qaXR0ZXIgPSBCQUNLT0ZGX0pJVFRFUjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0aW1lciBpcyBjdXJyZW50bHkgcnVubmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVyIHNob3VsZCBrZWVwIHRoZSBOb2RlIHByb2Nlc3MgcnVubmluZyBpZiBub1xuICAgICAgICAgKiBvdGhlciBhc3luYyBvcGVyYXRpb24gaXMgZG9pbmcgc28uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc1JlZiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSB0aGF0IHRoZSBjdXJyZW50bHkgcnVubmluZyB0aW1lciB3YXMgc3RhcnRlZC4gT25seSB2YWxpZCBpZlxuICAgICAgICAgKiBydW5uaW5nIGlzIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXBwcm94aW1hdGUgdGltZSB0aGF0IHRoZSBjdXJyZW50bHkgcnVubmluZyB0aW1lciB3aWxsIGVuZC4gT25seSB2YWxpZFxuICAgICAgICAgKiBpZiBydW5uaW5nIGlzIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5pdGlhbERlbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsRGVsYXkgPSBvcHRpb25zLmluaXRpYWxEZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSBvcHRpb25zLm11bHRpcGxpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5qaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmppdHRlciA9IG9wdGlvbnMuaml0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF4RGVsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1heERlbGF5ID0gb3B0aW9ucy5tYXhEZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHREZWxheSA9IHRoaXMuaW5pdGlhbERlbGF5O1xuICAgICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgIH1cbiAgICBydW5UaW1lcihkZWxheSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5lbmRUaW1lLnNldE1pbGxpc2Vjb25kcyh0aGlzLmVuZFRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aGlzLm5leHREZWxheSk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIGlmICghdGhpcy5oYXNSZWYpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBjYWxsYmFjayBhZnRlciB0aGUgY3VycmVudCBhbW91bnQgb2YgZGVsYXkgdGltZVxuICAgICAqL1xuICAgIHJ1bk9uY2UoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5ydW5UaW1lcih0aGlzLm5leHREZWxheSk7XG4gICAgICAgIGNvbnN0IG5leHRCYWNrb2ZmID0gTWF0aC5taW4odGhpcy5uZXh0RGVsYXkgKiB0aGlzLm11bHRpcGxpZXIsIHRoaXMubWF4RGVsYXkpO1xuICAgICAgICBjb25zdCBqaXR0ZXJNYWduaXR1ZGUgPSBuZXh0QmFja29mZiAqIHRoaXMuaml0dGVyO1xuICAgICAgICB0aGlzLm5leHREZWxheSA9XG4gICAgICAgICAgICBuZXh0QmFja29mZiArIHVuaWZvcm1SYW5kb20oLWppdHRlck1hZ25pdHVkZSwgaml0dGVyTWFnbml0dWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgdGltZXIuIFRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgdW50aWwgYHJ1bk9uY2VgIGlzIGNhbGxlZFxuICAgICAqIGFnYWluLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGRlbGF5IHRpbWUgdG8gaXRzIGluaXRpYWwgdmFsdWUuIElmIHRoZSB0aW1lciBpcyBzdGlsbCBydW5uaW5nLFxuICAgICAqIHJldHJvYWN0aXZlbHkgYXBwbHkgdGhhdCByZXNldCB0byB0aGUgY3VycmVudCB0aW1lci5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPSB0aGlzLmluaXRpYWxEZWxheTtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIG5ld0VuZFRpbWUuc2V0TWlsbGlzZWNvbmRzKG5ld0VuZFRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aGlzLm5leHREZWxheSk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgICAgIGlmIChub3cgPCBuZXdFbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lcihuZXdFbmRUaW1lLmdldFRpbWUoKSAtIG5vdy5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgdGltZXIgaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAgICovXG4gICAgaXNSdW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhhdCB3aGlsZSB0aGUgdGltZXIgaXMgcnVubmluZywgaXQgc2hvdWxkIGtlZXAgdGhlIE5vZGUgcHJvY2Vzc1xuICAgICAqIHJ1bm5pbmcuXG4gICAgICovXG4gICAgcmVmKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmhhc1JlZiA9IHRydWU7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGF0IHdoaWxlIHRoZSB0aW1lciBpcyBydW5uaW5nLCBpdCBzaG91bGQgbm90IGtlZXAgdGhlIE5vZGUgcHJvY2Vzc1xuICAgICAqIHJ1bm5pbmcuXG4gICAgICovXG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuaGFzUmVmID0gZmFsc2U7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhcHByb3hpbWF0ZSB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgdGltZXIgd2lsbCBmaXJlLiBPbmx5IHZhbGlkIGlmXG4gICAgICogdGhpcy5pc1J1bm5pbmcoKSBpcyB0cnVlLlxuICAgICAqL1xuICAgIGdldEVuZFRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZFRpbWU7XG4gICAgfVxufVxuZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IEJhY2tvZmZUaW1lb3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja29mZi10aW1lb3V0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhY2tvZmZUaW1lb3V0IiwiSU5JVElBTF9CQUNLT0ZGX01TIiwiQkFDS09GRl9NVUxUSVBMSUVSIiwiTUFYX0JBQ0tPRkZfTVMiLCJCQUNLT0ZGX0pJVFRFUiIsInVuaWZvcm1SYW5kb20iLCJtaW4iLCJtYXgiLCJNYXRoIiwicmFuZG9tIiwiY29uc3RydWN0b3IiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJpbml0aWFsRGVsYXkiLCJtdWx0aXBsaWVyIiwibWF4RGVsYXkiLCJqaXR0ZXIiLCJydW5uaW5nIiwiaGFzUmVmIiwic3RhcnRUaW1lIiwiRGF0ZSIsImVuZFRpbWUiLCJuZXh0RGVsYXkiLCJ0aW1lcklkIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVyIiwiZGVsYXkiLCJfYSIsIl9iIiwic2V0TWlsbGlzZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwidW5yZWYiLCJjYWxsIiwicnVuT25jZSIsIm5leHRCYWNrb2ZmIiwiaml0dGVyTWFnbml0dWRlIiwic3RvcCIsInJlc2V0Iiwibm93IiwibmV3RW5kVGltZSIsImdldFRpbWUiLCJpc1J1bm5pbmciLCJyZWYiLCJnZXRFbmRUaW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CallCredentials = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction isCurrentOauth2Client(client) {\n    return \"getRequestHeaders\" in client && typeof client.getRequestHeaders === \"function\";\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */ class CallCredentials {\n    /**\n     * Creates a new CallCredentials object from a given function that generates\n     * Metadata objects.\n     * @param metadataGenerator A function that accepts a set of options, and\n     * generates a Metadata object based on these options, which is passed back\n     * to the caller via a supplied (err, metadata) callback.\n     */ static createFromMetadataGenerator(metadataGenerator) {\n        return new SingleCallCredentials(metadataGenerator);\n    }\n    /**\n     * Create a gRPC credential from a Google credential object.\n     * @param googleCredentials The authentication client to use.\n     * @return The resulting CallCredentials object.\n     */ static createFromGoogleCredential(googleCredentials) {\n        return CallCredentials.createFromMetadataGenerator((options, callback)=>{\n            let getHeaders;\n            if (isCurrentOauth2Client(googleCredentials)) {\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n            } else {\n                getHeaders = new Promise((resolve, reject)=>{\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers)=>{\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        if (!headers) {\n                            reject(new Error(\"Headers not set by metadata plugin\"));\n                            return;\n                        }\n                        resolve(headers);\n                    });\n                });\n            }\n            getHeaders.then((headers)=>{\n                const metadata = new metadata_1.Metadata();\n                for (const key of Object.keys(headers)){\n                    metadata.add(key, headers[key]);\n                }\n                callback(null, metadata);\n            }, (err)=>{\n                callback(err);\n            });\n        });\n    }\n    static createEmpty() {\n        return new EmptyCallCredentials();\n    }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n    constructor(creds){\n        super();\n        this.creds = creds;\n    }\n    async generateMetadata(options) {\n        const base = new metadata_1.Metadata();\n        const generated = await Promise.all(this.creds.map((cred)=>cred.generateMetadata(options)));\n        for (const gen of generated){\n            base.merge(gen);\n        }\n        return base;\n    }\n    compose(other) {\n        return new ComposedCallCredentials(this.creds.concat([\n            other\n        ]));\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedCallCredentials) {\n            return this.creds.every((value, index)=>value._equals(other.creds[index]));\n        } else {\n            return false;\n        }\n    }\n}\nclass SingleCallCredentials extends CallCredentials {\n    constructor(metadataGenerator){\n        super();\n        this.metadataGenerator = metadataGenerator;\n    }\n    generateMetadata(options) {\n        return new Promise((resolve, reject)=>{\n            this.metadataGenerator(options, (err, metadata)=>{\n                if (metadata !== undefined) {\n                    resolve(metadata);\n                } else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    compose(other) {\n        return new ComposedCallCredentials([\n            this,\n            other\n        ]);\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SingleCallCredentials) {\n            return this.metadataGenerator === other.metadataGenerator;\n        } else {\n            return false;\n        }\n    }\n}\nclass EmptyCallCredentials extends CallCredentials {\n    generateMetadata(options) {\n        return Promise.resolve(new metadata_1.Metadata());\n    }\n    compose(other) {\n        return other;\n    }\n    _equals(other) {\n        return other instanceof EmptyCallCredentials;\n    }\n} //# sourceMappingURL=call-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxTQUFTQyxzQkFBc0JDLE1BQU07SUFDakMsT0FBUSx1QkFBdUJBLFVBQzNCLE9BQU9BLE9BQU9DLGlCQUFpQixLQUFLO0FBQzVDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUw7SUFDRjs7Ozs7O0tBTUMsR0FDRCxPQUFPTSw0QkFBNEJDLGlCQUFpQixFQUFFO1FBQ2xELE9BQU8sSUFBSUMsc0JBQXNCRDtJQUNyQztJQUNBOzs7O0tBSUMsR0FDRCxPQUFPRSwyQkFBMkJDLGlCQUFpQixFQUFFO1FBQ2pELE9BQU9WLGdCQUFnQk0sMkJBQTJCLENBQUMsQ0FBQ0ssU0FBU0M7WUFDekQsSUFBSUM7WUFDSixJQUFJVixzQkFBc0JPLG9CQUFvQjtnQkFDMUNHLGFBQWFILGtCQUFrQkwsaUJBQWlCLENBQUNNLFFBQVFHLFdBQVc7WUFDeEUsT0FDSztnQkFDREQsYUFBYSxJQUFJRSxRQUFRLENBQUNDLFNBQVNDO29CQUMvQlAsa0JBQWtCUSxrQkFBa0IsQ0FBQ1AsUUFBUUcsV0FBVyxFQUFFLENBQUNLLEtBQUtDO3dCQUM1RCxJQUFJRCxLQUFLOzRCQUNMRixPQUFPRTs0QkFDUDt3QkFDSjt3QkFDQSxJQUFJLENBQUNDLFNBQVM7NEJBQ1ZILE9BQU8sSUFBSUksTUFBTTs0QkFDakI7d0JBQ0o7d0JBQ0FMLFFBQVFJO29CQUNaO2dCQUNKO1lBQ0o7WUFDQVAsV0FBV1MsSUFBSSxDQUFDRixDQUFBQTtnQkFDWixNQUFNRyxXQUFXLElBQUl0QixXQUFXdUIsUUFBUTtnQkFDeEMsS0FBSyxNQUFNQyxPQUFPN0IsT0FBTzhCLElBQUksQ0FBQ04sU0FBVTtvQkFDcENHLFNBQVNJLEdBQUcsQ0FBQ0YsS0FBS0wsT0FBTyxDQUFDSyxJQUFJO2dCQUNsQztnQkFDQWIsU0FBUyxNQUFNVztZQUNuQixHQUFHSixDQUFBQTtnQkFDQ1AsU0FBU087WUFDYjtRQUNKO0lBQ0o7SUFDQSxPQUFPUyxjQUFjO1FBQ2pCLE9BQU8sSUFBSUM7SUFDZjtBQUNKO0FBQ0EvQix1QkFBdUIsR0FBR0U7QUFDMUIsTUFBTThCLGdDQUFnQzlCO0lBQ2xDK0IsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsS0FBSztRQUNMLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE1BQU1DLGlCQUFpQnRCLE9BQU8sRUFBRTtRQUM1QixNQUFNdUIsT0FBTyxJQUFJakMsV0FBV3VCLFFBQVE7UUFDcEMsTUFBTVcsWUFBWSxNQUFNcEIsUUFBUXFCLEdBQUcsQ0FBQyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ssR0FBRyxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLTCxnQkFBZ0IsQ0FBQ3RCO1FBQ2pGLEtBQUssTUFBTTRCLE9BQU9KLFVBQVc7WUFDekJELEtBQUtNLEtBQUssQ0FBQ0Q7UUFDZjtRQUNBLE9BQU9MO0lBQ1g7SUFDQU8sUUFBUUMsS0FBSyxFQUFFO1FBQ1gsT0FBTyxJQUFJWix3QkFBd0IsSUFBSSxDQUFDRSxLQUFLLENBQUNXLE1BQU0sQ0FBQztZQUFDRDtTQUFNO0lBQ2hFO0lBQ0FFLFFBQVFGLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLQSxPQUFPO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUlBLGlCQUFpQloseUJBQXlCO1lBQzFDLE9BQU8sSUFBSSxDQUFDRSxLQUFLLENBQUNhLEtBQUssQ0FBQyxDQUFDOUMsT0FBTytDLFFBQVUvQyxNQUFNNkMsT0FBTyxDQUFDRixNQUFNVixLQUFLLENBQUNjLE1BQU07UUFDOUUsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSxNQUFNdEMsOEJBQThCUjtJQUNoQytCLFlBQVl4QixpQkFBaUIsQ0FBRTtRQUMzQixLQUFLO1FBQ0wsSUFBSSxDQUFDQSxpQkFBaUIsR0FBR0E7SUFDN0I7SUFDQTBCLGlCQUFpQnRCLE9BQU8sRUFBRTtRQUN0QixPQUFPLElBQUlJLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekIsSUFBSSxDQUFDVixpQkFBaUIsQ0FBQ0ksU0FBUyxDQUFDUSxLQUFLSTtnQkFDbEMsSUFBSUEsYUFBYXdCLFdBQVc7b0JBQ3hCL0IsUUFBUU87Z0JBQ1osT0FDSztvQkFDRE4sT0FBT0U7Z0JBQ1g7WUFDSjtRQUNKO0lBQ0o7SUFDQXNCLFFBQVFDLEtBQUssRUFBRTtRQUNYLE9BQU8sSUFBSVosd0JBQXdCO1lBQUMsSUFBSTtZQUFFWTtTQUFNO0lBQ3BEO0lBQ0FFLFFBQVFGLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLQSxPQUFPO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUlBLGlCQUFpQmxDLHVCQUF1QjtZQUN4QyxPQUFPLElBQUksQ0FBQ0QsaUJBQWlCLEtBQUttQyxNQUFNbkMsaUJBQWlCO1FBQzdELE9BQ0s7WUFDRCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0EsTUFBTXNCLDZCQUE2QjdCO0lBQy9CaUMsaUJBQWlCdEIsT0FBTyxFQUFFO1FBQ3RCLE9BQU9JLFFBQVFDLE9BQU8sQ0FBQyxJQUFJZixXQUFXdUIsUUFBUTtJQUNsRDtJQUNBaUIsUUFBUUMsS0FBSyxFQUFFO1FBQ1gsT0FBT0E7SUFDWDtJQUNBRSxRQUFRRixLQUFLLEVBQUU7UUFDWCxPQUFPQSxpQkFBaUJiO0lBQzVCO0FBQ0osRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLWNyZWRlbnRpYWxzLmpzPzI4YjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuZnVuY3Rpb24gaXNDdXJyZW50T2F1dGgyQ2xpZW50KGNsaWVudCkge1xuICAgIHJldHVybiAoJ2dldFJlcXVlc3RIZWFkZXJzJyBpbiBjbGllbnQgJiZcbiAgICAgICAgdHlwZW9mIGNsaWVudC5nZXRSZXF1ZXN0SGVhZGVycyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZ2VuZXJpYyBtZXRob2Qgb2YgYWRkaW5nIGF1dGhlbnRpY2F0aW9uLXJlbGF0ZWRcbiAqIG1ldGFkYXRhIG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMuXG4gKi9cbmNsYXNzIENhbGxDcmVkZW50aWFscyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0IGZyb20gYSBnaXZlbiBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlc1xuICAgICAqIE1ldGFkYXRhIG9iamVjdHMuXG4gICAgICogQHBhcmFtIG1ldGFkYXRhR2VuZXJhdG9yIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgc2V0IG9mIG9wdGlvbnMsIGFuZFxuICAgICAqIGdlbmVyYXRlcyBhIE1ldGFkYXRhIG9iamVjdCBiYXNlZCBvbiB0aGVzZSBvcHRpb25zLCB3aGljaCBpcyBwYXNzZWQgYmFja1xuICAgICAqIHRvIHRoZSBjYWxsZXIgdmlhIGEgc3VwcGxpZWQgKGVyciwgbWV0YWRhdGEpIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IobWV0YWRhdGFHZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVDYWxsQ3JlZGVudGlhbHMobWV0YWRhdGFHZW5lcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBnUlBDIGNyZWRlbnRpYWwgZnJvbSBhIEdvb2dsZSBjcmVkZW50aWFsIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gZ29vZ2xlQ3JlZGVudGlhbHMgVGhlIGF1dGhlbnRpY2F0aW9uIGNsaWVudCB0byB1c2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENhbGxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsKGdvb2dsZUNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHJldHVybiBDYWxsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yKChvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgbGV0IGdldEhlYWRlcnM7XG4gICAgICAgICAgICBpZiAoaXNDdXJyZW50T2F1dGgyQ2xpZW50KGdvb2dsZUNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgIGdldEhlYWRlcnMgPSBnb29nbGVDcmVkZW50aWFscy5nZXRSZXF1ZXN0SGVhZGVycyhvcHRpb25zLnNlcnZpY2VfdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldEhlYWRlcnMgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZUNyZWRlbnRpYWxzLmdldFJlcXVlc3RNZXRhZGF0YShvcHRpb25zLnNlcnZpY2VfdXJsLCAoZXJyLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignSGVhZGVycyBub3Qgc2V0IGJ5IG1ldGFkYXRhIHBsdWdpbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldEhlYWRlcnMudGhlbihoZWFkZXJzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuYWRkKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlDYWxsQ3JlZGVudGlhbHMoKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IENhbGxDcmVkZW50aWFscztcbmNsYXNzIENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzIGV4dGVuZHMgQ2FsbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjcmVkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNyZWRzID0gY3JlZHM7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xuICAgICAgICBjb25zdCBiYXNlID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jcmVkcy5tYXAoY3JlZCA9PiBjcmVkLmdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykpKTtcbiAgICAgICAgZm9yIChjb25zdCBnZW4gb2YgZ2VuZXJhdGVkKSB7XG4gICAgICAgICAgICBiYXNlLm1lcmdlKGdlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENhbGxDcmVkZW50aWFscyh0aGlzLmNyZWRzLmNvbmNhdChbb3RoZXJdKSk7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NlZENhbGxDcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlZHMuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUuX2VxdWFscyhvdGhlci5jcmVkc1tpbmRleF0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNpbmdsZUNhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IobWV0YWRhdGFHZW5lcmF0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9IG1ldGFkYXRhR2VuZXJhdG9yO1xuICAgIH1cbiAgICBnZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFHZW5lcmF0b3Iob3B0aW9ucywgKGVyciwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcG9zZShvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKFt0aGlzLCBvdGhlcl0pO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgU2luZ2xlQ2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9PT0gb3RoZXIubWV0YWRhdGFHZW5lcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBFbXB0eUNhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSk7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEVtcHR5Q2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2FsbENyZWRlbnRpYWxzIiwibWV0YWRhdGFfMSIsInJlcXVpcmUiLCJpc0N1cnJlbnRPYXV0aDJDbGllbnQiLCJjbGllbnQiLCJnZXRSZXF1ZXN0SGVhZGVycyIsImNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvciIsIm1ldGFkYXRhR2VuZXJhdG9yIiwiU2luZ2xlQ2FsbENyZWRlbnRpYWxzIiwiY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWwiLCJnb29nbGVDcmVkZW50aWFscyIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImdldEhlYWRlcnMiLCJzZXJ2aWNlX3VybCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ2V0UmVxdWVzdE1ldGFkYXRhIiwiZXJyIiwiaGVhZGVycyIsIkVycm9yIiwidGhlbiIsIm1ldGFkYXRhIiwiTWV0YWRhdGEiLCJrZXkiLCJrZXlzIiwiYWRkIiwiY3JlYXRlRW1wdHkiLCJFbXB0eUNhbGxDcmVkZW50aWFscyIsIkNvbXBvc2VkQ2FsbENyZWRlbnRpYWxzIiwiY29uc3RydWN0b3IiLCJjcmVkcyIsImdlbmVyYXRlTWV0YWRhdGEiLCJiYXNlIiwiZ2VuZXJhdGVkIiwiYWxsIiwibWFwIiwiY3JlZCIsImdlbiIsIm1lcmdlIiwiY29tcG9zZSIsIm90aGVyIiwiY29uY2F0IiwiX2VxdWFscyIsImV2ZXJ5IiwiaW5kZXgiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-interface.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-interface.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\nfunction isInterceptingListener(listener) {\n    return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;\n}\nexports.isInterceptingListener = isInterceptingListener;\nclass InterceptingListenerImpl {\n    constructor(listener, nextListener){\n        this.listener = listener;\n        this.nextListener = nextListener;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.processingMessage = false;\n        this.pendingStatus = null;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextListener.onReceiveStatus(this.pendingStatus);\n        }\n    }\n    onReceiveMetadata(metadata) {\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, (metadata)=>{\n            this.processingMetadata = false;\n            this.nextListener.onReceiveMetadata(metadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onReceiveMessage(message) {\n        /* If this listener processes messages asynchronously, the last message may\n         * be reordered with respect to the status */ this.processingMessage = true;\n        this.listener.onReceiveMessage(message, (msg)=>{\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            } else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingStatus();\n            }\n        });\n    }\n    onReceiveStatus(status) {\n        this.listener.onReceiveStatus(status, (processedStatus)=>{\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = processedStatus;\n            } else {\n                this.nextListener.onReceiveStatus(processedStatus);\n            }\n        });\n    }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl; //# sourceMappingURL=call-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdDQUFnQyxHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQ3pFLFNBQVNHLHVCQUF1QkMsUUFBUTtJQUNwQyxPQUFRQSxTQUFTQyxpQkFBaUIsS0FBS0MsYUFDbkNGLFNBQVNDLGlCQUFpQixDQUFDRSxNQUFNLEtBQUs7QUFDOUM7QUFDQVAsOEJBQThCLEdBQUdHO0FBQ2pDLE1BQU1EO0lBQ0ZNLFlBQVlKLFFBQVEsRUFBRUssWUFBWSxDQUFFO1FBQ2hDLElBQUksQ0FBQ0wsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNLLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDekI7SUFDQUMsd0JBQXdCO1FBQ3BCLElBQUksSUFBSSxDQUFDSCxpQkFBaUIsRUFBRTtZQUN4QixJQUFJLENBQUNGLFlBQVksQ0FBQ00sZ0JBQWdCLENBQUMsSUFBSSxDQUFDQyxjQUFjO1lBQ3RELElBQUksQ0FBQ0EsY0FBYyxHQUFHO1lBQ3RCLElBQUksQ0FBQ0wsaUJBQWlCLEdBQUc7UUFDN0I7SUFDSjtJQUNBTSx1QkFBdUI7UUFDbkIsSUFBSSxJQUFJLENBQUNKLGFBQWEsRUFBRTtZQUNwQixJQUFJLENBQUNKLFlBQVksQ0FBQ1MsZUFBZSxDQUFDLElBQUksQ0FBQ0wsYUFBYTtRQUN4RDtJQUNKO0lBQ0FSLGtCQUFrQmMsUUFBUSxFQUFFO1FBQ3hCLElBQUksQ0FBQ1Qsa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDTixRQUFRLENBQUNDLGlCQUFpQixDQUFDYyxVQUFVQSxDQUFBQTtZQUN0QyxJQUFJLENBQUNULGtCQUFrQixHQUFHO1lBQzFCLElBQUksQ0FBQ0QsWUFBWSxDQUFDSixpQkFBaUIsQ0FBQ2M7WUFDcEMsSUFBSSxDQUFDTCxxQkFBcUI7WUFDMUIsSUFBSSxDQUFDRyxvQkFBb0I7UUFDN0I7SUFDSjtJQUNBLDhEQUE4RDtJQUM5REYsaUJBQWlCSyxPQUFPLEVBQUU7UUFDdEI7bURBQzJDLEdBQzNDLElBQUksQ0FBQ1IsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDUixRQUFRLENBQUNXLGdCQUFnQixDQUFDSyxTQUFTQyxDQUFBQTtZQUNwQyxJQUFJLENBQUNULGlCQUFpQixHQUFHO1lBQ3pCLElBQUksSUFBSSxDQUFDRixrQkFBa0IsRUFBRTtnQkFDekIsSUFBSSxDQUFDTSxjQUFjLEdBQUdLO2dCQUN0QixJQUFJLENBQUNWLGlCQUFpQixHQUFHO1lBQzdCLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDRixZQUFZLENBQUNNLGdCQUFnQixDQUFDTTtnQkFDbkMsSUFBSSxDQUFDSixvQkFBb0I7WUFDN0I7UUFDSjtJQUNKO0lBQ0FDLGdCQUFnQkksTUFBTSxFQUFFO1FBQ3BCLElBQUksQ0FBQ2xCLFFBQVEsQ0FBQ2MsZUFBZSxDQUFDSSxRQUFRQyxDQUFBQTtZQUNsQyxJQUFJLElBQUksQ0FBQ2Isa0JBQWtCLElBQUksSUFBSSxDQUFDRSxpQkFBaUIsRUFBRTtnQkFDbkQsSUFBSSxDQUFDQyxhQUFhLEdBQUdVO1lBQ3pCLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDZCxZQUFZLENBQUNTLGVBQWUsQ0FBQ0s7WUFDdEM7UUFDSjtJQUNKO0FBQ0o7QUFDQXZCLGdDQUFnQyxHQUFHRSwwQkFDbkMsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1pbnRlcmZhY2UuanM/OGIzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwgPSBleHBvcnRzLmlzSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBpc0ludGVyY2VwdGluZ0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIChsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhLmxlbmd0aCA9PT0gMSk7XG59XG5leHBvcnRzLmlzSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSBpc0ludGVyY2VwdGluZ0xpc3RlbmVyO1xuY2xhc3MgSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihsaXN0ZW5lciwgbmV4dExpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIgPSBuZXh0TGlzdGVuZXI7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBudWxsO1xuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ01lc3NhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1BlbmRpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKHRoaXMucGVuZGluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdTdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyh0aGlzLnBlbmRpbmdTdGF0dXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSwgbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBJZiB0aGlzIGxpc3RlbmVyIHByb2Nlc3NlcyBtZXNzYWdlcyBhc3luY2hyb25vdXNseSwgdGhlIGxhc3QgbWVzc2FnZSBtYXlcbiAgICAgICAgICogYmUgcmVvcmRlcmVkIHdpdGggcmVzcGVjdCB0byB0aGUgc3RhdHVzICovXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSwgbXNnID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N0YXR1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMsIHByb2Nlc3NlZFN0YXR1cyA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgfHwgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IHByb2Nlc3NlZFN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyhwcm9jZXNzZWRTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCA9IEludGVyY2VwdGluZ0xpc3RlbmVySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtaW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCIsImlzSW50ZXJjZXB0aW5nTGlzdGVuZXIiLCJsaXN0ZW5lciIsIm9uUmVjZWl2ZU1ldGFkYXRhIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiY29uc3RydWN0b3IiLCJuZXh0TGlzdGVuZXIiLCJwcm9jZXNzaW5nTWV0YWRhdGEiLCJoYXNQZW5kaW5nTWVzc2FnZSIsInByb2Nlc3NpbmdNZXNzYWdlIiwicGVuZGluZ1N0YXR1cyIsInByb2Nlc3NQZW5kaW5nTWVzc2FnZSIsIm9uUmVjZWl2ZU1lc3NhZ2UiLCJwZW5kaW5nTWVzc2FnZSIsInByb2Nlc3NQZW5kaW5nU3RhdHVzIiwib25SZWNlaXZlU3RhdHVzIiwibWV0YWRhdGEiLCJtZXNzYWdlIiwibXNnIiwic3RhdHVzIiwicHJvY2Vzc2VkU3RhdHVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-number.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-number.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getNextCallNumber = void 0;\nlet nextCallNumber = 0;\nfunction getNextCallNumber() {\n    return nextCallNumber++;\n}\nexports.getNextCallNumber = getNextCallNumber; //# sourceMappingURL=call-number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHlCQUF5QixHQUFHLEtBQUs7QUFDakMsSUFBSUcsaUJBQWlCO0FBQ3JCLFNBQVNEO0lBQ0wsT0FBT0M7QUFDWDtBQUNBSCx5QkFBeUIsR0FBR0UsbUJBQzVCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtbnVtYmVyLmpzP2QzZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0TmV4dENhbGxOdW1iZXIgPSB2b2lkIDA7XG5sZXQgbmV4dENhbGxOdW1iZXIgPSAwO1xuZnVuY3Rpb24gZ2V0TmV4dENhbGxOdW1iZXIoKSB7XG4gICAgcmV0dXJuIG5leHRDYWxsTnVtYmVyKys7XG59XG5leHBvcnRzLmdldE5leHRDYWxsTnVtYmVyID0gZ2V0TmV4dENhbGxOdW1iZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLW51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXROZXh0Q2FsbE51bWJlciIsIm5leHRDYWxsTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */ function callErrorFromStatus(status, callerStack) {\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n    const error = new Error(message);\n    const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n    return Object.assign(new Error(message), status, {\n        stack\n    });\n}\nexports.callErrorFromStatus = callErrorFromStatus;\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n    constructor(){\n        super();\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nclass ClientReadableStreamImpl extends stream_1.Readable {\n    constructor(deserialize){\n        super({\n            objectMode: true\n        });\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nclass ClientWritableStreamImpl extends stream_1.Writable {\n    constructor(serialize){\n        super({\n            objectMode: true\n        });\n        this.serialize = serialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n    constructor(serialize, deserialize){\n        super({\n            objectMode: true\n        });\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl; //# sourceMappingURL=call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsOEJBQThCLEdBQUdBLGdDQUFnQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsMkJBQTJCLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDeEssTUFBTU8sV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsOEVBQWE7QUFDekM7Ozs7O0NBS0MsR0FDRCxTQUFTRixvQkFBb0JLLE1BQU0sRUFBRUMsV0FBVztJQUM1QyxNQUFNQyxVQUFVLENBQUMsRUFBRUYsT0FBT0csSUFBSSxDQUFDLENBQUMsRUFBRUosWUFBWUssTUFBTSxDQUFDSixPQUFPRyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUVILE9BQU9LLE9BQU8sQ0FBQyxDQUFDO0lBQ3RGLE1BQU1DLFFBQVEsSUFBSUMsTUFBTUw7SUFDeEIsTUFBTU0sUUFBUSxDQUFDLEVBQUVGLE1BQU1FLEtBQUssQ0FBQyxlQUFlLEVBQUVQLFlBQVksQ0FBQztJQUMzRCxPQUFPZCxPQUFPc0IsTUFBTSxDQUFDLElBQUlGLE1BQU1MLFVBQVVGLFFBQVE7UUFBRVE7SUFBTTtBQUM3RDtBQUNBbkIsMkJBQTJCLEdBQUdNO0FBQzlCLE1BQU1ELDRCQUE0QkUsU0FBU2MsWUFBWTtJQUNuREMsYUFBYztRQUNWLEtBQUs7SUFDVDtJQUNBQyxTQUFTO1FBQ0wsSUFBSUM7UUFDSEEsQ0FBQUEsS0FBSyxJQUFJLENBQUNDLElBQUksTUFBTSxRQUFRRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdFLGdCQUFnQixDQUFDaEIsWUFBWUssTUFBTSxDQUFDWSxTQUFTLEVBQUU7SUFDNUc7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IndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLmpzP2ZlMzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCA9IGV4cG9ydHMuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLkNsaWVudFVuYXJ5Q2FsbEltcGwgPSBleHBvcnRzLmNhbGxFcnJvckZyb21TdGF0dXMgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogQ29uc3RydWN0IGEgU2VydmljZUVycm9yIGZyb20gYSBTdGF0dXNPYmplY3QuIFRoaXMgZnVuY3Rpb24gZXhpc3RzIHByaW1hcmlseVxuICogYXMgYW4gYXR0ZW1wdCB0byBtYWtlIHRoZSBlcnJvciBzdGFjayB0cmFjZSBjbGVhcmx5IGNvbW11bmljYXRlIHRoYXQgdGhlXG4gKiBlcnJvciBpcyBub3QgbmVjZXNzYXJpbHkgYSBwcm9ibGVtIGluIGdSUEMgaXRzZWxmLlxuICogQHBhcmFtIHN0YXR1c1xuICovXG5mdW5jdGlvbiBjYWxsRXJyb3JGcm9tU3RhdHVzKHN0YXR1cywgY2FsbGVyU3RhY2spIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYCR7c3RhdHVzLmNvZGV9ICR7Y29uc3RhbnRzXzEuU3RhdHVzW3N0YXR1cy5jb2RlXX06ICR7c3RhdHVzLmRldGFpbHN9YDtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBjb25zdCBzdGFjayA9IGAke2Vycm9yLnN0YWNrfVxcbmZvciBjYWxsIGF0XFxuJHtjYWxsZXJTdGFja31gO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihtZXNzYWdlKSwgc3RhdHVzLCB7IHN0YWNrIH0pO1xufVxuZXhwb3J0cy5jYWxsRXJyb3JGcm9tU3RhdHVzID0gY2FsbEVycm9yRnJvbVN0YXR1cztcbmNsYXNzIENsaWVudFVuYXJ5Q2FsbEltcGwgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRVbmFyeUNhbGxJbXBsID0gQ2xpZW50VW5hcnlDYWxsSW1wbDtcbmNsYXNzIENsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLlJlYWRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihkZXNlcmlhbGl6ZSkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0UmVhZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsID0gQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuV3JpdGFibGUge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZSkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBOdW1iZXIoZW5jb2RpbmcpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihmbGFncykpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGNodW5rKTtcbiAgICB9XG4gICAgX2ZpbmFsKGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFsZkNsb3NlKCk7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRXcml0YWJsZVN0cmVhbUltcGwgPSBDbGllbnRXcml0YWJsZVN0cmVhbUltcGw7XG5jbGFzcyBDbGllbnREdXBsZXhTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemUsIGRlc2VyaWFsaXplKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBjYWxsYmFjazogY2IsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZsYWdzID0gTnVtYmVyKGVuY29kaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZmxhZ3MpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBjaHVuayk7XG4gICAgfVxuICAgIF9maW5hbChjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbGZDbG9zZSgpO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCA9IENsaWVudER1cGxleFN0cmVhbUltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNsaWVudER1cGxleFN0cmVhbUltcGwiLCJDbGllbnRXcml0YWJsZVN0cmVhbUltcGwiLCJDbGllbnRSZWFkYWJsZVN0cmVhbUltcGwiLCJDbGllbnRVbmFyeUNhbGxJbXBsIiwiY2FsbEVycm9yRnJvbVN0YXR1cyIsImV2ZW50c18xIiwicmVxdWlyZSIsInN0cmVhbV8xIiwiY29uc3RhbnRzXzEiLCJzdGF0dXMiLCJjYWxsZXJTdGFjayIsIm1lc3NhZ2UiLCJjb2RlIiwiU3RhdHVzIiwiZGV0YWlscyIsImVycm9yIiwiRXJyb3IiLCJzdGFjayIsImFzc2lnbiIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwiY2FuY2VsIiwiX2EiLCJjYWxsIiwiY2FuY2VsV2l0aFN0YXR1cyIsIkNBTkNFTExFRCIsImdldFBlZXIiLCJfYiIsIlJlYWRhYmxlIiwiZGVzZXJpYWxpemUiLCJvYmplY3RNb2RlIiwiX3JlYWQiLCJfc2l6ZSIsInN0YXJ0UmVhZCIsIldyaXRhYmxlIiwic2VyaWFsaXplIiwiX3dyaXRlIiwiY2h1bmsiLCJlbmNvZGluZyIsImNiIiwiY29udGV4dCIsImNhbGxiYWNrIiwiZmxhZ3MiLCJOdW1iZXIiLCJpc05hTiIsInNlbmRNZXNzYWdlV2l0aENvbnRleHQiLCJfZmluYWwiLCJoYWxmQ2xvc2UiLCJEdXBsZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChannelCredentials = void 0;\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n    if (obj && !(obj instanceof Buffer)) {\n        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n    }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */ class ChannelCredentials {\n    constructor(callCredentials){\n        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n    }\n    /**\n     * Gets the set of per-call credentials associated with this instance.\n     */ _getCallCredentials() {\n        return this.callCredentials;\n    }\n    /**\n     * Return a new ChannelCredentials instance with a given set of credentials.\n     * The resulting instance can be used to construct a Channel that communicates\n     * over TLS.\n     * @param rootCerts The root certificate data.\n     * @param privateKey The client certificate private key, if available.\n     * @param certChain The client certificate key chain, if available.\n     * @param verifyOptions Additional options to modify certificate verification\n     */ static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n        var _a;\n        verifyIsBufferOrNull(rootCerts, \"Root certificate\");\n        verifyIsBufferOrNull(privateKey, \"Private key\");\n        verifyIsBufferOrNull(certChain, \"Certificate chain\");\n        if (privateKey && !certChain) {\n            throw new Error(\"Private key must be given with accompanying certificate chain\");\n        }\n        if (!privateKey && certChain) {\n            throw new Error(\"Certificate chain must be given with accompanying private key\");\n        }\n        const secureContext = (0, tls_1.createSecureContext)({\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\n            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        });\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with credentials created using\n     * the provided secureContext. The resulting instances can be used to\n     * construct a Channel that communicates over TLS. gRPC will not override\n     * anything in the provided secureContext, so the environment variables\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n     * not be applied.\n     * @param secureContext The return value of tls.createSecureContext()\n     * @param verifyOptions Additional options to modify certificate verification\n     */ static createFromSecureContext(secureContext, verifyOptions) {\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with no credentials.\n     */ static createInsecure() {\n        return new InsecureChannelCredentialsImpl();\n    }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(callCredentials){\n        super(callCredentials);\n    }\n    compose(callCredentials) {\n        throw new Error(\"Cannot compose insecure credentials\");\n    }\n    _getConnectionOptions() {\n        return null;\n    }\n    _isSecure() {\n        return false;\n    }\n    _equals(other) {\n        return other instanceof InsecureChannelCredentialsImpl;\n    }\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(secureContext, verifyOptions){\n        super();\n        this.secureContext = secureContext;\n        this.verifyOptions = verifyOptions;\n        this.connectionOptions = {\n            secureContext\n        };\n        // Node asserts that this option is a function, so we cannot pass undefined\n        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\n            this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n        }\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        // Copy to prevent callers from mutating this.connectionOptions\n        return Object.assign({}, this.connectionOptions);\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SecureChannelCredentialsImpl) {\n            return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;\n        } else {\n            return false;\n        }\n    }\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n    constructor(channelCredentials, callCreds){\n        super(callCreds);\n        this.channelCredentials = channelCredentials;\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        return this.channelCredentials._getConnectionOptions();\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedChannelCredentialsImpl) {\n            return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);\n        } else {\n            return false;\n        }\n    }\n} //# sourceMappingURL=channel-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDBCQUEwQixHQUFHLEtBQUs7QUFDbEMsTUFBTUcsUUFBUUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUMscUJBQXFCRCxtQkFBT0EsQ0FBQyw0RkFBb0I7QUFDdkQsTUFBTUUsZ0JBQWdCRixtQkFBT0EsQ0FBQyxrRkFBZTtBQUM3Qyw4REFBOEQ7QUFDOUQsU0FBU0cscUJBQXFCQyxHQUFHLEVBQUVDLFlBQVk7SUFDM0MsSUFBSUQsT0FBTyxDQUFFQSxDQUFBQSxlQUFlRSxNQUFLLEdBQUk7UUFDakMsTUFBTSxJQUFJQyxVQUFVLENBQUMsRUFBRUYsYUFBYSxnQ0FBZ0MsQ0FBQztJQUN6RTtBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU1QO0lBQ0ZVLFlBQVlDLGVBQWUsQ0FBRTtRQUN6QixJQUFJLENBQUNBLGVBQWUsR0FBR0EsbUJBQW1CUixtQkFBbUJTLGVBQWUsQ0FBQ0MsV0FBVztJQUM1RjtJQUNBOztLQUVDLEdBQ0RDLHNCQUFzQjtRQUNsQixPQUFPLElBQUksQ0FBQ0gsZUFBZTtJQUMvQjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsT0FBT0ksVUFBVUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsYUFBYSxFQUFFO1FBQzlELElBQUlDO1FBQ0pmLHFCQUFxQlcsV0FBVztRQUNoQ1gscUJBQXFCWSxZQUFZO1FBQ2pDWixxQkFBcUJhLFdBQVc7UUFDaEMsSUFBSUQsY0FBYyxDQUFDQyxXQUFXO1lBQzFCLE1BQU0sSUFBSUcsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ0osY0FBY0MsV0FBVztZQUMxQixNQUFNLElBQUlHLE1BQU07UUFDcEI7UUFDQSxNQUFN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Z0MsK0JBQStCLElBQUksQ0FBQ0Usa0JBQWtCLEVBQUVIO0lBQ3ZFO0lBQ0FOLHdCQUF3QjtRQUNwQixPQUFPLElBQUksQ0FBQ1Msa0JBQWtCLENBQUNULHFCQUFxQjtJQUN4RDtJQUNBQyxZQUFZO1FBQ1IsT0FBTztJQUNYO0lBQ0FDLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLQSxPQUFPO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUlBLGlCQUFpQkksZ0NBQWdDO1lBQ2pELE9BQVEsSUFBSSxDQUFDRSxrQkFBa0IsQ0FBQ1AsT0FBTyxDQUFDQyxNQUFNTSxrQkFBa0IsS0FDNUQsSUFBSSxDQUFDbEMsZUFBZSxDQUFDMkIsT0FBTyxDQUFDQyxNQUFNNUIsZUFBZTtRQUMxRCxPQUNLO1lBQ0QsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWwtY3JlZGVudGlhbHMuanM/OGU3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGFubmVsQ3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCB0bHNfMSA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgdGxzX2hlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3Rscy1oZWxwZXJzXCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHZlcmlmeUlzQnVmZmVyT3JOdWxsKG9iaiwgZnJpZW5kbHlOYW1lKSB7XG4gICAgaWYgKG9iaiAmJiAhKG9iaiBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmcmllbmRseU5hbWV9LCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIEJ1ZmZlci5gKTtcbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyBjcmVkZW50aWFscyBmb3IgY29tbXVuaWNhdGluZyBvdmVyIGEgY2hhbm5lbCwgYXMgd2VsbFxuICogYXMgYSBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHMsIHdoaWNoIGFyZSBhcHBsaWVkIHRvIGV2ZXJ5IG1ldGhvZCBjYWxsIG1hZGVcbiAqIG92ZXIgYSBjaGFubmVsIGluaXRpYWxpemVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqL1xuY2xhc3MgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMgPSBjYWxsQ3JlZGVudGlhbHMgfHwgY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgX2dldENhbGxDcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggYSBnaXZlbiBzZXQgb2YgY3JlZGVudGlhbHMuXG4gICAgICogVGhlIHJlc3VsdGluZyBpbnN0YW5jZSBjYW4gYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBDaGFubmVsIHRoYXQgY29tbXVuaWNhdGVzXG4gICAgICogb3ZlciBUTFMuXG4gICAgICogQHBhcmFtIHJvb3RDZXJ0cyBUaGUgcm9vdCBjZXJ0aWZpY2F0ZSBkYXRhLlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IFRoZSBjbGllbnQgY2VydGlmaWNhdGUgcHJpdmF0ZSBrZXksIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0gY2VydENoYWluIFRoZSBjbGllbnQgY2VydGlmaWNhdGUga2V5IGNoYWluLCBpZiBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIHZlcmlmeU9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIG1vZGlmeSBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3NsKHJvb3RDZXJ0cywgcHJpdmF0ZUtleSwgY2VydENoYWluLCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwocm9vdENlcnRzLCAnUm9vdCBjZXJ0aWZpY2F0ZScpO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChwcml2YXRlS2V5LCAnUHJpdmF0ZSBrZXknKTtcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwoY2VydENoYWluLCAnQ2VydGlmaWNhdGUgY2hhaW4nKTtcbiAgICAgICAgaWYgKHByaXZhdGVLZXkgJiYgIWNlcnRDaGFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcml2YXRlIGtleSBtdXN0IGJlIGdpdmVuIHdpdGggYWNjb21wYW55aW5nIGNlcnRpZmljYXRlIGNoYWluJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcml2YXRlS2V5ICYmIGNlcnRDaGFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDZXJ0aWZpY2F0ZSBjaGFpbiBtdXN0IGJlIGdpdmVuIHdpdGggYWNjb21wYW55aW5nIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VjdXJlQ29udGV4dCA9ICgwLCB0bHNfMS5jcmVhdGVTZWN1cmVDb250ZXh0KSh7XG4gICAgICAgICAgICBjYTogKF9hID0gcm9vdENlcnRzICE9PSBudWxsICYmIHJvb3RDZXJ0cyAhPT0gdm9pZCAwID8gcm9vdENlcnRzIDogKDAsIHRsc19oZWxwZXJzXzEuZ2V0RGVmYXVsdFJvb3RzRGF0YSkoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAga2V5OiBwcml2YXRlS2V5ICE9PSBudWxsICYmIHByaXZhdGVLZXkgIT09IHZvaWQgMCA/IHByaXZhdGVLZXkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjZXJ0OiBjZXJ0Q2hhaW4gIT09IG51bGwgJiYgY2VydENoYWluICE9PSB2b2lkIDAgPyBjZXJ0Q2hhaW4gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaXBoZXJzOiB0bHNfaGVscGVyc18xLkNJUEhFUl9TVUlURVMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucyAhPT0gbnVsbCAmJiB2ZXJpZnlPcHRpb25zICE9PSB2b2lkIDAgPyB2ZXJpZnlPcHRpb25zIDoge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggY3JlZGVudGlhbHMgY3JlYXRlZCB1c2luZ1xuICAgICAqIHRoZSBwcm92aWRlZCBzZWN1cmVDb250ZXh0LiBUaGUgcmVzdWx0aW5nIGluc3RhbmNlcyBjYW4gYmUgdXNlZCB0b1xuICAgICAqIGNvbnN0cnVjdCBhIENoYW5uZWwgdGhhdCBjb21tdW5pY2F0ZXMgb3ZlciBUTFMuIGdSUEMgd2lsbCBub3Qgb3ZlcnJpZGVcbiAgICAgKiBhbnl0aGluZyBpbiB0aGUgcHJvdmlkZWQgc2VjdXJlQ29udGV4dCwgc28gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAqIEdSUENfU1NMX0NJUEhFUl9TVUlURVMgYW5kIEdSUENfREVGQVVMVF9TU0xfUk9PVFNfRklMRV9QQVRIIHdpbGxcbiAgICAgKiBub3QgYmUgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0gc2VjdXJlQ29udGV4dCBUaGUgcmV0dXJuIHZhbHVlIG9mIHRscy5jcmVhdGVTZWN1cmVDb250ZXh0KClcbiAgICAgKiBAcGFyYW0gdmVyaWZ5T3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gbW9kaWZ5IGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tU2VjdXJlQ29udGV4dChzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbChzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zICE9PSBudWxsICYmIHZlcmlmeU9wdGlvbnMgIT09IHZvaWQgMCA/IHZlcmlmeU9wdGlvbnMgOiB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBDaGFubmVsQ3JlZGVudGlhbHMgaW5zdGFuY2Ugd2l0aCBubyBjcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5zZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsQ3JlZGVudGlhbHMgPSBDaGFubmVsQ3JlZGVudGlhbHM7XG5jbGFzcyBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwgZXh0ZW5kcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICBzdXBlcihjYWxsQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBjb21wb3NlKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wb3NlIGluc2VjdXJlIGNyZWRlbnRpYWxzJyk7XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbDtcbiAgICB9XG59XG5jbGFzcyBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VjdXJlQ29udGV4dCA9IHNlY3VyZUNvbnRleHQ7XG4gICAgICAgIHRoaXMudmVyaWZ5T3B0aW9ucyA9IHZlcmlmeU9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzZWN1cmVDb250ZXh0LFxuICAgICAgICB9O1xuICAgICAgICAvLyBOb2RlIGFzc2VydHMgdGhhdCB0aGlzIG9wdGlvbiBpcyBhIGZ1bmN0aW9uLCBzbyB3ZSBjYW5ub3QgcGFzcyB1bmRlZmluZWRcbiAgICAgICAgaWYgKHZlcmlmeU9wdGlvbnMgPT09IG51bGwgfHwgdmVyaWZ5T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPVxuICAgICAgICAgICAgICAgIHZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb3NlKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCBjb21iaW5lZENhbGxDcmVkZW50aWFscyA9IHRoaXMuY2FsbENyZWRlbnRpYWxzLmNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwodGhpcywgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgIC8vIENvcHkgdG8gcHJldmVudCBjYWxsZXJzIGZyb20gbXV0YXRpbmcgdGhpcy5jb25uZWN0aW9uT3B0aW9uc1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuc2VjdXJlQ29udGV4dCA9PT0gb3RoZXIuc2VjdXJlQ29udGV4dCAmJlxuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID09PVxuICAgICAgICAgICAgICAgICAgICBvdGhlci52ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ3JlZGVudGlhbHMsIGNhbGxDcmVkcykge1xuICAgICAgICBzdXBlcihjYWxsQ3JlZHMpO1xuICAgICAgICB0aGlzLmNoYW5uZWxDcmVkZW50aWFscyA9IGNoYW5uZWxDcmVkZW50aWFscztcbiAgICB9XG4gICAgY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMgPSB0aGlzLmNhbGxDcmVkZW50aWFscy5jb21wb3NlKGNhbGxDcmVkZW50aWFscyk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLCBjb21iaW5lZENhbGxDcmVkZW50aWFscyk7XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLl9lcXVhbHMob3RoZXIuY2hhbm5lbENyZWRlbnRpYWxzKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbENyZWRlbnRpYWxzLl9lcXVhbHMob3RoZXIuY2FsbENyZWRlbnRpYWxzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNoYW5uZWxDcmVkZW50aWFscyIsInRsc18xIiwicmVxdWlyZSIsImNhbGxfY3JlZGVudGlhbHNfMSIsInRsc19oZWxwZXJzXzEiLCJ2ZXJpZnlJc0J1ZmZlck9yTnVsbCIsIm9iaiIsImZyaWVuZGx5TmFtZSIsIkJ1ZmZlciIsIlR5cGVFcnJvciIsImNvbnN0cnVjdG9yIiwiY2FsbENyZWRlbnRpYWxzIiwiQ2FsbENyZWRlbnRpYWxzIiwiY3JlYXRlRW1wdHkiLCJfZ2V0Q2FsbENyZWRlbnRpYWxzIiwiY3JlYXRlU3NsIiwicm9vdENlcnRzIiwicHJpdmF0ZUtleSIsImNlcnRDaGFpbiIsInZlcmlmeU9wdGlvbnMiLCJfYSIsIkVycm9yIiwic2VjdXJlQ29udGV4dCIsImNyZWF0ZVNlY3VyZUNvbnRleHQiLCJjYSIsImdldERlZmF1bHRSb290c0RhdGEiLCJ1bmRlZmluZWQiLCJrZXkiLCJjZXJ0IiwiY2lwaGVycyIsIkNJUEhFUl9TVUlURVMiLCJTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIiwiY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQiLCJjcmVhdGVJbnNlY3VyZSIsIkluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCIsImNvbXBvc2UiLCJfZ2V0Q29ubmVjdGlvbk9wdGlvbnMiLCJfaXNTZWN1cmUiLCJfZXF1YWxzIiwib3RoZXIiLCJjb25uZWN0aW9uT3B0aW9ucyIsImNoZWNrU2VydmVySWRlbnRpdHkiLCJjb21iaW5lZENhbGxDcmVkZW50aWFscyIsIkNvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCIsImFzc2lnbiIsImNoYW5uZWxDcmVkZW50aWFscyIsImNhbGxDcmVkcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.channelOptionsEqual = exports.recognizedOptions = void 0;\n/**\n * This is for checking provided options at runtime. This is an object for\n * easier membership checking.\n */ exports.recognizedOptions = {\n    \"grpc.ssl_target_name_override\": true,\n    \"grpc.primary_user_agent\": true,\n    \"grpc.secondary_user_agent\": true,\n    \"grpc.default_authority\": true,\n    \"grpc.keepalive_time_ms\": true,\n    \"grpc.keepalive_timeout_ms\": true,\n    \"grpc.keepalive_permit_without_calls\": true,\n    \"grpc.service_config\": true,\n    \"grpc.max_concurrent_streams\": true,\n    \"grpc.initial_reconnect_backoff_ms\": true,\n    \"grpc.max_reconnect_backoff_ms\": true,\n    \"grpc.use_local_subchannel_pool\": true,\n    \"grpc.max_send_message_length\": true,\n    \"grpc.max_receive_message_length\": true,\n    \"grpc.enable_http_proxy\": true,\n    \"grpc.enable_channelz\": true,\n    \"grpc.dns_min_time_between_resolutions_ms\": true,\n    \"grpc.enable_retries\": true,\n    \"grpc.per_rpc_retry_buffer_size\": true,\n    \"grpc.retry_buffer_size\": true,\n    \"grpc.max_connection_age_ms\": true,\n    \"grpc.max_connection_age_grace_ms\": true,\n    \"grpc-node.max_session_memory\": true,\n    \"grpc.service_config_disable_resolution\": true,\n    \"grpc.client_idle_timeout_ms\": true,\n    \"grpc-node.tls_enable_trace\": true\n};\nfunction channelOptionsEqual(options1, options2) {\n    const keys1 = Object.keys(options1).sort();\n    const keys2 = Object.keys(options2).sort();\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for(let i = 0; i < keys1.length; i += 1){\n        if (keys1[i] !== keys2[i]) {\n            return false;\n        }\n        if (options1[keys1[i]] !== options2[keys2[i]]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.channelOptionsEqual = channelOptionsEqual; //# sourceMappingURL=channel-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUMvRDs7O0NBR0MsR0FDREEseUJBQXlCLEdBQUc7SUFDeEIsaUNBQWlDO0lBQ2pDLDJCQUEyQjtJQUMzQiw2QkFBNkI7SUFDN0IsMEJBQTBCO0lBQzFCLDBCQUEwQjtJQUMxQiw2QkFBNkI7SUFDN0IsdUNBQXVDO0lBQ3ZDLHVCQUF1QjtJQUN2QiwrQkFBK0I7SUFDL0IscUNBQXFDO0lBQ3JDLGlDQUFpQztJQUNqQyxrQ0FBa0M7SUFDbEMsZ0NBQWdDO0lBQ2hDLG1DQUFtQztJQUNuQywwQkFBMEI7SUFDMUIsd0JBQXdCO0lBQ3hCLDRDQUE0QztJQUM1Qyx1QkFBdUI7SUFDdkIsa0NBQWtDO0lBQ2xDLDBCQUEwQjtJQUMxQiw4QkFBOEI7SUFDOUIsb0NBQW9DO0lBQ3BDLGdDQUFnQztJQUNoQywwQ0FBMEM7SUFDMUMsK0JBQStCO0lBQy9CLDhCQUE4QjtBQUNsQztBQUNBLFNBQVNFLG9CQUFvQkUsUUFBUSxFQUFFQyxRQUFRO0lBQzNDLE1BQU1DLFFBQVFSLE9BQU9TLElBQUksQ0FBQ0gsVUFBVUksSUFBSTtJQUN4QyxNQUFNQyxRQUFRWCxPQUFPUyxJQUFJLENBQUNGLFVBQVVHLElBQUk7SUFDeEMsSUFBSUYsTUFBTUksTUFBTSxLQUFLRCxNQUFNQyxNQUFNLEVBQUU7UUFDL0IsT0FBTztJQUNYO0lBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlMLE1BQU1JLE1BQU0sRUFBRUMsS0FBSyxFQUFHO1FBQ3RDLElBQUlMLEtBQUssQ0FBQ0ssRUFBRSxLQUFLRixLQUFLLENBQUNFLEVBQUUsRUFBRTtZQUN2QixPQUFPO1FBQ1g7UUFDQSxJQUFJUCxRQUFRLENBQUNFLEtBQUssQ0FBQ0ssRUFBRSxDQUFDLEtBQUtOLFFBQVEsQ0FBQ0ksS0FBSyxDQUFDRSxFQUFFLENBQUMsRUFBRTtZQUMzQyxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBWCwyQkFBMkIsR0FBR0UscUJBQzlCLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWwtb3B0aW9ucy5qcz83NzZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoYW5uZWxPcHRpb25zRXF1YWwgPSBleHBvcnRzLnJlY29nbml6ZWRPcHRpb25zID0gdm9pZCAwO1xuLyoqXG4gKiBUaGlzIGlzIGZvciBjaGVja2luZyBwcm92aWRlZCBvcHRpb25zIGF0IHJ1bnRpbWUuIFRoaXMgaXMgYW4gb2JqZWN0IGZvclxuICogZWFzaWVyIG1lbWJlcnNoaXAgY2hlY2tpbmcuXG4gKi9cbmV4cG9ydHMucmVjb2duaXplZE9wdGlvbnMgPSB7XG4gICAgJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJzogdHJ1ZSxcbiAgICAnZ3JwYy5wcmltYXJ5X3VzZXJfYWdlbnQnOiB0cnVlLFxuICAgICdncnBjLnNlY29uZGFyeV91c2VyX2FnZW50JzogdHJ1ZSxcbiAgICAnZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSc6IHRydWUsXG4gICAgJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnOiB0cnVlLFxuICAgICdncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnOiB0cnVlLFxuICAgICdncnBjLnNlcnZpY2VfY29uZmlnJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJzogdHJ1ZSxcbiAgICAnZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnOiB0cnVlLFxuICAgICdncnBjLnVzZV9sb2NhbF9zdWJjaGFubmVsX3Bvb2wnOiB0cnVlLFxuICAgICdncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCc6IHRydWUsXG4gICAgJ2dycGMuZW5hYmxlX2h0dHBfcHJveHknOiB0cnVlLFxuICAgICdncnBjLmVuYWJsZV9jaGFubmVseic6IHRydWUsXG4gICAgJ2dycGMuZG5zX21pbl90aW1lX2JldHdlZW5fcmVzb2x1dGlvbnNfbXMnOiB0cnVlLFxuICAgICdncnBjLmVuYWJsZV9yZXRyaWVzJzogdHJ1ZSxcbiAgICAnZ3JwYy5wZXJfcnBjX3JldHJ5X2J1ZmZlcl9zaXplJzogdHJ1ZSxcbiAgICAnZ3JwYy5yZXRyeV9idWZmZXJfc2l6ZSc6IHRydWUsXG4gICAgJ2dycGMubWF4X2Nvbm5lY3Rpb25fYWdlX21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfZ3JhY2VfbXMnOiB0cnVlLFxuICAgICdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JzogdHJ1ZSxcbiAgICAnZ3JwYy5zZXJ2aWNlX2NvbmZpZ19kaXNhYmxlX3Jlc29sdXRpb24nOiB0cnVlLFxuICAgICdncnBjLmNsaWVudF9pZGxlX3RpbWVvdXRfbXMnOiB0cnVlLFxuICAgICdncnBjLW5vZGUudGxzX2VuYWJsZV90cmFjZSc6IHRydWUsXG59O1xuZnVuY3Rpb24gY2hhbm5lbE9wdGlvbnNFcXVhbChvcHRpb25zMSwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9wdGlvbnMxKS5zb3J0KCk7XG4gICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvcHRpb25zMikuc29ydCgpO1xuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5czEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGtleXMxW2ldICE9PSBrZXlzMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zMVtrZXlzMVtpXV0gIT09IG9wdGlvbnMyW2tleXMyW2ldXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5jaGFubmVsT3B0aW9uc0VxdWFsID0gY2hhbm5lbE9wdGlvbnNFcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWwtb3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjaGFubmVsT3B0aW9uc0VxdWFsIiwicmVjb2duaXplZE9wdGlvbnMiLCJvcHRpb25zMSIsIm9wdGlvbnMyIiwia2V5czEiLCJrZXlzIiwic29ydCIsImtleXMyIiwibGVuZ3RoIiwiaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChannelImplementation = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst internal_channel_1 = __webpack_require__(/*! ./internal-channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\");\nclass ChannelImplementation {\n    constructor(target, credentials, options){\n        if (typeof target !== \"string\") {\n            throw new TypeError(\"Channel target must be a string\");\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError(\"Channel credentials must be a ChannelCredentials object\");\n        }\n        if (options) {\n            if (typeof options !== \"object\") {\n                throw new TypeError(\"Channel options must be an object\");\n            }\n        }\n        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);\n    }\n    close() {\n        this.internalChannel.close();\n    }\n    getTarget() {\n        return this.internalChannel.getTarget();\n    }\n    getConnectivityState(tryToConnect) {\n        return this.internalChannel.getConnectivityState(tryToConnect);\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        this.internalChannel.watchConnectivityState(currentState, deadline, callback);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */ getChannelzRef() {\n        return this.internalChannel.getChannelzRef();\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== \"string\") {\n            throw new TypeError(\"Channel#createCall: method must be a string\");\n        }\n        if (!(typeof deadline === \"number\" || deadline instanceof Date)) {\n            throw new TypeError(\"Channel#createCall: deadline must be a number or Date\");\n        }\n        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);\n    }\n}\nexports.ChannelImplementation = ChannelImplementation; //# sourceMappingURL=channel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxNQUFNRyx3QkFBd0JDLG1CQUFPQSxDQUFDLGtHQUF1QjtBQUM3RCxNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDLDRGQUFvQjtBQUN2RCxNQUFNRjtJQUNGSSxZQUFZQyxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsT0FBTyxDQUFFO1FBQ3RDLElBQUksT0FBT0YsV0FBVyxVQUFVO1lBQzVCLE1BQU0sSUFBSUcsVUFBVTtRQUN4QjtRQUNBLElBQUksQ0FBRUYsQ0FBQUEsdUJBQXVCTCxzQkFBc0JRLGtCQUFrQixHQUFHO1lBQ3BFLE1BQU0sSUFBSUQsVUFBVTtRQUN4QjtRQUNBLElBQUlELFNBQVM7WUFDVCxJQUFJLE9BQU9BLFlBQVksVUFBVTtnQkFDN0IsTUFBTSxJQUFJQyxVQUFVO1lBQ3hCO1FBQ0o7UUFDQSxJQUFJLENBQUNFLGVBQWUsR0FBRyxJQUFJUCxtQkFBbUJRLGVBQWUsQ0FBQ04sUUFBUUMsYUFBYUM7SUFDdkY7SUFDQUssUUFBUTtRQUNKLElBQUksQ0FBQ0YsZUFBZSxDQUFDRSxLQUFLO0lBQzlCO0lBQ0FDLFlBQVk7UUFDUixPQUFPLElBQUksQ0FBQ0gsZUFBZSxDQUFDRyxTQUFTO0lBQ3pDO0lBQ0FDLHFCQUFxQkMsWUFBWSxFQUFFO1FBQy9CLE9BQU8sSUFBSSxDQUFDTCxlQUFlLENBQUNJLG9CQUFvQixDQUFDQztJQUNyRDtJQUNBQyx1QkFBdUJDLFlBQVksRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUU7UUFDckQsSUFBSSxDQUFDVCxlQUFlLENBQUNNLHNCQUFzQixDQUFDQyxjQUFjQyxVQUFVQztJQUN4RTtJQUNBOzs7O0tBSUMsR0FDREMsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUNWLGVBQWUsQ0FBQ1UsY0FBYztJQUM5QztJQUNBQyxXQUFXQyxNQUFNLEVBQUVKLFFBQVEsRUFBRUssSUFBSSxFQUFFQyxVQUFVLEVBQUVDLGNBQWMsRUFBRTtRQUMzRCxJQUFJLE9BQU9ILFdBQVcsVUFBVTtZQUM1QixNQUFNLElBQUlkLFVBQVU7UUFDeEI7UUFDQSxJQUFJLENBQUUsUUFBT1UsYUFBYSxZQUFZQSxvQkFBb0JRLElBQUcsR0FBSTtZQUM3RCxNQUFNLElBQUlsQixVQUFVO1FBQ3hCO1FBQ0EsT0FBTyxJQUFJLENBQUNFLGVBQWUsQ0FBQ1csVUFBVSxDQUFDQyxRQUFRSixVQUFVSyxNQUFNQyxZQUFZQztJQUMvRTtBQUNKO0FBQ0EzQiw2QkFBNkIsR0FBR0UsdUJBQ2hDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWwuanM/Y2Q4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGFubmVsSW1wbGVtZW50YXRpb24gPSB2b2lkIDA7XG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgaW50ZXJuYWxfY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwtY2hhbm5lbFwiKTtcbmNsYXNzIENoYW5uZWxJbXBsZW1lbnRhdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjcmVkZW50aWFscywgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgdGFyZ2V0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjcmVkZW50aWFscyBpbnN0YW5jZW9mIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIGNyZWRlbnRpYWxzIG11c3QgYmUgYSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsQ2hhbm5lbCA9IG5ldyBpbnRlcm5hbF9jaGFubmVsXzEuSW50ZXJuYWxDaGFubmVsKHRhcmdldCwgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbENoYW5uZWwuY2xvc2UoKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0VGFyZ2V0KCk7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKHRyeVRvQ29ubmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ5VG9Db25uZWN0KTtcbiAgICB9XG4gICAgd2F0Y2hDb25uZWN0aXZpdHlTdGF0ZShjdXJyZW50U3RhdGUsIGRlYWRsaW5lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmludGVybmFsQ2hhbm5lbC53YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGFubmVseiByZWZlcmVuY2Ugb2JqZWN0IGZvciB0aGlzIGNoYW5uZWwuIFRoZSByZXR1cm5lZCB2YWx1ZSBpc1xuICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKTtcbiAgICB9XG4gICAgY3JlYXRlQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogbWV0aG9kIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0eXBlb2YgZGVhZGxpbmUgPT09ICdudW1iZXInIHx8IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogZGVhZGxpbmUgbXVzdCBiZSBhIG51bWJlciBvciBEYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDaGFubmVsLmNyZWF0ZUNhbGwobWV0aG9kLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50Q2FsbCwgcHJvcGFnYXRlRmxhZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbEltcGxlbWVudGF0aW9uID0gQ2hhbm5lbEltcGxlbWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsX2NyZWRlbnRpYWxzXzEiLCJyZXF1aXJlIiwiaW50ZXJuYWxfY2hhbm5lbF8xIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJjcmVkZW50aWFscyIsIm9wdGlvbnMiLCJUeXBlRXJyb3IiLCJDaGFubmVsQ3JlZGVudGlhbHMiLCJpbnRlcm5hbENoYW5uZWwiLCJJbnRlcm5hbENoYW5uZWwiLCJjbG9zZSIsImdldFRhcmdldCIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwidHJ5VG9Db25uZWN0Iiwid2F0Y2hDb25uZWN0aXZpdHlTdGF0ZSIsImN1cnJlbnRTdGF0ZSIsImRlYWRsaW5lIiwiY2FsbGJhY2siLCJnZXRDaGFubmVselJlZiIsImNyZWF0ZUNhbGwiLCJtZXRob2QiLCJob3N0IiwicGFyZW50Q2FsbCIsInByb3BhZ2F0ZUZsYWdzIiwiRGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channelz.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nfunction channelRefToMessage(ref) {\n    return {\n        channel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction subchannelRefToMessage(ref) {\n    return {\n        subchannel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction serverRefToMessage(ref) {\n    return {\n        server_id: ref.id\n    };\n}\nfunction socketRefToMessage(ref) {\n    return {\n        socket_id: ref.id,\n        name: ref.name\n    };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */ const TARGET_RETAINED_TRACES = 32;\nclass ChannelzTrace {\n    constructor(){\n        this.events = [];\n        this.eventsLogged = 0;\n        this.creationTimestamp = new Date();\n    }\n    addTrace(severity, description, child) {\n        const timestamp = new Date();\n        this.events.push({\n            description: description,\n            severity: severity,\n            timestamp: timestamp,\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === \"channel\" ? child : undefined,\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === \"subchannel\" ? child : undefined\n        });\n        // Whenever the trace array gets too large, discard the first half\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\n        }\n        this.eventsLogged += 1;\n    }\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: this.events.map((event)=>{\n                return {\n                    description: event.description,\n                    severity: event.severity,\n                    timestamp: dateToProtoTimestamp(event.timestamp),\n                    channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n                    subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n                };\n            })\n        };\n    }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n    constructor(){\n        this.channelChildren = new Map();\n        this.subchannelChildren = new Map();\n        this.socketChildren = new Map();\n    }\n    refChild(child) {\n        var _a, _b, _c;\n        switch(child.kind){\n            case \"channel\":\n                {\n                    const trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.channelChildren.set(child.id, trackedChild);\n                    break;\n                }\n            case \"subchannel\":\n                {\n                    const trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.subchannelChildren.set(child.id, trackedChild);\n                    break;\n                }\n            case \"socket\":\n                {\n                    const trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.socketChildren.set(child.id, trackedChild);\n                    break;\n                }\n        }\n    }\n    unrefChild(child) {\n        switch(child.kind){\n            case \"channel\":\n                {\n                    const trackedChild = this.channelChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.channelChildren.delete(child.id);\n                        } else {\n                            this.channelChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n            case \"subchannel\":\n                {\n                    const trackedChild = this.subchannelChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.subchannelChildren.delete(child.id);\n                        } else {\n                            this.subchannelChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n            case \"socket\":\n                {\n                    const trackedChild = this.socketChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.socketChildren.delete(child.id);\n                        } else {\n                            this.socketChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n        }\n    }\n    getChildLists() {\n        const channels = [];\n        for (const { ref } of this.channelChildren.values()){\n            channels.push(ref);\n        }\n        const subchannels = [];\n        for (const { ref } of this.subchannelChildren.values()){\n            subchannels.push(ref);\n        }\n        const sockets = [];\n        for (const { ref } of this.socketChildren.values()){\n            sockets.push(ref);\n        }\n        return {\n            channels,\n            subchannels,\n            sockets\n        };\n    }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzCallTracker {\n    constructor(){\n        this.callsStarted = 0;\n        this.callsSucceeded = 0;\n        this.callsFailed = 0;\n        this.lastCallStartedTimestamp = null;\n    }\n    addCallStarted() {\n        this.callsStarted += 1;\n        this.lastCallStartedTimestamp = new Date();\n    }\n    addCallSucceeded() {\n        this.callsSucceeded += 1;\n    }\n    addCallFailed() {\n        this.callsFailed += 1;\n    }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\nfunction getNextId() {\n    return nextId++;\n}\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"channel\"\n    };\n    if (channelzEnabled) {\n        channels[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzChannel = registerChannelzChannel;\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"subchannel\"\n    };\n    if (channelzEnabled) {\n        subchannels[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        kind: \"server\"\n    };\n    if (channelzEnabled) {\n        servers[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzServer = registerChannelzServer;\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"socket\"\n    };\n    if (channelzEnabled) {\n        sockets[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzSocket = registerChannelzSocket;\nfunction unregisterChannelzRef(ref) {\n    switch(ref.kind){\n        case \"channel\":\n            delete channels[ref.id];\n            return;\n        case \"subchannel\":\n            delete subchannels[ref.id];\n            return;\n        case \"server\":\n            delete servers[ref.id];\n            return;\n        case \"socket\":\n            delete sockets[ref.id];\n            return;\n    }\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */ function parseIPv6Section(addressSection) {\n    const numberValue = Number.parseInt(addressSection, 16);\n    return [\n        numberValue / 256 | 0,\n        numberValue % 256\n    ];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */ function parseIPv6Chunk(addressChunk) {\n    if (addressChunk === \"\") {\n        return [];\n    }\n    const bytePairs = addressChunk.split(\":\").map((section)=>parseIPv6Section(section));\n    const result = [];\n    return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */ function ipAddressStringToBuffer(ipAddress) {\n    if ((0, net_1.isIPv4)(ipAddress)) {\n        return Buffer.from(Uint8Array.from(ipAddress.split(\".\").map((segment)=>Number.parseInt(segment))));\n    } else if ((0, net_1.isIPv6)(ipAddress)) {\n        let leftSection;\n        let rightSection;\n        const doubleColonIndex = ipAddress.indexOf(\"::\");\n        if (doubleColonIndex === -1) {\n            leftSection = ipAddress;\n            rightSection = \"\";\n        } else {\n            leftSection = ipAddress.substring(0, doubleColonIndex);\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\n        }\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n        return Buffer.concat([\n            leftBuffer,\n            middleBuffer,\n            rightBuffer\n        ]);\n    } else {\n        return null;\n    }\n}\nfunction connectivityStateToMessage(state) {\n    switch(state){\n        case connectivity_state_1.ConnectivityState.CONNECTING:\n            return {\n                state: \"CONNECTING\"\n            };\n        case connectivity_state_1.ConnectivityState.IDLE:\n            return {\n                state: \"IDLE\"\n            };\n        case connectivity_state_1.ConnectivityState.READY:\n            return {\n                state: \"READY\"\n            };\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\n            return {\n                state: \"SHUTDOWN\"\n            };\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n            return {\n                state: \"TRANSIENT_FAILURE\"\n            };\n        default:\n            return {\n                state: \"UNKNOWN\"\n            };\n    }\n}\nfunction dateToProtoTimestamp(date) {\n    if (!date) {\n        return null;\n    }\n    const millisSinceEpoch = date.getTime();\n    return {\n        seconds: millisSinceEpoch / 1000 | 0,\n        nanos: millisSinceEpoch % 1000 * 1000000\n    };\n}\nfunction getChannelMessage(channelEntry) {\n    const resolvedInfo = channelEntry.getInfo();\n    return {\n        ref: channelRefToMessage(channelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        channel_ref: resolvedInfo.children.channels.map((ref)=>channelRefToMessage(ref)),\n        subchannel_ref: resolvedInfo.children.subchannels.map((ref)=>subchannelRefToMessage(ref))\n    };\n}\nfunction GetChannel(call, callback) {\n    const channelId = Number.parseInt(call.request.channel_id);\n    const channelEntry = channels[channelId];\n    if (channelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No channel data found for id \" + channelId\n        });\n        return;\n    }\n    callback(null, {\n        channel: getChannelMessage(channelEntry)\n    });\n}\nfunction GetTopChannels(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_channel_id);\n    for(; i < channels.length; i++){\n        const channelEntry = channels[i];\n        if (channelEntry === undefined) {\n            continue;\n        }\n        resultList.push(getChannelMessage(channelEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        channel: resultList,\n        end: i >= servers.length\n    });\n}\nfunction getServerMessage(serverEntry) {\n    const resolvedInfo = serverEntry.getInfo();\n    return {\n        ref: serverRefToMessage(serverEntry.ref),\n        data: {\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        listen_socket: resolvedInfo.listenerChildren.sockets.map((ref)=>socketRefToMessage(ref))\n    };\n}\nfunction GetServer(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No server data found for id \" + serverId\n        });\n        return;\n    }\n    callback(null, {\n        server: getServerMessage(serverEntry)\n    });\n}\nfunction GetServers(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_server_id);\n    for(; i < servers.length; i++){\n        const serverEntry = servers[i];\n        if (serverEntry === undefined) {\n            continue;\n        }\n        resultList.push(getServerMessage(serverEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        server: resultList,\n        end: i >= servers.length\n    });\n}\nfunction GetSubchannel(call, callback) {\n    const subchannelId = Number.parseInt(call.request.subchannel_id);\n    const subchannelEntry = subchannels[subchannelId];\n    if (subchannelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No subchannel data found for id \" + subchannelId\n        });\n        return;\n    }\n    const resolvedInfo = subchannelEntry.getInfo();\n    const subchannelMessage = {\n        ref: subchannelRefToMessage(subchannelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        socket_ref: resolvedInfo.children.sockets.map((ref)=>socketRefToMessage(ref))\n    };\n    callback(null, {\n        subchannel: subchannelMessage\n    });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n    var _a;\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {\n        return {\n            address: \"tcpip_address\",\n            tcpip_address: {\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n                port: subchannelAddress.port\n            }\n        };\n    } else {\n        return {\n            address: \"uds_address\",\n            uds_address: {\n                filename: subchannelAddress.path\n            }\n        };\n    }\n}\nfunction GetSocket(call, callback) {\n    var _a, _b, _c, _d, _e;\n    const socketId = Number.parseInt(call.request.socket_id);\n    const socketEntry = sockets[socketId];\n    if (socketEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No socket data found for id \" + socketId\n        });\n        return;\n    }\n    const resolvedInfo = socketEntry.getInfo();\n    const securityMessage = resolvedInfo.security ? {\n        model: \"tls\",\n        tls: {\n            cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? \"standard_name\" : \"other_name\",\n            standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n            other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n            local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n            remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n        }\n    } : null;\n    const socketMessage = {\n        ref: socketRefToMessage(socketEntry.ref),\n        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n        security: securityMessage,\n        data: {\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\n            streams_started: resolvedInfo.streamsStarted,\n            streams_succeeded: resolvedInfo.streamsSucceeded,\n            streams_failed: resolvedInfo.streamsFailed,\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n            messages_received: resolvedInfo.messagesReceived,\n            messages_sent: resolvedInfo.messagesSent,\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n            local_flow_control_window: resolvedInfo.localFlowControlWindow ? {\n                value: resolvedInfo.localFlowControlWindow\n            } : null,\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {\n                value: resolvedInfo.remoteFlowControlWindow\n            } : null\n        }\n    };\n    callback(null, {\n        socket: socketMessage\n    });\n}\nfunction GetServerSockets(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No server data found for id \" + serverId\n        });\n        return;\n    }\n    const startId = Number.parseInt(call.request.start_socket_id);\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resolvedInfo = serverEntry.getInfo();\n    // If we wanted to include listener sockets in the result, this line would\n    // instead say\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n    const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2)=>ref1.id - ref2.id);\n    const resultList = [];\n    let i = 0;\n    for(; i < allSockets.length; i++){\n        if (allSockets[i].id >= startId) {\n            resultList.push(socketRefToMessage(allSockets[i]));\n            if (resultList.length >= maxResults) {\n                break;\n            }\n        }\n    }\n    callback(null, {\n        socket_ref: resultList,\n        end: i >= allSockets.length\n    });\n}\nfunction getChannelzHandlers() {\n    return {\n        GetChannel,\n        GetTopChannels,\n        GetServer,\n        GetServers,\n        GetSubchannel,\n        GetSocket,\n        GetServerSockets\n    };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n    if (loadedChannelzDefinition) {\n        return loadedChannelzDefinition;\n    }\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n     * runtime for users who will not use/enable channelz. */ const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\n    const loadedProto = loaderLoadSync(\"channelz.proto\", {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n        includeDirs: [\n            `${__dirname}/../../proto`\n        ]\n    });\n    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);\n    loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n    return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup; //# sourceMappingURL=channelz.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxhQUFhLEdBQUdBLG9DQUFvQyxHQUFHQSwyQkFBMkIsR0FBR0EsNkJBQTZCLEdBQUdBLDhCQUE4QixHQUFHQSw4QkFBOEIsR0FBR0Esa0NBQWtDLEdBQUdBLCtCQUErQixHQUFHQSwyQkFBMkIsR0FBR0EsK0JBQStCLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDM1YsTUFBTWEsUUFBUUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUMsdUJBQXVCRCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUcsdUJBQXVCSCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUksVUFBVUosbUJBQU9BLENBQUMsc0VBQVM7QUFDakMsTUFBTUssZ0JBQWdCTCxtQkFBT0EsQ0FBQyxrRkFBZTtBQUM3QyxTQUFTTSxvQkFBb0JDLEdBQUc7SUFDNUIsT0FBTztRQUNIQyxZQUFZRCxJQUFJRSxFQUFFO1FBQ2xCQyxNQUFNSCxJQUFJRyxJQUFJO0lBQ2xCO0FBQ0o7QUFDQSxTQUFTQyx1QkFBdUJKLEdBQUc7SUFDL0IsT0FBTztRQUNISyxlQUFlTCxJQUFJRSxFQUFFO1FBQ3JCQyxNQUFNSCxJQUFJRyxJQUFJO0lBQ2xCO0FBQ0o7QUFDQSxTQUFTRyxtQkFBbUJOLEdBQUc7SUFDM0IsT0FBTztRQUNITyxXQUFXUCxJQUFJRSxFQUFFO0lBQ3JCO0FBQ0o7QUFDQSxTQUFTTSxtQkFBbUJSLEdBQUc7SUFDM0IsT0FBTztRQUNIUyxXQUFXVCxJQUFJRSxFQUFFO1FBQ2pCQyxNQUFNSCxJQUFJRyxJQUFJO0lBQ2xCO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNELE1BQU1PLHlCQUF5QjtBQUMvQixNQUFNbkI7SUFDRm9CLGFBQWM7UUFDVixJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsSUFBSUM7SUFDakM7SUFDQUMsU0FBU0MsUUFBUSxFQUFFQyxXQUFXLEVBQUVDLEtBQUssRUFBRTtRQUNuQyxNQUFNQyxZQUFZLElBQUlMO1FBQ3RCLElBQUksQ0FBQ0gsTUFBTSxDQUFDUyxJQUFJLENBQUM7WUFDYkgsYUFBYUE7WUFDYkQsVUFBVUE7WUFDVkcsV0FBV0E7WUFDWEUsY0FBYyxDQUFDSCxVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTUksSUFBSSxNQUFNLFlBQVlKLFFBQVFLO1lBQ2pHQyxpQkFBaUIsQ0FBQ04sVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1JLElBQUksTUFBTSxlQUFlSixRQUFRSztRQUMzRztRQUNBLGtFQUFrRTtRQUNsRSxJQUFJLElBQUksQ0FBQ1osTUFBTSxDQUFDYyxNQUFNLElBQUloQix5QkFBeUIsR0FBRztZQUNsRCxJQUFJLENBQUNFLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQ2UsS0FBSyxDQUFDakI7UUFDcEM7UUFDQSxJQUFJLENBQUNHLFlBQVksSUFBSTtJQUN6QjtJQUNBZSxrQkFBa0I7UUFDZCxPQUFPO1lBQ0hDLG9CQUFvQkMscUJBQXFCLElBQUksQ0FBQ2hCLGlCQUFpQjtZQUMvRGlCLG1CQUFtQixJQUFJLENBQUNsQixZQUFZO1lBQ3BDRCxRQUFRLElBQUksQ0FBQ0EsTUFBTSxDQUFDb0IsR0FBRyxDQUFDQyxDQUFBQTtnQkFDcEIsT0FBTztvQkFDSGYsYUFBYWUsTUFBTWYsV0FBVztvQkFDOUJELFVBQVVnQixNQUFNaEIsUUFBUTtvQkFDeEJHLFdBQVdVLHFCQUFxQkcsTUFBTWIsU0FBUztvQkFDL0NjLGFBQWFELE1BQU1YLFlBQVksR0FDekJ2QixvQkFBb0JrQyxNQUFNWCxZQUFZLElBQ3RDO29CQUNOYSxnQkFBZ0JGLE1BQU1SLGVBQWUsR0FDL0JyQix1QkFBdUI2QixNQUFNUixlQUFlLElBQzVDO2dCQUNWO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFDQTlDLHFCQUFxQixHQUFHWTtBQUN4QixNQUFNRDtJQUNGcUIsYUFBYztRQUNWLElBQUksQ0FBQ3lCLGVBQWUsR0FBRyxJQUFJQztRQUMzQixJQUFJLENBQUNDLGtCQUFrQixHQUFHLElBQUlEO1FBQzlCLElBQUksQ0FBQ0UsY0FBYyxHQUFHLElBQUlGO0lBQzlCO0lBQ0FHLFNBQVNyQixLQUFLLEVBQUU7UUFDWixJQUFJc0IsSUFBSUMsSUFBSUM7UUFDWixPQUFReEIsTUFBTUksSUFBSTtZQUNkLEtBQUs7Z0JBQVc7b0JBQ1osTUFBTXFCLGVBQWUsQ0FBQ0gsS0FBSyxJQUFJLENBQUNMLGVBQWUsQ0FBQ1MsR0FBRyxDQUFDMUIsTUFBTWpCLEVBQUUsT0FBTyxRQUFRdUMsT0FBTyxLQUFLLElBQUlBLEtBQUs7d0JBQzVGekMsS0FBS21CO3dCQUNMMkIsT0FBTztvQkFDWDtvQkFDQUYsYUFBYUUsS0FBSyxJQUFJO29CQUN0QixJQUFJLENBQUNWLGVBQWUsQ0FBQ1csR0FBRyxDQUFDNUIsTUFBTWpCLEVBQUUsRUFBRTBDO29CQUNuQztnQkFDSjtZQUNBLEtBQUs7Z0JBQWM7b0JBQ2YsTUFBTUEsZUFBZSxDQUFDRixLQUFLLElBQUksQ0FBQ0osa0JBQWtCLENBQUNPLEdBQUcsQ0FBQzFCLE1BQU1qQixFQUFFLE9BQU8sUUFBUXdDLE9BQU8sS0FBSyxJQUFJQSxLQUFLO3dCQUMvRjFDLEtBQUttQjt3QkFDTDJCLE9BQU87b0JBQ1g7b0JBQ0FGLGFBQWFFLEtBQUssSUFBSTtvQkFDdEIsSUFBSSxDQUFDUixrQkFBa0IsQ0FBQ1MsR0FBRyxDQUFDNUIsTUFBTWpCLEVBQUUsRUFBRTBDO29CQUN0QztnQkFDSjtZQUNBLEtBQUs7Z0JBQVU7b0JBQ1gsTUFBTUEsZUFBZSxDQUFDRCxLQUFLLElBQUksQ0FBQ0osY0FBYyxDQUFDTSxHQUFHLENBQUMxQixNQUFNakIsRUFBRSxPQUFPLFFBQVF5QyxPQUFPLEtBQUssSUFBSUEsS0FBSzt3QkFDM0YzQyxLQUFLbUI7d0JBQ0wyQixPQUFPO29CQUNYO29CQUNBRixhQUFhRSxLQUFLLElBQUk7b0JBQ3RCLElBQUksQ0FBQ1AsY0FBYyxDQUFDUSxHQUFHLENBQUM1QixNQUFNakIsRUFBRSxFQUFFMEM7b0JBQ2xDO2dCQUNKO1FBQ0o7SUFDSjtJQUNBSSxXQUFXN0IsS0FBSyxFQUFFO1FBQ2QsT0FBUUEsTUFBTUksSUFBSTtZQUNkLEtBQUs7Z0JBQVc7b0JBQ1osTUFBTXFCLGVBQWUsSUFBSSxDQUFDUixlQUFlLENBQUNTLEdBQUcsQ0FBQzFCLE1BQU1qQixFQUFFO29CQUN0RCxJQUFJMEMsaUJBQWlCcEIsV0FBVzt3QkFDNUJvQixhQUFhRSxLQUFLLElBQUk7d0JBQ3RCLElBQUlGLGFBQWFFLEtBQUssS0FBSyxHQUFHOzRCQUMxQixJQUFJLENBQUNWLGVBQWUsQ0FBQ2EsTUFBTSxDQUFDOUIsTUFBTWpCLEVBQUU7d0JBQ3hDLE9BQ0s7NEJBQ0QsSUFBSSxDQUFDa0MsZUFBZSxDQUFDVyxHQUFHLENBQUM1QixNQUFNakIsRUFBRSxFQUFFMEM7d0JBQ3ZDO29CQUNKO29CQUNBO2dCQUNKO1lBQ0EsS0FBSztnQkFBYztvQkFDZixNQUFNQSxlQUFlLElBQUksQ0FBQ04sa0JBQWtCLENBQUNPLEdBQUcsQ0FBQzFCLE1BQU1qQixFQUFFO29CQUN6RCxJQUFJMEMsaUJBQWlCcEIsV0FBVzt3QkFDNUJvQixhQUFhRSxLQUFLLElBQUk7d0JBQ3RCLElBQUlGLGFBQWFFLEtBQUssS0FBSyxHQUFHOzRCQUMxQixJQUFJLENBQUNSLGtCQUFrQixDQUFDVyxNQUFNLENBQUM5QixNQUFNakIsRUFBRTt3QkFDM0MsT0FDSzs0QkFDRCxJQUFJLENBQUNvQyxrQkFBa0IsQ0FBQ1MsR0FBRyxDQUFDNUIsTUFBTWpCLEVBQUUsRUFBRTBDO3dCQUMxQztvQkFDSjtvQkFDQTtnQkFDSjtZQUNBLEtBQUs7Z0JBQVU7b0JBQ1gsTUFBTUEsZUFBZSxJQUFJLENBQUNMLGNBQWMsQ0FBQ00sR0FBRyxDQUFDMUIsTUFBTWpCLEVBQUU7b0JBQ3JELElBQUkwQyxpQkFBaUJwQixXQUFXO3dCQUM1Qm9CLGFBQWFFLEtBQUssSUFBSTt3QkFDdEIsSUFBSUYsYUFBYUUsS0FBSyxLQUFLLEdBQUc7NEJBQzFCLElBQUksQ0FBQ1AsY0FBYyxDQUFDVSxNQUFNLENBQUM5QixNQUFNakIsRUFBRTt3QkFDdkMsT0FDSzs0QkFDRCxJQUFJLENBQUNxQyxjQUFjLENBQUNRLEdBQUcsQ0FBQzVCLE1BQU1qQixFQUFFLEVBQUUwQzt3QkFDdEM7b0JBQ0o7b0JBQ0E7Z0JBQ0o7UUFDSjtJQUNKO0lBQ0FNLGdCQUFnQjtRQUNaLE1BQU1DLFdBQVcsRUFBRTtRQUNuQixLQUFLLE1BQU0sRUFBRW5ELEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQ29DLGVBQWUsQ0FBQ2dCLE1BQU0sR0FBSTtZQUNqREQsU0FBUzlCLElBQUksQ0FBQ3JCO1FBQ2xCO1FBQ0EsTUFBTXFELGNBQWMsRUFBRTtRQUN0QixLQUFLLE1BQU0sRUFBRXJELEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQ3NDLGtCQUFrQixDQUFDYyxNQUFNLEdBQUk7WUFDcERDLFlBQVloQyxJQUFJLENBQUNyQjtRQUNyQjtRQUNBLE1BQU1zRCxVQUFVLEVBQUU7UUFDbEIsS0FBSyxNQUFNLEVBQUV0RCxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQUN1QyxjQUFjLENBQUNhLE1BQU0sR0FBSTtZQUNoREUsUUFBUWpDLElBQUksQ0FBQ3JCO1FBQ2pCO1FBQ0EsT0FBTztZQUFFbUQ7WUFBVUU7WUFBYUM7UUFBUTtJQUM1QztBQUNKO0FBQ0EzRSwrQkFBK0IsR0FBR1c7QUFDbEMsTUFBTUQ7SUFDRnNCLGFBQWM7UUFDVixJQUFJLENBQUM0QyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyx3QkFBd0IsR0FBRztJQUNwQztJQUNBQyxpQkFBaUI7UUFDYixJQUFJLENBQUNKLFlBQVksSUFBSTtRQUNyQixJQUFJLENBQUNHLHdCQUF3QixHQUFHLElBQUkzQztJQUN4QztJQUNBNkMsbUJBQW1CO1FBQ2YsSUFBSSxDQUFDSixjQUFjLElBQUk7SUFDM0I7SUFDQUssZ0JBQWdCO1FBQ1osSUFBSSxDQUFDSixXQUFXLElBQUk7SUFDeEI7QUFDSjtBQUNBOUUsMkJBQTJCLEdBQUdVO0FBQzlCLElBQUl5RSxTQUFTO0FBQ2IsU0FBU0M7SUFDTCxPQUFPRDtBQUNYO0FBQ0EsTUFBTVgsV0FBVyxFQUFFO0FBQ25CLE1BQU1FLGNBQWMsRUFBRTtBQUN0QixNQUFNVyxVQUFVLEVBQUU7QUFDbEIsTUFBTVYsVUFBVSxFQUFFO0FBQ2xCLFNBQVNsRSx3QkFBd0JlLElBQUksRUFBRThELE9BQU8sRUFBRUMsZUFBZTtJQUMzRCxNQUFNaEUsS0FBSzZEO0lBQ1gsTUFBTS9ELE1BQU07UUFBRUU7UUFBSUM7UUFBTW9CLE1BQU07SUFBVTtJQUN4QyxJQUFJMkMsaUJBQWlCO1FBQ2pCZixRQUFRLENBQUNqRCxHQUFHLEdBQUc7WUFBRUY7WUFBS2lFO1FBQVE7SUFDbEM7SUFDQSxPQUFPakU7QUFDWDtBQUNBckIsK0JBQStCLEdBQUdTO0FBQ2xDLFNBQVNELDJCQUEyQmdCLElBQUksRUFBRThELE9BQU8sRUFBRUMsZUFBZTtJQUM5RCxNQUFNaEUsS0FBSzZEO0lBQ1gsTUFBTS9ELE1BQU07UUFBRUU7UUFBSUM7UUFBTW9CLE1BQU07SUFBYTtJQUMzQyxJQUFJMkMsaUJBQWlCO1FBQ2pCYixXQUFXLENBQUNuRCxHQUFHLEdBQUc7WUFBRUY7WUFBS2lFO1FBQVE7SUFDckM7SUFDQSxPQUFPakU7QUFDWDtBQUNBckIsa0NBQWtDLEdBQUdRO0FBQ3JDLFNBQVNELHVCQUF1QitFLE9BQU8sRUFBRUMsZUFBZTtJQUNwRCxNQUFNaEUsS0FBSzZEO0lBQ1gsTUFBTS9ELE1BQU07UUFBRUU7UUFBSXFCLE1BQU07SUFBUztJQUNqQyxJQUFJMkMsaUJBQWlCO1FBQ2pCRixPQUFPLENBQUM5RCxHQUFHLEdBQUc7WUFBRUY7WUFBS2lFO1FBQVE7SUFDakM7SUFDQSxPQUFPakU7QUFDWDtBQUNBckIsOEJBQThCLEdBQUdPO0FBQ2pDLFNBQVNELHVCQUF1QmtCLElBQUksRUFBRThELE9BQU8sRUFBRUMsZUFBZTtJQUMxRCxNQUFNaEUsS0FBSzZEO0lBQ1gsTUFBTS9ELE1BQU07UUFBRUU7UUFBSUM7UUFBTW9CLE1BQU07SUFBUztJQUN2QyxJQUFJMkMsaUJBQWlCO1FBQ2pCWixPQUFPLENBQUNwRCxHQUFHLEdBQUc7WUFBRUY7WUFBS2lFO1FBQVE7SUFDakM7SUFDQSxPQUFPakU7QUFDWDtBQUNBckIsOEJBQThCLEdBQUdNO0FBQ2pDLFNBQVNELHNCQUFzQmdCLEdBQUc7SUFDOUIsT0FBUUEsSUFBSXVCLElBQUk7UUFDWixLQUFLO1lBQ0QsT0FBTzRCLFFBQVEsQ0FBQ25ELElBQUlFLEVBQUUsQ0FBQztZQUN2QjtRQUNKLEtBQUs7WUFDRCxPQUFPbUQsV0FBVyxDQUFDckQsSUFBSUUsRUFBRSxDQUFDO1lBQzFCO1FBQ0osS0FBSztZQUNELE9BQU84RCxPQUFPLENBQUNoRSxJQUFJRSxFQUFFLENBQUM7WUFDdEI7UUFDSixLQUFLO1lBQ0QsT0FBT29ELE9BQU8sQ0FBQ3RELElBQUlFLEVBQUUsQ0FBQztZQUN0QjtJQUNSO0FBQ0o7QUFDQXZCLDZCQUE2QixHQUFHSztBQUNoQzs7OztDQUlDLEdBQ0QsU0FBU21GLGlCQUFpQkMsY0FBYztJQUNwQyxNQUFNQyxjQUFjQyxPQUFPQyxRQUFRLENBQUNILGdCQUFnQjtJQUNwRCxPQUFPO1FBQUVDLGNBQWMsTUFBTztRQUFHQSxjQUFjO0tBQUk7QUFDdkQ7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVNHLGVBQWVDLFlBQVk7SUFDaEMsSUFBSUEsaUJBQWlCLElBQUk7UUFDckIsT0FBTyxFQUFFO0lBQ2I7SUFDQSxNQUFNQyxZQUFZRCxhQUNiRSxLQUFLLENBQUMsS0FDTjNDLEdBQUcsQ0FBQzRDLENBQUFBLFVBQVdULGlCQUFpQlM7SUFDckMsTUFBTUMsU0FBUyxFQUFFO0lBQ2pCLE9BQU9BLE9BQU9DLE1BQU0sSUFBSUo7QUFDNUI7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVNLLHdCQUF3QkMsU0FBUztJQUN0QyxJQUFJLENBQUMsR0FBR3hGLE1BQU15RixNQUFNLEVBQUVELFlBQVk7UUFDOUIsT0FBT0UsTUFBTUEsQ0FBQ0MsSUFBSSxDQUFDQyxXQUFXRCxJQUFJLENBQUNILFVBQVVMLEtBQUssQ0FBQyxLQUFLM0MsR0FBRyxDQUFDcUQsQ0FBQUEsVUFBV2YsT0FBT0MsUUFBUSxDQUFDYztJQUMzRixPQUNLLElBQUksQ0FBQyxHQUFHN0YsTUFBTThGLE1BQU0sRUFBRU4sWUFBWTtRQUNuQyxJQUFJTztRQUNKLElBQUlDO1FBQ0osTUFBTUMsbUJBQW1CVCxVQUFVVSxPQUFPLENBQUM7UUFDM0MsSUFBSUQscUJBQXFCLENBQUMsR0FBRztZQUN6QkYsY0FBY1A7WUFDZFEsZUFBZTtRQUNuQixPQUNLO1lBQ0RELGNBQWNQLFVBQVVXLFNBQVMsQ0FBQyxHQUFHRjtZQUNyQ0QsZUFBZVIsVUFBVVcsU0FBUyxDQUFDRixtQkFBbUI7UUFDMUQ7UUFDQSxNQUFNRyxhQUFhVixNQUFNQSxDQUFDQyxJQUFJLENBQUNYLGVBQWVlO1FBQzlDLE1BQU1NLGNBQWNYLE1BQU1BLENBQUNDLElBQUksQ0FBQ1gsZUFBZWdCO1FBQy9DLE1BQU1NLGVBQWVaLE1BQU1BLENBQUNhLEtBQUssQ0FBQyxLQUFLSCxXQUFXbEUsTUFBTSxHQUFHbUUsWUFBWW5FLE1BQU0sRUFBRTtRQUMvRSxPQUFPd0QsTUFBTUEsQ0FBQ0osTUFBTSxDQUFDO1lBQUNjO1lBQVlFO1lBQWNEO1NBQVk7SUFDaEUsT0FDSztRQUNELE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU0csMkJBQTJCQyxLQUFLO0lBQ3JDLE9BQVFBO1FBQ0osS0FBS3ZHLHFCQUFxQndHLGlCQUFpQixDQUFDQyxVQUFVO1lBQ2xELE9BQU87Z0JBQ0hGLE9BQU87WUFDWDtRQUNKLEtBQUt2RyxxQkFBcUJ3RyxpQkFBaUIsQ0FBQ0UsSUFBSTtZQUM1QyxPQUFPO2dCQUNISCxPQUFPO1lBQ1g7UUFDSixLQUFLdkcscUJBQXFCd0csaUJBQWlCLENBQUNHLEtBQUs7WUFDN0MsT0FBTztnQkFDSEosT0FBTztZQUNYO1FBQ0osS0FBS3ZHLHFCQUFxQndHLGlCQUFpQixDQUFDSSxRQUFRO1lBQ2hELE9BQU87Z0JBQ0hMLE9BQU87WUFDWDtRQUNKLEtBQUt2RyxxQkFBcUJ3RyxpQkFBaUIsQ0FBQ0ssaUJBQWlCO1lBQ3pELE9BQU87Z0JBQ0hOLE9BQU87WUFDWDtRQUNKO1lBQ0ksT0FBTztnQkFDSEEsT0FBTztZQUNYO0lBQ1I7QUFDSjtBQUNBLFNBQVNuRSxxQkFBcUIwRSxJQUFJO0lBQzlCLElBQUksQ0FBQ0EsTUFBTTtRQUNQLE9BQU87SUFDWDtJQUNBLE1BQU1DLG1CQUFtQkQsS0FBS0UsT0FBTztJQUNyQyxPQUFPO1FBQ0hDLFNBQVMsbUJBQW9CLE9BQVE7UUFDckNDLE9BQU8sbUJBQW9CLE9BQVE7SUFDdkM7QUFDSjtBQUNBLFNBQVNDLGtCQUFrQkMsWUFBWTtJQUNuQyxNQUFNQyxlQUFlRCxhQUFhN0MsT0FBTztJQUN6QyxPQUFPO1FBQ0hqRSxLQUFLRCxvQkFBb0IrRyxhQUFhOUcsR0FBRztRQUN6Q2dILE1BQU07WUFDRkMsUUFBUUYsYUFBYUUsTUFBTTtZQUMzQmhCLE9BQU9ELDJCQUEyQmUsYUFBYWQsS0FBSztZQUNwRGlCLGVBQWVILGFBQWFJLFdBQVcsQ0FBQzVELFlBQVk7WUFDcEQ2RCxpQkFBaUJMLGFBQWFJLFdBQVcsQ0FBQzNELGNBQWM7WUFDeEQ2RCxjQUFjTixhQUFhSSxXQUFXLENBQUMxRCxXQUFXO1lBQ2xENkQsNkJBQTZCeEYscUJBQXFCaUYsYUFBYUksV0FBVyxDQUFDekQsd0JBQXdCO1lBQ25HNkQsT0FBT1IsYUFBYVEsS0FBSyxDQUFDM0YsZUFBZTtRQUM3QztRQUNBTSxhQUFhNkUsYUFBYVMsUUFBUSxDQUFDckUsUUFBUSxDQUFDbkIsR0FBRyxDQUFDaEMsQ0FBQUEsTUFBT0Qsb0JBQW9CQztRQUMzRW1DLGdCQUFnQjRFLGFBQWFTLFFBQVEsQ0FBQ25FLFdBQVcsQ0FBQ3JCLEdBQUcsQ0FBQ2hDLENBQUFBLE1BQU9JLHVCQUF1Qko7SUFDeEY7QUFDSjtBQUNBLFNBQVN5SCxXQUFXQyxJQUFJLEVBQUVDLFFBQVE7SUFDOUIsTUFBTUMsWUFBWXRELE9BQU9DLFFBQVEsQ0FBQ21ELEtBQUtHLE9BQU8sQ0FBQzVILFVBQVU7SUFDekQsTUFBTTZHLGVBQWUzRCxRQUFRLENBQUN5RSxVQUFVO0lBQ3hDLElBQUlkLGlCQUFpQnRGLFdBQVc7UUFDNUJtRyxTQUFTO1lBQ0xHLE1BQU1uSSxZQUFZb0ksTUFBTSxDQUFDQyxTQUFTO1lBQ2xDQyxTQUFTLGtDQUFrQ0w7UUFDL0M7UUFDQTtJQUNKO0lBQ0FELFNBQVMsTUFBTTtRQUFFTyxTQUFTckIsa0JBQWtCQztJQUFjO0FBQzlEO0FBQ0EsU0FBU3FCLGVBQWVULElBQUksRUFBRUMsUUFBUTtJQUNsQyxNQUFNUyxhQUFhOUQsT0FBT0MsUUFBUSxDQUFDbUQsS0FBS0csT0FBTyxDQUFDUSxXQUFXO0lBQzNELE1BQU1DLGFBQWEsRUFBRTtJQUNyQixJQUFJQyxJQUFJakUsT0FBT0MsUUFBUSxDQUFDbUQsS0FBS0csT0FBTyxDQUFDVyxnQkFBZ0I7SUFDckQsTUFBT0QsSUFBSXBGLFNBQVN6QixNQUFNLEVBQUU2RyxJQUFLO1FBQzdCLE1BQU16QixlQUFlM0QsUUFBUSxDQUFDb0YsRUFBRTtRQUNoQyxJQUFJekIsaUJBQWlCdEYsV0FBVztZQUM1QjtRQUNKO1FBQ0E4RyxXQUFXakgsSUFBSSxDQUFDd0Ysa0JBQWtCQztRQUNsQyxJQUFJd0IsV0FBVzVHLE1BQU0sSUFBSTBHLFlBQVk7WUFDakM7UUFDSjtJQUNKO0lBQ0FULFNBQVMsTUFBTTtRQUNYTyxTQUFTSTtRQUNURyxLQUFLRixLQUFLdkUsUUFBUXRDLE1BQU07SUFDNUI7QUFDSjtBQUNBLFNBQVNnSCxpQkFBaUJDLFdBQVc7SUFDakMsTUFBTTVCLGVBQWU0QixZQUFZMUUsT0FBTztJQUN4QyxPQUFPO1FBQ0hqRSxLQUFLTSxtQkFBbUJxSSxZQUFZM0ksR0FBRztRQUN2Q2dILE1BQU07WUFDRkUsZUFBZUgsYUFBYUksV0FBVyxDQUFDNUQsWUFBWTtZQUNwRDZELGlCQUFpQkwsYUFBYUksV0FBVyxDQUFDM0QsY0FBYztZQUN4RDZELGNBQWNOLGFBQWFJLFdBQVcsQ0FBQzFELFdBQVc7WUFDbEQ2RCw2QkFBNkJ4RixxQkFBcUJpRixhQUFhSSxXQUFXLENBQUN6RCx3QkFBd0I7WUFDbkc2RCxPQUFPUixhQUFhUSxLQUFLLENBQUMzRixlQUFlO1FBQzdDO1FBQ0FnSCxlQUFlN0IsYUFBYThCLGdCQUFnQixDQUFDdkYsT0FBTyxDQUFDdEIsR0FBRyxDQUFDaEMsQ0FBQUEsTUFBT1EsbUJBQW1CUjtJQUN2RjtBQUNKO0FBQ0EsU0FBUzhJLFVBQVVwQixJQUFJLEVBQUVDLFFBQVE7SUFDN0IsTUFBTW9CLFdBQVd6RSxPQUFPQyxRQUFRLENBQUNtRCxLQUFLRyxPQUFPLENBQUN0SCxTQUFTO0lBQ3ZELE1BQU1vSSxjQUFjM0UsT0FBTyxDQUFDK0UsU0FBUztJQUNyQyxJQUFJSixnQkFBZ0JuSCxXQUFXO1FBQzNCbUcsU0FBUztZQUNMRyxNQUFNbkksWUFBWW9JLE1BQU0sQ0FBQ0MsU0FBUztZQUNsQ0MsU0FBUyxpQ0FBaUNjO1FBQzlDO1FBQ0E7SUFDSjtJQUNBcEIsU0FBUyxNQUFNO1FBQUVxQixRQUFRTixpQkFBaUJDO0lBQWE7QUFDM0Q7QUFDQSxTQUFTTSxXQUFXdkIsSUFBSSxFQUFFQyxRQUFRO0lBQzlCLE1BQU1TLGFBQWE5RCxPQUFPQyxRQUFRLENBQUNtRCxLQUFLRyxPQUFPLENBQUNRLFdBQVc7SUFDM0QsTUFBTUMsYUFBYSxFQUFFO0lBQ3JCLElBQUlDLElBQUlqRSxPQUFPQyxRQUFRLENBQUNtRCxLQUFLRyxPQUFPLENBQUNxQixlQUFlO0lBQ3BELE1BQU9YLElBQUl2RSxRQUFRdEMsTUFBTSxFQUFFNkcsSUFBSztRQUM1QixNQUFNSSxjQUFjM0UsT0FBTyxDQUFDdUUsRUFBRTtRQUM5QixJQUFJSSxnQkFBZ0JuSCxXQUFXO1lBQzNCO1FBQ0o7UUFDQThHLFdBQVdqSCxJQUFJLENBQUNxSCxpQkFBaUJDO1FBQ2pDLElBQUlMLFdBQVc1RyxNQUFNLElBQUkwRyxZQUFZO1lBQ2pDO1FBQ0o7SUFDSjtJQUNBVCxTQUFTLE1BQU07UUFDWHFCLFFBQVFWO1FBQ1JHLEtBQUtGLEtBQUt2RSxRQUFRdEMsTUFBTTtJQUM1QjtBQUNKO0FBQ0EsU0FBU3lILGNBQWN6QixJQUFJLEVBQUVDLFFBQVE7SUFDakMsTUFBTXlCLGVBQWU5RSxPQUFPQyxRQUFRLENBQUNtRCxLQUFLRyxPQUFPLENBQUN4SCxhQUFhO0lBQy9ELE1BQU1nSixrQkFBa0JoRyxXQUFXLENBQUMrRixhQUFhO0lBQ2pELElBQUlDLG9CQUFvQjdILFdBQVc7UUFDL0JtRyxTQUFTO1lBQ0xHLE1BQU1uSSxZQUFZb0ksTUFBTSxDQUFDQyxTQUFTO1lBQ2xDQyxTQUFTLHFDQUFxQ21CO1FBQ2xEO1FBQ0E7SUFDSjtJQUNBLE1BQU1yQyxlQUFlc0MsZ0JBQWdCcEYsT0FBTztJQUM1QyxNQUFNcUYsb0JBQW9CO1FBQ3RCdEosS0FBS0ksdUJBQXVCaUosZ0JBQWdCckosR0FBRztRQUMvQ2dILE1BQU07WUFDRkMsUUFBUUYsYUFBYUUsTUFBTTtZQUMzQmhCLE9BQU9ELDJCQUEyQmUsYUFBYWQsS0FBSztZQUNwRGlCLGVBQWVILGFBQWFJLFdBQVcsQ0FBQzVELFlBQVk7WUFDcEQ2RCxpQkFBaUJMLGFBQWFJLFdBQVcsQ0FBQzNELGNBQWM7WUFDeEQ2RCxjQUFjTixhQUFhSSxXQUFXLENBQUMxRCxXQUFXO1lBQ2xENkQsNkJBQTZCeEYscUJBQXFCaUYsYUFBYUksV0FBVyxDQUFDekQsd0JBQXdCO1lBQ25HNkQsT0FBT1IsYUFBYVEsS0FBSyxDQUFDM0YsZUFBZTtRQUM3QztRQUNBMkgsWUFBWXhDLGFBQWFTLFFBQVEsQ0FBQ2xFLE9BQU8sQ0FBQ3RCLEdBQUcsQ0FBQ2hDLENBQUFBLE1BQU9RLG1CQUFtQlI7SUFDNUU7SUFDQTJILFNBQVMsTUFBTTtRQUFFNkIsWUFBWUY7SUFBa0I7QUFDbkQ7QUFDQSxTQUFTRyxrQ0FBa0NDLGlCQUFpQjtJQUN4RCxJQUFJakg7SUFDSixJQUFJLENBQUMsR0FBRzdDLHFCQUFxQitKLHNCQUFzQixFQUFFRCxvQkFBb0I7UUFDckUsT0FBTztZQUNIRSxTQUFTO1lBQ1RDLGVBQWU7Z0JBQ1hDLFlBQVksQ0FBQ3JILEtBQUtzQyx3QkFBd0IyRSxrQkFBa0JLLElBQUksT0FBTyxRQUFRdEgsT0FBTyxLQUFLLElBQUlBLEtBQUtqQjtnQkFDcEd3SSxNQUFNTixrQkFBa0JNLElBQUk7WUFDaEM7UUFDSjtJQUNKLE9BQ0s7UUFDRCxPQUFPO1lBQ0hKLFNBQVM7WUFDVEssYUFBYTtnQkFDVEMsVUFBVVIsa0JBQWtCUyxJQUFJO1lBQ3BDO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBU0MsVUFBVTFDLElBQUksRUFBRUMsUUFBUTtJQUM3QixJQUFJbEYsSUFBSUMsSUFBSUMsSUFBSTBILElBQUlDO0lBQ3BCLE1BQU1DLFdBQVdqRyxPQUFPQyxRQUFRLENBQUNtRCxLQUFLRyxPQUFPLENBQUNwSCxTQUFTO0lBQ3ZELE1BQU0rSixjQUFjbEgsT0FBTyxDQUFDaUgsU0FBUztJQUNyQyxJQUFJQyxnQkFBZ0JoSixXQUFXO1FBQzNCbUcsU0FBUztZQUNMRyxNQUFNbkksWUFBWW9JLE1BQU0sQ0FBQ0MsU0FBUztZQUNsQ0MsU0FBUyxpQ0FBaUNzQztRQUM5QztRQUNBO0lBQ0o7SUFDQSxNQUFNeEQsZUFBZXlELFlBQVl2RyxPQUFPO0lBQ3hDLE1BQU13RyxrQkFBa0IxRCxhQUFhMkQsUUFBUSxHQUN2QztRQUNFQyxPQUFPO1FBQ1BDLEtBQUs7WUFDREMsY0FBYzlELGFBQWEyRCxRQUFRLENBQUNJLHVCQUF1QixHQUNyRCxrQkFDQTtZQUNOQyxlQUFlLENBQUN0SSxLQUFLc0UsYUFBYTJELFFBQVEsQ0FBQ0ksdUJBQXVCLE1BQU0sUUFBUXJJLE9BQU8sS0FBSyxJQUFJQSxLQUFLakI7WUFDckd3SixZQUFZLENBQUN0SSxLQUFLcUUsYUFBYTJELFFBQVEsQ0FBQ08sb0JBQW9CLE1BQU0sUUFBUXZJLE9BQU8sS0FBSyxJQUFJQSxLQUFLbEI7WUFDL0YwSixtQkFBbUIsQ0FBQ3ZJLEtBQUtvRSxhQUFhMkQsUUFBUSxDQUFDUyxnQkFBZ0IsTUFBTSxRQUFReEksT0FBTyxLQUFLLElBQUlBLEtBQUtuQjtZQUNsRzRKLG9CQUFvQixDQUFDZixLQUFLdEQsYUFBYTJELFFBQVEsQ0FBQ1csaUJBQWlCLE1BQU0sUUFBUWhCLE9BQU8sS0FBSyxJQUFJQSxLQUFLN0k7UUFDeEc7SUFDSixJQUNFO0lBQ04sTUFBTThKLGdCQUFnQjtRQUNsQnRMLEtBQUtRLG1CQUFtQmdLLFlBQVl4SyxHQUFHO1FBQ3ZDdUwsT0FBT3hFLGFBQWF5RSxZQUFZLEdBQzFCL0Isa0NBQWtDMUMsYUFBYXlFLFlBQVksSUFDM0Q7UUFDTkMsUUFBUTFFLGFBQWEyRSxhQUFhLEdBQzVCakMsa0NBQWtDMUMsYUFBYTJFLGFBQWEsSUFDNUQ7UUFDTkMsYUFBYSxDQUFDckIsS0FBS3ZELGFBQWE2RSxVQUFVLE1BQU0sUUFBUXRCLE9BQU8sS0FBSyxJQUFJQSxLQUFLOUk7UUFDN0VrSixVQUFVRDtRQUNWekQsTUFBTTtZQUNGNkUsa0JBQWtCOUUsYUFBYStFLGNBQWM7WUFDN0NDLGlCQUFpQmhGLGFBQWFpRixjQUFjO1lBQzVDQyxtQkFBbUJsRixhQUFhbUYsZ0JBQWdCO1lBQ2hEQyxnQkFBZ0JwRixhQUFhcUYsYUFBYTtZQUMxQ0MscUNBQXFDdksscUJBQXFCaUYsYUFBYXVGLCtCQUErQjtZQUN0R0Msc0NBQXNDeksscUJBQXFCaUYsYUFBYXlGLGdDQUFnQztZQUN4R0MsbUJBQW1CMUYsYUFBYTJGLGdCQUFnQjtZQUNoREMsZUFBZTVGLGFBQWE2RixZQUFZO1lBQ3hDQyxpQ0FBaUMvSyxxQkFBcUJpRixhQUFhK0YsNEJBQTRCO1lBQy9GQyw2QkFBNkJqTCxxQkFBcUJpRixhQUFhaUcsd0JBQXdCO1lBQ3ZGQywyQkFBMkJsRyxhQUFhbUcsc0JBQXNCLEdBQ3hEO2dCQUFFdE8sT0FBT21JLGFBQWFtRyxzQkFBc0I7WUFBQyxJQUM3QztZQUNOQyw0QkFBNEJwRyxhQUFhcUcsdUJBQXVCLEdBQzFEO2dCQUFFeE8sT0FBT21JLGFBQWFxRyx1QkFBdUI7WUFBQyxJQUM5QztRQUNWO0lBQ0o7SUFDQXpGLFNBQVMsTUFBTTtRQUFFMEYsUUFBUS9CO0lBQWM7QUFDM0M7QUFDQSxTQUFTZ0MsaUJBQWlCNUYsSUFBSSxFQUFFQyxRQUFRO0lBQ3BDLE1BQU1vQixXQUFXekUsT0FBT0MsUUFBUSxDQUFDbUQsS0FBS0csT0FBTyxDQUFDdEgsU0FBUztJQUN2RCxNQUFNb0ksY0FBYzNFLE9BQU8sQ0FBQytFLFNBQVM7SUFDckMsSUFBSUosZ0JBQWdCbkgsV0FBVztRQUMzQm1HLFNBQVM7WUFDTEcsTUFBTW5JLFlBQVlvSSxNQUFNLENBQUNDLFNBQVM7WUFDbENDLFNBQVMsaUNBQWlDYztRQUM5QztRQUNBO0lBQ0o7SUFDQSxNQUFNd0UsVUFBVWpKLE9BQU9DLFFBQVEsQ0FBQ21ELEtBQUtHLE9BQU8sQ0FBQzJGLGVBQWU7SUFDNUQsTUFBTXBGLGFBQWE5RCxPQUFPQyxRQUFRLENBQUNtRCxLQUFLRyxPQUFPLENBQUNRLFdBQVc7SUFDM0QsTUFBTXRCLGVBQWU0QixZQUFZMUUsT0FBTztJQUN4QywwRUFBMEU7SUFDMUUsY0FBYztJQUNkLGlKQUFpSjtJQUNqSixNQUFNd0osYUFBYTFHLGFBQWEyRyxlQUFlLENBQUNwSyxPQUFPLENBQUNxSyxJQUFJLENBQUMsQ0FBQ0MsTUFBTUMsT0FBU0QsS0FBSzFOLEVBQUUsR0FBRzJOLEtBQUszTixFQUFFO0lBQzlGLE1BQU1vSSxhQUFhLEVBQUU7SUFDckIsSUFBSUMsSUFBSTtJQUNSLE1BQU9BLElBQUlrRixXQUFXL0wsTUFBTSxFQUFFNkcsSUFBSztRQUMvQixJQUFJa0YsVUFBVSxDQUFDbEYsRUFBRSxDQUFDckksRUFBRSxJQUFJcU4sU0FBUztZQUM3QmpGLFdBQVdqSCxJQUFJLENBQUNiLG1CQUFtQmlOLFVBQVUsQ0FBQ2xGLEVBQUU7WUFDaEQsSUFBSUQsV0FBVzVHLE1BQU0sSUFBSTBHLFlBQVk7Z0JBQ2pDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FULFNBQVMsTUFBTTtRQUNYNEIsWUFBWWpCO1FBQ1pHLEtBQUtGLEtBQUtrRixXQUFXL0wsTUFBTTtJQUMvQjtBQUNKO0FBQ0EsU0FBUzNDO0lBQ0wsT0FBTztRQUNIMEk7UUFDQVU7UUFDQVc7UUFDQUc7UUFDQUU7UUFDQWlCO1FBQ0FrRDtJQUNKO0FBQ0o7QUFDQTNPLDJCQUEyQixHQUFHSTtBQUM5QixJQUFJK08sMkJBQTJCO0FBQy9CLFNBQVNoUDtJQUNMLElBQUlnUCwwQkFBMEI7UUFDMUIsT0FBT0E7SUFDWDtJQUNBOzJEQUN1RCxHQUN2RCxNQUFNQyxpQkFBaUJ0TyxzSEFDVjtJQUNiLE1BQU13TyxjQUFjRixlQUFlLGtCQUFrQjtRQUNqREcsVUFBVTtRQUNWQyxPQUFPQztRQUNQQyxPQUFPRDtRQUNQRSxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsYUFBYTtZQUFDLENBQUMsRUFBRUMsVUFBVSxZQUFZLENBQUM7U0FBQztJQUM3QztJQUNBLE1BQU1DLHFCQUFxQixDQUFDLEdBQUc1TyxjQUFjNk8scUJBQXFCLEVBQUVWO0lBQ3BFSCwyQkFDSVksbUJBQW1CRSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsRUFBRSxDQUFDQyxRQUFRLENBQUNDLE9BQU87SUFDeEQsT0FBT2xCO0FBQ1g7QUFDQW5QLG9DQUFvQyxHQUFHRztBQUN2QyxTQUFTRDtJQUNKLElBQUdnQixRQUFRb1Asb0JBQW9CLEVBQUVuUSw4QkFBOEJDO0FBQ3BFO0FBQ0FKLGFBQWEsR0FBR0UsT0FDaEIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanM/NjI3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpIYW5kbGVycyA9IGV4cG9ydHMudW5yZWdpc3RlckNoYW5uZWx6UmVmID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwgPSBleHBvcnRzLkNoYW5uZWx6Q2FsbFRyYWNrZXIgPSBleHBvcnRzLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyID0gZXhwb3J0cy5DaGFubmVselRyYWNlID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuY29uc3QgbWFrZV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL21ha2UtY2xpZW50XCIpO1xuZnVuY3Rpb24gY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFubmVsX2lkOiByZWYuaWQsXG4gICAgICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgIH07XG59XG5mdW5jdGlvbiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YmNoYW5uZWxfaWQ6IHJlZi5pZCxcbiAgICAgICAgbmFtZTogcmVmLm5hbWUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlcnZlclJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2ZXJfaWQ6IHJlZi5pZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNvY2tldF9pZDogcmVmLmlkLFxuICAgICAgICBuYW1lOiByZWYubmFtZSxcbiAgICB9O1xufVxuLyoqXG4gKiBUaGUgbG9vc2UgdXBwZXIgYm91bmQgb24gdGhlIG51bWJlciBvZiBldmVudHMgdGhhdCBzaG91bGQgYmUgcmV0YWluZWQgaW4gYVxuICogdHJhY2UuIFRoaXMgbWF5IGJlIGV4Y2VlZGVkIGJ5IHVwIHRvIGEgZmFjdG9yIG9mIDIuIEFyYml0cmFyaWx5IGNob3NlbiBhcyBhXG4gKiBudW1iZXIgdGhhdCBzaG91bGQgYmUgbGFyZ2UgZW5vdWdoIHRvIGNvbnRhaW4gdGhlIHJlY2VudCByZWxldmFudFxuICogaW5mb3JtYXRpb24sIGJ1dCBzbWFsbCBlbm91Z2ggdG8gbm90IHVzZSBleGNlc3NpdmUgbWVtb3J5LlxuICovXG5jb25zdCBUQVJHRVRfUkVUQUlORURfVFJBQ0VTID0gMzI7XG5jbGFzcyBDaGFubmVselRyYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHNMb2dnZWQgPSAwO1xuICAgICAgICB0aGlzLmNyZWF0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgYWRkVHJhY2Uoc2V2ZXJpdHksIGRlc2NyaXB0aW9uLCBjaGlsZCkge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNldmVyaXR5OiBzZXZlcml0eSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgY2hpbGRDaGFubmVsOiAoY2hpbGQgPT09IG51bGwgfHwgY2hpbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkLmtpbmQpID09PSAnY2hhbm5lbCcgPyBjaGlsZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoaWxkU3ViY2hhbm5lbDogKGNoaWxkID09PSBudWxsIHx8IGNoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZC5raW5kKSA9PT0gJ3N1YmNoYW5uZWwnID8gY2hpbGQgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXaGVuZXZlciB0aGUgdHJhY2UgYXJyYXkgZ2V0cyB0b28gbGFyZ2UsIGRpc2NhcmQgdGhlIGZpcnN0IGhhbGZcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA+PSBUQVJHRVRfUkVUQUlORURfVFJBQ0VTICogMikge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cy5zbGljZShUQVJHRVRfUkVUQUlORURfVFJBQ0VTKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50c0xvZ2dlZCArPSAxO1xuICAgIH1cbiAgICBnZXRUcmFjZU1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGlvbl90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHRoaXMuY3JlYXRpb25UaW1lc3RhbXApLFxuICAgICAgICAgICAgbnVtX2V2ZW50c19sb2dnZWQ6IHRoaXMuZXZlbnRzTG9nZ2VkLFxuICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cy5tYXAoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBldmVudC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHk6IGV2ZW50LnNldmVyaXR5LFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKGV2ZW50LnRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxfcmVmOiBldmVudC5jaGlsZENoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZENoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxfcmVmOiBldmVudC5jaGlsZFN1YmNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZFN1YmNoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpUcmFjZSA9IENoYW5uZWx6VHJhY2U7XG5jbGFzcyBDaGFubmVsekNoaWxkcmVuVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgcmVmQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSAoX2EgPSB0aGlzLmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogY2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3ViY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSAoX2IgPSB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogY2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc29ja2V0Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrZWRDaGlsZCA9IChfYyA9IHRoaXMuc29ja2V0Q2hpbGRyZW4uZ2V0KGNoaWxkLmlkKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGNoaWxkLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVmQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgc3dpdGNoIChjaGlsZC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdjaGFubmVsJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrZWRDaGlsZCA9IHRoaXMuY2hhbm5lbENoaWxkcmVuLmdldChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDaGlsZHJlbi5kZWxldGUoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3ViY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uZGVsZXRlKGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NvY2tldCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSB0aGlzLnNvY2tldENoaWxkcmVuLmdldChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLmRlbGV0ZShjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDaGlsZExpc3RzKCkge1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5jaGFubmVsQ2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNoYW5uZWxzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJjaGFubmVscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyByZWYgfSBvZiB0aGlzLnNvY2tldENoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXRzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFubmVscywgc3ViY2hhbm5lbHMsIHNvY2tldHMgfTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyID0gQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXI7XG5jbGFzcyBDaGFubmVsekNhbGxUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jYWxsc1N0YXJ0ZWQgPSAwO1xuICAgICAgICB0aGlzLmNhbGxzU3VjY2VlZGVkID0gMDtcbiAgICAgICAgdGhpcy5jYWxsc0ZhaWxlZCA9IDA7XG4gICAgICAgIHRoaXMubGFzdENhbGxTdGFydGVkVGltZXN0YW1wID0gbnVsbDtcbiAgICB9XG4gICAgYWRkQ2FsbFN0YXJ0ZWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdGFydGVkICs9IDE7XG4gICAgICAgIHRoaXMubGFzdENhbGxTdGFydGVkVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgYWRkQ2FsbFN1Y2NlZWRlZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsc1N1Y2NlZWRlZCArPSAxO1xuICAgIH1cbiAgICBhZGRDYWxsRmFpbGVkKCkge1xuICAgICAgICB0aGlzLmNhbGxzRmFpbGVkICs9IDE7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyID0gQ2hhbm5lbHpDYWxsVHJhY2tlcjtcbmxldCBuZXh0SWQgPSAxO1xuZnVuY3Rpb24gZ2V0TmV4dElkKCkge1xuICAgIHJldHVybiBuZXh0SWQrKztcbn1cbmNvbnN0IGNoYW5uZWxzID0gW107XG5jb25zdCBzdWJjaGFubmVscyA9IFtdO1xuY29uc3Qgc2VydmVycyA9IFtdO1xuY29uc3Qgc29ja2V0cyA9IFtdO1xuZnVuY3Rpb24gcmVnaXN0ZXJDaGFubmVsekNoYW5uZWwobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBuYW1lLCBraW5kOiAnY2hhbm5lbCcgfTtcbiAgICBpZiAoY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgIGNoYW5uZWxzW2lkXSA9IHsgcmVmLCBnZXRJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiByZWY7XG59XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsID0gcmVnaXN0ZXJDaGFubmVsekNoYW5uZWw7XG5mdW5jdGlvbiByZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbChuYW1lLCBnZXRJbmZvLCBjaGFubmVsekVuYWJsZWQpIHtcbiAgICBjb25zdCBpZCA9IGdldE5leHRJZCgpO1xuICAgIGNvbnN0IHJlZiA9IHsgaWQsIG5hbWUsIGtpbmQ6ICdzdWJjaGFubmVsJyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc3ViY2hhbm5lbHNbaWRdID0geyByZWYsIGdldEluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwgPSByZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbDtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXIoZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBraW5kOiAnc2VydmVyJyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc2VydmVyc1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gcmVnaXN0ZXJDaGFubmVselNlcnZlcjtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBuYW1lLCBraW5kOiAnc29ja2V0JyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc29ja2V0c1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gcmVnaXN0ZXJDaGFubmVselNvY2tldDtcbmZ1bmN0aW9uIHVucmVnaXN0ZXJDaGFubmVselJlZihyZWYpIHtcbiAgICBzd2l0Y2ggKHJlZi5raW5kKSB7XG4gICAgICAgIGNhc2UgJ2NoYW5uZWwnOlxuICAgICAgICAgICAgZGVsZXRlIGNoYW5uZWxzW3JlZi5pZF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ3N1YmNoYW5uZWwnOlxuICAgICAgICAgICAgZGVsZXRlIHN1YmNoYW5uZWxzW3JlZi5pZF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ3NlcnZlcic6XG4gICAgICAgICAgICBkZWxldGUgc2VydmVyc1tyZWYuaWRdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdzb2NrZXQnOlxuICAgICAgICAgICAgZGVsZXRlIHNvY2tldHNbcmVmLmlkXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG59XG5leHBvcnRzLnVucmVnaXN0ZXJDaGFubmVselJlZiA9IHVucmVnaXN0ZXJDaGFubmVselJlZjtcbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgc2VjdGlvbiBvZiBhbiBJUHY2IGFkZHJlc3MgYXMgdHdvIGJ5dGVzXG4gKiBAcGFyYW0gYWRkcmVzc1NlY3Rpb24gQSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgbGVuZ3RoIHVwIHRvIDRcbiAqIEByZXR1cm5zIFRoZSBwYWlyIG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIGFkZHJlc3Mgc2VjdGlvblxuICovXG5mdW5jdGlvbiBwYXJzZUlQdjZTZWN0aW9uKGFkZHJlc3NTZWN0aW9uKSB7XG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBOdW1iZXIucGFyc2VJbnQoYWRkcmVzc1NlY3Rpb24sIDE2KTtcbiAgICByZXR1cm4gWyhudW1iZXJWYWx1ZSAvIDI1NikgfCAwLCBudW1iZXJWYWx1ZSAlIDI1Nl07XG59XG4vKipcbiAqIFBhcnNlIGEgY2h1bmsgb2YgYW4gSVB2NiBhZGRyZXNzIHN0cmluZyB0byBzb21lIG51bWJlciBvZiBieXRlc1xuICogQHBhcmFtIGFkZHJlc3NDaHVuayBTb21lIG51bWJlciBvZiBzZWdtZW50cyBvZiB1cCB0byA0IGhleGFkZWNpbWFsXG4gKiAgIGNoYXJhY3RlcnMgZWFjaCwgam9pbmVkIGJ5IGNvbG9ucy5cbiAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIGFkZHJlc3MgY2h1bmtcbiAqL1xuZnVuY3Rpb24gcGFyc2VJUHY2Q2h1bmsoYWRkcmVzc0NodW5rKSB7XG4gICAgaWYgKGFkZHJlc3NDaHVuayA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBieXRlUGFpcnMgPSBhZGRyZXNzQ2h1bmtcbiAgICAgICAgLnNwbGl0KCc6JylcbiAgICAgICAgLm1hcChzZWN0aW9uID0+IHBhcnNlSVB2NlNlY3Rpb24oc2VjdGlvbikpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJldHVybiByZXN1bHQuY29uY2F0KC4uLmJ5dGVQYWlycyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgb3IgSVB2NiBhZGRyZXNzIGZyb20gc3RyaW5nIHJlcHJlc2VudGF0aW9uIHRvIGJpbmFyeVxuICogcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSBpcEFkZHJlc3MgYW4gSVAgYWRkcmVzcyBpbiBzdGFuZGFyZCBJUHY0IG9yIElQdjYgdGV4dCBmb3JtYXRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKGlwQWRkcmVzcykge1xuICAgIGlmICgoMCwgbmV0XzEuaXNJUHY0KShpcEFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShVaW50OEFycmF5LmZyb20oaXBBZGRyZXNzLnNwbGl0KCcuJykubWFwKHNlZ21lbnQgPT4gTnVtYmVyLnBhcnNlSW50KHNlZ21lbnQpKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgbmV0XzEuaXNJUHY2KShpcEFkZHJlc3MpKSB7XG4gICAgICAgIGxldCBsZWZ0U2VjdGlvbjtcbiAgICAgICAgbGV0IHJpZ2h0U2VjdGlvbjtcbiAgICAgICAgY29uc3QgZG91YmxlQ29sb25JbmRleCA9IGlwQWRkcmVzcy5pbmRleE9mKCc6OicpO1xuICAgICAgICBpZiAoZG91YmxlQ29sb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxlZnRTZWN0aW9uID0gaXBBZGRyZXNzO1xuICAgICAgICAgICAgcmlnaHRTZWN0aW9uID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWZ0U2VjdGlvbiA9IGlwQWRkcmVzcy5zdWJzdHJpbmcoMCwgZG91YmxlQ29sb25JbmRleCk7XG4gICAgICAgICAgICByaWdodFNlY3Rpb24gPSBpcEFkZHJlc3Muc3Vic3RyaW5nKGRvdWJsZUNvbG9uSW5kZXggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZWZ0QnVmZmVyID0gQnVmZmVyLmZyb20ocGFyc2VJUHY2Q2h1bmsobGVmdFNlY3Rpb24pKTtcbiAgICAgICAgY29uc3QgcmlnaHRCdWZmZXIgPSBCdWZmZXIuZnJvbShwYXJzZUlQdjZDaHVuayhyaWdodFNlY3Rpb24pKTtcbiAgICAgICAgY29uc3QgbWlkZGxlQnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2IC0gbGVmdEJ1ZmZlci5sZW5ndGggLSByaWdodEJ1ZmZlci5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbbGVmdEJ1ZmZlciwgbWlkZGxlQnVmZmVyLCByaWdodEJ1ZmZlcl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2Uoc3RhdGUpIHtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdDT05ORUNUSU5HJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdJRExFJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFk6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnUkVBRFknLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdTSFVURE9XTicsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1RSQU5TSUVOVF9GQUlMVVJFJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnVU5LTk9XTicsXG4gICAgICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRhdGVUb1Byb3RvVGltZXN0YW1wKGRhdGUpIHtcbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1pbGxpc1NpbmNlRXBvY2ggPSBkYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWNvbmRzOiAobWlsbGlzU2luY2VFcG9jaCAvIDEwMDApIHwgMCxcbiAgICAgICAgbmFub3M6IChtaWxsaXNTaW5jZUVwb2NoICUgMTAwMCkgKiAxMDAwMDAwLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpIHtcbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBjaGFubmVsRW50cnkuZ2V0SW5mbygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZjogY2hhbm5lbFJlZlRvTWVzc2FnZShjaGFubmVsRW50cnkucmVmKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGFyZ2V0OiByZXNvbHZlZEluZm8udGFyZ2V0LFxuICAgICAgICAgICAgc3RhdGU6IGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHJlc29sdmVkSW5mby5zdGF0ZSksXG4gICAgICAgICAgICBjYWxsc19zdGFydGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBjYWxsc19mYWlsZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIGxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpLFxuICAgICAgICB9LFxuICAgICAgICBjaGFubmVsX3JlZjogcmVzb2x2ZWRJbmZvLmNoaWxkcmVuLmNoYW5uZWxzLm1hcChyZWYgPT4gY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpKSxcbiAgICAgICAgc3ViY2hhbm5lbF9yZWY6IHJlc29sdmVkSW5mby5jaGlsZHJlbi5zdWJjaGFubmVscy5tYXAocmVmID0+IHN1YmNoYW5uZWxSZWZUb01lc3NhZ2UocmVmKSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEdldENoYW5uZWwoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjaGFubmVsSWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LmNoYW5uZWxfaWQpO1xuICAgIGNvbnN0IGNoYW5uZWxFbnRyeSA9IGNoYW5uZWxzW2NoYW5uZWxJZF07XG4gICAgaWYgKGNoYW5uZWxFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgICAgICAgICBkZXRhaWxzOiAnTm8gY2hhbm5lbCBkYXRhIGZvdW5kIGZvciBpZCAnICsgY2hhbm5lbElkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7IGNoYW5uZWw6IGdldENoYW5uZWxNZXNzYWdlKGNoYW5uZWxFbnRyeSkgfSk7XG59XG5mdW5jdGlvbiBHZXRUb3BDaGFubmVscyhjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1heFJlc3VsdHMgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzKTtcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgbGV0IGkgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X2NoYW5uZWxfaWQpO1xuICAgIGZvciAoOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbEVudHJ5ID0gY2hhbm5lbHNbaV07XG4gICAgICAgIGlmIChjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKGdldENoYW5uZWxNZXNzYWdlKGNoYW5uZWxFbnRyeSkpO1xuICAgICAgICBpZiAocmVzdWx0TGlzdC5sZW5ndGggPj0gbWF4UmVzdWx0cykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICBjaGFubmVsOiByZXN1bHRMaXN0LFxuICAgICAgICBlbmQ6IGkgPj0gc2VydmVycy5sZW5ndGgsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTZXJ2ZXJNZXNzYWdlKHNlcnZlckVudHJ5KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc2VydmVyRW50cnkuZ2V0SW5mbygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZjogc2VydmVyUmVmVG9NZXNzYWdlKHNlcnZlckVudHJ5LnJlZiksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGNhbGxzX3N0YXJ0ZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBjYWxsc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIHRyYWNlOiByZXNvbHZlZEluZm8udHJhY2UuZ2V0VHJhY2VNZXNzYWdlKCksXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3Rlbl9zb2NrZXQ6IHJlc29sdmVkSW5mby5saXN0ZW5lckNoaWxkcmVuLnNvY2tldHMubWFwKHJlZiA9PiBzb2NrZXRSZWZUb01lc3NhZ2UocmVmKSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEdldFNlcnZlcihjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlcnZlcklkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zZXJ2ZXJfaWQpO1xuICAgIGNvbnN0IHNlcnZlckVudHJ5ID0gc2VydmVyc1tzZXJ2ZXJJZF07XG4gICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzZXJ2ZXIgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNlcnZlcklkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7IHNlcnZlcjogZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkgfSk7XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXJzKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMpO1xuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcbiAgICBsZXQgaSA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc3RhcnRfc2VydmVyX2lkKTtcbiAgICBmb3IgKDsgaSA8IHNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJzW2ldO1xuICAgICAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKGdldFNlcnZlck1lc3NhZ2Uoc2VydmVyRW50cnkpKTtcbiAgICAgICAgaWYgKHJlc3VsdExpc3QubGVuZ3RoID49IG1heFJlc3VsdHMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgc2VydmVyOiByZXN1bHRMaXN0LFxuICAgICAgICBlbmQ6IGkgPj0gc2VydmVycy5sZW5ndGgsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBHZXRTdWJjaGFubmVsKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc3ViY2hhbm5lbElkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zdWJjaGFubmVsX2lkKTtcbiAgICBjb25zdCBzdWJjaGFubmVsRW50cnkgPSBzdWJjaGFubmVsc1tzdWJjaGFubmVsSWRdO1xuICAgIGlmIChzdWJjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHN1YmNoYW5uZWwgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHN1YmNoYW5uZWxJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc3ViY2hhbm5lbEVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBzdWJjaGFubmVsTWVzc2FnZSA9IHtcbiAgICAgICAgcmVmOiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHN1YmNoYW5uZWxFbnRyeS5yZWYpLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IHJlc29sdmVkSW5mby50YXJnZXQsXG4gICAgICAgICAgICBzdGF0ZTogY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2UocmVzb2x2ZWRJbmZvLnN0YXRlKSxcbiAgICAgICAgICAgIGNhbGxzX3N0YXJ0ZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBjYWxsc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIHRyYWNlOiByZXNvbHZlZEluZm8udHJhY2UuZ2V0VHJhY2VNZXNzYWdlKCksXG4gICAgICAgIH0sXG4gICAgICAgIHNvY2tldF9yZWY6IHJlc29sdmVkSW5mby5jaGlsZHJlbi5zb2NrZXRzLm1hcChyZWYgPT4gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikpLFxuICAgIH07XG4gICAgY2FsbGJhY2sobnVsbCwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsTWVzc2FnZSB9KTtcbn1cbmZ1bmN0aW9uIHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShzdWJjaGFubmVsQWRkcmVzcykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKHN1YmNoYW5uZWxBZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogJ3RjcGlwX2FkZHJlc3MnLFxuICAgICAgICAgICAgdGNwaXBfYWRkcmVzczoge1xuICAgICAgICAgICAgICAgIGlwX2FkZHJlc3M6IChfYSA9IGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKHN1YmNoYW5uZWxBZGRyZXNzLmhvc3QpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcG9ydDogc3ViY2hhbm5lbEFkZHJlc3MucG9ydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogJ3Vkc19hZGRyZXNzJyxcbiAgICAgICAgICAgIHVkc19hZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHN1YmNoYW5uZWxBZGRyZXNzLnBhdGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIEdldFNvY2tldChjYWxsLCBjYWxsYmFjaykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3Qgc29ja2V0SWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNvY2tldF9pZCk7XG4gICAgY29uc3Qgc29ja2V0RW50cnkgPSBzb2NrZXRzW3NvY2tldElkXTtcbiAgICBpZiAoc29ja2V0RW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHNvY2tldCBkYXRhIGZvdW5kIGZvciBpZCAnICsgc29ja2V0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNvY2tldEVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBzZWN1cml0eU1lc3NhZ2UgPSByZXNvbHZlZEluZm8uc2VjdXJpdHlcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBtb2RlbDogJ3RscycsXG4gICAgICAgICAgICB0bHM6IHtcbiAgICAgICAgICAgICAgICBjaXBoZXJfc3VpdGU6IHJlc29sdmVkSW5mby5zZWN1cml0eS5jaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZVxuICAgICAgICAgICAgICAgICAgICA/ICdzdGFuZGFyZF9uYW1lJ1xuICAgICAgICAgICAgICAgICAgICA6ICdvdGhlcl9uYW1lJyxcbiAgICAgICAgICAgICAgICBzdGFuZGFyZF9uYW1lOiAoX2EgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvdGhlcl9uYW1lOiAoX2IgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVPdGhlck5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsb2NhbF9jZXJ0aWZpY2F0ZTogKF9jID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmxvY2FsQ2VydGlmaWNhdGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZW1vdGVfY2VydGlmaWNhdGU6IChfZCA9IHJlc29sdmVkSW5mby5zZWN1cml0eS5yZW1vdGVDZXJ0aWZpY2F0ZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3Qgc29ja2V0TWVzc2FnZSA9IHtcbiAgICAgICAgcmVmOiBzb2NrZXRSZWZUb01lc3NhZ2Uoc29ja2V0RW50cnkucmVmKSxcbiAgICAgICAgbG9jYWw6IHJlc29sdmVkSW5mby5sb2NhbEFkZHJlc3NcbiAgICAgICAgICAgID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5sb2NhbEFkZHJlc3MpXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIHJlbW90ZTogcmVzb2x2ZWRJbmZvLnJlbW90ZUFkZHJlc3NcbiAgICAgICAgICAgID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzKVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICByZW1vdGVfbmFtZTogKF9lID0gcmVzb2x2ZWRJbmZvLnJlbW90ZU5hbWUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VjdXJpdHk6IHNlY3VyaXR5TWVzc2FnZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAga2VlcF9hbGl2ZXNfc2VudDogcmVzb2x2ZWRJbmZvLmtlZXBBbGl2ZXNTZW50LFxuICAgICAgICAgICAgc3RyZWFtc19zdGFydGVkOiByZXNvbHZlZEluZm8uc3RyZWFtc1N0YXJ0ZWQsXG4gICAgICAgICAgICBzdHJlYW1zX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNTdWNjZWVkZWQsXG4gICAgICAgICAgICBzdHJlYW1zX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2xvY2FsX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbGFzdF9yZW1vdGVfc3RyZWFtX2NyZWF0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8ubGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbWVzc2FnZXNfcmVjZWl2ZWQ6IHJlc29sdmVkSW5mby5tZXNzYWdlc1JlY2VpdmVkLFxuICAgICAgICAgICAgbWVzc2FnZXNfc2VudDogcmVzb2x2ZWRJbmZvLm1lc3NhZ2VzU2VudCxcbiAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9yZWNlaXZlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9zZW50X3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCksXG4gICAgICAgICAgICBsb2NhbF9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ubG9jYWxGbG93Q29udHJvbFdpbmRvd1xuICAgICAgICAgICAgICAgID8geyB2YWx1ZTogcmVzb2x2ZWRJbmZvLmxvY2FsRmxvd0NvbnRyb2xXaW5kb3cgfVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJlbW90ZV9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ucmVtb3RlRmxvd0NvbnRyb2xXaW5kb3dcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IHJlc29sdmVkSW5mby5yZW1vdGVGbG93Q29udHJvbFdpbmRvdyB9XG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgY2FsbGJhY2sobnVsbCwgeyBzb2NrZXQ6IHNvY2tldE1lc3NhZ2UgfSk7XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXJTb2NrZXRzKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VydmVySWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNlcnZlcl9pZCk7XG4gICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJzW3NlcnZlcklkXTtcbiAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHNlcnZlciBkYXRhIGZvdW5kIGZvciBpZCAnICsgc2VydmVySWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X3NvY2tldF9pZCk7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMpO1xuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNlcnZlckVudHJ5LmdldEluZm8oKTtcbiAgICAvLyBJZiB3ZSB3YW50ZWQgdG8gaW5jbHVkZSBsaXN0ZW5lciBzb2NrZXRzIGluIHRoZSByZXN1bHQsIHRoaXMgbGluZSB3b3VsZFxuICAgIC8vIGluc3RlYWQgc2F5XG4gICAgLy8gY29uc3QgYWxsU29ja2V0cyA9IHJlc29sdmVkSW5mby5saXN0ZW5lckNoaWxkcmVuLnNvY2tldHMuY29uY2F0KHJlc29sdmVkSW5mby5zZXNzaW9uQ2hpbGRyZW4uc29ja2V0cykuc29ydCgocmVmMSwgcmVmMikgPT4gcmVmMS5pZCAtIHJlZjIuaWQpO1xuICAgIGNvbnN0IGFsbFNvY2tldHMgPSByZXNvbHZlZEluZm8uc2Vzc2lvbkNoaWxkcmVuLnNvY2tldHMuc29ydCgocmVmMSwgcmVmMikgPT4gcmVmMS5pZCAtIHJlZjIuaWQpO1xuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBhbGxTb2NrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbGxTb2NrZXRzW2ldLmlkID49IHN0YXJ0SWQpIHtcbiAgICAgICAgICAgIHJlc3VsdExpc3QucHVzaChzb2NrZXRSZWZUb01lc3NhZ2UoYWxsU29ja2V0c1tpXSkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdExpc3QubGVuZ3RoID49IG1heFJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHNvY2tldF9yZWY6IHJlc3VsdExpc3QsXG4gICAgICAgIGVuZDogaSA+PSBhbGxTb2NrZXRzLmxlbmd0aCxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWx6SGFuZGxlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgR2V0Q2hhbm5lbCxcbiAgICAgICAgR2V0VG9wQ2hhbm5lbHMsXG4gICAgICAgIEdldFNlcnZlcixcbiAgICAgICAgR2V0U2VydmVycyxcbiAgICAgICAgR2V0U3ViY2hhbm5lbCxcbiAgICAgICAgR2V0U29ja2V0LFxuICAgICAgICBHZXRTZXJ2ZXJTb2NrZXRzLFxuICAgIH07XG59XG5leHBvcnRzLmdldENoYW5uZWx6SGFuZGxlcnMgPSBnZXRDaGFubmVsekhhbmRsZXJzO1xubGV0IGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbiA9IG51bGw7XG5mdW5jdGlvbiBnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uKCkge1xuICAgIGlmIChsb2FkZWRDaGFubmVsekRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbjtcbiAgICB9XG4gICAgLyogVGhlIHB1cnBvc2Ugb2YgdGhpcyBjb21wbGV4aXR5IGlzIHRvIGF2b2lkIGxvYWRpbmcgQGdycGMvcHJvdG8tbG9hZGVyIGF0XG4gICAgICogcnVudGltZSBmb3IgdXNlcnMgd2hvIHdpbGwgbm90IHVzZS9lbmFibGUgY2hhbm5lbHouICovXG4gICAgY29uc3QgbG9hZGVyTG9hZFN5bmMgPSByZXF1aXJlKCdAZ3JwYy9wcm90by1sb2FkZXInKVxuICAgICAgICAubG9hZFN5bmM7XG4gICAgY29uc3QgbG9hZGVkUHJvdG8gPSBsb2FkZXJMb2FkU3luYygnY2hhbm5lbHoucHJvdG8nLCB7XG4gICAgICAgIGtlZXBDYXNlOiB0cnVlLFxuICAgICAgICBsb25nczogU3RyaW5nLFxuICAgICAgICBlbnVtczogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0czogdHJ1ZSxcbiAgICAgICAgb25lb2ZzOiB0cnVlLFxuICAgICAgICBpbmNsdWRlRGlyczogW2Ake19fZGlybmFtZX0vLi4vLi4vcHJvdG9gXSxcbiAgICB9KTtcbiAgICBjb25zdCBjaGFubmVsekdycGNPYmplY3QgPSAoMCwgbWFrZV9jbGllbnRfMS5sb2FkUGFja2FnZURlZmluaXRpb24pKGxvYWRlZFByb3RvKTtcbiAgICBsb2FkZWRDaGFubmVsekRlZmluaXRpb24gPVxuICAgICAgICBjaGFubmVsekdycGNPYmplY3QuZ3JwYy5jaGFubmVsei52MS5DaGFubmVsei5zZXJ2aWNlO1xuICAgIHJldHVybiBsb2FkZWRDaGFubmVsekRlZmluaXRpb247XG59XG5leHBvcnRzLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24gPSBnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uO1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2UpKGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24sIGdldENoYW5uZWx6SGFuZGxlcnMpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbHouanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2V0dXAiLCJnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uIiwiZ2V0Q2hhbm5lbHpIYW5kbGVycyIsInVucmVnaXN0ZXJDaGFubmVselJlZiIsInJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQiLCJyZWdpc3RlckNoYW5uZWx6U2VydmVyIiwicmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwiLCJyZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCIsIkNoYW5uZWx6Q2FsbFRyYWNrZXIiLCJDaGFubmVsekNoaWxkcmVuVHJhY2tlciIsIkNoYW5uZWx6VHJhY2UiLCJuZXRfMSIsInJlcXVpcmUiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsImNvbnN0YW50c18xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJhZG1pbl8xIiwibWFrZV9jbGllbnRfMSIsImNoYW5uZWxSZWZUb01lc3NhZ2UiLCJyZWYiLCJjaGFubmVsX2lkIiwiaWQiLCJuYW1lIiwic3ViY2hhbm5lbFJlZlRvTWVzc2FnZSIsInN1YmNoYW5uZWxfaWQiLCJzZXJ2ZXJSZWZUb01lc3NhZ2UiLCJzZXJ2ZXJfaWQiLCJzb2NrZXRSZWZUb01lc3NhZ2UiLCJzb2NrZXRfaWQiLCJUQVJHRVRfUkVUQUlORURfVFJBQ0VTIiwiY29uc3RydWN0b3IiLCJldmVudHMiLCJldmVudHNMb2dnZWQiLCJjcmVhdGlvblRpbWVzdGFtcCIsIkRhdGUiLCJhZGRUcmFjZSIsInNldmVyaXR5IiwiZGVzY3JpcHRpb24iLCJjaGlsZCIsInRpbWVzdGFtcCIsInB1c2giLCJjaGlsZENoYW5uZWwiLCJraW5kIiwidW5kZWZpbmVkIiwiY2hpbGRTdWJjaGFubmVsIiwibGVuZ3RoIiwic2xpY2UiLCJnZXRUcmFjZU1lc3NhZ2UiLCJjcmVhdGlvbl90aW1lc3RhbXAiLCJkYXRlVG9Qcm90b1RpbWVzdGFtcCIsIm51bV9ldmVudHNfbG9nZ2VkIiwibWFwIiwiZXZlbnQiLCJjaGFubmVsX3JlZiIsInN1YmNoYW5uZWxfcmVmIiwiY2hhbm5lbENoaWxkcmVuIiwiTWFwIiwic3ViY2hhbm5lbENoaWxkcmVuIiwic29ja2V0Q2hpbGRyZW4iLCJyZWZDaGlsZCIsIl9hIiwiX2IiLCJfYyIsInRyYWNrZWRDaGlsZCIsImdldCIsImNvdW50Iiwic2V0IiwidW5yZWZDaGlsZCIsImRlbGV0ZSIsImdldENoaWxkTGlzdHMiLCJjaGFubmVscyIsInZhbHVlcyIsInN1YmNoYW5uZWxzIiwic29ja2V0cyIsImNhbGxzU3RhcnRlZCIsImNhbGxzU3VjY2VlZGVkIiwiY2FsbHNGYWlsZWQiLCJsYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAiLCJhZGRDYWxsU3RhcnRlZCIsImFkZENhbGxTdWNjZWVkZWQiLCJhZGRDYWxsRmFpbGVkIiwibmV4dElkIiwiZ2V0TmV4dElkIiwic2VydmVycyIsImdldEluZm8iLCJjaGFubmVsekVuYWJsZWQiLCJwYXJzZUlQdjZTZWN0aW9uIiwiYWRkcmVzc1NlY3Rpb24iLCJudW1iZXJWYWx1ZSIsIk51bWJlciIsInBhcnNlSW50IiwicGFyc2VJUHY2Q2h1bmsiLCJhZGRyZXNzQ2h1bmsiLCJieXRlUGFpcnMiLCJzcGxpdCIsInNlY3Rpb24iLCJyZXN1bHQiLCJjb25jYXQiLCJpcEFkZHJlc3NTdHJpbmdUb0J1ZmZlciIsImlwQWRkcmVzcyIsImlzSVB2NCIsIkJ1ZmZlciIsImZyb20iLCJVaW50OEFycmF5Iiwic2VnbWVudCIsImlzSVB2NiIsImxlZnRTZWN0aW9uIiwicmlnaHRTZWN0aW9uIiwiZG91YmxlQ29sb25JbmRleCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJsZWZ0QnVmZmVyIiwicmlnaHRCdWZmZXIiLCJtaWRkbGVCdWZmZXIiLCJhbGxvYyIsImNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlIiwic3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIkNPTk5FQ1RJTkciLCJJRExFIiwiUkVBRFkiLCJTSFVURE9XTiIsIlRSQU5TSUVOVF9GQUlMVVJFIiwiZGF0ZSIsIm1pbGxpc1NpbmNlRXBvY2giLCJnZXRUaW1lIiwic2Vjb25kcyIsIm5hbm9zIiwiZ2V0Q2hhbm5lbE1lc3NhZ2UiLCJjaGFubmVsRW50cnkiLCJyZXNvbHZlZEluZm8iLCJkYXRhIiwidGFyZ2V0IiwiY2FsbHNfc3RhcnRlZCIsImNhbGxUcmFja2VyIiwiY2FsbHNfc3VjY2VlZGVkIiwiY2FsbHNfZmFpbGVkIiwibGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wIiwidHJhY2UiLCJjaGlsZHJlbiIsIkdldENoYW5uZWwiLCJjYWxsIiwiY2FsbGJhY2siLCJjaGFubmVsSWQiLCJyZXF1ZXN0IiwiY29kZSIsIlN0YXR1cyIsIk5PVF9GT1VORCIsImRldGFpbHMiLCJjaGFubmVsIiwiR2V0VG9wQ2hhbm5lbHMiLCJtYXhSZXN1bHRzIiwibWF4X3Jlc3VsdHMiLCJyZXN1bHRMaXN0IiwiaSIsInN0YXJ0X2NoYW5uZWxfaWQiLCJlbmQiLCJnZXRTZXJ2ZXJNZXNzYWdlIiwic2VydmVyRW50cnkiLCJsaXN0ZW5fc29ja2V0IiwibGlzdGVuZXJDaGlsZHJlbiIsIkdldFNlcnZlciIsInNlcnZlcklkIiwic2VydmVyIiwiR2V0U2VydmVycyIsInN0YXJ0X3NlcnZlcl9pZCIsIkdldFN1YmNoYW5uZWwiLCJzdWJjaGFubmVsSWQiLCJzdWJjaGFubmVsRW50cnkiLCJzdWJjaGFubmVsTWVzc2FnZSIsInNvY2tldF9yZWYiLCJzdWJjaGFubmVsIiwic3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlIiwic3ViY2hhbm5lbEFkZHJlc3MiLCJpc1RjcFN1YmNoYW5uZWxBZGRyZXNzIiwiYWRkcmVzcyIsInRjcGlwX2FkZHJlc3MiLCJpcF9hZGRyZXNzIiwiaG9zdCIsInBvcnQiLCJ1ZHNfYWRkcmVzcyIsImZpbGVuYW1lIiwicGF0aCIsIkdldFNvY2tldCIsIl9kIiwiX2UiLCJzb2NrZXRJZCIsInNvY2tldEVudHJ5Iiwic2VjdXJpdHlNZXNzYWdlIiwic2VjdXJpdHkiLCJtb2RlbCIsInRscyIsImNpcGhlcl9zdWl0ZSIsImNpcGhlclN1aXRlU3RhbmRhcmROYW1lIiwic3RhbmRhcmRfbmFtZSIsIm90aGVyX25hbWUiLCJjaXBoZXJTdWl0ZU90aGVyTmFtZSIsImxvY2FsX2NlcnRpZmljYXRlIiwibG9jYWxDZXJ0aWZpY2F0ZSIsInJlbW90ZV9jZXJ0aWZpY2F0ZSIsInJlbW90ZUNlcnRpZmljYXRlIiwic29ja2V0TWVzc2FnZSIsImxvY2FsIiwibG9jYWxBZGRyZXNzIiwicmVtb3RlIiwicmVtb3RlQWRkcmVzcyIsInJlbW90ZV9uYW1lIiwicmVtb3RlTmFtZSIsImtlZXBfYWxpdmVzX3NlbnQiLCJrZWVwQWxpdmVzU2VudCIsInN0cmVhbXNfc3RhcnRlZCIsInN0cmVhbXNTdGFydGVkIiwic3RyZWFtc19zdWNjZWVkZWQiLCJzdHJlYW1zU3VjY2VlZGVkIiwic3RyZWFtc19mYWlsZWQiLCJzdHJlYW1zRmFpbGVkIiwibGFzdF9sb2NhbF9zdHJlYW1fY3JlYXRlZF90aW1lc3RhbXAiLCJsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibGFzdF9yZW1vdGVfc3RyZWFtX2NyZWF0ZWRfdGltZXN0YW1wIiwibGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXAiLCJtZXNzYWdlc19yZWNlaXZlZCIsIm1lc3NhZ2VzUmVjZWl2ZWQiLCJtZXNzYWdlc19zZW50IiwibWVzc2FnZXNTZW50IiwibGFzdF9tZXNzYWdlX3JlY2VpdmVkX3RpbWVzdGFtcCIsImxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAiLCJsYXN0X21lc3NhZ2Vfc2VudF90aW1lc3RhbXAiLCJsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAiLCJsb2NhbF9mbG93X2NvbnRyb2xfd2luZG93IiwibG9jYWxGbG93Q29udHJvbFdpbmRvdyIsInJlbW90ZV9mbG93X2NvbnRyb2xfd2luZG93IiwicmVtb3RlRmxvd0NvbnRyb2xXaW5kb3ciLCJzb2NrZXQiLCJHZXRTZXJ2ZXJTb2NrZXRzIiwic3RhcnRJZCIsInN0YXJ0X3NvY2tldF9pZCIsImFsbFNvY2tldHMiLCJzZXNzaW9uQ2hpbGRyZW4iLCJzb3J0IiwicmVmMSIsInJlZjIiLCJsb2FkZWRDaGFubmVsekRlZmluaXRpb24iLCJsb2FkZXJMb2FkU3luYyIsImxvYWRTeW5jIiwibG9hZGVkUHJvdG8iLCJrZWVwQ2FzZSIsImxvbmdzIiwiU3RyaW5nIiwiZW51bXMiLCJkZWZhdWx0cyIsIm9uZW9mcyIsImluY2x1ZGVEaXJzIiwiX19kaXJuYW1lIiwiY2hhbm5lbHpHcnBjT2JqZWN0IiwibG9hZFBhY2thZ2VEZWZpbml0aW9uIiwiZ3JwYyIsImNoYW5uZWx6IiwidjEiLCJDaGFubmVseiIsInNlcnZpY2UiLCJyZWdpc3RlckFkbWluU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/error.js\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */ class InterceptorConfigurationError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"InterceptorConfigurationError\";\n        Error.captureStackTrace(this, InterceptorConfigurationError);\n    }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n    constructor(){\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveStatus(onReceiveStatus) {\n        this.status = onReceiveStatus;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveStatus: this.status\n        };\n    }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n    constructor(){\n        this.start = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withHalfClose(halfClose) {\n        this.halfClose = halfClose;\n        return this;\n    }\n    withCancel(cancel) {\n        this.cancel = cancel;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMessage: this.message,\n            halfClose: this.halfClose,\n            cancel: this.cancel\n        };\n    }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */ const defaultListener = {\n    onReceiveMetadata: (metadata, next)=>{\n        next(metadata);\n    },\n    onReceiveMessage: (message, next)=>{\n        next(message);\n    },\n    onReceiveStatus: (status, next)=>{\n        next(status);\n    }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */ const defaultRequester = {\n    start: (metadata, listener, next)=>{\n        next(metadata, listener);\n    },\n    sendMessage: (message, next)=>{\n        next(message);\n    },\n    halfClose: (next)=>{\n        next();\n    },\n    cancel: (next)=>{\n        next();\n    }\n};\nclass InterceptingCall {\n    constructor(nextCall, requester){\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        /**\n         * Indicates that metadata has been passed to the requester's start\n         * method but it has not been passed to the corresponding next callback\n         */ this.processingMetadata = false;\n        /**\n         * Message context for a pending message that is waiting for\n         */ this.pendingMessageContext = null;\n        /**\n         * Indicates that a message has been passed to the requester's sendMessage\n         * method but it has not been passed to the corresponding next callback\n         */ this.processingMessage = false;\n        /**\n         * Indicates that a status was received but could not be propagated because\n         * a message was still being processed.\n         */ this.pendingHalfClose = false;\n        if (requester) {\n            this.requester = {\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n            };\n        } else {\n            this.requester = defaultRequester;\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.requester.cancel(()=>{\n            this.nextCall.cancelWithStatus(status, details);\n        });\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    processPendingMessage() {\n        if (this.pendingMessageContext) {\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n            this.pendingMessageContext = null;\n            this.pendingMessage = null;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.pendingHalfClose) {\n            this.nextCall.halfClose();\n        }\n    }\n    start(metadata, interceptingListener) {\n        var _a, _b, _c, _d, _e, _f;\n        const fullInterceptingListener = {\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata)=>{},\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message)=>{},\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status)=>{}\n        };\n        this.processingMetadata = true;\n        this.requester.start(metadata, fullInterceptingListener, (md, listener)=>{\n            var _a, _b, _c;\n            this.processingMetadata = false;\n            let finalInterceptingListener;\n            if ((0, call_interface_1.isInterceptingListener)(listener)) {\n                finalInterceptingListener = listener;\n            } else {\n                const fullListener = {\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n                };\n                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n            }\n            this.nextCall.start(md, finalInterceptingListener);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        this.processingMessage = true;\n        this.requester.sendMessage(message, (finalMessage)=>{\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessageContext = context;\n                this.pendingMessage = message;\n            } else {\n                this.nextCall.sendMessageWithContext(context, finalMessage);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    halfClose() {\n        this.requester.halfClose(()=>{\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingHalfClose = true;\n            } else {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n    var _a, _b;\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n    const host = options.host;\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n    const propagateFlags = options.propagate_flags;\n    const credentials = options.credentials;\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n    if (credentials) {\n        call.setCredentials(credentials);\n    }\n    return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */ class BaseInterceptingCall {\n    constructor(call, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    methodDefinition){\n        this.call = call;\n        this.methodDefinition = methodDefinition;\n    }\n    cancelWithStatus(status, details) {\n        this.call.cancelWithStatus(status, details);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        let serialized;\n        try {\n            serialized = this.methodDefinition.requestSerialize(message);\n        } catch (e) {\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);\n            return;\n        }\n        this.call.sendMessageWithContext(context, serialized);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    start(metadata, interceptingListener) {\n        let readError = null;\n        this.call.start(metadata, {\n            onReceiveMetadata: (metadata)=>{\n                var _a;\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n            },\n            onReceiveMessage: (message)=>{\n                var _a;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let deserialized;\n                try {\n                    deserialized = this.methodDefinition.responseDeserialize(message);\n                } catch (e) {\n                    readError = {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,\n                        metadata: new metadata_1.Metadata()\n                    };\n                    this.call.cancelWithStatus(readError.code, readError.details);\n                    return;\n                }\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n            },\n            onReceiveStatus: (status)=>{\n                var _a, _b;\n                if (readError) {\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n                } else {\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n                }\n            }\n        });\n    }\n    startRead() {\n        this.call.startRead();\n    }\n    halfClose() {\n        this.call.halfClose();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */ class BaseUnaryInterceptingCall extends BaseInterceptingCall {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(call, methodDefinition){\n        super(call, methodDefinition);\n    }\n    start(metadata, listener) {\n        var _a, _b;\n        let receivedMessage = false;\n        const wrapperListener = {\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata)=>{},\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage: (message)=>{\n                var _a;\n                receivedMessage = true;\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n            },\n            onReceiveStatus: (status)=>{\n                var _a, _b;\n                if (!receivedMessage) {\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n                }\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n            }\n        };\n        super.start(metadata, wrapperListener);\n        this.call.startRead();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */ class BaseStreamingInterceptingCall extends BaseInterceptingCall {\n}\nfunction getBottomInterceptingCall(channel, options, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n    const call = getCall(channel, methodDefinition.path, options);\n    if (methodDefinition.responseStream) {\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\n    } else {\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\n    }\n}\nfunction getInterceptingCall(interceptorArgs, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n    if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError(\"Both interceptors and interceptor_providers were passed as options \" + \"to the client constructor. Only one of these is allowed.\");\n    }\n    if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError(\"Both interceptors and interceptor_providers were passed as call \" + \"options. Only one of these is allowed.\");\n    }\n    let interceptors = [];\n    // Interceptors passed to the call override interceptors passed to the client constructor\n    if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider)=>provider(methodDefinition))).filter((interceptor)=>interceptor);\n    // Filter out falsy values when providers return nothing\n    } else {\n        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider)=>provider(methodDefinition))).filter((interceptor)=>interceptor);\n    // Filter out falsy values when providers return nothing\n    }\n    const interceptorOptions = Object.assign({}, options, {\n        method_definition: methodDefinition\n    });\n    /* For each interceptor in the list, the nextCall function passed to it is\n     * based on the next interceptor in the list, using a nextCall function\n     * constructed with the following interceptor in the list, and so on. The\n     * initialValue, which is effectively at the end of the list, is a nextCall\n     * function that invokes getBottomInterceptingCall, the result of which\n     * handles (de)serialization and also gets the underlying call from the\n     * channel. */ const getCall = interceptors.reduceRight((nextCall, nextInterceptor)=>{\n        return (currentOptions)=>nextInterceptor(currentOptions, nextCall);\n    }, (finalOptions)=>getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n    return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall; //# sourceMappingURL=client-interceptors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUdBLHdCQUF3QixHQUFHQSx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUdBLHFDQUFxQyxHQUFHLEtBQUs7QUFDM0osTUFBTU8sYUFBYUMsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDbkQsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsc0VBQVM7QUFDakM7OztDQUdDLEdBQ0QsTUFBTUYsc0NBQXNDTTtJQUN4Q0MsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaSCxNQUFNSSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVWO0lBQ2xDO0FBQ0o7QUFDQU4scUNBQXFDLEdBQUdNO0FBQ3hDLE1BQU1EO0lBQ0ZRLGFBQWM7UUFDVixJQUFJLENBQUNJLFFBQVEsR0FBR0M7UUFDaEIsSUFBSSxDQUFDSixPQUFPLEdBQUdJO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdEO0lBQ2xCO0lBQ0FFLHNCQUFzQkMsaUJBQWlCLEVBQUU7UUFDckMsSUFBSSxDQUFDSixRQUFRLEdBQUdJO1FBQ2hCLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLHFCQUFxQkMsZ0JBQWdCLEVBQUU7UUFDbkMsSUFBSSxDQUFDVCxPQUFPLEdBQUdTO1FBQ2YsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsb0JBQW9CQyxlQUFlLEVBQUU7UUFDakMsSUFBSSxDQUFDTixNQUFNLEdBQUdNO1FBQ2QsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsUUFBUTtR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K0U7UUFDaEQsT0FBT0MsQ0FBQUEsaUJBQWtCRCxnQkFBZ0JDLGdCQUFnQmhGO0lBQzdELEdBQUcsQ0FBQ2lGLGVBQWlCcEIsMEJBQTBCOUIsU0FBU2tELGNBQWNwQztJQUN0RSxPQUFPZixRQUFRNkM7QUFDbkI7QUFDQWxILDJCQUEyQixHQUFHRSxxQkFDOUIsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcz8xMzBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLkludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBleHBvcnRzLkxpc3RlbmVyQnVpbGRlciA9IGV4cG9ydHMuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjYWxsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vY2FsbC1pbnRlcmZhY2VcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbi8qKlxuICogRXJyb3IgY2xhc3MgYXNzb2NpYXRlZCB3aXRoIHBhc3NpbmcgYm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yXG4gKiBwcm92aWRlcnMgdG8gYSBjbGllbnQgY29uc3RydWN0b3Igb3IgYXMgY2FsbCBvcHRpb25zLlxuICovXG5jbGFzcyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3InO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcik7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciA9IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yO1xuY2xhc3MgTGlzdGVuZXJCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2l0aE9uUmVjZWl2ZU1ldGFkYXRhKG9uUmVjZWl2ZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBvblJlY2VpdmVNZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVNZXNzYWdlKG9uUmVjZWl2ZU1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gb25SZWNlaXZlTWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVTdGF0dXMob25SZWNlaXZlU3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gb25SZWNlaXZlU3RhdHVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBMaXN0ZW5lckJ1aWxkZXI7XG5jbGFzcyBSZXF1ZXN0ZXJCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHdpdGhTdGFydChzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoU2VuZE1lc3NhZ2Uoc2VuZE1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gc2VuZE1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoSGFsZkNsb3NlKGhhbGZDbG9zZSkge1xuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IGhhbGZDbG9zZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhDYW5jZWwoY2FuY2VsKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBoYWxmQ2xvc2U6IHRoaXMuaGFsZkNsb3NlLFxuICAgICAgICAgICAgY2FuY2VsOiB0aGlzLmNhbmNlbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBSZXF1ZXN0ZXJCdWlsZGVyO1xuLyoqXG4gKiBBIExpc3RlbmVyIHdpdGggYSBkZWZhdWx0IHBhc3MtdGhyb3VnaCBpbXBsZW1lbnRhdGlvbiBvZiBlYWNoIG1ldGhvZC4gVXNlZFxuICogZm9yIGZpbGxpbmcgb3V0IExpc3RlbmVycyB3aXRoIHNvbWUgbWV0aG9kcyBvbWl0dGVkLlxuICovXG5jb25zdCBkZWZhdWx0TGlzdGVuZXIgPSB7XG4gICAgb25SZWNlaXZlTWV0YWRhdGE6IChtZXRhZGF0YSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1ldGFkYXRhKTtcbiAgICB9LFxuICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWVzc2FnZSk7XG4gICAgfSxcbiAgICBvblJlY2VpdmVTdGF0dXM6IChzdGF0dXMsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChzdGF0dXMpO1xuICAgIH0sXG59O1xuLyoqXG4gKiBBIFJlcXVlc3RlciB3aXRoIGEgZGVmYXVsdCBwYXNzLXRocm91Z2ggaW1wbGVtZW50YXRpb24gb2YgZWFjaCBtZXRob2QuIFVzZWRcbiAqIGZvciBmaWxsaW5nIG91dCBSZXF1ZXN0ZXJzIHdpdGggc29tZSBtZXRob2RzIG9taXR0ZWQuXG4gKi9cbmNvbnN0IGRlZmF1bHRSZXF1ZXN0ZXIgPSB7XG4gICAgc3RhcnQ6IChtZXRhZGF0YSwgbGlzdGVuZXIsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXRhZGF0YSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgc2VuZE1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWVzc2FnZSk7XG4gICAgfSxcbiAgICBoYWxmQ2xvc2U6IG5leHQgPT4ge1xuICAgICAgICBuZXh0KCk7XG4gICAgfSxcbiAgICBjYW5jZWw6IG5leHQgPT4ge1xuICAgICAgICBuZXh0KCk7XG4gICAgfSxcbn07XG5jbGFzcyBJbnRlcmNlcHRpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihuZXh0Q2FsbCwgcmVxdWVzdGVyKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5uZXh0Q2FsbCA9IG5leHRDYWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgbWV0YWRhdGEgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSByZXF1ZXN0ZXIncyBzdGFydFxuICAgICAgICAgKiBtZXRob2QgYnV0IGl0IGhhcyBub3QgYmVlbiBwYXNzZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgbmV4dCBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1lc3NhZ2UgY29udGV4dCBmb3IgYSBwZW5kaW5nIG1lc3NhZ2UgdGhhdCBpcyB3YWl0aW5nIGZvclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYSBtZXNzYWdlIGhhcyBiZWVuIHBhc3NlZCB0byB0aGUgcmVxdWVzdGVyJ3Mgc2VuZE1lc3NhZ2VcbiAgICAgICAgICogbWV0aG9kIGJ1dCBpdCBoYXMgbm90IGJlZW4gcGFzc2VkIHRvIHRoZSBjb3JyZXNwb25kaW5nIG5leHQgY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IGEgc3RhdHVzIHdhcyByZWNlaXZlZCBidXQgY291bGQgbm90IGJlIHByb3BhZ2F0ZWQgYmVjYXVzZVxuICAgICAgICAgKiBhIG1lc3NhZ2Ugd2FzIHN0aWxsIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IGZhbHNlO1xuICAgICAgICBpZiAocmVxdWVzdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RlciA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogKF9hID0gcmVxdWVzdGVyLnN0YXJ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0UmVxdWVzdGVyLnN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlOiAoX2IgPSByZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRSZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgaGFsZkNsb3NlOiAoX2MgPSByZXF1ZXN0ZXIuaGFsZkNsb3NlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0UmVxdWVzdGVyLmhhbGZDbG9zZSxcbiAgICAgICAgICAgICAgICBjYW5jZWw6IChfZCA9IHJlcXVlc3Rlci5jYW5jZWwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRSZXF1ZXN0ZXIuY2FuY2VsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVyID0gZGVmYXVsdFJlcXVlc3RlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5jYW5jZWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQodGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQsIHRoaXMucGVuZGluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdIYWxmQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGludGVyY2VwdGluZ0xpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCBmdWxsSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9iID0gKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChpbnRlcmNlcHRpbmdMaXN0ZW5lcikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChtZXRhZGF0YSA9PiB7IH0pLFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9kID0gKF9jID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iaW5kKGludGVyY2VwdGluZ0xpc3RlbmVyKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKG1lc3NhZ2UgPT4geyB9KSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKF9mID0gKF9lID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmJpbmQoaW50ZXJjZXB0aW5nTGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAoc3RhdHVzID0+IHsgfSksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuc3RhcnQobWV0YWRhdGEsIGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lciwgKG1kLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXI7XG4gICAgICAgICAgICBpZiAoKDAsIGNhbGxfaW50ZXJmYWNlXzEuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lcikobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbExpc3RlbmVyID0ge1xuICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9hID0gbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9iID0gbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKF9jID0gbGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0TGlzdGVuZXIub25SZWNlaXZlU3RhdHVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IG5ldyBjYWxsX2ludGVyZmFjZV8xLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbChmdWxsTGlzdGVuZXIsIGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnN0YXJ0KG1kLCBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSwgZmluYWxNZXNzYWdlID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBmaW5hbE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe30sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMubmV4dENhbGwuc3RhcnRSZWFkKCk7XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuaGFsZkNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSB8fCB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dENhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJjZXB0aW5nQ2FsbCA9IEludGVyY2VwdGluZ0NhbGw7XG5mdW5jdGlvbiBnZXRDYWxsKGNoYW5uZWwsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRlYWRsaW5lID0gKF9hID0gb3B0aW9ucy5kZWFkbGluZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSW5maW5pdHk7XG4gICAgY29uc3QgaG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgICBjb25zdCBwYXJlbnQgPSAoX2IgPSBvcHRpb25zLnBhcmVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICBjb25zdCBwcm9wYWdhdGVGbGFncyA9IG9wdGlvbnMucHJvcGFnYXRlX2ZsYWdzO1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscztcbiAgICBjb25zdCBjYWxsID0gY2hhbm5lbC5jcmVhdGVDYWxsKHBhdGgsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnQsIHByb3BhZ2F0ZUZsYWdzKTtcbiAgICBpZiAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY2FsbC5zZXRDcmVkZW50aWFscyhjcmVkZW50aWFscyk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsO1xufVxuLyoqXG4gKiBJbnRlcmNlcHRpbmdDYWxsIGltcGxlbWVudGF0aW9uIHRoYXQgZGlyZWN0bHkgb3ducyB0aGUgdW5kZXJseWluZyBDYWxsXG4gKiBvYmplY3QgYW5kIGhhbmRsZXMgc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJhaXpsaWF0aW9uLlxuICovXG5jbGFzcyBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBtZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0aG9kRGVmaW5pdGlvbiA9IG1ldGhvZERlZmluaXRpb247XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICBsZXQgc2VyaWFsaXplZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSB0aGlzLm1ldGhvZERlZmluaXRpb24ucmVxdWVzdFNlcmlhbGl6ZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCBgUmVxdWVzdCBtZXNzYWdlIHNlcmlhbGl6YXRpb24gZmFpbHVyZTogJHsoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGUpfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIHNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHt9LCBtZXNzYWdlKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGludGVyY2VwdGluZ0xpc3RlbmVyKSB7XG4gICAgICAgIGxldCByZWFkRXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbGwuc3RhcnQobWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiBtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplZCA9IHRoaXMubWV0aG9kRGVmaW5pdGlvbi5yZXNwb25zZURlc2VyaWFsaXplKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVzcG9uc2UgbWVzc2FnZSBwYXJzaW5nIGVycm9yOiAkeygwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZSl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGwuY2FuY2VsV2l0aFN0YXR1cyhyZWFkRXJyb3IuY29kZSwgcmVhZEVycm9yLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgZGVzZXJpYWxpemVkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAocmVhZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCByZWFkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHdpdGggc3BlY2lhbC1jYXNlZCBiZWhhdmlvciBmb3IgbWV0aG9kcyB3aXRoIHVuYXJ5XG4gKiByZXNwb25zZXMuXG4gKi9cbmNsYXNzIEJhc2VVbmFyeUludGVyY2VwdGluZ0NhbGwgZXh0ZW5kcyBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBtZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHN1cGVyKGNhbGwsIG1ldGhvZERlZmluaXRpb24pO1xuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlY2VpdmVkTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCB3cmFwcGVyTGlzdGVuZXIgPSB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9iID0gKF9hID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChsaXN0ZW5lcikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChtZXRhZGF0YSA9PiB7IH0pLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgKF9hID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVyLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmICghcmVjZWl2ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChsaXN0ZW5lciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYiA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGxpc3RlbmVyLCBzdGF0dXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIuc3RhcnQobWV0YWRhdGEsIHdyYXBwZXJMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHdpdGggc3BlY2lhbC1jYXNlZCBiZWhhdmlvciBmb3IgbWV0aG9kcyB3aXRoIHN0cmVhbWluZ1xuICogcmVzcG9uc2VzLlxuICovXG5jbGFzcyBCYXNlU3RyZWFtaW5nSW50ZXJjZXB0aW5nQ2FsbCBleHRlbmRzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcbn1cbmZ1bmN0aW9uIGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwoY2hhbm5lbCwgb3B0aW9ucywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubWV0aG9kRGVmaW5pdGlvbikge1xuICAgIGNvbnN0IGNhbGwgPSBnZXRDYWxsKGNoYW5uZWwsIG1ldGhvZERlZmluaXRpb24ucGF0aCwgb3B0aW9ucyk7XG4gICAgaWYgKG1ldGhvZERlZmluaXRpb24ucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlU3RyZWFtaW5nSW50ZXJjZXB0aW5nQ2FsbChjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZVVuYXJ5SW50ZXJjZXB0aW5nQ2FsbChjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbnRlcmNlcHRpbmdDYWxsKGludGVyY2VwdG9yQXJncywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubWV0aG9kRGVmaW5pdGlvbiwgb3B0aW9ucywgY2hhbm5lbCkge1xuICAgIGlmIChpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIG9wdGlvbnMgJyArXG4gICAgICAgICAgICAndG8gdGhlIGNsaWVudCBjb25zdHJ1Y3Rvci4gT25seSBvbmUgb2YgdGhlc2UgaXMgYWxsb3dlZC4nKTtcbiAgICB9XG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvclByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcignQm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yX3Byb3ZpZGVycyB3ZXJlIHBhc3NlZCBhcyBjYWxsICcgK1xuICAgICAgICAgICAgJ29wdGlvbnMuIE9ubHkgb25lIG9mIHRoZXNlIGlzIGFsbG93ZWQuJyk7XG4gICAgfVxuICAgIGxldCBpbnRlcmNlcHRvcnMgPSBbXTtcbiAgICAvLyBJbnRlcmNlcHRvcnMgcGFzc2VkIHRvIHRoZSBjYWxsIG92ZXJyaWRlIGludGVyY2VwdG9ycyBwYXNzZWQgdG8gdGhlIGNsaWVudCBjb25zdHJ1Y3RvclxuICAgIGlmIChpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9ycy5sZW5ndGggPiAwIHx8XG4gICAgICAgIGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpbnRlcmNlcHRvcnMgPSBbXVxuICAgICAgICAgICAgLmNvbmNhdChpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9ycywgaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvclByb3ZpZGVycy5tYXAocHJvdmlkZXIgPT4gcHJvdmlkZXIobWV0aG9kRGVmaW5pdGlvbikpKVxuICAgICAgICAgICAgLmZpbHRlcihpbnRlcmNlcHRvciA9PiBpbnRlcmNlcHRvcik7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgZmFsc3kgdmFsdWVzIHdoZW4gcHJvdmlkZXJzIHJldHVybiBub3RoaW5nXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnRlcmNlcHRvcnMgPSBbXVxuICAgICAgICAgICAgLmNvbmNhdChpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JzLCBpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnMubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyKG1ldGhvZERlZmluaXRpb24pKSlcbiAgICAgICAgICAgIC5maWx0ZXIoaW50ZXJjZXB0b3IgPT4gaW50ZXJjZXB0b3IpO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IGZhbHN5IHZhbHVlcyB3aGVuIHByb3ZpZGVycyByZXR1cm4gbm90aGluZ1xuICAgIH1cbiAgICBjb25zdCBpbnRlcmNlcHRvck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIG1ldGhvZF9kZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgIH0pO1xuICAgIC8qIEZvciBlYWNoIGludGVyY2VwdG9yIGluIHRoZSBsaXN0LCB0aGUgbmV4dENhbGwgZnVuY3Rpb24gcGFzc2VkIHRvIGl0IGlzXG4gICAgICogYmFzZWQgb24gdGhlIG5leHQgaW50ZXJjZXB0b3IgaW4gdGhlIGxpc3QsIHVzaW5nIGEgbmV4dENhbGwgZnVuY3Rpb25cbiAgICAgKiBjb25zdHJ1Y3RlZCB3aXRoIHRoZSBmb2xsb3dpbmcgaW50ZXJjZXB0b3IgaW4gdGhlIGxpc3QsIGFuZCBzbyBvbi4gVGhlXG4gICAgICogaW5pdGlhbFZhbHVlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0LCBpcyBhIG5leHRDYWxsXG4gICAgICogZnVuY3Rpb24gdGhhdCBpbnZva2VzIGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwsIHRoZSByZXN1bHQgb2Ygd2hpY2hcbiAgICAgKiBoYW5kbGVzIChkZSlzZXJpYWxpemF0aW9uIGFuZCBhbHNvIGdldHMgdGhlIHVuZGVybHlpbmcgY2FsbCBmcm9tIHRoZVxuICAgICAqIGNoYW5uZWwuICovXG4gICAgY29uc3QgZ2V0Q2FsbCA9IGludGVyY2VwdG9ycy5yZWR1Y2VSaWdodCgobmV4dENhbGwsIG5leHRJbnRlcmNlcHRvcikgPT4ge1xuICAgICAgICByZXR1cm4gY3VycmVudE9wdGlvbnMgPT4gbmV4dEludGVyY2VwdG9yKGN1cnJlbnRPcHRpb25zLCBuZXh0Q2FsbCk7XG4gICAgfSwgKGZpbmFsT3B0aW9ucykgPT4gZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbChjaGFubmVsLCBmaW5hbE9wdGlvbnMsIG1ldGhvZERlZmluaXRpb24pKTtcbiAgICByZXR1cm4gZ2V0Q2FsbChpbnRlcmNlcHRvck9wdGlvbnMpO1xufVxuZXhwb3J0cy5nZXRJbnRlcmNlcHRpbmdDYWxsID0gZ2V0SW50ZXJjZXB0aW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC1pbnRlcmNlcHRvcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0SW50ZXJjZXB0aW5nQ2FsbCIsIkludGVyY2VwdGluZ0NhbGwiLCJSZXF1ZXN0ZXJCdWlsZGVyIiwiTGlzdGVuZXJCdWlsZGVyIiwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IiLCJtZXRhZGF0YV8xIiwicmVxdWlyZSIsImNhbGxfaW50ZXJmYWNlXzEiLCJjb25zdGFudHNfMSIsImVycm9yXzEiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm5hbWUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm1ldGFkYXRhIiwidW5kZWZpbmVkIiwic3RhdHVzIiwid2l0aE9uUmVjZWl2ZU1ldGFkYXRhIiwib25SZWNlaXZlTWV0YWRhdGEiLCJ3aXRoT25SZWNlaXZlTWVzc2FnZSIsIm9uUmVjZWl2ZU1lc3NhZ2UiLCJ3aXRoT25SZWNlaXZlU3RhdHVzIiwib25SZWNlaXZlU3RhdHVzIiwiYnVpbGQiLCJzdGFydCIsImhhbGZDbG9zZSIsImNhbmNlbCIsIndpdGhTdGFydCIsIndpdGhTZW5kTWVzc2FnZSIsInNlbmRNZXNzYWdlIiwid2l0aEhhbGZDbG9zZSIsIndpdGhDYW5jZWwiLCJkZWZhdWx0TGlzdGVuZXIiLCJuZXh0IiwiZGVmYXVsdFJlcXVlc3RlciIsImxpc3RlbmVyIiwibmV4dENhbGwiLCJyZXF1ZXN0ZXIiLCJfYSIsIl9iIiwiX2MiLCJfZCIsInByb2Nlc3NpbmdNZXRhZGF0YSIsInBlbmRpbmdNZXNzYWdlQ29udGV4dCIsInByb2Nlc3NpbmdNZXNzYWdlIiwicGVuZGluZ0hhbGZDbG9zZSIsImNhbmNlbFdpdGhTdGF0dXMiLCJkZXRhaWxzIiwiZ2V0UGVlciIsInByb2Nlc3NQZW5kaW5nTWVzc2FnZSIsInNlbmRNZXNzYWdlV2l0aENvbnRleHQiLCJwZW5kaW5nTWVzc2FnZSIsInByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlIiwiaW50ZXJjZXB0aW5nTGlzdGVuZXIiLCJfZSIsIl9mIiwiZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyIiwiYmluZCIsIm1kIiwiZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciIsImlzSW50ZXJjZXB0aW5nTGlzdGVuZXIiLCJmdWxsTGlzdGVuZXIiLCJJbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwiLCJjb250ZXh0IiwiZmluYWxNZXNzYWdlIiwic3RhcnRSZWFkIiwiZ2V0Q2FsbCIsImNoYW5uZWwiLCJwYXRoIiwib3B0aW9ucyIsImRlYWRsaW5lIiwiSW5maW5pdHkiLCJob3N0IiwicGFyZW50IiwicHJvcGFnYXRlRmxhZ3MiLCJwcm9wYWdhdGVfZmxhZ3MiLCJjcmVkZW50aWFscyIsImNhbGwiLCJjcmVhdGVDYWxsIiwic2V0Q3JlZGVudGlhbHMiLCJCYXNlSW50ZXJjZXB0aW5nQ2FsbCIsIm1ldGhvZERlZmluaXRpb24iLCJzZXJpYWxpemVkIiwicmVxdWVzdFNlcmlhbGl6ZSIsImUiLCJTdGF0dXMiLCJJTlRFUk5BTCIsImdldEVycm9yTWVzc2FnZSIsInJlYWRFcnJvciIsImRlc2VyaWFsaXplZCIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJjb2RlIiwiTWV0YWRhdGEiLCJCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsIiwicmVjZWl2ZWRNZXNzYWdlIiwid3JhcHBlckxpc3RlbmVyIiwiQmFzZVN0cmVhbWluZ0ludGVyY2VwdGluZ0NhbGwiLCJnZXRCb3R0b21JbnRlcmNlcHRpbmdDYWxsIiwicmVzcG9uc2VTdHJlYW0iLCJpbnRlcmNlcHRvckFyZ3MiLCJjbGllbnRJbnRlcmNlcHRvcnMiLCJsZW5ndGgiLCJjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVycyIsImNhbGxJbnRlcmNlcHRvcnMiLCJjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMiLCJpbnRlcmNlcHRvcnMiLCJjb25jYXQiLCJtYXAiLCJwcm92aWRlciIsImZpbHRlciIsImludGVyY2VwdG9yIiwiaW50ZXJjZXB0b3JPcHRpb25zIiwiYXNzaWduIiwibWV0aG9kX2RlZmluaXRpb24iLCJyZWR1Y2VSaWdodCIsIm5leHRJbnRlcmNlcHRvciIsImN1cnJlbnRPcHRpb25zIiwiZmluYWxPcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Client = void 0;\nconst call_1 = __webpack_require__(/*! ./call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js\");\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n    return typeof arg === \"function\";\n}\nfunction getErrorStackString(error) {\n    return error.stack.split(\"\\n\").slice(1).join(\"\\n\");\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */ class Client {\n    constructor(address, credentials, options = {}){\n        var _a, _b;\n        options = Object.assign({}, options);\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n        delete options.interceptors;\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n        delete options.interceptor_providers;\n        if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n            throw new Error(\"Both interceptors and interceptor_providers were passed as options \" + \"to the client constructor. Only one of these is allowed.\");\n        }\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;\n        delete options.callInvocationTransformer;\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        } else if (options.channelFactoryOverride) {\n            const channelFactoryOverride = options.channelFactoryOverride;\n            delete options.channelFactoryOverride;\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n        } else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err)=>{\n            if (err) {\n                callback(new Error(\"Failed to connect before the deadline\"));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            } catch (e) {\n                callback(new Error(\"The channel has been closed\"));\n                return;\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                callback();\n            } else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                } catch (e) {\n                    callback(new Error(\"The channel has been closed\"));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (isFunction(arg1)) {\n            return {\n                metadata: new metadata_1.Metadata(),\n                options: {},\n                callback: arg1\n            };\n        } else if (isFunction(arg2)) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return {\n                    metadata: arg1,\n                    options: {},\n                    callback: arg2\n                };\n            } else {\n                return {\n                    metadata: new metadata_1.Metadata(),\n                    options: arg1,\n                    callback: arg2\n                };\n            }\n        } else {\n            if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {\n                throw new Error(\"Incorrect arguments passed\");\n            }\n            return {\n                metadata: arg1,\n                options: arg2,\n                callback: arg3\n            };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientUnaryCallImpl(),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata)=>{\n                emitter.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, \"Too many responses received\");\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.INTERNAL,\n                            details: \"No message received\",\n                            metadata: status.metadata\n                        }, callerStack));\n                    } else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                } else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                emitter.emit(\"status\", status);\n            }\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return emitter;\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientWritableStreamImpl(serialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata)=>{\n                emitter.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, \"Too many responses received\");\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.INTERNAL,\n                            details: \"No message received\",\n                            metadata: status.metadata\n                        }, callerStack));\n                    } else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                } else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                emitter.emit(\"status\", status);\n            }\n        });\n        return emitter;\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            } else {\n                options = {};\n            }\n        } else {\n            if (arg1) {\n                options = arg1;\n            } else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return {\n            metadata,\n            options\n        };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientReadableStreamImpl(deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata (metadata) {\n                stream.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                stream.push(message);\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit(\"error\", (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                stream.emit(\"status\", status);\n            }\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return stream;\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata (metadata) {\n                stream.emit(\"metadata\", metadata);\n            },\n            onReceiveMessage (message) {\n                stream.push(message);\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit(\"error\", (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                stream.emit(\"status\", status);\n            }\n        });\n        return stream;\n    }\n}\nexports.Client = Client; //# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyxvRUFBUTtBQUMvQixNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQywwRUFBVztBQUNyQyxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNSSxhQUFhSixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSyx3QkFBd0JMLG1CQUFPQSxDQUFDLGtHQUF1QjtBQUM3RCxNQUFNTSxpQkFBaUJDO0FBQ3ZCLE1BQU1DLHFCQUFxQkQ7QUFDM0IsTUFBTUUsOEJBQThCRjtBQUNwQyxNQUFNRyxxQ0FBcUNIO0FBQzNDLFNBQVNJLFdBQVdDLEdBQUc7SUFDbkIsT0FBTyxPQUFPQSxRQUFRO0FBQzFCO0FBQ0EsU0FBU0Msb0JBQW9CQyxLQUFLO0lBQzlCLE9BQU9BLE1BQU1DLEtBQUssQ0FBQ0MsS0FBSyxDQUFDLE1BQU1DLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUM7QUFDakQ7QUFDQTs7O0NBR0MsR0FDRCxNQUFNcEI7SUFDRnFCLFlBQVlDLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQzVDLElBQUlDLElBQUlDO1FBQ1JGLFVBQVU1QixPQUFPK0IsTUFBTSxDQUFDLENBQUMsR0FBR0g7UUFDNUIsSUFBSSxDQUFDZCxtQkFBbUIsR0FBRyxDQUFDZSxLQUFLRCxRQUFRSSxZQUFZLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtRQUMxRixPQUFPRCxRQUFRSSxZQUFZO1FBQzNCLElBQUksQ0FBQ2pC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RTtRQUN6SDtRQUNBLE1BQU0yQyxPQUFPLENBQUMsR0FBRzlELHNCQUFzQndFLG1CQUFtQixFQUFFTCxpQkFBaUJOLGVBQWVOLGdCQUFnQixFQUFFTSxlQUFlSSxXQUFXLEVBQUVKLGVBQWVHLE9BQU87UUFDaEs7Ozs0QkFHb0IsR0FDcEJrQyxPQUFPcEMsSUFBSSxHQUFHQTtRQUNkLElBQUlZLGlCQUFpQjtRQUNyQixJQUFJQyxtQkFBbUIsSUFBSW5EO1FBQzNCc0MsS0FBS2MsS0FBSyxDQUFDZixlQUFlZCxRQUFRLEVBQUU7WUFDaEM4QixtQkFBa0I5QixRQUFRO2dCQUN0Qm1ELE9BQU9wQixJQUFJLENBQUMsWUFBWS9CO1lBQzVCO1lBQ0FnQyxrQkFBaUJDLE9BQU87Z0JBQ3BCa0IsT0FBT0MsSUFBSSxDQUFDbkI7WUFDaEI7WUFDQUksaUJBQWdCQyxNQUFNO2dCQUNsQixJQUFJWCxnQkFBZ0I7b0JBQ2hCO2dCQUNKO2dCQUNBQSxpQkFBaUI7Z0JBQ2pCd0IsT0FBT0MsSUFBSSxDQUFDO2dCQUNaLElBQUlkLE9BQU9DLElBQUksS0FBS3hGLFlBQVlvRixNQUFNLENBQUNLLEVBQUUsRUFBRTtvQkFDdkMsTUFBTUMsY0FBY2hGLG9CQUFvQm1FO29CQUN4Q3VCLE9BQU9wQixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUdwRixPQUFPK0YsbUJBQW1CLEVBQUVKLFFBQVFHO2dCQUNqRTtnQkFDQTs2Q0FDNkIsR0FDN0JiLG1CQUFtQjtnQkFDbkJ1QixPQUFPcEIsSUFBSSxDQUFDLFVBQVVPO1lBQzFCO1FBQ0o7UUFDQSxPQUFPYTtJQUNYO0FBQ0o7QUFDQTNHLGNBQWMsR0FBR0UsUUFDakIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzPzgyNjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgY2FsbF8xID0gcmVxdWlyZShcIi4vY2FsbFwiKTtcbmNvbnN0IGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgY2xpZW50X2ludGVyY2VwdG9yc18xID0gcmVxdWlyZShcIi4vY2xpZW50LWludGVyY2VwdG9yc1wiKTtcbmNvbnN0IENIQU5ORUxfU1lNQk9MID0gU3ltYm9sKCk7XG5jb25zdCBJTlRFUkNFUFRPUl9TWU1CT0wgPSBTeW1ib2woKTtcbmNvbnN0IElOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTCA9IFN5bWJvbCgpO1xuY29uc3QgQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTCA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGdldEVycm9yU3RhY2tTdHJpbmcoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDEpLmpvaW4oJ1xcbicpO1xufVxuLyoqXG4gKiBBIGdlbmVyaWMgZ1JQQyBjbGllbnQuIFByaW1hcmlseSB1c2VmdWwgYXMgYSBiYXNlIGNsYXNzIGZvciBhbGwgZ2VuZXJhdGVkXG4gKiBjbGllbnRzLlxuICovXG5jbGFzcyBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0gPSAoX2EgPSBvcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmludGVyY2VwdG9ycztcbiAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdID0gKF9iID0gb3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnM7XG4gICAgICAgIGlmICh0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yX3Byb3ZpZGVycyB3ZXJlIHBhc3NlZCBhcyBvcHRpb25zICcgK1xuICAgICAgICAgICAgICAgICd0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yLiBPbmx5IG9uZSBvZiB0aGVzZSBpcyBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0gPVxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyO1xuICAgICAgICBpZiAob3B0aW9ucy5jaGFubmVsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gb3B0aW9ucy5jaGFubmVsT3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRmFjdG9yeU92ZXJyaWRlID0gb3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2hhbm5lbEZhY3RvcnlPdmVycmlkZTtcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gY2hhbm5lbEZhY3RvcnlPdmVycmlkZShhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXSA9IG5ldyBjaGFubmVsXzEuQ2hhbm5lbEltcGxlbWVudGF0aW9uKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0uY2xvc2UoKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbQ0hBTk5FTF9TWU1CT0xdO1xuICAgIH1cbiAgICB3YWl0Rm9yUmVhZHkoZGVhZGxpbmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrU3RhdGUgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCBiZWZvcmUgdGhlIGRlYWRsaW5lJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXdTdGF0ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzW0NIQU5ORUxfU1lNQk9MXS5nZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUaGUgY2hhbm5lbCBoYXMgYmVlbiBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXS53YXRjaENvbm5lY3Rpdml0eVN0YXRlKG5ld1N0YXRlLCBkZWFkbGluZSwgY2hlY2tTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignVGhlIGNoYW5uZWwgaGFzIGJlZW4gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNoZWNrU3RhdGUpO1xuICAgIH1cbiAgICBjaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZzEpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSwgb3B0aW9uczoge30sIGNhbGxiYWNrOiBhcmcxIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihhcmcyKSkge1xuICAgICAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IGFyZzEsIG9wdGlvbnM6IHt9LCBjYWxsYmFjazogYXJnMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksIG9wdGlvbnM6IGFyZzEsIGNhbGxiYWNrOiBhcmcyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShhcmcxIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5NZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgIGFyZzIgaW5zdGFuY2VvZiBPYmplY3QgJiZcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGFyZzMpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGFyZ3VtZW50cyBwYXNzZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBhcmcxLCBvcHRpb25zOiBhcmcyLCBjYWxsYmFjazogYXJnMyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1ha2VVbmFyeVJlcXVlc3QobWV0aG9kLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBhcmd1bWVudCwgbWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzKG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnQsXG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50VW5hcnlDYWxsSW1wbCgpLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjaGVja2VkQXJndW1lbnRzLmNhbGxiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbCA9ICgwLCBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbCkoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cbiAgICAgICAgZW1pdHRlci5jYWxsID0gY2FsbDtcbiAgICAgICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgJ1RvbyBtYW55IHJlc3BvbnNlcyByZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBtZXNzYWdlIHJlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKG51bGwsIHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKShzdGF0dXMsIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIEF2b2lkIHJldGFpbmluZyB0aGUgY2FsbGVyU3RhY2tFcnJvciBvYmplY3QgaW4gdGhlIGNhbGwgY29udGV4dCBvZlxuICAgICAgICAgICAgICAgICAqIHRoZSBzdGF0dXMgZXZlbnQgaGFuZGxlci4gKi9cbiAgICAgICAgICAgICAgICBjYWxsZXJTdGFja0Vycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZShhcmd1bWVudCk7XG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgIH1cbiAgICBtYWtlQ2xpZW50U3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsKHNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNoZWNrZWRBcmd1bWVudHMuY2FsbGJhY2ssXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xuICAgICAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCAnVG9vIG1hbnkgcmVzcG9uc2VzIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ05vIG1lc3NhZ2UgcmVjZWl2ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0dXMubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICB9XG4gICAgY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMoYXJnMSwgYXJnMikge1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gYXJnMTtcbiAgICAgICAgICAgIGlmIChhcmcyKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1ldGFkYXRhLCBvcHRpb25zIH07XG4gICAgfVxuICAgIG1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgYXJndW1lbnQsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbChkZXNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBzdHJlYW0uY2FsbCA9IGNhbGw7XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsICgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBBdm9pZCByZXRhaW5pbmcgdGhlIGNhbGxlclN0YWNrRXJyb3Igb2JqZWN0IGluIHRoZSBjYWxsIGNvbnRleHQgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3RhdHVzIGV2ZW50IGhhbmRsZXIuICovXG4gICAgICAgICAgICAgICAgY2FsbGVyU3RhY2tFcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZShhcmd1bWVudCk7XG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIG1ha2VCaWRpU3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbChzZXJpYWxpemUsIGRlc2VyaWFsaXplKSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwpKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxuICAgICAgICAgKiBlbmZvcmNlIHRoaXMgd2l0aCB0aGUgdHlwZSBzeXN0ZW0uIFdlIG5lZWQgdG8gY29uc3RydWN0IHRoaXMgZW1pdHRlclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXG4gICAgICAgIHN0cmVhbS5jYWxsID0gY2FsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ21ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCAoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2xpZW50IiwiY2FsbF8xIiwicmVxdWlyZSIsImNoYW5uZWxfMSIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwiY29uc3RhbnRzXzEiLCJtZXRhZGF0YV8xIiwiY2xpZW50X2ludGVyY2VwdG9yc18xIiwiQ0hBTk5FTF9TWU1CT0wiLCJTeW1ib2wiLCJJTlRFUkNFUFRPUl9TWU1CT0wiLCJJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0wiLCJDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MIiwiaXNGdW5jdGlvbiIsImFyZyIsImdldEVycm9yU3RhY2tTdHJpbmciLCJlcnJvciIsInN0YWNrIiwic3BsaXQiLCJzbGljZSIsImpvaW4iLCJjb25zdHJ1Y3RvciIsImFkZHJlc3MiLCJjcmVkZW50aWFscyIsIm9wdGlvbnMiLCJfYSIsIl9iIiwiYXNzaWduIiwiaW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3JfcHJvdmlkZXJzIiwibGVuZ3RoIiwiRXJyb3IiLCJjYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyIiwiY2hhbm5lbE92ZXJyaWRlIiwiY2hhbm5lbEZhY3RvcnlPdmVycmlkZSIsIkNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNsb3NlIiwiZ2V0Q2hhbm5lbCIsIndhaXRGb3JSZWFkeSIsImRlYWRsaW5lIiwiY2FsbGJhY2siLCJjaGVja1N0YXRlIiwiZXJyIiwibmV3U3RhdGUiLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsImUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIlJFQURZIiwid2F0Y2hDb25uZWN0aXZpdHlTdGF0ZSIsInNldEltbWVkaWF0ZSIsImNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzIiwiYXJnMSIsImFyZzIiLCJhcmczIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsIm1ha2VVbmFyeVJlcXVlc3QiLCJtZXRob2QiLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsImFyZ3VtZW50IiwiY2hlY2tlZEFyZ3VtZW50cyIsIm1ldGhvZERlZmluaXRpb24iLCJwYXRoIiwicmVxdWVzdFN0cmVhbSIsInJlc3BvbnNlU3RyZWFtIiwicmVxdWVzdFNlcmlhbGl6ZSIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJjYWxsUHJvcGVydGllcyIsImNhbGwiLCJDbGllbnRVbmFyeUNhbGxJbXBsIiwiY2hhbm5lbCIsImNhbGxPcHRpb25zIiwiZW1pdHRlciIsImludGVyY2VwdG9yQXJncyIsImNsaWVudEludGVyY2VwdG9ycyIsImNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzIiwiY2FsbEludGVyY2VwdG9ycyIsImNhbGxJbnRlcmNlcHRvclByb3ZpZGVycyIsImdldEludGVyY2VwdGluZ0NhbGwiLCJyZXNwb25zZU1lc3NhZ2UiLCJyZWNlaXZlZFN0YXR1cyIsImNhbGxlclN0YWNrRXJyb3IiLCJzdGFydCIsIm9uUmVjZWl2ZU1ldGFkYXRhIiwiZW1pdCIsIm9uUmVjZWl2ZU1lc3NhZ2UiLCJtZXNzYWdlIiwiY2FuY2VsV2l0aFN0YXR1cyIsIlN0YXR1cyIsIklOVEVSTkFMIiwib25SZWNlaXZlU3RhdHVzIiwic3RhdHVzIiwiY29kZSIsIk9LIiwiY2FsbGVyU3RhY2siLCJjYWxsRXJyb3JGcm9tU3RhdHVzIiwiZGV0YWlscyIsInNlbmRNZXNzYWdlIiwiaGFsZkNsb3NlIiwibWFrZUNsaWVudFN0cmVhbVJlcXVlc3QiLCJDbGllbnRXcml0YWJsZVN0cmVhbUltcGwiLCJjaGVja01ldGFkYXRhQW5kT3B0aW9ucyIsIm1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0IiwiQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsIiwic3RyZWFtIiwicHVzaCIsIm1ha2VCaWRpU3RyZWFtUmVxdWVzdCIsIkNsaWVudER1cGxleFN0cmVhbUltcGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CompressionAlgorithms = void 0;\nvar CompressionAlgorithms;\n(function(CompressionAlgorithms) {\n    CompressionAlgorithms[CompressionAlgorithms[\"identity\"] = 0] = \"identity\";\n    CompressionAlgorithms[CompressionAlgorithms[\"deflate\"] = 1] = \"deflate\";\n    CompressionAlgorithms[CompressionAlgorithms[\"gzip\"] = 2] = \"gzip\";\n})(CompressionAlgorithms || (exports.CompressionAlgorithms = CompressionAlgorithms = {})); //# sourceMappingURL=compression-algorithms.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxJQUFJRTtBQUNILFVBQVVBLHFCQUFxQjtJQUM1QkEscUJBQXFCLENBQUNBLHFCQUFxQixDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDL0RBLHFCQUFxQixDQUFDQSxxQkFBcUIsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzlEQSxxQkFBcUIsQ0FBQ0EscUJBQXFCLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztBQUMvRCxHQUFHQSx5QkFBMEJGLENBQUFBLDZCQUE2QixHQUFHRSx3QkFBd0IsQ0FBQyxLQUN0RixrREFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzPzI5MjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcHJlc3Npb25BbGdvcml0aG1zID0gdm9pZCAwO1xudmFyIENvbXByZXNzaW9uQWxnb3JpdGhtcztcbihmdW5jdGlvbiAoQ29tcHJlc3Npb25BbGdvcml0aG1zKSB7XG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImlkZW50aXR5XCJdID0gMF0gPSBcImlkZW50aXR5XCI7XG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImRlZmxhdGVcIl0gPSAxXSA9IFwiZGVmbGF0ZVwiO1xuICAgIENvbXByZXNzaW9uQWxnb3JpdGhtc1tDb21wcmVzc2lvbkFsZ29yaXRobXNbXCJnemlwXCJdID0gMl0gPSBcImd6aXBcIjtcbn0pKENvbXByZXNzaW9uQWxnb3JpdGhtcyB8fCAoZXhwb3J0cy5Db21wcmVzc2lvbkFsZ29yaXRobXMgPSBDb21wcmVzc2lvbkFsZ29yaXRobXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb21wcmVzc2lvbkFsZ29yaXRobXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst isCompressionAlgorithmKey = (key)=>{\n    return typeof key === \"number\" && typeof compression_algorithms_1.CompressionAlgorithms[key] === \"string\";\n};\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */ async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */ async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */ output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.deflate(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.inflate(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.gzip(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.unzip(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName){\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName) {\n    switch(compressionName){\n        case \"identity\":\n            return new IdentityHandler();\n        case \"deflate\":\n            return new DeflateHandler();\n        case \"gzip\":\n            return new GzipHandler();\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor(channelOptions, sharedFilterConfig){\n        var _a;\n        super();\n        this.sharedFilterConfig = sharedFilterConfig;\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = \"identity\";\n        const compressionAlgorithmKey = channelOptions[\"grpc.default_compression_algorithm\"];\n        if (compressionAlgorithmKey !== undefined) {\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n                const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(\",\");\n                /**\n                 * There are two possible situations here:\n                 * 1) We don't have any info yet from the server about what compression it supports\n                 *    In that case we should just use what the client tells us to use\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\n                 */ if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);\n                }\n            } else {\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n            }\n        }\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set(\"grpc-accept-encoding\", \"identity,deflate,gzip\");\n        headers.set(\"accept-encoding\", \"identity\");\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n        if (this.currentCompressionAlgorithm === \"identity\") {\n            headers.remove(\"grpc-encoding\");\n        } else {\n            headers.set(\"grpc-encoding\", this.currentCompressionAlgorithm);\n        }\n        return headers;\n    }\n    receiveMetadata(metadata) {\n        const receiveEncoding = metadata.get(\"grpc-encoding\");\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === \"string\") {\n                this.receiveCompression = getCompressionHandler(encoding);\n            }\n        }\n        metadata.remove(\"grpc-encoding\");\n        /* Check to see if the compression we're using to send messages is supported by the server\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */ const serverSupportedEncodingsHeader = metadata.get(\"grpc-accept-encoding\")[0];\n        if (serverSupportedEncodingsHeader) {\n            this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(\",\");\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n                this.sendCompression = new IdentityHandler();\n                this.currentCompressionAlgorithm = \"identity\";\n            }\n        }\n        metadata.remove(\"grpc-accept-encoding\");\n        return metadata;\n    }\n    async sendMessage(message) {\n        var _a;\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */ const resolvedMessage = await message;\n        let compress;\n        if (this.sendCompression instanceof IdentityHandler) {\n            compress = false;\n        } else {\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* WriteFlags.NoCompress */ ) === 0;\n        }\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */ return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel, options){\n        this.options = options;\n        this.sharedFilterConfig = {};\n    }\n    createFilter() {\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory; //# sourceMappingURL=compression-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0NBQWdDLEdBQUdBLHlCQUF5QixHQUFHLEtBQUs7QUFDcEUsTUFBTUksT0FBT0MsbUJBQU9BLENBQUMsa0JBQU07QUFDM0IsTUFBTUMsMkJBQTJCRCxtQkFBT0EsQ0FBQyx3R0FBMEI7QUFDbkUsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUksVUFBVUosbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTUssNEJBQTRCLENBQUNDO0lBQy9CLE9BQVEsT0FBT0EsUUFBUSxZQUFZLE9BQU9MLHlCQUF5Qk0scUJBQXFCLENBQUNELElBQUksS0FBSztBQUN0RztBQUNBLE1BQU1FO0lBQ0Y7Ozs7S0FJQyxHQUNELE1BQU1DLGFBQWFDLE9BQU8sRUFBRUMsUUFBUSxFQUFFO1FBQ2xDLElBQUlDLGdCQUFnQkY7UUFDcEIsSUFBSUMsVUFBVTtZQUNWQyxnQkFBZ0IsTUFBTSxJQUFJLENBQUNDLGVBQWUsQ0FBQ0Q7UUFDL0M7UUFDQSxNQUFNRSxTQUFTQyxNQUFNQSxDQUFDQyxXQUFXLENBQUNKLGNBQWNLLE1BQU0sR0FBRztRQUN6REgsT0FBT0ksVUFBVSxDQUFDUCxXQUFXLElBQUksR0FBRztRQUNwQ0csT0FBT0ssYUFBYSxDQUFDUCxjQUFjSyxNQUFNLEVBQUU7UUFDM0NMLGNBQWNRLElBQUksQ0FBQ04sUUFBUTtRQUMzQixPQUFPQTtJQUNYO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTU8sWUFBWUMsSUFBSSxFQUFFO1FBQ3BCLE1BQU1DLGFBQWFELEtBQUtFLFNBQVMsQ0FBQyxPQUFPO1FBQ3pDLElBQUla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QUFPO1lBQ0hwQyxTQUFTLE1BQU0sSUFBSSxDQUFDcUMsZUFBZSxDQUFDdEMsWUFBWSxDQUFDOEQsZ0JBQWdCN0QsT0FBTyxFQUFFQztZQUMxRTZELE9BQU9ELGdCQUFnQkMsS0FBSztRQUNoQztJQUNKO0lBQ0EsTUFBTUMsZUFBZS9ELE9BQU8sRUFBRTtRQUMxQjs7O3lCQUdpQixHQUNqQixPQUFPLElBQUksQ0FBQ3NDLGtCQUFrQixDQUFDM0IsV0FBVyxDQUFDLE1BQU1YO0lBQ3JEO0FBQ0o7QUFDQWYseUJBQXlCLEdBQUdHO0FBQzVCLE1BQU1EO0lBQ0YyQyxZQUFZa0MsT0FBTyxFQUFFQyxPQUFPLENBQUU7UUFDMUIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDOUIsa0JBQWtCLEdBQUcsQ0FBQztJQUMvQjtJQUNBK0IsZUFBZTtRQUNYLE9BQU8sSUFBSTlFLGtCQUFrQixJQUFJLENBQUM2RSxPQUFPLEVBQUUsSUFBSSxDQUFDOUIsa0JBQWtCO0lBQ3RFO0FBQ0o7QUFDQWxELGdDQUFnQyxHQUFHRSwwQkFDbkMsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzPzc1ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlciA9IHZvaWQgMDtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWFsZ29yaXRobXNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGZpbHRlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBpc0NvbXByZXNzaW9uQWxnb3JpdGhtS2V5ID0gKGtleSkgPT4ge1xuICAgIHJldHVybiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMS5Db21wcmVzc2lvbkFsZ29yaXRobXNba2V5XSA9PT0gJ3N0cmluZycpO1xufTtcbmNsYXNzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgUmF3IHVuY29tcHJlc3NlZCBtZXNzYWdlIGJ5dGVzXG4gICAgICogQHBhcmFtIGNvbXByZXNzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtZXNzYWdlIHNob3VsZCBiZSBjb21wcmVzc2VkXG4gICAgICogQHJldHVybiBGcmFtZWQgbWVzc2FnZSwgY29tcHJlc3NlZCBpZiBhcHBsaWNhYmxlXG4gICAgICovXG4gICAgYXN5bmMgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIGNvbXByZXNzKSB7XG4gICAgICAgIGxldCBtZXNzYWdlQnVmZmVyID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGNvbXByZXNzKSB7XG4gICAgICAgICAgICBtZXNzYWdlQnVmZmVyID0gYXdhaXQgdGhpcy5jb21wcmVzc01lc3NhZ2UobWVzc2FnZUJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lc3NhZ2VCdWZmZXIubGVuZ3RoICsgNSk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KGNvbXByZXNzID8gMSA6IDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShtZXNzYWdlQnVmZmVyLmxlbmd0aCwgMSk7XG4gICAgICAgIG1lc3NhZ2VCdWZmZXIuY29weShvdXRwdXQsIDUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YSBGcmFtZWQgbWVzc2FnZSwgcG9zc2libHkgY29tcHJlc3NlZFxuICAgICAqIEByZXR1cm4gVW5jb21wcmVzc2VkIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyByZWFkTWVzc2FnZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSBkYXRhLnJlYWRVSW50OCgwKSA9PT0gMTtcbiAgICAgICAgbGV0IG1lc3NhZ2VCdWZmZXIgPSBkYXRhLnNsaWNlKDUpO1xuICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgbWVzc2FnZUJ1ZmZlciA9IGF3YWl0IHRoaXMuZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZUJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VCdWZmZXI7XG4gICAgfVxufVxuY2xhc3MgSWRlbnRpdHlIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBhc3luYyBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIGNvbXByZXNzKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXNzYWdlLmxlbmd0aCArIDUpO1xuICAgICAgICAvKiBXaXRoIFwiaWRlbnRpdHlcIiBjb21wcmVzc2lvbiwgbWVzc2FnZXMgc2hvdWxkIGFsd2F5cyBiZSBtYXJrZWQgYXNcbiAgICAgICAgICogdW5jb21wcmVzc2VkICovXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShtZXNzYWdlLmxlbmd0aCwgMSk7XG4gICAgICAgIG1lc3NhZ2UuY29weShvdXRwdXQsIDUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1JlY2VpdmVkIGNvbXByZXNzZWQgbWVzc2FnZSBidXQgXCJncnBjLWVuY29kaW5nXCIgaGVhZGVyIHdhcyBpZGVudGl0eScpKTtcbiAgICB9XG59XG5jbGFzcyBEZWZsYXRlSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHpsaWIuZGVmbGF0ZShtZXNzYWdlLCAoZXJyLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgemxpYi5pbmZsYXRlKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEd6aXBIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgemxpYi5nemlwKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB6bGliLnVuemlwKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVua25vd25IYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wcmVzc2lvbk5hbWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbk5hbWUgPSBjb21wcmVzc2lvbk5hbWU7XG4gICAgfVxuICAgIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFJlY2VpdmVkIG1lc3NhZ2UgY29tcHJlc3NlZCB3aXRoIHVuc3VwcG9ydGVkIGNvbXByZXNzaW9uIG1ldGhvZCAke3RoaXMuY29tcHJlc3Npb25OYW1lfWApKTtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB1bnJlYWNoYWJsZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBDb21wcmVzc2lvbiBtZXRob2Qgbm90IHN1cHBvcnRlZDogJHt0aGlzLmNvbXByZXNzaW9uTmFtZX1gKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKGNvbXByZXNzaW9uTmFtZSkge1xuICAgIHN3aXRjaCAoY29tcHJlc3Npb25OYW1lKSB7XG4gICAgICAgIGNhc2UgJ2lkZW50aXR5JzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgIGNhc2UgJ2RlZmxhdGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWZsYXRlSGFuZGxlcigpO1xuICAgICAgICBjYXNlICdnemlwJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3ppcEhhbmRsZXIoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5rbm93bkhhbmRsZXIoY29tcHJlc3Npb25OYW1lKTtcbiAgICB9XG59XG5jbGFzcyBDb21wcmVzc2lvbkZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxPcHRpb25zLCBzaGFyZWRGaWx0ZXJDb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyA9IHNoYXJlZEZpbHRlckNvbmZpZztcbiAgICAgICAgdGhpcy5zZW5kQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uID0gbmV3IElkZW50aXR5SGFuZGxlcigpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9ICdpZGVudGl0eSc7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5ID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMuZGVmYXVsdF9jb21wcmVzc2lvbl9hbGdvcml0aG0nXTtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzaW9uQWxnb3JpdGhtS2V5KGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFNlbGVjdGVkRW5jb2RpbmcgPSBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zW2NvbXByZXNzaW9uQWxnb3JpdGhtS2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgPSAoX2EgPSBzaGFyZWRGaWx0ZXJDb25maWcuc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdIZWFkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZXJlIGFyZSB0d28gcG9zc2libGUgc2l0dWF0aW9ucyBoZXJlOlxuICAgICAgICAgICAgICAgICAqIDEpIFdlIGRvbid0IGhhdmUgYW55IGluZm8geWV0IGZyb20gdGhlIHNlcnZlciBhYm91dCB3aGF0IGNvbXByZXNzaW9uIGl0IHN1cHBvcnRzXG4gICAgICAgICAgICAgICAgICogICAgSW4gdGhhdCBjYXNlIHdlIHNob3VsZCBqdXN0IHVzZSB3aGF0IHRoZSBjbGllbnQgdGVsbHMgdXMgdG8gdXNlXG4gICAgICAgICAgICAgICAgICogMikgV2UndmUgcHJldmlvdXNseSByZWNlaXZlZCBhIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciBpbmNsdWRpbmcgYSBncnBjLWFjY2VwdC1lbmNvZGluZyBoZWFkZXJcbiAgICAgICAgICAgICAgICAgKiAgICBJbiB0aGF0IGNhc2Ugd2Ugb25seSB3YW50IHRvIHVzZSB0aGUgZW5jb2RpbmcgY2hvc2VuIGJ5IHRoZSBjbGllbnQgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBpdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncy5pbmNsdWRlcyhjbGllbnRTZWxlY3RlZEVuY29kaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9IGNsaWVudFNlbGVjdGVkRW5jb2Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBJbnZhbGlkIHZhbHVlIHByb3ZpZGVkIGZvciBncnBjLmRlZmF1bHRfY29tcHJlc3Npb25fYWxnb3JpdGhtIG9wdGlvbjogJHtjb21wcmVzc2lvbkFsZ29yaXRobUtleX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IG1ldGFkYXRhO1xuICAgICAgICBoZWFkZXJzLnNldCgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHksZGVmbGF0ZSxnemlwJyk7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHknKTtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZW5kIHRoZSBoZWFkZXIgaWYgaXQncyBcImlkZW50aXR5XCIgLSAgYmVoYXZpb3IgaXMgaWRlbnRpY2FsOyBzYXZlIHRoZSBiYW5kd2lkdGhcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ2dycGMtZW5jb2RpbmcnLCB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCByZWNlaXZlRW5jb2RpbmcgPSBtZXRhZGF0YS5nZXQoJ2dycGMtZW5jb2RpbmcnKTtcbiAgICAgICAgaWYgKHJlY2VpdmVFbmNvZGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGluZyA9IHJlY2VpdmVFbmNvZGluZ1swXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlQ29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbkhhbmRsZXIoZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICAvKiBDaGVjayB0byBzZWUgaWYgdGhlIGNvbXByZXNzaW9uIHdlJ3JlIHVzaW5nIHRvIHNlbmQgbWVzc2FnZXMgaXMgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXJcbiAgICAgICAgICogSWYgbm90LCByZXNldCB0aGUgc2VuZENvbXByZXNzaW9uIGZpbHRlciBhbmQgaGF2ZSBpdCB1c2UgdGhlIGRlZmF1bHQgSWRlbnRpdHlIYW5kbGVyICovXG4gICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlciA9IG1ldGFkYXRhLmdldCgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKVswXTtcbiAgICAgICAgaWYgKHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcuc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdIZWFkZXIgPVxuICAgICAgICAgICAgICAgIHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyA9IHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgaWYgKCFzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MuaW5jbHVkZXModGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPSAnaWRlbnRpdHknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLyogVGhpcyBmaWx0ZXIgaXMgc3BlY2lhbC4gVGhlIGlucHV0IG1lc3NhZ2UgaXMgdGhlIGJhcmUgbWVzc2FnZSBieXRlcyxcbiAgICAgICAgICogYW5kIHRoZSBvdXRwdXQgaXMgYSBmcmFtZWQgYW5kIHBvc3NpYmx5IGNvbXByZXNzZWQgbWVzc2FnZS4gRm9yIHRoaXNcbiAgICAgICAgICogcmVhc29uLCB0aGlzIGZpbHRlciBzaG91bGQgYmUgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZmlsdGVyIHN0YWNrICovXG4gICAgICAgIGNvbnN0IHJlc29sdmVkTWVzc2FnZSA9IGF3YWl0IG1lc3NhZ2U7XG4gICAgICAgIGxldCBjb21wcmVzcztcbiAgICAgICAgaWYgKHRoaXMuc2VuZENvbXByZXNzaW9uIGluc3RhbmNlb2YgSWRlbnRpdHlIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcHJlc3MgPSAoKChfYSA9IHJlc29sdmVkTWVzc2FnZS5mbGFncykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgJiAyIC8qIFdyaXRlRmxhZ3MuTm9Db21wcmVzcyAqLykgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHRoaXMuc2VuZENvbXByZXNzaW9uLndyaXRlTWVzc2FnZShyZXNvbHZlZE1lc3NhZ2UubWVzc2FnZSwgY29tcHJlc3MpLFxuICAgICAgICAgICAgZmxhZ3M6IHJlc29sdmVkTWVzc2FnZS5mbGFncyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBUaGlzIGZpbHRlciBpcyBhbHNvIHNwZWNpYWwuIFRoZSBpbnB1dCBtZXNzYWdlIGlzIGZyYW1lZCBhbmQgcG9zc2libHlcbiAgICAgICAgICogY29tcHJlc3NlZCwgYW5kIHRoZSBvdXRwdXQgbWVzc2FnZSBpcyBkZWZyYW1lZCBhbmQgdW5jb21wcmVzc2VkLiBTb1xuICAgICAgICAgKiB0aGlzIGlzIGFub3RoZXIgcmVhc29uIHRoYXQgdGhpcyBmaWx0ZXIgc2hvdWxkIGJlIGF0IHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAgICAqIGZpbHRlciBzdGFjay4gKi9cbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uLnJlYWRNZXNzYWdlKGF3YWl0IG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXIgPSBDb21wcmVzc2lvbkZpbHRlcjtcbmNsYXNzIENvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyA9IHt9O1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcHJlc3Npb25GaWx0ZXIodGhpcy5vcHRpb25zLCB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkgPSBDb21wcmVzc2lvbkZpbHRlckZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2lvbi1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5IiwiQ29tcHJlc3Npb25GaWx0ZXIiLCJ6bGliIiwicmVxdWlyZSIsImNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSIsImNvbnN0YW50c18xIiwiZmlsdGVyXzEiLCJsb2dnaW5nIiwiaXNDb21wcmVzc2lvbkFsZ29yaXRobUtleSIsImtleSIsIkNvbXByZXNzaW9uQWxnb3JpdGhtcyIsIkNvbXByZXNzaW9uSGFuZGxlciIsIndyaXRlTWVzc2FnZSIsIm1lc3NhZ2UiLCJjb21wcmVzcyIsIm1lc3NhZ2VCdWZmZXIiLCJjb21wcmVzc01lc3NhZ2UiLCJvdXRwdXQiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImxlbmd0aCIsIndyaXRlVUludDgiLCJ3cml0ZVVJbnQzMkJFIiwiY29weSIsInJlYWRNZXNzYWdlIiwiZGF0YSIsImNvbXByZXNzZWQiLCJyZWFkVUludDgiLCJzbGljZSIsImRlY29tcHJlc3NNZXNzYWdlIiwiSWRlbnRpdHlIYW5kbGVyIiwiUHJvbWlzZSIsInJlamVjdCIsIkVycm9yIiwiRGVmbGF0ZUhhbmRsZXIiLCJyZXNvbHZlIiwiZGVmbGF0ZSIsImVyciIsImluZmxhdGUiLCJHemlwSGFuZGxlciIsImd6aXAiLCJ1bnppcCIsIlVua25vd25IYW5kbGVyIiwiY29uc3RydWN0b3IiLCJjb21wcmVzc2lvbk5hbWUiLCJnZXRDb21wcmVzc2lvbkhhbmRsZXIiLCJCYXNlRmlsdGVyIiwiY2hhbm5lbE9wdGlvbnMiLCJzaGFyZWRGaWx0ZXJDb25maWciLCJfYSIsInNlbmRDb21wcmVzc2lvbiIsInJlY2VpdmVDb21wcmVzc2lvbiIsImN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSIsImNvbXByZXNzaW9uQWxnb3JpdGhtS2V5IiwidW5kZWZpbmVkIiwiY2xpZW50U2VsZWN0ZWRFbmNvZGluZyIsInNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyIsInNlcnZlclN1cHBvcnRlZEVuY29kaW5nSGVhZGVyIiwic3BsaXQiLCJpbmNsdWRlcyIsImxvZyIsIkxvZ1ZlcmJvc2l0eSIsIkVSUk9SIiwic2VuZE1ldGFkYXRhIiwibWV0YWRhdGEiLCJoZWFkZXJzIiwic2V0IiwicmVtb3ZlIiwicmVjZWl2ZU1ldGFkYXRhIiwicmVjZWl2ZUVuY29kaW5nIiwiZ2V0IiwiZW5jb2RpbmciLCJzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIiLCJzZW5kTWVzc2FnZSIsInJlc29sdmVkTWVzc2FnZSIsImZsYWdzIiwicmVjZWl2ZU1lc3NhZ2UiLCJjaGFubmVsIiwib3B0aW9ucyIsImNyZWF0ZUZpbHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/connectivity-state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ConnectivityState = void 0;\nvar ConnectivityState;\n(function(ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState || (exports.ConnectivityState = ConnectivityState = {})); //# sourceMappingURL=connectivity-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pDLElBQUlFO0FBQ0gsVUFBVUEsaUJBQWlCO0lBQ3hCQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUNuREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDekRBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ3BEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQ2hFQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztBQUMzRCxHQUFHQSxxQkFBc0JGLENBQUFBLHlCQUF5QixHQUFHRSxvQkFBb0IsQ0FBQyxLQUMxRSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25uZWN0aXZpdHktc3RhdGUuanM/NGVlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25uZWN0aXZpdHlTdGF0ZSA9IHZvaWQgMDtcbnZhciBDb25uZWN0aXZpdHlTdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGl2aXR5U3RhdGUpIHtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIklETEVcIl0gPSAwXSA9IFwiSURMRVwiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiQ09OTkVDVElOR1wiXSA9IDFdID0gXCJDT05ORUNUSU5HXCI7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJSRUFEWVwiXSA9IDJdID0gXCJSRUFEWVwiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiVFJBTlNJRU5UX0ZBSUxVUkVcIl0gPSAzXSA9IFwiVFJBTlNJRU5UX0ZBSUxVUkVcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlNIVVRET1dOXCJdID0gNF0gPSBcIlNIVVRET1dOXCI7XG59KShDb25uZWN0aXZpdHlTdGF0ZSB8fCAoZXhwb3J0cy5Db25uZWN0aXZpdHlTdGF0ZSA9IENvbm5lY3Rpdml0eVN0YXRlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpdml0eS1zdGF0ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb25uZWN0aXZpdHlTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;\nvar Status;\n(function(Status) {\n    Status[Status[\"OK\"] = 0] = \"OK\";\n    Status[Status[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    Status[Status[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    Status[Status[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    Status[Status[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    Status[Status[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    Status[Status[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    Status[Status[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    Status[Status[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    Status[Status[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    Status[Status[\"ABORTED\"] = 10] = \"ABORTED\";\n    Status[Status[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    Status[Status[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    Status[Status[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    Status[Status[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    Status[Status[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n    Status[Status[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n})(Status || (exports.Status = Status = {}));\nvar LogVerbosity;\n(function(LogVerbosity) {\n    LogVerbosity[LogVerbosity[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogVerbosity[LogVerbosity[\"INFO\"] = 1] = \"INFO\";\n    LogVerbosity[LogVerbosity[\"ERROR\"] = 2] = \"ERROR\";\n    LogVerbosity[LogVerbosity[\"NONE\"] = 3] = \"NONE\";\n})(LogVerbosity || (exports.LogVerbosity = LogVerbosity = {}));\n/**\n * NOTE: This enum is not currently used in any implemented API in this\n * library. It is included only for type parity with the other implementation.\n */ var Propagate;\n(function(Propagate) {\n    Propagate[Propagate[\"DEADLINE\"] = 1] = \"DEADLINE\";\n    Propagate[Propagate[\"CENSUS_STATS_CONTEXT\"] = 2] = \"CENSUS_STATS_CONTEXT\";\n    Propagate[Propagate[\"CENSUS_TRACING_CONTEXT\"] = 4] = \"CENSUS_TRACING_CONTEXT\";\n    Propagate[Propagate[\"CANCELLATION\"] = 8] = \"CANCELLATION\";\n    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\n    Propagate[Propagate[\"DEFAULTS\"] = 65535] = \"DEFAULTS\";\n})(Propagate || (exports.Propagate = Propagate = {}));\n// -1 means unlimited\nexports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\n// 4 MB default\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQ0FBMEMsR0FBR0EsdUNBQXVDLEdBQUdBLGlCQUFpQixHQUFHQSxvQkFBb0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDeEosSUFBSU07QUFDSCxVQUFVQSxNQUFNO0lBQ2JBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUc7SUFDM0JBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDbENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDaENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUN6Q0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQzFDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztJQUMxQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMscUJBQXFCLEdBQUcsRUFBRSxHQUFHO0lBQzNDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxzQkFBc0IsR0FBRyxFQUFFLEdBQUc7SUFDNUNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFVBQVUsR0FBRyxHQUFHLEdBQUc7SUFDakNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGVBQWUsR0FBRyxHQUFHLEdBQUc7SUFDdENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUN2Q0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUNsQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsY0FBYyxHQUFHLEdBQUcsR0FBRztJQUNyQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsWUFBWSxHQUFHLEdBQUcsR0FBRztJQUNuQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxHQUFHO0FBQzdDLEdBQUdBLFVBQVdOLENBQUFBLGNBQWMsR0FBR00sU0FBUyxDQUFDO0FBQ3pDLElBQUlEO0FBQ0gsVUFBVUEsWUFBWTtJQUNuQkEsWUFBWSxDQUFDQSxZQUFZLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUMxQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUN6Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUMxQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztBQUM3QyxHQUFHQSxnQkFBaUJMLENBQUFBLG9CQUFvQixHQUFHSyxlQUFlLENBQUM7QUFDM0Q7OztDQUdDLEdBQ0QsSUFBSUQ7QUFDSCxVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyx1QkFBdUIsR0FBRyxFQUFFLEdBQUc7SUFDbkRBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLHlCQUF5QixHQUFHLEVBQUUsR0FBRztJQUNyREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUMzQyw0RkFBNEY7SUFDNUZBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFdBQVcsR0FBRyxNQUFNLEdBQUc7QUFDL0MsR0FBR0EsYUFBY0osQ0FBQUEsaUJBQWlCLEdBQUdJLFlBQVksQ0FBQztBQUNsRCxxQkFBcUI7QUFDckJKLHVDQUF1QyxHQUFHLENBQUM7QUFDM0MsZUFBZTtBQUNmQSwwQ0FBMEMsR0FBRyxJQUFJLE9BQU8sTUFDeEQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzPzFjMmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCA9IGV4cG9ydHMuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCA9IGV4cG9ydHMuUHJvcGFnYXRlID0gZXhwb3J0cy5Mb2dWZXJib3NpdHkgPSBleHBvcnRzLlN0YXR1cyA9IHZvaWQgMDtcbnZhciBTdGF0dXM7XG4oZnVuY3Rpb24gKFN0YXR1cykge1xuICAgIFN0YXR1c1tTdGF0dXNbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJDQU5DRUxMRURcIl0gPSAxXSA9IFwiQ0FOQ0VMTEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOS05PV05cIl0gPSAyXSA9IFwiVU5LTk9XTlwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gM10gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiREVBRExJTkVfRVhDRUVERURcIl0gPSA0XSA9IFwiREVBRExJTkVfRVhDRUVERURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiTk9UX0ZPVU5EXCJdID0gNV0gPSBcIk5PVF9GT1VORFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJBTFJFQURZX0VYSVNUU1wiXSA9IDZdID0gXCJBTFJFQURZX0VYSVNUU1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJQRVJNSVNTSU9OX0RFTklFRFwiXSA9IDddID0gXCJQRVJNSVNTSU9OX0RFTklFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkZBSUxFRF9QUkVDT05ESVRJT05cIl0gPSA5XSA9IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJBQk9SVEVEXCJdID0gMTBdID0gXCJBQk9SVEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOSU1QTEVNRU5URURcIl0gPSAxMl0gPSBcIlVOSU1QTEVNRU5URURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiSU5URVJOQUxcIl0gPSAxM10gPSBcIklOVEVSTkFMXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJEQVRBX0xPU1NcIl0gPSAxNV0gPSBcIkRBVEFfTE9TU1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJVTkFVVEhFTlRJQ0FURURcIl0gPSAxNl0gPSBcIlVOQVVUSEVOVElDQVRFRFwiO1xufSkoU3RhdHVzIHx8IChleHBvcnRzLlN0YXR1cyA9IFN0YXR1cyA9IHt9KSk7XG52YXIgTG9nVmVyYm9zaXR5O1xuKGZ1bmN0aW9uIChMb2dWZXJib3NpdHkpIHtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiREVCVUdcIl0gPSAwXSA9IFwiREVCVUdcIjtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiSU5GT1wiXSA9IDFdID0gXCJJTkZPXCI7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIkVSUk9SXCJdID0gMl0gPSBcIkVSUk9SXCI7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIk5PTkVcIl0gPSAzXSA9IFwiTk9ORVwiO1xufSkoTG9nVmVyYm9zaXR5IHx8IChleHBvcnRzLkxvZ1ZlcmJvc2l0eSA9IExvZ1ZlcmJvc2l0eSA9IHt9KSk7XG4vKipcbiAqIE5PVEU6IFRoaXMgZW51bSBpcyBub3QgY3VycmVudGx5IHVzZWQgaW4gYW55IGltcGxlbWVudGVkIEFQSSBpbiB0aGlzXG4gKiBsaWJyYXJ5LiBJdCBpcyBpbmNsdWRlZCBvbmx5IGZvciB0eXBlIHBhcml0eSB3aXRoIHRoZSBvdGhlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xudmFyIFByb3BhZ2F0ZTtcbihmdW5jdGlvbiAoUHJvcGFnYXRlKSB7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkRFQURMSU5FXCJdID0gMV0gPSBcIkRFQURMSU5FXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19TVEFUU19DT05URVhUXCJdID0gMl0gPSBcIkNFTlNVU19TVEFUU19DT05URVhUXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19UUkFDSU5HX0NPTlRFWFRcIl0gPSA0XSA9IFwiQ0VOU1VTX1RSQUNJTkdfQ09OVEVYVFwiO1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDQU5DRUxMQVRJT05cIl0gPSA4XSA9IFwiQ0FOQ0VMTEFUSU9OXCI7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9pbmNsdWRlL2dycGMvaW1wbC9jb2RlZ2VuL3Byb3BhZ2F0aW9uX2JpdHMuaCNMNDNcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiREVGQVVMVFNcIl0gPSA2NTUzNV0gPSBcIkRFRkFVTFRTXCI7XG59KShQcm9wYWdhdGUgfHwgKGV4cG9ydHMuUHJvcGFnYXRlID0gUHJvcGFnYXRlID0ge30pKTtcbi8vIC0xIG1lYW5zIHVubGltaXRlZFxuZXhwb3J0cy5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIID0gLTE7XG4vLyA0IE1CIGRlZmF1bHRcbmV4cG9ydHMuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCA9IDQgKiAxMDI0ICogMTAyNDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIIiwiREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCIsIlByb3BhZ2F0ZSIsIkxvZ1ZlcmJvc2l0eSIsIlN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/control-plane-status.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.restrictControlPlaneStatusCode = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\n    constants_1.Status.OK,\n    constants_1.Status.INVALID_ARGUMENT,\n    constants_1.Status.NOT_FOUND,\n    constants_1.Status.ALREADY_EXISTS,\n    constants_1.Status.FAILED_PRECONDITION,\n    constants_1.Status.ABORTED,\n    constants_1.Status.OUT_OF_RANGE,\n    constants_1.Status.DATA_LOSS\n];\nfunction restrictControlPlaneStatusCode(code, details) {\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n        return {\n            code: constants_1.Status.INTERNAL,\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`\n        };\n    } else {\n        return {\n            code,\n            details\n        };\n    }\n}\nexports.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode; //# sourceMappingURL=control-plane-status.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29udHJvbC1wbGFuZS1zdGF0dXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNDQUFzQyxHQUFHLEtBQUs7QUFDOUMsTUFBTUcsY0FBY0MsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUMsb0NBQW9DO0lBQ3RDRixZQUFZRyxNQUFNLENBQUNDLEVBQUU7SUFDckJKLFlBQVlHLE1BQU0sQ0FBQ0UsZ0JBQWdCO0lBQ25DTCxZQUFZRyxNQUFNLENBQUNHLFNBQVM7SUFDNUJOLFlBQVlHLE1BQU0sQ0FBQ0ksY0FBYztJQUNqQ1AsWUFBWUcsTUFBTSxDQUFDSyxtQkFBbUI7SUFDdENSLFlBQVlHLE1BQU0sQ0FBQ00sT0FBTztJQUMxQlQsWUFBWUcsTUFBTSxDQUFDTyxZQUFZO0lBQy9CVixZQUFZRyxNQUFNLENBQUNRLFNBQVM7Q0FDL0I7QUFDRCxTQUFTWiwrQkFBK0JhLElBQUksRUFBRUMsT0FBTztJQUNqRCxJQUFJWCxrQ0FBa0NZLFFBQVEsQ0FBQ0YsT0FBTztRQUNsRCxPQUFPO1lBQ0hBLE1BQU1aLFlBQVlHLE1BQU0sQ0FBQ1ksUUFBUTtZQUNqQ0YsU0FBUyxDQUFDLG1DQUFtQyxFQUFFRCxLQUFLLENBQUMsRUFBRVosWUFBWUcsTUFBTSxDQUFDUyxLQUFLLENBQUMsQ0FBQyxFQUFFQyxRQUFRLENBQUM7UUFDaEc7SUFDSixPQUNLO1FBQ0QsT0FBTztZQUFFRDtZQUFNQztRQUFRO0lBQzNCO0FBQ0o7QUFDQWhCLHNDQUFzQyxHQUFHRSxnQ0FDekMsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29udHJvbC1wbGFuZS1zdGF0dXMuanM/NzU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IElOQVBQUk9QUklBVEVfQ09OVFJPTF9QTEFORV9DT0RFUyA9IFtcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLklOVkFMSURfQVJHVU1FTlQsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuQUxSRUFEWV9FWElTVFMsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkZBSUxFRF9QUkVDT05ESVRJT04sXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkFCT1JURUQsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk9VVF9PRl9SQU5HRSxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuREFUQV9MT1NTLFxuXTtcbmZ1bmN0aW9uIHJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZShjb2RlLCBkZXRhaWxzKSB7XG4gICAgaWYgKElOQVBQUk9QUklBVEVfQ09OVFJPTF9QTEFORV9DT0RFUy5pbmNsdWRlcyhjb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgZGV0YWlsczogYEludmFsaWQgc3RhdHVzIGZyb20gY29udHJvbCBwbGFuZTogJHtjb2RlfSAke2NvbnN0YW50c18xLlN0YXR1c1tjb2RlXX0gJHtkZXRhaWxzfWAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBjb2RlLCBkZXRhaWxzIH07XG4gICAgfVxufVxuZXhwb3J0cy5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUgPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sLXBsYW5lLXN0YXR1cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUiLCJjb25zdGFudHNfMSIsInJlcXVpcmUiLCJJTkFQUFJPUFJJQVRFX0NPTlRST0xfUExBTkVfQ09ERVMiLCJTdGF0dXMiLCJPSyIsIklOVkFMSURfQVJHVU1FTlQiLCJOT1RfRk9VTkQiLCJBTFJFQURZX0VYSVNUUyIsIkZBSUxFRF9QUkVDT05ESVRJT04iLCJBQk9SVEVEIiwiT1VUX09GX1JBTkdFIiwiREFUQV9MT1NTIiwiY29kZSIsImRldGFpbHMiLCJpbmNsdWRlcyIsIklOVEVSTkFMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/deadline.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.deadlineToString = exports.getRelativeTimeout = exports.getDeadlineTimeoutString = exports.minDeadline = void 0;\nfunction minDeadline(...deadlineList) {\n    let minValue = Infinity;\n    for (const deadline of deadlineList){\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n        if (deadlineMsecs < minValue) {\n            minValue = deadlineMsecs;\n        }\n    }\n    return minValue;\n}\nexports.minDeadline = minDeadline;\nconst units = [\n    [\n        \"m\",\n        1\n    ],\n    [\n        \"S\",\n        1000\n    ],\n    [\n        \"M\",\n        60 * 1000\n    ],\n    [\n        \"H\",\n        60 * 60 * 1000\n    ]\n];\nfunction getDeadlineTimeoutString(deadline) {\n    const now = new Date().getTime();\n    if (deadline instanceof Date) {\n        deadline = deadline.getTime();\n    }\n    const timeoutMs = Math.max(deadline - now, 0);\n    for (const [unit, factor] of units){\n        const amount = timeoutMs / factor;\n        if (amount < 1e8) {\n            return String(Math.ceil(amount)) + unit;\n        }\n    }\n    throw new Error(\"Deadline is too far in the future\");\n}\nexports.getDeadlineTimeoutString = getDeadlineTimeoutString;\n/**\n * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\n * In particular, \"When delay is larger than 2147483647 or less than 1, the\n * delay will be set to 1. Non-integer delays are truncated to an integer.\"\n * This number of milliseconds is almost 25 days.\n */ const MAX_TIMEOUT_TIME = 2147483647;\n/**\n * Get the timeout value that should be passed to setTimeout now for the timer\n * to end at the deadline. For any deadline before now, the timer should end\n * immediately, represented by a value of 0. For any deadline more than\n * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will\n * end at that time, so it is treated as infinitely far in the future.\n * @param deadline\n * @returns\n */ function getRelativeTimeout(deadline) {\n    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;\n    const now = new Date().getTime();\n    const timeout = deadlineMs - now;\n    if (timeout < 0) {\n        return 0;\n    } else if (timeout > MAX_TIMEOUT_TIME) {\n        return Infinity;\n    } else {\n        return timeout;\n    }\n}\nexports.getRelativeTimeout = getRelativeTimeout;\nfunction deadlineToString(deadline) {\n    if (deadline instanceof Date) {\n        return deadline.toISOString();\n    } else {\n        const dateDeadline = new Date(deadline);\n        if (Number.isNaN(dateDeadline.getTime())) {\n            return \"\" + deadline;\n        } else {\n            return dateDeadline.toISOString();\n        }\n    }\n}\nexports.deadlineToString = deadlineToString; //# sourceMappingURL=deadline.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHQSwwQkFBMEIsR0FBR0EsZ0NBQWdDLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDdEgsU0FBU0ssWUFBWSxHQUFHQyxZQUFZO0lBQ2hDLElBQUlDLFdBQVdDO0lBQ2YsS0FBSyxNQUFNQyxZQUFZSCxhQUFjO1FBQ2pDLE1BQU1JLGdCQUFnQkQsb0JBQW9CRSxPQUFPRixTQUFTRyxPQUFPLEtBQUtIO1FBQ3RFLElBQUlDLGdCQUFnQkgsVUFBVTtZQUMxQkEsV0FBV0c7UUFDZjtJQUNKO0lBQ0EsT0FBT0g7QUFDWDtBQUNBUCxtQkFBbUIsR0FBR0s7QUFDdEIsTUFBTVEsUUFBUTtJQUNWO1FBQUM7UUFBSztLQUFFO0lBQ1I7UUFBQztRQUFLO0tBQUs7SUFDWDtRQUFDO1FBQUssS0FBSztLQUFLO0lBQ2hCO1FBQUM7UUFBSyxLQUFLLEtBQUs7S0FBSztDQUN4QjtBQUNELFNBQVNULHlCQUF5QkssUUFBUTtJQUN0QyxNQUFNSyxNQUFNLElBQUlILE9BQU9DLE9BQU87SUFDOUIsSUFBSUgsb0JBQW9CRSxNQUFNO1FBQzFCRixXQUFXQSxTQUFTRyxPQUFPO0lBQy9CO0lBQ0EsTUFBTUcsWUFBWUMsS0FBS0MsR0FBRyxDQUFDUixXQUFXSyxLQUFLO0lBQzNDLEtBQUssTUFBTSxDQUFDSSxNQUFNQyxPQUFPLElBQUlOLE1BQU87UUFDaEMsTUFBTU8sU0FBU0wsWUFBWUk7UUFDM0IsSUFBSUMsU0FBUyxLQUFLO1lBQ2QsT0FBT0MsT0FBT0wsS0FBS00sSUFBSSxDQUFDRixXQUFXRjtRQUN2QztJQUNKO0lBQ0EsTUFBTSxJQUFJSyxNQUFNO0FBQ3BCO0FBQ0F2QixnQ0FBZ0MsR0FBR0k7QUFDbkM7Ozs7O0NBS0MsR0FDRCxNQUFNb0IsbUJBQW1CO0FBQ3pCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU3JCLG1CQUFtQk0sUUFBUTtJQUNoQyxNQUFNZ0IsYUFBYWhCLG9CQUFvQkUsT0FBT0YsU0FBU0csT0FBTyxLQUFLSDtJQUNuRSxNQUFNSyxNQUFNLElBQUlILE9BQU9DLE9BQU87SUFDOUIsTUFBTWMsVUFBVUQsYUFBYVg7SUFDN0IsSUFBSVksVUFBVSxHQUFHO1FBQ2IsT0FBTztJQUNYLE9BQ0ssSUFBSUEsVUFBVUYsa0JBQWtCO1FBQ2pDLE9BQU9oQjtJQUNYLE9BQ0s7UUFDRCxPQUFPa0I7SUFDWDtBQUNKO0FBQ0ExQiwwQkFBMEIsR0FBR0c7QUFDN0IsU0FBU0QsaUJBQWlCTyxRQUFRO0lBQzlCLElBQUlBLG9CQUFvQkUsTUFBTTtRQUMxQixPQUFPRixTQUFTa0IsV0FBVztJQUMvQixPQUNLO1FBQ0QsTUFBTUMsZUFBZSxJQUFJakIsS0FBS0Y7UUFDOUIsSUFBSW9CLE9BQU9DLEtBQUssQ0FBQ0YsYUFBYWhCLE9BQU8sS0FBSztZQUN0QyxPQUFPLEtBQUtIO1FBQ2hCLE9BQ0s7WUFDRCxPQUFPbUIsYUFBYUQsV0FBVztRQUNuQztJQUNKO0FBQ0o7QUFDQTNCLHdCQUF3QixHQUFHRSxrQkFDM0Isb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanM/ZGVjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWFkbGluZVRvU3RyaW5nID0gZXhwb3J0cy5nZXRSZWxhdGl2ZVRpbWVvdXQgPSBleHBvcnRzLmdldERlYWRsaW5lVGltZW91dFN0cmluZyA9IGV4cG9ydHMubWluRGVhZGxpbmUgPSB2b2lkIDA7XG5mdW5jdGlvbiBtaW5EZWFkbGluZSguLi5kZWFkbGluZUxpc3QpIHtcbiAgICBsZXQgbWluVmFsdWUgPSBJbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IGRlYWRsaW5lIG9mIGRlYWRsaW5lTGlzdCkge1xuICAgICAgICBjb25zdCBkZWFkbGluZU1zZWNzID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUuZ2V0VGltZSgpIDogZGVhZGxpbmU7XG4gICAgICAgIGlmIChkZWFkbGluZU1zZWNzIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgIG1pblZhbHVlID0gZGVhZGxpbmVNc2VjcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluVmFsdWU7XG59XG5leHBvcnRzLm1pbkRlYWRsaW5lID0gbWluRGVhZGxpbmU7XG5jb25zdCB1bml0cyA9IFtcbiAgICBbJ20nLCAxXSxcbiAgICBbJ1MnLCAxMDAwXSxcbiAgICBbJ00nLCA2MCAqIDEwMDBdLFxuICAgIFsnSCcsIDYwICogNjAgKiAxMDAwXSxcbl07XG5mdW5jdGlvbiBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmcoZGVhZGxpbmUpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBpZiAoZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGRlYWRsaW5lID0gZGVhZGxpbmUuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lb3V0TXMgPSBNYXRoLm1heChkZWFkbGluZSAtIG5vdywgMCk7XG4gICAgZm9yIChjb25zdCBbdW5pdCwgZmFjdG9yXSBvZiB1bml0cykge1xuICAgICAgICBjb25zdCBhbW91bnQgPSB0aW1lb3V0TXMgLyBmYWN0b3I7XG4gICAgICAgIGlmIChhbW91bnQgPCAxZTgpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5jZWlsKGFtb3VudCkpICsgdW5pdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlYWRsaW5lIGlzIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZScpO1xufVxuZXhwb3J0cy5nZXREZWFkbGluZVRpbWVvdXRTdHJpbmcgPSBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmc7XG4vKipcbiAqIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3RpbWVycy5odG1sI3NldHRpbWVvdXRjYWxsYmFjay1kZWxheS1hcmdzXG4gKiBJbiBwYXJ0aWN1bGFyLCBcIldoZW4gZGVsYXkgaXMgbGFyZ2VyIHRoYW4gMjE0NzQ4MzY0NyBvciBsZXNzIHRoYW4gMSwgdGhlXG4gKiBkZWxheSB3aWxsIGJlIHNldCB0byAxLiBOb24taW50ZWdlciBkZWxheXMgYXJlIHRydW5jYXRlZCB0byBhbiBpbnRlZ2VyLlwiXG4gKiBUaGlzIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXMgYWxtb3N0IDI1IGRheXMuXG4gKi9cbmNvbnN0IE1BWF9USU1FT1VUX1RJTUUgPSAyMTQ3NDgzNjQ3O1xuLyoqXG4gKiBHZXQgdGhlIHRpbWVvdXQgdmFsdWUgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHNldFRpbWVvdXQgbm93IGZvciB0aGUgdGltZXJcbiAqIHRvIGVuZCBhdCB0aGUgZGVhZGxpbmUuIEZvciBhbnkgZGVhZGxpbmUgYmVmb3JlIG5vdywgdGhlIHRpbWVyIHNob3VsZCBlbmRcbiAqIGltbWVkaWF0ZWx5LCByZXByZXNlbnRlZCBieSBhIHZhbHVlIG9mIDAuIEZvciBhbnkgZGVhZGxpbmUgbW9yZSB0aGFuXG4gKiBNQVhfVElNRU9VVF9USU1FIG1pbGxpc2Vjb25kcyBpbiB0aGUgZnV0dXJlLCBhIHRpbWVyIGNhbm5vdCBiZSBzZXQgdGhhdCB3aWxsXG4gKiBlbmQgYXQgdGhhdCB0aW1lLCBzbyBpdCBpcyB0cmVhdGVkIGFzIGluZmluaXRlbHkgZmFyIGluIHRoZSBmdXR1cmUuXG4gKiBAcGFyYW0gZGVhZGxpbmVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldFJlbGF0aXZlVGltZW91dChkZWFkbGluZSkge1xuICAgIGNvbnN0IGRlYWRsaW5lTXMgPSBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUgPyBkZWFkbGluZS5nZXRUaW1lKCkgOiBkZWFkbGluZTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCB0aW1lb3V0ID0gZGVhZGxpbmVNcyAtIG5vdztcbiAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRpbWVvdXQgPiBNQVhfVElNRU9VVF9USU1FKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aW1lb3V0O1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0UmVsYXRpdmVUaW1lb3V0ID0gZ2V0UmVsYXRpdmVUaW1lb3V0O1xuZnVuY3Rpb24gZGVhZGxpbmVUb1N0cmluZyhkZWFkbGluZSkge1xuICAgIGlmIChkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRlYWRsaW5lLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBkYXRlRGVhZGxpbmUgPSBuZXcgRGF0ZShkZWFkbGluZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oZGF0ZURlYWRsaW5lLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIGRlYWRsaW5lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVEZWFkbGluZS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWFkbGluZVRvU3RyaW5nID0gZGVhZGxpbmVUb1N0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYWRsaW5lLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlYWRsaW5lVG9TdHJpbmciLCJnZXRSZWxhdGl2ZVRpbWVvdXQiLCJnZXREZWFkbGluZVRpbWVvdXRTdHJpbmciLCJtaW5EZWFkbGluZSIsImRlYWRsaW5lTGlzdCIsIm1pblZhbHVlIiwiSW5maW5pdHkiLCJkZWFkbGluZSIsImRlYWRsaW5lTXNlY3MiLCJEYXRlIiwiZ2V0VGltZSIsInVuaXRzIiwibm93IiwidGltZW91dE1zIiwiTWF0aCIsIm1heCIsInVuaXQiLCJmYWN0b3IiLCJhbW91bnQiLCJTdHJpbmciLCJjZWlsIiwiRXJyb3IiLCJNQVhfVElNRU9VVF9USU1FIiwiZGVhZGxpbmVNcyIsInRpbWVvdXQiLCJ0b0lTT1N0cmluZyIsImRhdGVEZWFkbGluZSIsIk51bWJlciIsImlzTmFOIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/duration.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isDuration = exports.durationToMs = exports.msToDuration = void 0;\nfunction msToDuration(millis) {\n    return {\n        seconds: millis / 1000 | 0,\n        nanos: millis % 1000 * 1000000 | 0\n    };\n}\nexports.msToDuration = msToDuration;\nfunction durationToMs(duration) {\n    return duration.seconds * 1000 + duration.nanos / 1000000 | 0;\n}\nexports.durationToMs = durationToMs;\nfunction isDuration(value) {\n    return typeof value.seconds === \"number\" && typeof value.nanos === \"number\";\n}\nexports.isDuration = isDuration; //# sourceMappingURL=duration.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUN4RSxTQUFTSSxhQUFhQyxNQUFNO0lBQ3hCLE9BQU87UUFDSEMsU0FBUyxTQUFVLE9BQVE7UUFDM0JDLE9BQU8sU0FBVyxPQUFRLFVBQVc7SUFDekM7QUFDSjtBQUNBUCxvQkFBb0IsR0FBR0k7QUFDdkIsU0FBU0QsYUFBYUssUUFBUTtJQUMxQixPQUFPLFNBQVVGLE9BQU8sR0FBRyxPQUFPRSxTQUFTRCxLQUFLLEdBQUcsVUFBVztBQUNsRTtBQUNBUCxvQkFBb0IsR0FBR0c7QUFDdkIsU0FBU0QsV0FBV0QsS0FBSztJQUNyQixPQUFPLE9BQU9BLE1BQU1LLE9BQU8sS0FBSyxZQUFZLE9BQU9MLE1BQU1NLEtBQUssS0FBSztBQUN2RTtBQUNBUCxrQkFBa0IsR0FBR0UsWUFDckIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanM/ZDExMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0R1cmF0aW9uID0gZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBleHBvcnRzLm1zVG9EdXJhdGlvbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIG1zVG9EdXJhdGlvbihtaWxsaXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWNvbmRzOiAobWlsbGlzIC8gMTAwMCkgfCAwLFxuICAgICAgICBuYW5vczogKChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDApIHwgMCxcbiAgICB9O1xufVxuZXhwb3J0cy5tc1RvRHVyYXRpb24gPSBtc1RvRHVyYXRpb247XG5mdW5jdGlvbiBkdXJhdGlvblRvTXMoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gKGR1cmF0aW9uLnNlY29uZHMgKiAxMDAwICsgZHVyYXRpb24ubmFub3MgLyAxMDAwMDAwKSB8IDA7XG59XG5leHBvcnRzLmR1cmF0aW9uVG9NcyA9IGR1cmF0aW9uVG9NcztcbmZ1bmN0aW9uIGlzRHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnNlY29uZHMgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5uYW5vcyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzRHVyYXRpb24gPSBpc0R1cmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHVyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNEdXJhdGlvbiIsImR1cmF0aW9uVG9NcyIsIm1zVG9EdXJhdGlvbiIsIm1pbGxpcyIsInNlY29uZHMiLCJuYW5vcyIsImR1cmF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/error.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getErrorCode = exports.getErrorMessage = void 0;\nfunction getErrorMessage(error) {\n    if (error instanceof Error) {\n        return error.message;\n    } else {\n        return String(error);\n    }\n}\nexports.getErrorMessage = getErrorMessage;\nfunction getErrorCode(error) {\n    if (typeof error === \"object\" && error !== null && \"code\" in error && typeof error.code === \"number\") {\n        return error.code;\n    } else {\n        return null;\n    }\n}\nexports.getErrorCode = getErrorCode; //# sourceMappingURL=error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQ3RELFNBQVNHLGdCQUFnQkMsS0FBSztJQUMxQixJQUFJQSxpQkFBaUJDLE9BQU87UUFDeEIsT0FBT0QsTUFBTUUsT0FBTztJQUN4QixPQUNLO1FBQ0QsT0FBT0MsT0FBT0g7SUFDbEI7QUFDSjtBQUNBSix1QkFBdUIsR0FBR0c7QUFDMUIsU0FBU0QsYUFBYUUsS0FBSztJQUN2QixJQUFJLE9BQU9BLFVBQVUsWUFDakJBLFVBQVUsUUFDVixVQUFVQSxTQUNWLE9BQU9BLE1BQU1JLElBQUksS0FBSyxVQUFVO1FBQ2hDLE9BQU9KLE1BQU1JLElBQUk7SUFDckIsT0FDSztRQUNELE9BQU87SUFDWDtBQUNKO0FBQ0FSLG9CQUFvQixHQUFHRSxjQUN2QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9lcnJvci5qcz9lYzk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVycm9yQ29kZSA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGVycm9yKTtcbiAgICB9XG59XG5leHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTtcbmZ1bmN0aW9uIGdldEVycm9yQ29kZShlcnJvcikge1xuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgICAgICdjb2RlJyBpbiBlcnJvciAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLmNvZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmdldEVycm9yQ29kZSA9IGdldEVycm9yQ29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEVycm9yQ29kZSIsImdldEVycm9yTWVzc2FnZSIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiU3RyaW5nIiwiY29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/experimental.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OutlierDetectionLoadBalancingConfig = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.subchannelAddressToString = exports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.durationToMs = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = void 0;\nvar logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nObject.defineProperty(exports, \"trace\", ({\n    enumerable: true,\n    get: function() {\n        return logging_1.trace;\n    }\n}));\nObject.defineProperty(exports, \"log\", ({\n    enumerable: true,\n    get: function() {\n        return logging_1.log;\n    }\n}));\nvar resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nObject.defineProperty(exports, \"registerResolver\", ({\n    enumerable: true,\n    get: function() {\n        return resolver_1.registerResolver;\n    }\n}));\nObject.defineProperty(exports, \"createResolver\", ({\n    enumerable: true,\n    get: function() {\n        return resolver_1.createResolver;\n    }\n}));\nvar uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nObject.defineProperty(exports, \"uriToString\", ({\n    enumerable: true,\n    get: function() {\n        return uri_parser_1.uriToString;\n    }\n}));\nvar duration_1 = __webpack_require__(/*! ./duration */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nObject.defineProperty(exports, \"durationToMs\", ({\n    enumerable: true,\n    get: function() {\n        return duration_1.durationToMs;\n    }\n}));\nvar backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nObject.defineProperty(exports, \"BackoffTimeout\", ({\n    enumerable: true,\n    get: function() {\n        return backoff_timeout_1.BackoffTimeout;\n    }\n}));\nvar load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nObject.defineProperty(exports, \"createChildChannelControlHelper\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.createChildChannelControlHelper;\n    }\n}));\nObject.defineProperty(exports, \"registerLoadBalancerType\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.registerLoadBalancerType;\n    }\n}));\nObject.defineProperty(exports, \"getFirstUsableConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.getFirstUsableConfig;\n    }\n}));\nObject.defineProperty(exports, \"validateLoadBalancingConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.validateLoadBalancingConfig;\n    }\n}));\nvar subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nObject.defineProperty(exports, \"subchannelAddressToString\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_address_1.subchannelAddressToString;\n    }\n}));\nvar load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nObject.defineProperty(exports, \"ChildLoadBalancerHandler\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_child_handler_1.ChildLoadBalancerHandler;\n    }\n}));\nvar picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nObject.defineProperty(exports, \"UnavailablePicker\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.UnavailablePicker;\n    }\n}));\nObject.defineProperty(exports, \"QueuePicker\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.QueuePicker;\n    }\n}));\nObject.defineProperty(exports, \"PickResultType\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.PickResultType;\n    }\n}));\nvar filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nObject.defineProperty(exports, \"BaseFilter\", ({\n    enumerable: true,\n    get: function() {\n        return filter_1.BaseFilter;\n    }\n}));\nvar filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nObject.defineProperty(exports, \"FilterStackFactory\", ({\n    enumerable: true,\n    get: function() {\n        return filter_stack_1.FilterStackFactory;\n    }\n}));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"registerAdminService\", ({\n    enumerable: true,\n    get: function() {\n        return admin_1.registerAdminService;\n    }\n}));\nvar subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nObject.defineProperty(exports, \"BaseSubchannelWrapper\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_interface_1.BaseSubchannelWrapper;\n    }\n}));\nvar load_balancer_outlier_detection_1 = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nObject.defineProperty(exports, \"OutlierDetectionLoadBalancingConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_outlier_detection_1.OutlierDetectionLoadBalancingConfig;\n    }\n})); //# sourceMappingURL=experimental.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQ0FBMkMsR0FBR0EsNkJBQTZCLEdBQUdBLDRCQUE0QixHQUFHQSwwQkFBMEIsR0FBR0Esa0JBQWtCLEdBQUdBLHNCQUFzQixHQUFHQSxtQkFBbUIsR0FBR0EseUJBQXlCLEdBQUdBLGdDQUFnQyxHQUFHQSxpQ0FBaUMsR0FBR0EsbUNBQW1DLEdBQUdBLDRCQUE0QixHQUFHQSxnQ0FBZ0MsR0FBR0EsdUNBQXVDLEdBQUdBLHNCQUFzQixHQUFHQSxvQkFBb0IsR0FBR0EsbUJBQW1CLEdBQUdBLHNCQUFzQixHQUFHQSx3QkFBd0IsR0FBR0EsV0FBVyxHQUFHQSxhQUFhLEdBQUcsS0FBSztBQUNobUIsSUFBSXVCLFlBQVlDLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DMUIseUNBQXdDO0lBQUUyQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxVQUFVRCxLQUFLO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDM0d4Qix1Q0FBc0M7SUFBRTJCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILFVBQVVGLEdBQUc7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN2RyxJQUFJTSxhQUFhSCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUNyQzFCLG9EQUFtRDtJQUFFMkIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsV0FBV1AsZ0JBQWdCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEl0QixrREFBaUQ7SUFBRTJCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLFdBQVdSLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM5SCxJQUFJUyxlQUFlSixtQkFBT0EsQ0FBQyxnRkFBYztBQUN6QzFCLCtDQUE4QztJQUFFMkIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Us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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9leHBlcmltZW50YWwuanM/NGFkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcgPSBleHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IGV4cG9ydHMucmVnaXN0ZXJBZG1pblNlcnZpY2UgPSBleHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUZpbHRlciA9IGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSBleHBvcnRzLlF1ZXVlUGlja2VyID0gZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IGV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gZXhwb3J0cy52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcgPSBleHBvcnRzLmdldEZpcnN0VXNhYmxlQ29uZmlnID0gZXhwb3J0cy5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUgPSBleHBvcnRzLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSBleHBvcnRzLkJhY2tvZmZUaW1lb3V0ID0gZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBleHBvcnRzLnVyaVRvU3RyaW5nID0gZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IGV4cG9ydHMubG9nID0gZXhwb3J0cy50cmFjZSA9IHZvaWQgMDtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHJhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZ2dpbmdfMS50cmFjZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2luZ18xLmxvZzsgfSB9KTtcbnZhciByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdpc3RlclJlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcjsgfSB9KTtcbnZhciB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXJpVG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZzsgfSB9KTtcbnZhciBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4vZHVyYXRpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkdXJhdGlvblRvTXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zOyB9IH0pO1xudmFyIGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFja29mZlRpbWVvdXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0OyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEZpcnN0VXNhYmxlQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuZ2V0Rmlyc3RVc2FibGVDb25maWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWc7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nOyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7IH0gfSk7XG52YXIgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmF2YWlsYWJsZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRdWV1ZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUXVldWVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaWNrUmVzdWx0VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGU7IH0gfSk7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlRmlsdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfMS5CYXNlRmlsdGVyOyB9IH0pO1xudmFyIGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsdGVyU3RhY2tGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfc3RhY2tfMS5GaWx0ZXJTdGFja0ZhY3Rvcnk7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJBZG1pblNlcnZpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2U7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlcjsgfSB9KTtcbnZhciBsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb25fMS5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZzsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGVyaW1lbnRhbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyIsIkJhc2VTdWJjaGFubmVsV3JhcHBlciIsInJlZ2lzdGVyQWRtaW5TZXJ2aWNlIiwiRmlsdGVyU3RhY2tGYWN0b3J5IiwiQmFzZUZpbHRlciIsIlBpY2tSZXN1bHRUeXBlIiwiUXVldWVQaWNrZXIiLCJVbmF2YWlsYWJsZVBpY2tlciIsIkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlciIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWciLCJnZXRGaXJzdFVzYWJsZUNvbmZpZyIsInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSIsImNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIiLCJCYWNrb2ZmVGltZW91dCIsImR1cmF0aW9uVG9NcyIsInVyaVRvU3RyaW5nIiwiY3JlYXRlUmVzb2x2ZXIiLCJyZWdpc3RlclJlc29sdmVyIiwibG9nIiwidHJhY2UiLCJsb2dnaW5nXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsInJlc29sdmVyXzEiLCJ1cmlfcGFyc2VyXzEiLCJkdXJhdGlvbl8xIiwiYmFja29mZl90aW1lb3V0XzEiLCJsb2FkX2JhbGFuY2VyXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsImxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xIiwicGlja2VyXzEiLCJmaWx0ZXJfMSIsImZpbHRlcl9zdGFja18xIiwiYWRtaW5fMSIsInN1YmNoYW5uZWxfaW50ZXJmYWNlXzEiLCJsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter-stack.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FilterStackFactory = exports.FilterStack = void 0;\nclass FilterStack {\n    constructor(filters){\n        this.filters = filters;\n    }\n    sendMetadata(metadata) {\n        let result = metadata;\n        for(let i = 0; i < this.filters.length; i++){\n            result = this.filters[i].sendMetadata(result);\n        }\n        return result;\n    }\n    receiveMetadata(metadata) {\n        let result = metadata;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveMetadata(result);\n        }\n        return result;\n    }\n    sendMessage(message) {\n        let result = message;\n        for(let i = 0; i < this.filters.length; i++){\n            result = this.filters[i].sendMessage(result);\n        }\n        return result;\n    }\n    receiveMessage(message) {\n        let result = message;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveMessage(result);\n        }\n        return result;\n    }\n    receiveTrailers(status) {\n        let result = status;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveTrailers(result);\n        }\n        return result;\n    }\n    push(filters) {\n        this.filters.unshift(...filters);\n    }\n    getFilters() {\n        return this.filters;\n    }\n}\nexports.FilterStack = FilterStack;\nclass FilterStackFactory {\n    constructor(factories){\n        this.factories = factories;\n    }\n    push(filterFactories) {\n        this.factories.unshift(...filterFactories);\n    }\n    clone() {\n        return new FilterStackFactory([\n            ...this.factories\n        ]);\n    }\n    createFilter() {\n        return new FilterStack(this.factories.map((factory)=>factory.createFilter()));\n    }\n}\nexports.FilterStackFactory = FilterStackFactory; //# sourceMappingURL=filter-stack.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUN4RCxNQUFNRztJQUNGQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FDLGFBQWFDLFFBQVEsRUFBRTtRQUNuQixJQUFJQyxTQUFTRDtRQUNiLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxNQUFNLEVBQUVELElBQUs7WUFDMUNELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0gsWUFBWSxDQUFDRTtRQUMxQztRQUNBLE9BQU9BO0lBQ1g7SUFDQUcsZ0JBQWdCSixRQUFRLEVBQUU7UUFDdEIsSUFBSUMsU0FBU0Q7UUFDYixJQUFLLElBQUlFLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0UsZUFBZSxDQUFDSDtRQUM3QztRQUNBLE9BQU9BO0lBQ1g7SUFDQUksWUFBWUMsT0FBTyxFQUFFO1FBQ2pCLElBQUlMLFNBQVNLO1FBQ2IsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sRUFBRUQsSUFBSztZQUMxQ0QsU0FBUyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ksRUFBRSxDQUFDRyxXQUFXLENBQUNKO1FBQ3pDO1FBQ0EsT0FBT0E7SUFDWDtJQUNBTSxlQUFlRCxPQUFPLEVBQUU7UUFDcEIsSUFBSUwsU0FBU0s7UUFDYixJQUFLLElBQUlKLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0ssY0FBYyxDQUFDTjtRQUM1QztRQUNBLE9BQU9BO0lBQ1g7SUFDQU8sZ0JBQWdCQyxNQUFNLEVBQUU7UUFDcEIsSUFBSVIsU0FBU1E7UUFDYixJQUFLLElBQUlQLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ00sZUFBZSxDQUFDUDtRQUM3QztRQUNBLE9BQU9BO0lBQ1g7SUFDQVMsS0FBS1osT0FBTyxFQUFFO1FBQ1YsSUFBSSxDQUFDQSxPQUFPLENBQUNhLE9BQU8sSUFBSWI7SUFDNUI7SUFDQWMsYUFBYTtRQUNULE9BQU8sSUFBSSxDQUFDZCxPQUFPO0lBQ3ZCO0FBQ0o7QUFDQUwsbUJBQW1CLEdBQUdHO0FBQ3RCLE1BQU1EO0lBQ0ZFLFlBQVlnQixTQUFTLENBQUU7UUFDbkIsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0FILEtBQUtJLGVBQWUsRUFBRTtRQUNsQixJQUFJLENBQUNELFNBQVMsQ0FBQ0YsT0FBTyxJQUFJRztJQUM5QjtJQUNBQyxRQUFRO1FBQ0osT0FBTyxJQUFJcEIsbUJBQW1CO2VBQUksSUFBSSxDQUFDa0IsU0FBUztTQUFDO0lBQ3JEO0lBQ0FHLGVBQWU7UUFDWCxPQUFPLElBQUlwQixZQUFZLElBQUksQ0FBQ2lCLFNBQVMsQ0FBQ0ksR0FBRyxDQUFDQyxDQUFBQSxVQUFXQSxRQUFRRixZQUFZO0lBQzdFO0FBQ0o7QUFDQXZCLDBCQUEwQixHQUFHRSxvQkFDN0Isd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzPzc1MzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmlsdGVyU3RhY2tGYWN0b3J5ID0gZXhwb3J0cy5GaWx0ZXJTdGFjayA9IHZvaWQgMDtcbmNsYXNzIEZpbHRlclN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0uc2VuZE1ldGFkYXRhKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnJlY2VpdmVNZXRhZGF0YShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1lc3NhZ2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0uc2VuZE1lc3NhZ2UocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXNzYWdlO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0ucmVjZWl2ZU1lc3NhZ2UocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZWNlaXZlVHJhaWxlcnMoc3RhdHVzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzdGF0dXM7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlVHJhaWxlcnMocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwdXNoKGZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnVuc2hpZnQoLi4uZmlsdGVycyk7XG4gICAgfVxuICAgIGdldEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJTdGFjayA9IEZpbHRlclN0YWNrO1xuY2xhc3MgRmlsdGVyU3RhY2tGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3JpZXMpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XG4gICAgfVxuICAgIHB1c2goZmlsdGVyRmFjdG9yaWVzKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yaWVzLnVuc2hpZnQoLi4uZmlsdGVyRmFjdG9yaWVzKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsdGVyU3RhY2tGYWN0b3J5KFsuLi50aGlzLmZhY3Rvcmllc10pO1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsdGVyU3RhY2sodGhpcy5mYWN0b3JpZXMubWFwKGZhY3RvcnkgPT4gZmFjdG9yeS5jcmVhdGVGaWx0ZXIoKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVyU3RhY2tGYWN0b3J5ID0gRmlsdGVyU3RhY2tGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLXN0YWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZpbHRlclN0YWNrRmFjdG9yeSIsIkZpbHRlclN0YWNrIiwiY29uc3RydWN0b3IiLCJmaWx0ZXJzIiwic2VuZE1ldGFkYXRhIiwibWV0YWRhdGEiLCJyZXN1bHQiLCJpIiwibGVuZ3RoIiwicmVjZWl2ZU1ldGFkYXRhIiwic2VuZE1lc3NhZ2UiLCJtZXNzYWdlIiwicmVjZWl2ZU1lc3NhZ2UiLCJyZWNlaXZlVHJhaWxlcnMiLCJzdGF0dXMiLCJwdXNoIiwidW5zaGlmdCIsImdldEZpbHRlcnMiLCJmYWN0b3JpZXMiLCJmaWx0ZXJGYWN0b3JpZXMiLCJjbG9uZSIsImNyZWF0ZUZpbHRlciIsIm1hcCIsImZhY3RvcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseFilter = void 0;\nclass BaseFilter {\n    async sendMetadata(metadata) {\n        return metadata;\n    }\n    receiveMetadata(metadata) {\n        return metadata;\n    }\n    async sendMessage(message) {\n        return message;\n    }\n    async receiveMessage(message) {\n        return message;\n    }\n    receiveTrailers(status) {\n        return status;\n    }\n}\nexports.BaseFilter = BaseFilter; //# sourceMappingURL=filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBRyxLQUFLO0FBQzFCLE1BQU1FO0lBQ0YsTUFBTUMsYUFBYUMsUUFBUSxFQUFFO1FBQ3pCLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCRCxRQUFRLEVBQUU7UUFDdEIsT0FBT0E7SUFDWDtJQUNBLE1BQU1FLFlBQVlDLE9BQU8sRUFBRTtRQUN2QixPQUFPQTtJQUNYO0lBQ0EsTUFBTUMsZUFBZUQsT0FBTyxFQUFFO1FBQzFCLE9BQU9BO0lBQ1g7SUFDQUUsZ0JBQWdCQyxNQUFNLEVBQUU7UUFDcEIsT0FBT0E7SUFDWDtBQUNKO0FBQ0FWLGtCQUFrQixHQUFHRSxZQUNyQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9maWx0ZXIuanM/MGYzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlRmlsdGVyID0gdm9pZCAwO1xuY2xhc3MgQmFzZUZpbHRlciB7XG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUZpbHRlciA9IEJhc2VGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQmFzZUZpbHRlciIsInNlbmRNZXRhZGF0YSIsIm1ldGFkYXRhIiwicmVjZWl2ZU1ldGFkYXRhIiwic2VuZE1lc3NhZ2UiLCJtZXNzYWdlIiwicmVjZWl2ZU1lc3NhZ2UiLCJyZWNlaXZlVHJhaWxlcnMiLCJzdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/http_proxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst resolver_dns_1 = __webpack_require__(/*! ./resolver-dns */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst TRACER_NAME = \"proxy\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = \"\";\n    let envVar = \"\";\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */ if (process.env.grpc_proxy) {\n        envVar = \"grpc_proxy\";\n        proxyEnv = process.env.grpc_proxy;\n    } else if (process.env.https_proxy) {\n        envVar = \"https_proxy\";\n        proxyEnv = process.env.https_proxy;\n    } else if (process.env.http_proxy) {\n        envVar = \"http_proxy\";\n        proxyEnv = process.env.http_proxy;\n    } else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    } catch (e) {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== \"http:\") {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            (0, logging_1.log)(constants_1.LogVerbosity.INFO, \"userinfo found in proxy URI\");\n            userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n        } else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const hostname = proxyUrl.hostname;\n    let port = proxyUrl.port;\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\n     * 80. We need to set that explicitly here if it is omitted because otherwise\n     * it will use gRPC's default port 443. */ if (port === \"\") {\n        port = \"80\";\n    }\n    const result = {\n        address: `${hostname}:${port}`\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace(\"Proxy server \" + result.address + \" set by environment variable \" + envVar);\n    return result;\n}\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */ let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = \"no_grpc_proxy\";\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = \"no_proxy\";\n    }\n    if (noProxyStr) {\n        trace(\"No proxy server list set by environment variable \" + envVar);\n        return noProxyStr.split(\",\");\n    } else {\n        return [];\n    }\n}\nfunction mapProxyName(target, options) {\n    var _a;\n    const noProxyResult = {\n        target: target,\n        extraOptions: {}\n    };\n    if (((_a = options[\"grpc.enable_http_proxy\"]) !== null && _a !== void 0 ? _a : 1) === 0) {\n        return noProxyResult;\n    }\n    if (target.scheme === \"unix\") {\n        return noProxyResult;\n    }\n    const proxyInfo = getProxyInfo();\n    if (!proxyInfo.address) {\n        return noProxyResult;\n    }\n    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n    if (!hostPort) {\n        return noProxyResult;\n    }\n    const serverHost = hostPort.host;\n    for (const host of getNoProxyHostList()){\n        if (host === serverHost) {\n            trace(\"Not using proxy for target in no_proxy list: \" + (0, uri_parser_1.uriToString)(target));\n            return noProxyResult;\n        }\n    }\n    const extraOptions = {\n        \"grpc.http_connect_target\": (0, uri_parser_1.uriToString)(target)\n    };\n    if (proxyInfo.creds) {\n        extraOptions[\"grpc.http_connect_creds\"] = proxyInfo.creds;\n    }\n    return {\n        target: {\n            scheme: \"dns\",\n            path: proxyInfo.address\n        },\n        extraOptions: extraOptions\n    };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n    var _a;\n    if (!(\"grpc.http_connect_target\" in channelOptions)) {\n        return Promise.resolve({});\n    }\n    const realTarget = channelOptions[\"grpc.http_connect_target\"];\n    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\n    if (parsedTarget === null) {\n        return Promise.resolve({});\n    }\n    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);\n    if (splitHostPost === null) {\n        return Promise.resolve({});\n    }\n    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;\n    const options = {\n        method: \"CONNECT\",\n        path: hostPort\n    };\n    const headers = {\n        Host: hostPort\n    };\n    // Connect to the subchannel address as a proxy\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n        options.host = address.host;\n        options.port = address.port;\n    } else {\n        options.socketPath = address.path;\n    }\n    if (\"grpc.http_connect_creds\" in channelOptions) {\n        headers[\"Proxy-Authorization\"] = \"Basic \" + Buffer.from(channelOptions[\"grpc.http_connect_creds\"]).toString(\"base64\");\n    }\n    options.headers = headers;\n    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n    trace(\"Using proxy \" + proxyAddressString + \" to connect to \" + options.path);\n    return new Promise((resolve, reject)=>{\n        const request = http.request(options);\n        request.once(\"connect\", (res, socket, head)=>{\n            var _a;\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === 200) {\n                trace(\"Successfully connected to \" + options.path + \" through proxy \" + proxyAddressString);\n                if (\"secureContext\" in connectionOptions) {\n                    /* The proxy is connecting to a TLS server, so upgrade this socket\n                     * connection to a TLS connection.\n                     * This is a workaround for https://github.com/nodejs/node/issues/32922\n                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */ const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);\n                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n                    const cts = tls.connect(Object.assign({\n                        host: remoteHost,\n                        servername: remoteHost,\n                        socket: socket\n                    }, connectionOptions), ()=>{\n                        trace(\"Successfully established a TLS connection to \" + options.path + \" through proxy \" + proxyAddressString);\n                        resolve({\n                            socket: cts,\n                            realTarget: parsedTarget\n                        });\n                    });\n                    cts.on(\"error\", (error)=>{\n                        trace(\"Failed to establish a TLS connection to \" + options.path + \" through proxy \" + proxyAddressString + \" with error \" + error.message);\n                        reject();\n                    });\n                } else {\n                    trace(\"Successfully established a plaintext connection to \" + options.path + \" through proxy \" + proxyAddressString);\n                    resolve({\n                        socket,\n                        realTarget: parsedTarget\n                    });\n                }\n            } else {\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, \"Failed to connect to \" + options.path + \" through proxy \" + proxyAddressString + \" with status \" + res.statusCode);\n                reject();\n            }\n        });\n        request.once(\"error\", (err)=>{\n            request.removeAllListeners();\n            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, \"Failed to connect to proxy \" + proxyAddressString + \" with error \" + err.message);\n            reject();\n        });\n        request.end();\n    });\n}\nexports.getProxiedConnection = getProxiedConnection; //# sourceMappingURL=http_proxy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaHR0cF9wcm94eS5qcyIsIm1hcHBpbmdzIjoiOztBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw0QkFBNEIsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUMzRCxNQUFNSSxZQUFZQyxtQkFBT0EsQ0FBQywwRUFBVztBQUNyQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNSSxNQUFNSixtQkFBT0EsQ0FBQyxnQkFBSztBQUN6QixNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTSx1QkFBdUJOLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNTyxlQUFlUCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNUSxRQUFRUixtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNUyxpQkFBaUJULG1CQUFPQSxDQUFDLG9GQUFnQjtBQUMvQyxNQUFNVSxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZlAsUUFBUU0sS0FBSyxDQUFDVixZQUFZWSxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQSxTQUFTRztJQUNMLElBQUlDLFdBQVc7SUFDZixJQUFJQyxTQUFTO0lBQ2I7OztLQUdDLEdBQ0QsSUFBSUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxVQUFVLEVBQUU7UUFDeEJILFNBQVM7UUFDVEQsV0FBV0UsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxVQUFVO0lBQ3JDLE9BQ0ssSUFBSUYsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRSxXQUFXLEVBQUU7UUFDOUJKLFNBQVM7UUFDVEQsV0FBV0UsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRSxXQUFXO0lBQ3RDLE9BQ0ssSUFBSUgsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRyxVQUFVLEVBQUU7UUFDN0JMLFNBQVM7UUFDVEQsV0FBV0UsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRyxVQUFVO0lBQ3JDLE9BQ0s7UUFDRCxPQUFPLENBQUM7SUFDWjtJQUNBLElBQUlDO0lBQ0osSUFBSTtRQUNBQSxXQUFXLElBQUlmLE1BQU1nQixHQUFHLENBQUNSO0lBQzdCLEVBQ0EsT0FBT1MsR0FBRztRQUNMLElBQUcxQixVQUFVMkIsR0FBRyxFQUFFekIsWUFBWVksWUFBWSxDQUFDYyxLQUFLLEVBQUUsQ0FBQyx1QkFBdUIsRUFBRVYsT0FBTyxTQUFTLENBQUM7UUFDOUYsT0FBTyxDQUFDO0lBQ1o7SUFDQSxJQUFJTSxTQUFTSyxRQUFRLEtBQUssU0FBUztRQUM5QixJQUFHN0IsVUFBVTJCLEdBQUcsRUFBRXpCLFlBQVlZLFlBQVksQ0FBQ2MsS0FBSyxFQUFFLENBQUMsQ0FBQyxFQUFFSixTQUFTSyxRQUFRLENBQUMsbUNBQW1DLENBQUM7UUFDN0csT0FBTyxDQUFDO0lBQ1o7SUFDQSxJQUFJQyxXQUFXO0lBQ2YsSUFBSU4sU0FBU08sUUFBUSxFQUFFO1FBQ25CLElBQUlQLFNBQVNRLFFBQVEsRUFBRTtZQUNsQixJQUFHaEMsVUFBVTJCLEdBQUcsRUFBRXpCLFlBQVlZLFlBQVksQ0FBQ21CLElBQUksRUFBRTtZQUNsREgsV0FBVyxDQUFDLEVBQUVOLFNBQVNPLFFBQVEsQ0FBQyxDQUFDLEVBQUVQLFNBQVNRLFFBQVEsQ0FBQyxDQUFDO1FBQzFELE9BQ0s7WUFDREYsV0FBV04sU0FBU08sUUFBUTtRQUNoQztJQUNKO0lBQ0EsTUFBTUcsV0FBV1YsU0FBU1UsUUFBUTtJQUNsQyxJQUFJQyxPQUFPWCxTQUFTVyxJQUFJO0lBQ3hCOzs0Q0FFd0MsR0FDeEMsSUFBSUEsU0FBUyxJQUFJO1FBQ2JBLE9BQU87SUFDWDtJQUNBLE1BQU1DLFNBQVM7UUFDWEMsU0FBUyxDQUFDLEVBQUVILFNBQVMsQ0FBQyxFQUFFQyxLQUFLLENBQUM7SUFDbEM7SUFDQSxJQUFJTCxVQUFVO1FBQ1ZNLE9BQU9FLEtBQUssR0FBR1I7SUFDbkI7SUFDQWxCLE1BQU0sa0JBQWtCd0IsT0FBT0MsT0FBTyxHQUFHLGtDQUFrQ25CO0lBQzNFLE9BQU9rQjtBQUNYO0FBQ0EsU0FBU0c7SUFDTCwwRUFBMEUsR0FDMUUsSUFBSUMsYUFBYXJCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ3FCLGFBQWE7SUFDMUMsSUFBSXZCLFNBQVM7SUFDYixJQUFJLENBQUNzQixZQUFZO1FBQ2JBLGFBQWFyQixPQUFPQSxDQUFDQyxHQUFHLENBQUNzQixRQUFRO1FBQ2pDeEIsU0FBUztJQUNiO0lBQ0EsSUFBSXNCLFlBQVk7UUFDWjVCLE1BQU0sc0RBQXNETTtRQUM1RCxPQUFPc0IsV0FBV0csS0FBSyxDQUFDO0lBQzVCLE9BQ0s7UUFDRCxPQUFPLEVBQUU7SUFDYjtBQUNKO0FBQ0EsU0FBUzVDLGFBQWE2QyxNQUFNLEVBQUVDLE9BQU87SUFDakMsSUFBSUM7SUFDSixNQUFNQyxnQkFBZ0I7UUFDbEJILFFBQVFBO1FBQ1JJLGNBQWMsQ0FBQztJQUNuQjtJQUNBLElBQUksQ0FBQyxDQUFDRixLQUFLRCxPQUFPLENBQUMseUJBQXlCLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUlBLEtBQUssT0FBTyxHQUFHO1FBQ3JGLE9BQU9DO0lBQ1g7SUFDQSxJQUFJSCxPQUFPSyxNQUFNLEtBQUssUUFBUTtRQUMxQixPQUFPRjtJQUNYO0lBQ0EsTUFBTUcsWUFBWWxDO0lBQ2xCLElBQUksQ0FBQ2tDLFVBQVViLE9BQU8sRUFBRTtRQUNwQixPQUFPVTtJQUNYO0lBQ0EsTUFBTUksV0FBVyxDQUFDLEdBQUczQyxhQUFhNEMsYUFBYSxFQUFFUixPQUFPUyxJQUFJO0lBQzVELElBQUksQ0FBQ0YsVUFBVTtRQUNYLE9BQU9KO0lBQ1g7SUFDQSxNQUFNTyxhQUFhSCxTQUFTSSxJQUFJO0lBQ2hDLEtBQUssTUFBTUEsUUFBUWhCLHFCQUFzQjtRQUNyQyxJQUFJZ0IsU0FBU0QsWUFBWTtZQUNyQjFDLE1BQU0sa0RBQWtELENBQUMsR0FBR0osYUFBYWdELFdBQVcsRUFBRVo7WUFDdEYsT0FBT0c7UUFDWDtJQUNKO0lBQ0EsTUFBTUMsZUFBZTtRQUNqQiw0QkFBNEIsQ0FBQyxHQUFHeEMsYUFBYWdELFdBQVcsRUFBRVo7SUFDOUQ7SUFDQSxJQUFJTSxVQUFVWixLQUFLLEVBQUU7UUFDakJVLFlBQVksQ0FBQywwQkFBMEIsR0FBR0UsVUFBVVosS0FBSztJQUM3RDtJQUNBLE9BQU87UUFDSE0sUUFBUTtZQUNKSyxRQUFRO1lBQ1JJLE1BQU1ILFVBQVViLE9BQU87UUFDM0I7UUFDQVcsY0FBY0E7SUFDbEI7QUFDSjtBQUNBcEQsb0JBQW9CLEdBQUdHO0FBQ3ZCLFNBQVNELHFCQUFxQnVDLE9BQU8sRUFBRW9CLGNBQWMsRUFBRUMsaUJBQWlCO0lBQ3BFLElBQUlaO0lBQ0osSUFBSSxDQUFFLCtCQUE4QlcsY0FBYSxHQUFJO1FBQ2pELE9BQU9FLFFBQVFDLE9BQU8sQ0FBQyxDQUFDO0lBQzVCO0lBQ0EsTUFBTUMsYUFBYUosY0FBYyxDQUFDLDJCQUEyQjtJQUM3RCxNQUFNSyxlQUFlLENBQUMsR0FBR3RELGFBQWF1RCxRQUFRLEVBQUVGO0lBQ2hELElBQUlDLGlCQUFpQixNQUFNO1FBQ3ZCLE9BQU9ILFFBQVFDLE9BQU8sQ0FBQyxDQUFDO0lBQzVCO0lBQ0EsTUFBTUksZ0JBQWdCLENBQUMsR0FBR3hELGFBQWE0QyxhQUFhLEVBQUVVLGFBQWFULElBQUk7SUFDdkUsSUFBSVcsa0JBQWtCLE1BQU07UUFDeEIsT0FBT0wsUUFBUUMsT0FBTyxDQUFDLENBQUM7SUFDNUI7SUFDQSxNQUFNVCxXQUFXLENBQUMsRUFBRWEsY0FBY1QsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDVCxLQUFLa0IsY0FBYzdCLElBQUksTUFBTSxRQUFRVyxPQUFPLEtBQUssSUFBSUEsS0FBS3BDLGVBQWV1RCxZQUFZLENBQUMsQ0FBQztJQUNsSSxNQUFNcEIsVUFBVTtRQUNacUIsUUFBUTtRQUNSYixNQUFNRjtJQUNWO0lBQ0EsTUFBTWdCLFVBQVU7UUFDWkMsTUFBTWpCO0lBQ1Y7SUFDQSwrQ0FBK0M7SUFDL0MsSUFBSSxDQUFDLEdBQUc1QyxxQkFBcUI4RCxzQkFBc0IsRUFBRWhDLFVBQVU7UUFDM0RRLFFBQVFVLElBQUksR0FBR2xCLFFBQVFrQixJQUFJO1FBQzNCVixRQUFRVixJQUFJLEdBQUdFLFFBQVFGLElBQUk7SUFDL0IsT0FDSztRQUNEVSxRQUFReUIsVUFBVSxHQUFHakMsUUFBUWdCLElBQUk7SUFDckM7SUFDQSxJQUFJLDZCQUE2QkksZ0JBQWdCO1FBQzdDVSxPQUFPLENBQUMsc0JBQXNCLEdBQzFCLFdBQ0lJLE1BQU1BLENBQUNDLElBQUksQ0FBQ2YsY0FBYyxDQUFDLDBCQUEwQixFQUFFZ0IsUUFBUSxDQUFDO0lBQzVFO0lBQ0E1QixRQUFRc0IsT0FBTyxHQUFHQTtJQUNsQixNQUFNTyxxQkFBcUIsQ0FBQyxHQUFHbkUscUJBQXFCb0UseUJBQXlCLEVBQUV0QztJQUMvRXpCLE1BQU0saUJBQWlCOEQscUJBQXFCLG9CQUFvQjdCLFFBQVFRLElBQUk7SUFDNUUsT0FBTyxJQUFJTSxRQUFRLENBQUNDLFNBQVNnQjtRQUN6QixNQUFNQyxVQUFVekUsS0FBS3lFLE9BQU8sQ0FBQ2hDO1FBQzdCZ0MsUUFBUUMsSUFBSSxDQUFDLFdBQVcsQ0FBQ0MsS0FBS0MsUUFBUUM7WUFDbEMsSUFBSW5DO1lBQ0orQixRQUFRSyxrQkFBa0I7WUFDMUJGLE9BQU9FLGtCQUFrQjtZQUN6QixJQUFJSCxJQUFJSSxVQUFVLEtBQUssS0FBSztnQkFDeEJ2RSxNQUFNLCtCQUNGaUMsUUFBUVEsSUFBSSxHQUNaLG9CQUNBcUI7Z0JBQ0osSUFBSSxtQkFBbUJoQixtQkFBbUI7b0JBQ3RDOzs7c0ZBR2tFLEdBQ2xFLE1BQU0wQixhQUFhLENBQUMsR0FBR2pGLFdBQVdrRixtQkFBbUIsRUFBRXZCO29CQUN2RCxNQUFNWCxXQUFXLENBQUMsR0FBRzNDLGFBQWE0QyxhQUFhLEVBQUVnQztvQkFDakQsTUFBTUUsYUFBYSxDQUFDeEMsS0FBS0ssYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVNJLElBQUksTUFBTSxRQUFRVCxPQUFPLEtBQUssSUFBSUEsS0FBS3NDO29CQUM3SCxNQUFNRyxNQUFNbEYsSUFBSW1GLE9BQU8sQ0FBQzlGLE9BQU8rRixNQUFNLENBQUM7d0JBQUVsQyxNQUFNK0I7d0JBQVlJLFlBQVlKO3dCQUFZTixRQUFRQTtvQkFBTyxHQUFHdEIsb0JBQW9CO3dCQUNwSDlDLE1BQU0sa0RBQ0ZpQyxRQUFRUSxJQUFJLEdBQ1osb0JBQ0FxQjt3QkFDSmQsUUFBUTs0QkFBRW9CLFFBQVFPOzRCQUFLMUIsWUFBWUM7d0JBQWE7b0JBQ3BEO29CQUNBeUIsSUFBSUksRUFBRSxDQUFDLFNBQVMsQ0FBQ0M7d0JBQ2JoRixNQUFNLDZDQUNGaUMsUUFBUVEsSUFBSSxHQUNaLG9CQUNBcUIscUJBQ0EsaUJBQ0FrQixNQUFNQyxPQUFPO3dCQUNqQmpCO29CQUNKO2dCQUNKLE9BQ0s7b0JBQ0RoRSxNQUFNLHdEQUNGaUMsUUFBUVEsSUFBSSxHQUNaLG9CQUNBcUI7b0JBQ0pkLFFBQVE7d0JBQ0pvQjt3QkFDQW5CLFlBQVlDO29CQUNoQjtnQkFDSjtZQUNKLE9BQ0s7Z0JBQ0EsSUFBRzlELFVBQVUyQixHQUFHLEVBQUV6QixZQUFZWSxZQUFZLENBQUNjLEtBQUssRUFBRSwwQkFDL0NpQixRQUFRUSxJQUFJLEdBQ1osb0JBQ0FxQixxQkFDQSxrQkFDQUssSUFBSUksVUFBVTtnQkFDbEJQO1lBQ0o7UUFDSjtRQUNBQyxRQUFRQyxJQUFJLENBQUMsU0FBU2dCLENBQUFBO1lBQ2xCakIsUUFBUUssa0JBQWtCO1lBQ3pCLElBQUdsRixVQUFVMkIsR0FBRyxFQUFFekIsWUFBWVksWUFBWSxDQUFDYyxLQUFLLEVBQUUsZ0NBQy9DOEMscUJBQ0EsaUJBQ0FvQixJQUFJRCxPQUFPO1lBQ2ZqQjtRQUNKO1FBQ0FDLFFBQVFrQixHQUFHO0lBQ2Y7QUFDSjtBQUNBbkcsNEJBQTRCLEdBQUdFLHNCQUMvQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9odHRwX3Byb3h5LmpzPzI4ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UHJveGllZENvbm5lY3Rpb24gPSBleHBvcnRzLm1hcFByb3h5TmFtZSA9IHZvaWQgMDtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHJlc29sdmVyX2Ruc18xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItZG5zXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncHJveHknO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5mdW5jdGlvbiBnZXRQcm94eUluZm8oKSB7XG4gICAgbGV0IHByb3h5RW52ID0gJyc7XG4gICAgbGV0IGVudlZhciA9ICcnO1xuICAgIC8qIFByZWZlciB1c2luZyAnZ3JwY19wcm94eScuIEZhbGxiYWNrIG9uICdodHRwX3Byb3h5JyBpZiBpdCBpcyBub3Qgc2V0LlxuICAgICAqIEFsc28gcHJlZmVyIHVzaW5nICdodHRwc19wcm94eScgd2l0aCBmYWxsYmFjayBvbiAnaHR0cF9wcm94eScuIFRoZVxuICAgICAqIGZhbGxiYWNrIGJlaGF2aW9yIGNhbiBiZSByZW1vdmVkIGlmIHRoZXJlJ3MgYSBkZW1hbmQgZm9yIGl0LlxuICAgICAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5ncnBjX3Byb3h5KSB7XG4gICAgICAgIGVudlZhciA9ICdncnBjX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5ncnBjX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5odHRwc19wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnaHR0cHNfcHJveHknO1xuICAgICAgICBwcm94eUVudiA9IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5odHRwX3Byb3h5KSB7XG4gICAgICAgIGVudlZhciA9ICdodHRwX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5odHRwX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBsZXQgcHJveHlVcmw7XG4gICAgdHJ5IHtcbiAgICAgICAgcHJveHlVcmwgPSBuZXcgdXJsXzEuVVJMKHByb3h5RW52KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYGNhbm5vdCBwYXJzZSB2YWx1ZSBvZiBcIiR7ZW52VmFyfVwiIGVudiB2YXJgKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAocHJveHlVcmwucHJvdG9jb2wgIT09ICdodHRwOicpIHtcbiAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYFwiJHtwcm94eVVybC5wcm90b2NvbH1cIiBzY2hlbWUgbm90IHN1cHBvcnRlZCBpbiBwcm94eSBVUklgKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBsZXQgdXNlckNyZWQgPSBudWxsO1xuICAgIGlmIChwcm94eVVybC51c2VybmFtZSkge1xuICAgICAgICBpZiAocHJveHlVcmwucGFzc3dvcmQpIHtcbiAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTywgJ3VzZXJpbmZvIGZvdW5kIGluIHByb3h5IFVSSScpO1xuICAgICAgICAgICAgdXNlckNyZWQgPSBgJHtwcm94eVVybC51c2VybmFtZX06JHtwcm94eVVybC5wYXNzd29yZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlckNyZWQgPSBwcm94eVVybC51c2VybmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBob3N0bmFtZSA9IHByb3h5VXJsLmhvc3RuYW1lO1xuICAgIGxldCBwb3J0ID0gcHJveHlVcmwucG9ydDtcbiAgICAvKiBUaGUgcHJveHkgVVJMIHVzZXMgdGhlIHNjaGVtZSBcImh0dHA6XCIsIHdoaWNoIGhhcyBhIGRlZmF1bHQgcG9ydCBudW1iZXIgb2ZcbiAgICAgKiA4MC4gV2UgbmVlZCB0byBzZXQgdGhhdCBleHBsaWNpdGx5IGhlcmUgaWYgaXQgaXMgb21pdHRlZCBiZWNhdXNlIG90aGVyd2lzZVxuICAgICAqIGl0IHdpbGwgdXNlIGdSUEMncyBkZWZhdWx0IHBvcnQgNDQzLiAqL1xuICAgIGlmIChwb3J0ID09PSAnJykge1xuICAgICAgICBwb3J0ID0gJzgwJztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBhZGRyZXNzOiBgJHtob3N0bmFtZX06JHtwb3J0fWAsXG4gICAgfTtcbiAgICBpZiAodXNlckNyZWQpIHtcbiAgICAgICAgcmVzdWx0LmNyZWRzID0gdXNlckNyZWQ7XG4gICAgfVxuICAgIHRyYWNlKCdQcm94eSBzZXJ2ZXIgJyArIHJlc3VsdC5hZGRyZXNzICsgJyBzZXQgYnkgZW52aXJvbm1lbnQgdmFyaWFibGUgJyArIGVudlZhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE5vUHJveHlIb3N0TGlzdCgpIHtcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ25vX2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnbm9fcHJveHknIGlmIGl0IGlzIG5vdCBzZXQuICovXG4gICAgbGV0IG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19ncnBjX3Byb3h5O1xuICAgIGxldCBlbnZWYXIgPSAnbm9fZ3JwY19wcm94eSc7XG4gICAgaWYgKCFub1Byb3h5U3RyKSB7XG4gICAgICAgIG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19wcm94eTtcbiAgICAgICAgZW52VmFyID0gJ25vX3Byb3h5JztcbiAgICB9XG4gICAgaWYgKG5vUHJveHlTdHIpIHtcbiAgICAgICAgdHJhY2UoJ05vIHByb3h5IHNlcnZlciBsaXN0IHNldCBieSBlbnZpcm9ubWVudCB2YXJpYWJsZSAnICsgZW52VmFyKTtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlTdHIuc3BsaXQoJywnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBQcm94eU5hbWUodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG5vUHJveHlSZXN1bHQgPSB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBleHRyYU9wdGlvbnM6IHt9LFxuICAgIH07XG4gICAgaWYgKCgoX2EgPSBvcHRpb25zWydncnBjLmVuYWJsZV9odHRwX3Byb3h5J10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnNjaGVtZSA9PT0gJ3VuaXgnKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBwcm94eUluZm8gPSBnZXRQcm94eUluZm8oKTtcbiAgICBpZiAoIXByb3h5SW5mby5hZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0LnBhdGgpO1xuICAgIGlmICghaG9zdFBvcnQpIHtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHNlcnZlckhvc3QgPSBob3N0UG9ydC5ob3N0O1xuICAgIGZvciAoY29uc3QgaG9zdCBvZiBnZXROb1Byb3h5SG9zdExpc3QoKSkge1xuICAgICAgICBpZiAoaG9zdCA9PT0gc2VydmVySG9zdCkge1xuICAgICAgICAgICAgdHJhY2UoJ05vdCB1c2luZyBwcm94eSBmb3IgdGFyZ2V0IGluIG5vX3Byb3h5IGxpc3Q6ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpKTtcbiAgICAgICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhT3B0aW9ucyA9IHtcbiAgICAgICAgJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCc6ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCksXG4gICAgfTtcbiAgICBpZiAocHJveHlJbmZvLmNyZWRzKSB7XG4gICAgICAgIGV4dHJhT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSA9IHByb3h5SW5mby5jcmVkcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICBzY2hlbWU6ICdkbnMnLFxuICAgICAgICAgICAgcGF0aDogcHJveHlJbmZvLmFkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhT3B0aW9uczogZXh0cmFPcHRpb25zLFxuICAgIH07XG59XG5leHBvcnRzLm1hcFByb3h5TmFtZSA9IG1hcFByb3h5TmFtZTtcbmZ1bmN0aW9uIGdldFByb3hpZWRDb25uZWN0aW9uKGFkZHJlc3MsIGNoYW5uZWxPcHRpb25zLCBjb25uZWN0aW9uT3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoISgnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JyBpbiBjaGFubmVsT3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWxUYXJnZXQgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0J107XG4gICAgY29uc3QgcGFyc2VkVGFyZ2V0ID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkocmVhbFRhcmdldCk7XG4gICAgaWYgKHBhcnNlZFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9XG4gICAgY29uc3Qgc3BsaXRIb3N0UG9zdCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkocGFyc2VkVGFyZ2V0LnBhdGgpO1xuICAgIGlmIChzcGxpdEhvc3RQb3N0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgIH1cbiAgICBjb25zdCBob3N0UG9ydCA9IGAke3NwbGl0SG9zdFBvc3QuaG9zdH06JHsoX2EgPSBzcGxpdEhvc3RQb3N0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlc29sdmVyX2Ruc18xLkRFRkFVTFRfUE9SVH1gO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ0NPTk5FQ1QnLFxuICAgICAgICBwYXRoOiBob3N0UG9ydCxcbiAgICB9O1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgIEhvc3Q6IGhvc3RQb3J0LFxuICAgIH07XG4gICAgLy8gQ29ubmVjdCB0byB0aGUgc3ViY2hhbm5lbCBhZGRyZXNzIGFzIGEgcHJveHlcbiAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKGFkZHJlc3MpKSB7XG4gICAgICAgIG9wdGlvbnMuaG9zdCA9IGFkZHJlc3MuaG9zdDtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gYWRkcmVzcy5wb3J0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gYWRkcmVzcy5wYXRoO1xuICAgIH1cbiAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X2NyZWRzJyBpbiBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPVxuICAgICAgICAgICAgJ0Jhc2ljICcgK1xuICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF9jcmVkcyddKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgY29uc3QgcHJveHlBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpO1xuICAgIHRyYWNlKCdVc2luZyBwcm94eSAnICsgcHJveHlBZGRyZXNzU3RyaW5nICsgJyB0byBjb25uZWN0IHRvICcgKyBvcHRpb25zLnBhdGgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3Qub25jZSgnY29ubmVjdCcsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBjb25uZWN0ZWQgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFRoZSBwcm94eSBpcyBjb25uZWN0aW5nIHRvIGEgVExTIHNlcnZlciwgc28gdXBncmFkZSB0aGlzIHNvY2tldFxuICAgICAgICAgICAgICAgICAgICAgKiBjb25uZWN0aW9uIHRvIGEgVExTIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzMyOTIyXG4gICAgICAgICAgICAgICAgICAgICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjLW5vZGUvcHVsbC8xMzY5IGZvciBtb3JlIGluZm8uICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSAoMCwgcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KShwYXJzZWRUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUhvc3QgPSAoX2EgPSBob3N0UG9ydCA9PT0gbnVsbCB8fCBob3N0UG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9zdFBvcnQuaG9zdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGFyZ2V0UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3RzID0gdGxzLmNvbm5lY3QoT2JqZWN0LmFzc2lnbih7IGhvc3Q6IHJlbW90ZUhvc3QsIHNlcnZlcm5hbWU6IHJlbW90ZUhvc3QsIHNvY2tldDogc29ja2V0IH0sIGNvbm5lY3Rpb25PcHRpb25zKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCBhIFRMUyBjb25uZWN0aW9uIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgc29ja2V0OiBjdHMsIHJlYWxUYXJnZXQ6IHBhcnNlZFRhcmdldCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cy5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKCdGYWlsZWQgdG8gZXN0YWJsaXNoIGEgVExTIGNvbm5lY3Rpb24gdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnU3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkIGEgcGxhaW50ZXh0IGNvbm5lY3Rpb24gdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsVGFyZ2V0OiBwYXJzZWRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsICdGYWlsZWQgdG8gY29ubmVjdCB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAnIHdpdGggc3RhdHVzICcgK1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIGNvbm5lY3QgdG8gcHJveHkgJyArXG4gICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRQcm94aWVkQ29ubmVjdGlvbiA9IGdldFByb3hpZWRDb25uZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cF9wcm94eS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRQcm94aWVkQ29ubmVjdGlvbiIsIm1hcFByb3h5TmFtZSIsImxvZ2dpbmdfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsInJlc29sdmVyXzEiLCJodHRwIiwidGxzIiwibG9nZ2luZyIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwidXJpX3BhcnNlcl8xIiwidXJsXzEiLCJyZXNvbHZlcl9kbnNfMSIsIlRSQUNFUl9OQU1FIiwidHJhY2UiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJnZXRQcm94eUluZm8iLCJwcm94eUVudiIsImVudlZhciIsInByb2Nlc3MiLCJlbnYiLCJncnBjX3Byb3h5IiwiaHR0cHNfcHJveHkiLCJodHRwX3Byb3h5IiwicHJveHlVcmwiLCJVUkwiLCJlIiwibG9nIiwiRVJST1IiLCJwcm90b2NvbCIsInVzZXJDcmVkIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIklORk8iLCJob3N0bmFtZSIsInBvcnQiLCJyZXN1bHQiLCJhZGRyZXNzIiwiY3JlZHMiLCJnZXROb1Byb3h5SG9zdExpc3QiLCJub1Byb3h5U3RyIiwibm9fZ3JwY19wcm94eSIsIm5vX3Byb3h5Iiwic3BsaXQiLCJ0YXJnZXQiLCJvcHRpb25zIiwiX2EiLCJub1Byb3h5UmVzdWx0IiwiZXh0cmFPcHRpb25zIiwic2NoZW1lIiwicHJveHlJbmZvIiwiaG9zdFBvcnQiLCJzcGxpdEhvc3RQb3J0IiwicGF0aCIsInNlcnZlckhvc3QiLCJob3N0IiwidXJpVG9TdHJpbmciLCJjaGFubmVsT3B0aW9ucyIsImNvbm5lY3Rpb25PcHRpb25zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWFsVGFyZ2V0IiwicGFyc2VkVGFyZ2V0IiwicGFyc2VVcmkiLCJzcGxpdEhvc3RQb3N0IiwiREVGQVVMVF9QT1JUIiwibWV0aG9kIiwiaGVhZGVycyIsIkhvc3QiLCJpc1RjcFN1YmNoYW5uZWxBZGRyZXNzIiwic29ja2V0UGF0aCIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsInByb3h5QWRkcmVzc1N0cmluZyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJyZWplY3QiLCJyZXF1ZXN0Iiwib25jZSIsInJlcyIsInNvY2tldCIsImhlYWQiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJzdGF0dXNDb2RlIiwidGFyZ2V0UGF0aCIsImdldERlZmF1bHRBdXRob3JpdHkiLCJyZW1vdGVIb3N0IiwiY3RzIiwiY29ubmVjdCIsImFzc2lnbiIsInNlcnZlcm5hbWUiLCJvbiIsImVycm9yIiwibWVzc2FnZSIsImVyciIsImVuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.experimental = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nObject.defineProperty(exports, \"CallCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return call_credentials_1.CallCredentials;\n    }\n}));\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nObject.defineProperty(exports, \"Channel\", ({\n    enumerable: true,\n    get: function() {\n        return channel_1.ChannelImplementation;\n    }\n}));\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nObject.defineProperty(exports, \"compressionAlgorithms\", ({\n    enumerable: true,\n    get: function() {\n        return compression_algorithms_1.CompressionAlgorithms;\n    }\n}));\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nObject.defineProperty(exports, \"connectivityState\", ({\n    enumerable: true,\n    get: function() {\n        return connectivity_state_1.ConnectivityState;\n    }\n}));\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nObject.defineProperty(exports, \"ChannelCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return channel_credentials_1.ChannelCredentials;\n    }\n}));\nconst client_1 = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\");\nObject.defineProperty(exports, \"Client\", ({\n    enumerable: true,\n    get: function() {\n        return client_1.Client;\n    }\n}));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nObject.defineProperty(exports, \"logVerbosity\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.LogVerbosity;\n    }\n}));\nObject.defineProperty(exports, \"status\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.Status;\n    }\n}));\nObject.defineProperty(exports, \"propagate\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.Propagate;\n    }\n}));\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nObject.defineProperty(exports, \"loadPackageDefinition\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.loadPackageDefinition;\n    }\n}));\nObject.defineProperty(exports, \"makeClientConstructor\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.makeClientConstructor;\n    }\n}));\nObject.defineProperty(exports, \"makeGenericClientConstructor\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.makeClientConstructor;\n    }\n}));\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nObject.defineProperty(exports, \"Metadata\", ({\n    enumerable: true,\n    get: function() {\n        return metadata_1.Metadata;\n    }\n}));\nconst server_1 = __webpack_require__(/*! ./server */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js\");\nObject.defineProperty(exports, \"Server\", ({\n    enumerable: true,\n    get: function() {\n        return server_1.Server;\n    }\n}));\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nObject.defineProperty(exports, \"ServerCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return server_credentials_1.ServerCredentials;\n    }\n}));\nconst status_builder_1 = __webpack_require__(/*! ./status-builder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\");\nObject.defineProperty(exports, \"StatusBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return status_builder_1.StatusBuilder;\n    }\n}));\n/**** Client Credentials ****/ // Using assign only copies enumerable properties, which is what we want\nexports.credentials = {\n    /**\n     * Combine a ChannelCredentials with any number of CallCredentials into a\n     * single ChannelCredentials object.\n     * @param channelCredentials The ChannelCredentials object.\n     * @param callCredentials Any number of CallCredentials objects.\n     * @return The resulting ChannelCredentials object.\n     */ combineChannelCredentials: (channelCredentials, ...callCredentials)=>{\n        return callCredentials.reduce((acc, other)=>acc.compose(other), channelCredentials);\n    },\n    /**\n     * Combine any number of CallCredentials into a single CallCredentials\n     * object.\n     * @param first The first CallCredentials object.\n     * @param additional Any number of additional CallCredentials objects.\n     * @return The resulting CallCredentials object.\n     */ combineCallCredentials: (first, ...additional)=>{\n        return additional.reduce((acc, other)=>acc.compose(other), first);\n    },\n    // from channel-credentials.ts\n    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,\n    createSsl: channel_credentials_1.ChannelCredentials.createSsl,\n    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,\n    // from call-credentials.ts\n    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,\n    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,\n    createEmpty: call_credentials_1.CallCredentials.createEmpty\n};\n/**\n * Close a Client object.\n * @param client The client to close.\n */ const closeClient = (client)=>client.close();\nexports.closeClient = closeClient;\nconst waitForClientReady = (client, deadline, callback)=>client.waitForReady(deadline, callback);\nexports.waitForClientReady = waitForClientReady;\n/* eslint-enable @typescript-eslint/no-explicit-any */ /**** Unimplemented function stubs ****/ /* eslint-disable @typescript-eslint/no-explicit-any */ const loadObject = (value, options)=>{\n    throw new Error(\"Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead\");\n};\nexports.loadObject = loadObject;\nconst load = (filename, format, options)=>{\n    throw new Error(\"Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead\");\n};\nexports.load = load;\nconst setLogger = (logger)=>{\n    logging.setLogger(logger);\n};\nexports.setLogger = setLogger;\nconst setLogVerbosity = (verbosity)=>{\n    logging.setLoggerVerbosity(verbosity);\n};\nexports.setLogVerbosity = setLogVerbosity;\nconst getClientChannel = (client)=>{\n    return client_1.Client.prototype.getChannel.call(client);\n};\nexports.getClientChannel = getClientChannel;\nvar client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nObject.defineProperty(exports, \"ListenerBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.ListenerBuilder;\n    }\n}));\nObject.defineProperty(exports, \"RequesterBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.RequesterBuilder;\n    }\n}));\nObject.defineProperty(exports, \"InterceptingCall\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.InterceptingCall;\n    }\n}));\nObject.defineProperty(exports, \"InterceptorConfigurationError\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.InterceptorConfigurationError;\n    }\n}));\nvar channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nObject.defineProperty(exports, \"getChannelzServiceDefinition\", ({\n    enumerable: true,\n    get: function() {\n        return channelz_1.getChannelzServiceDefinition;\n    }\n}));\nObject.defineProperty(exports, \"getChannelzHandlers\", ({\n    enumerable: true,\n    get: function() {\n        return channelz_1.getChannelzHandlers;\n    }\n}));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"addAdminServicesToServer\", ({\n    enumerable: true,\n    get: function() {\n        return admin_1.addAdminServicesToServer;\n    }\n}));\nconst experimental = __webpack_require__(/*! ./experimental */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nexports.experimental = experimental;\nconst resolver_dns = __webpack_require__(/*! ./resolver-dns */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst resolver_uds = __webpack_require__(/*! ./resolver-uds */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\");\nconst resolver_ip = __webpack_require__(/*! ./resolver-ip */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\");\nconst load_balancer_pick_first = __webpack_require__(/*! ./load-balancer-pick-first */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst load_balancer_round_robin = __webpack_require__(/*! ./load-balancer-round-robin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\");\nconst load_balancer_outlier_detection = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nconst channelz = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\n(()=>{\n    resolver_dns.setup();\n    resolver_uds.setup();\n    resolver_ip.setup();\n    load_balancer_pick_first.setup();\n    load_balancer_round_robin.setup();\n    load_balancer_outlier_detection.setup();\n    channelz.setup();\n})(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSxnQ0FBZ0MsR0FBR0EsMkJBQTJCLEdBQUdBLG9DQUFvQyxHQUFHQSxxQ0FBcUMsR0FBR0Esd0JBQXdCLEdBQUdBLHdCQUF3QixHQUFHQSx1QkFBdUIsR0FBR0EscUJBQXFCLEdBQUdBLHdCQUF3QixHQUFHQSx5QkFBeUIsR0FBR0EsY0FBYyxHQUFHQSx1QkFBdUIsR0FBR0EsaUJBQWlCLEdBQUdBLFlBQVksR0FBR0Esa0JBQWtCLEdBQUdBLHVCQUF1QixHQUFHQSwwQkFBMEIsR0FBR0EsMEJBQTBCLEdBQUdBLG1CQUFtQixHQUFHQSxlQUFlLEdBQUdBLG9DQUFvQyxHQUFHQSw2QkFBNkIsR0FBR0EsNkJBQTZCLEdBQUdBLGNBQWMsR0FBR0EsNkJBQTZCLEdBQUdBLGlCQUFpQixHQUFHQSx5QkFBeUIsR0FBR0EsY0FBYyxHQUFHQSxvQkFBb0IsR0FBR0EsZ0JBQWdCLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDbjBCLE1BQU1rQyxxQkFBcUJDLG1CQUFPQSxDQUFDLDRGQUFvQjtBQUN2RHJDLG1EQUFrRDtJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsbUJBQW1CaEIsZUFBZTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hJLE1BQU1vQixZQUFZSCxtQkFBT0EsQ0FBQywwRUFBVztBQUNyQ3JDLDJDQUEwQztJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsVUFBVUMscUJBQXFCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0gsTUFBTUMsMkJBQTJCTCxtQkFBT0EsQ0FBQyx3R0FBMEI7QUFDbkVyQyx5REFBd0Q7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9HLHlCQUF5QkMscUJBQXFCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDMUosTUFBTUMsdUJBQXVCUCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0RyQyxxREFBb0Q7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9LLHFCQUFxQkMsaUJBQWlCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUksTUFBTUMsd0JBQXdCVCxtQkFBT0EsQ0FBQyxrR0FBdUI7QUFDN0RyQyxzREFBcUQ7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9PLHNCQUFzQnpCLGtCQUFrQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2pKLE1BQU0wQixXQUFXVixtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQ3JDLDBDQUF5QztJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT1EsU0FBU25CLE1BQU07SUFBRTtBQUFFLENBQUMsRUFBQztBQUM1RyxNQUFNb0IsY0FBY1gsbUJBQU9BLENBQUMsOEVBQWE7QUFDekNyQyxnREFBK0M7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9TLFlBQVlDLFlBQVk7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzSGpELDBDQUF5QztJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT1MsWUFBWUUsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9HbEQsNkNBQTRDO0lBQUVzQyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPUyxZQUFZRyxTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDckgsTUFBTUMsVUFBVWYsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTWdCLGdCQUFnQmhCLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDckMseURBQXdEO0lBQUVzQyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPYyxjQUFjMUIscUJBQXFCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0kzQix5REFBd0Q7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9jLGNBQWMzQixxQkFBcUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMvSTFCLGdFQUErRDtJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2MsY0FBYzNCLHFCQUFxQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3RKLE1BQU00QixhQUFhakIsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkNyQyw0Q0FBMkM7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9lLFdBQVdwQixRQUFRO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEgsTUFBTXFCLFdBQVdsQixtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQ3JDLDBDQUF5QztJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2dCLFNBQVN4QyxNQUFNO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDNUcsTUFBTXlDLHVCQUF1Qm5CLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRHJDLHFEQUFvRDtJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2lCLHFCQUFxQjFDLGlCQUFpQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzlJLE1BQU0yQyxtQkFBbUJwQixtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDbkRyQyxpREFBZ0Q7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9rQixpQkFBaUI3QyxhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEksNEJBQTRCLEdBQzVCLHdFQUF3RTtBQUN4RVYsbUJBQW1CLEdBQUc7SUFDbEI7Ozs7OztLQU1DLEdBQ0R3RCwyQkFBMkIsQ0FBQ0Msb0JBQW9CLEdBQUdDO1FBQy9DLE9BQU9BLGdCQUFnQkMsTUFBTSxDQUFDLENBQUNDLEtBQUtDLFFBQVVELElBQUlFLE9BQU8sQ0FBQ0QsUUFBUUo7SUFDdEU7SUFDQTs7Ozs7O0tBTUMsR0FDRE0sd0JBQXdCLENBQUNDLE9BQU8sR0FBR0M7UUFDL0IsT0FBT0EsV0FBV04sTUFBTSxDQUFDLENBQUNDLEtBQUtDLFFBQVVELElBQUlFLE9BQU8sQ0FBQ0QsUUFBUUc7SUFDakU7SUFDQSw4QkFBOEI7SUFDOUJFLGdCQUFnQnRCLHNCQUFzQnpCLGtCQUFrQixDQUFDK0MsY0FBYztJQUN2RUMsV0FBV3ZCLHNCQUFzQnpCLGtCQUFrQixDQUFDZ0QsU0FBUztJQUM3REMseUJBQXlCeEIsc0JBQXNCekIsa0JBQWtCLENBQUNpRCx1QkFBdUI7SUFDekYsMkJBQTJCO0lBQzNCQyw2QkFBNkJuQyxtQkFBbUJoQixlQUFlLENBQUNtRCwyQkFBMkI7SUFDM0ZDLDRCQUE0QnBDLG1CQUFtQmhCLGVBQWUsQ0FBQ29ELDBCQUEwQjtJQUN6RkMsYUFBYXJDLG1CQUFtQmhCLGVBQWUsQ0FBQ3FELFdBQVc7QUFDL0Q7QUFDQTs7O0NBR0MsR0FDRCxNQUFNbEQsY0FBYyxDQUFDbUQsU0FBV0EsT0FBT0MsS0FBSztBQUM1Q3pFLG1CQUFtQixHQUFHcUI7QUFDdEIsTUFBTUQscUJBQXFCLENBQUNvRCxRQUFRRSxVQUFVQyxXQUFhSCxPQUFPSSxZQUFZLENBQUNGLFVBQVVDO0FBQ3pGM0UsMEJBQTBCLEdBQUdvQjtBQUM3QixvREFBb0QsR0FDcEQsc0NBQXNDLEdBQ3RDLHFEQUFxRCxHQUNyRCxNQUFNSCxhQUFhLENBQUNoQixPQUFPNEU7SUFDdkIsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCO0FBQ0E5RSxrQkFBa0IsR0FBR2lCO0FBQ3JCLE1BQU1ELE9BQU8sQ0FBQytELFVBQVVDLFFBQVFIO0lBQzVCLE1BQU0sSUFBSUMsTUFBTTtBQUNwQjtBQUNBOUUsWUFBWSxHQUFHZ0I7QUFDZixNQUFNRCxZQUFZLENBQUNrRTtJQUNmL0IsUUFBUW5DLFNBQVMsQ0FBQ2tFO0FBQ3RCO0FBQ0FqRixpQkFBaUIsR0FBR2U7QUFDcEIsTUFBTUQsa0JBQWtCLENBQUNvRTtJQUNyQmhDLFFBQVFpQyxrQkFBa0IsQ0FBQ0Q7QUFDL0I7QUFDQWxGLHVCQUF1QixHQUFHYztBQUMxQixNQUFNSCxtQkFBbUIsQ0FBQzZEO0lBQ3RCLE9BQU8zQixTQUFTbkIsTUFBTSxDQUFDMEQsU0FBUyxDQUFDQyxVQUFVLENBQUNDLElBQUksQ0FBQ2Q7QUFDckQ7QUFDQXhFLHdCQUF3QixHQUFHVztBQUMzQixJQUFJNEUsd0JBQXdCcEQsbUJBQU9BLENBQUMsa0dBQXVCO0FBQzNEckMsbURBQWtEO0lBQUVzQyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPa0Qsc0JBQXNCOUUsZUFBZTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzNJWCxvREFBbUQ7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9rRCxzQkFBc0IvRSxnQkFBZ0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM3SVYsb0RBQW1EO0lBQUVzQyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPa0Qsc0JBQXNCaEYsZ0JBQWdCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0lULGlFQUFnRTtJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2tELHNCQUFzQmpGLDZCQUE2QjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3ZLLElBQUlrRixhQUFhckQsbUJBQU9BLENBQUMsNEVBQVk7QUFDckNyQyxnRUFBK0Q7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9tRCxXQUFXbkYsNEJBQTRCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDMUpQLHVEQUFzRDtJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT21ELFdBQVdwRixtQkFBbUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN4SSxJQUFJcUYsVUFBVXRELG1CQUFPQSxDQUFDLHNFQUFTO0FBQy9CckMsNERBQTJEO0lBQUVzQyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0QsUUFBUXRGLHdCQUF3QjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9JLE1BQU1ELGVBQWVpQyxtQkFBT0EsQ0FBQyxvRkFBZ0I7QUFDN0NuQyxvQkFBb0IsR0FBR0U7QUFDdkIsTUFBTXdGLGVBQWV2RCxtQkFBT0EsQ0FBQyxvRkFBZ0I7QUFDN0MsTUFBTXdELGVBQWV4RCxtQkFBT0EsQ0FBQyxvRkFBZ0I7QUFDN0MsTUFBTXlELGNBQWN6RCxtQkFBT0EsQ0FBQyxrRkFBZTtBQUMzQyxNQUFNMEQsMkJBQTJCMUQsbUJBQU9BLENBQUMsNEdBQTRCO0FBQ3JFLE1BQU0yRCw0QkFBNEIzRCxtQkFBT0EsQ0FBQyw4R0FBNkI7QUFDdkUsTUFBTTRELGtDQUFrQzVELG1CQUFPQSxDQUFDLDBIQUFtQztBQUNuRixNQUFNNkQsV0FBVzdELG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3BDO0lBQ0d1RCxhQUFhTyxLQUFLO0lBQ2xCTixhQUFhTSxLQUFLO0lBQ2xCTCxZQUFZSyxLQUFLO0lBQ2pCSix5QkFBeUJJLEtBQUs7SUFDOUJILDBCQUEwQkcsS0FBSztJQUMvQkYsZ0NBQWdDRSxLQUFLO0lBQ3JDRCxTQUFTQyxLQUFLO0FBQ2xCLE1BQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanM/Mzk1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHBlcmltZW50YWwgPSBleHBvcnRzLmFkZEFkbWluU2VydmljZXNUb1NlcnZlciA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpIYW5kbGVycyA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGV4cG9ydHMuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgPSBleHBvcnRzLkludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBleHBvcnRzLkxpc3RlbmVyQnVpbGRlciA9IGV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IGV4cG9ydHMuZ2V0Q2xpZW50Q2hhbm5lbCA9IGV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSBleHBvcnRzLlNlcnZlciA9IGV4cG9ydHMuc2V0TG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5zZXRMb2dnZXIgPSBleHBvcnRzLmxvYWQgPSBleHBvcnRzLmxvYWRPYmplY3QgPSBleHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IGV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gZXhwb3J0cy53YWl0Rm9yQ2xpZW50UmVhZHkgPSBleHBvcnRzLmNsb3NlQ2xpZW50ID0gZXhwb3J0cy5DaGFubmVsID0gZXhwb3J0cy5tYWtlR2VuZXJpY0NsaWVudENvbnN0cnVjdG9yID0gZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSBleHBvcnRzLmxvYWRQYWNrYWdlRGVmaW5pdGlvbiA9IGV4cG9ydHMuQ2xpZW50ID0gZXhwb3J0cy5jb21wcmVzc2lvbkFsZ29yaXRobXMgPSBleHBvcnRzLnByb3BhZ2F0ZSA9IGV4cG9ydHMuY29ubmVjdGl2aXR5U3RhdGUgPSBleHBvcnRzLnN0YXR1cyA9IGV4cG9ydHMubG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5NZXRhZGF0YSA9IGV4cG9ydHMuY3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbENyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzOyB9IH0pO1xuY29uc3QgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoYW5uZWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWxfMS5DaGFubmVsSW1wbGVtZW50YXRpb247IH0gfSk7XG5jb25zdCBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbi1hbGdvcml0aG1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHJlc3Npb25BbGdvcml0aG1zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zOyB9IH0pO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25uZWN0aXZpdHlTdGF0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGU7IH0gfSk7XG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hhbm5lbENyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzOyB9IH0pO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF8xLkNsaWVudDsgfSB9KTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9nVmVyYm9zaXR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdGF0dXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLlN0YXR1czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByb3BhZ2F0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuUHJvcGFnYXRlOyB9IH0pO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBtYWtlX2NsaWVudF8xID0gcmVxdWlyZShcIi4vbWFrZS1jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2FkUGFja2FnZURlZmluaXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubG9hZFBhY2thZ2VEZWZpbml0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZUNsaWVudENvbnN0cnVjdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWtlX2NsaWVudF8xLm1ha2VDbGllbnRDb25zdHJ1Y3RvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VHZW5lcmljQ2xpZW50Q29uc3RydWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubWFrZUNsaWVudENvbnN0cnVjdG9yOyB9IH0pO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWV0YWRhdGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ldGFkYXRhXzEuTWV0YWRhdGE7IH0gfSk7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyXzEuU2VydmVyOyB9IH0pO1xuY29uc3Qgc2VydmVyX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItY3JlZGVudGlhbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyX2NyZWRlbnRpYWxzXzEuU2VydmVyQ3JlZGVudGlhbHM7IH0gfSk7XG5jb25zdCBzdGF0dXNfYnVpbGRlcl8xID0gcmVxdWlyZShcIi4vc3RhdHVzLWJ1aWxkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdGF0dXNCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0dXNfYnVpbGRlcl8xLlN0YXR1c0J1aWxkZXI7IH0gfSk7XG4vKioqKiBDbGllbnQgQ3JlZGVudGlhbHMgKioqKi9cbi8vIFVzaW5nIGFzc2lnbiBvbmx5IGNvcGllcyBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIHdoaWNoIGlzIHdoYXQgd2Ugd2FudFxuZXhwb3J0cy5jcmVkZW50aWFscyA9IHtcbiAgICAvKipcbiAgICAgKiBDb21iaW5lIGEgQ2hhbm5lbENyZWRlbnRpYWxzIHdpdGggYW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgaW50byBhXG4gICAgICogc2luZ2xlIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICogQHBhcmFtIGNoYW5uZWxDcmVkZW50aWFscyBUaGUgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY2FsbENyZWRlbnRpYWxzIEFueSBudW1iZXIgb2YgQ2FsbENyZWRlbnRpYWxzIG9iamVjdHMuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgY29tYmluZUNoYW5uZWxDcmVkZW50aWFsczogKGNoYW5uZWxDcmVkZW50aWFscywgLi4uY2FsbENyZWRlbnRpYWxzKSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxsQ3JlZGVudGlhbHMucmVkdWNlKChhY2MsIG90aGVyKSA9PiBhY2MuY29tcG9zZShvdGhlciksIGNoYW5uZWxDcmVkZW50aWFscyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDb21iaW5lIGFueSBudW1iZXIgb2YgQ2FsbENyZWRlbnRpYWxzIGludG8gYSBzaW5nbGUgQ2FsbENyZWRlbnRpYWxzXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgQ2FsbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbCBBbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgQ2FsbENyZWRlbnRpYWxzIG9iamVjdHMuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENhbGxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgY29tYmluZUNhbGxDcmVkZW50aWFsczogKGZpcnN0LCAuLi5hZGRpdGlvbmFsKSA9PiB7XG4gICAgICAgIHJldHVybiBhZGRpdGlvbmFsLnJlZHVjZSgoYWNjLCBvdGhlcikgPT4gYWNjLmNvbXBvc2Uob3RoZXIpLCBmaXJzdCk7XG4gICAgfSxcbiAgICAvLyBmcm9tIGNoYW5uZWwtY3JlZGVudGlhbHMudHNcbiAgICBjcmVhdGVJbnNlY3VyZTogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVJbnNlY3VyZSxcbiAgICBjcmVhdGVTc2w6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlU3NsLFxuICAgIGNyZWF0ZUZyb21TZWN1cmVDb250ZXh0OiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21TZWN1cmVDb250ZXh0LFxuICAgIC8vIGZyb20gY2FsbC1jcmVkZW50aWFscy50c1xuICAgIGNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcjogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IsXG4gICAgY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWw6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWwsXG4gICAgY3JlYXRlRW1wdHk6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRW1wdHksXG59O1xuLyoqXG4gKiBDbG9zZSBhIENsaWVudCBvYmplY3QuXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBjbGllbnQgdG8gY2xvc2UuXG4gKi9cbmNvbnN0IGNsb3NlQ2xpZW50ID0gKGNsaWVudCkgPT4gY2xpZW50LmNsb3NlKCk7XG5leHBvcnRzLmNsb3NlQ2xpZW50ID0gY2xvc2VDbGllbnQ7XG5jb25zdCB3YWl0Rm9yQ2xpZW50UmVhZHkgPSAoY2xpZW50LCBkZWFkbGluZSwgY2FsbGJhY2spID0+IGNsaWVudC53YWl0Rm9yUmVhZHkoZGVhZGxpbmUsIGNhbGxiYWNrKTtcbmV4cG9ydHMud2FpdEZvckNsaWVudFJlYWR5ID0gd2FpdEZvckNsaWVudFJlYWR5O1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKioqKiBVbmltcGxlbWVudGVkIGZ1bmN0aW9uIHN0dWJzICoqKiovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBsb2FkT2JqZWN0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXZhaWxhYmxlIGluIHRoaXMgbGlicmFyeS4gVXNlIEBncnBjL3Byb3RvLWxvYWRlciBhbmQgbG9hZFBhY2thZ2VEZWZpbml0aW9uIGluc3RlYWQnKTtcbn07XG5leHBvcnRzLmxvYWRPYmplY3QgPSBsb2FkT2JqZWN0O1xuY29uc3QgbG9hZCA9IChmaWxlbmFtZSwgZm9ybWF0LCBvcHRpb25zKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXZhaWxhYmxlIGluIHRoaXMgbGlicmFyeS4gVXNlIEBncnBjL3Byb3RvLWxvYWRlciBhbmQgbG9hZFBhY2thZ2VEZWZpbml0aW9uIGluc3RlYWQnKTtcbn07XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuY29uc3Qgc2V0TG9nZ2VyID0gKGxvZ2dlcikgPT4ge1xuICAgIGxvZ2dpbmcuc2V0TG9nZ2VyKGxvZ2dlcik7XG59O1xuZXhwb3J0cy5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XG5jb25zdCBzZXRMb2dWZXJib3NpdHkgPSAodmVyYm9zaXR5KSA9PiB7XG4gICAgbG9nZ2luZy5zZXRMb2dnZXJWZXJib3NpdHkodmVyYm9zaXR5KTtcbn07XG5leHBvcnRzLnNldExvZ1ZlcmJvc2l0eSA9IHNldExvZ1ZlcmJvc2l0eTtcbmNvbnN0IGdldENsaWVudENoYW5uZWwgPSAoY2xpZW50KSA9PiB7XG4gICAgcmV0dXJuIGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUuZ2V0Q2hhbm5lbC5jYWxsKGNsaWVudCk7XG59O1xuZXhwb3J0cy5nZXRDbGllbnRDaGFubmVsID0gZ2V0Q2xpZW50Q2hhbm5lbDtcbnZhciBjbGllbnRfaW50ZXJjZXB0b3JzXzEgPSByZXF1aXJlKFwiLi9jbGllbnQtaW50ZXJjZXB0b3JzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlzdGVuZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuTGlzdGVuZXJCdWlsZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdGVyQnVpbGRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50X2ludGVyY2VwdG9yc18xLlJlcXVlc3RlckJ1aWxkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcmNlcHRpbmdDYWxsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuSW50ZXJjZXB0aW5nQ2FsbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3I7IH0gfSk7XG52YXIgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbHpfMS5nZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q2hhbm5lbHpIYW5kbGVyc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbHpfMS5nZXRDaGFubmVsekhhbmRsZXJzOyB9IH0pO1xudmFyIGFkbWluXzEgPSByZXF1aXJlKFwiLi9hZG1pblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZEFkbWluU2VydmljZXNUb1NlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRtaW5fMS5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXI7IH0gfSk7XG5jb25zdCBleHBlcmltZW50YWwgPSByZXF1aXJlKFwiLi9leHBlcmltZW50YWxcIik7XG5leHBvcnRzLmV4cGVyaW1lbnRhbCA9IGV4cGVyaW1lbnRhbDtcbmNvbnN0IHJlc29sdmVyX2RucyA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyLWRuc1wiKTtcbmNvbnN0IHJlc29sdmVyX3VkcyA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyLXVkc1wiKTtcbmNvbnN0IHJlc29sdmVyX2lwID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItaXBcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3QgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3RcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX3JvdW5kX3JvYmluID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1yb3VuZC1yb2JpblwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb24gPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uXCIpO1xuY29uc3QgY2hhbm5lbHogPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbigoKSA9PiB7XG4gICAgcmVzb2x2ZXJfZG5zLnNldHVwKCk7XG4gICAgcmVzb2x2ZXJfdWRzLnNldHVwKCk7XG4gICAgcmVzb2x2ZXJfaXAuc2V0dXAoKTtcbiAgICBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3Quc2V0dXAoKTtcbiAgICBsb2FkX2JhbGFuY2VyX3JvdW5kX3JvYmluLnNldHVwKCk7XG4gICAgbG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbi5zZXR1cCgpO1xuICAgIGNoYW5uZWx6LnNldHVwKCk7XG59KSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZXhwZXJpbWVudGFsIiwiYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyIiwiZ2V0Q2hhbm5lbHpIYW5kbGVycyIsImdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24iLCJJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciIsIkludGVyY2VwdGluZ0NhbGwiLCJSZXF1ZXN0ZXJCdWlsZGVyIiwiTGlzdGVuZXJCdWlsZGVyIiwiU3RhdHVzQnVpbGRlciIsImdldENsaWVudENoYW5uZWwiLCJTZXJ2ZXJDcmVkZW50aWFscyIsIlNlcnZlciIsInNldExvZ1ZlcmJvc2l0eSIsInNldExvZ2dlciIsImxvYWQiLCJsb2FkT2JqZWN0IiwiQ2FsbENyZWRlbnRpYWxzIiwiQ2hhbm5lbENyZWRlbnRpYWxzIiwid2FpdEZvckNsaWVudFJlYWR5IiwiY2xvc2VDbGllbnQiLCJDaGFubmVsIiwibWFrZUdlbmVyaWNDbGllbnRDb25zdHJ1Y3RvciIsIm1ha2VDbGllbnRDb25zdHJ1Y3RvciIsImxvYWRQYWNrYWdlRGVmaW5pdGlvbiIsIkNsaWVudCIsImNvbXByZXNzaW9uQWxnb3JpdGhtcyIsInByb3BhZ2F0ZSIsImNvbm5lY3Rpdml0eVN0YXRlIiwic3RhdHVzIiwibG9nVmVyYm9zaXR5IiwiTWV0YWRhdGEiLCJjcmVkZW50aWFscyIsImNhbGxfY3JlZGVudGlhbHNfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY2hhbm5lbF8xIiwiQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY29tcHJlc3Npb25fYWxnb3JpdGhtc18xIiwiQ29tcHJlc3Npb25BbGdvcml0aG1zIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJDb25uZWN0aXZpdHlTdGF0ZSIsImNoYW5uZWxfY3JlZGVudGlhbHNfMSIsImNsaWVudF8xIiwiY29uc3RhbnRzXzEiLCJMb2dWZXJib3NpdHkiLCJTdGF0dXMiLCJQcm9wYWdhdGUiLCJsb2dnaW5nIiwibWFrZV9jbGllbnRfMSIsIm1ldGFkYXRhXzEiLCJzZXJ2ZXJfMSIsInNlcnZlcl9jcmVkZW50aWFsc18xIiwic3RhdHVzX2J1aWxkZXJfMSIsImNvbWJpbmVDaGFubmVsQ3JlZGVudGlhbHMiLCJjaGFubmVsQ3JlZGVudGlhbHMiLCJjYWxsQ3JlZGVudGlhbHMiLCJyZWR1Y2UiLCJhY2MiLCJvdGhlciIsImNvbXBvc2UiLCJjb21iaW5lQ2FsbENyZWRlbnRpYWxzIiwiZmlyc3QiLCJhZGRpdGlvbmFsIiwiY3JlYXRlSW5zZWN1cmUiLCJjcmVhdGVTc2wiLCJjcmVhdGVGcm9tU2VjdXJlQ29udGV4dCIsImNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvciIsImNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsIiwiY3JlYXRlRW1wdHkiLCJjbGllbnQiLCJjbG9zZSIsImRlYWRsaW5lIiwiY2FsbGJhY2siLCJ3YWl0Rm9yUmVhZHkiLCJvcHRpb25zIiwiRXJyb3IiLCJmaWxlbmFtZSIsImZvcm1hdCIsImxvZ2dlciIsInZlcmJvc2l0eSIsInNldExvZ2dlclZlcmJvc2l0eSIsInByb3RvdHlwZSIsImdldENoYW5uZWwiLCJjYWxsIiwiY2xpZW50X2ludGVyY2VwdG9yc18xIiwiY2hhbm5lbHpfMSIsImFkbWluXzEiLCJyZXNvbHZlcl9kbnMiLCJyZXNvbHZlcl91ZHMiLCJyZXNvbHZlcl9pcCIsImxvYWRfYmFsYW5jZXJfcGlja19maXJzdCIsImxvYWRfYmFsYW5jZXJfcm91bmRfcm9iaW4iLCJsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uIiwiY2hhbm5lbHoiLCJzZXR1cCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/internal-channel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InternalChannel = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst resolving_load_balancer_1 = __webpack_require__(/*! ./resolving-load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\");\nconst subchannel_pool_1 = __webpack_require__(/*! ./subchannel-pool */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst max_message_size_filter_1 = __webpack_require__(/*! ./max-message-size-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst load_balancing_call_1 = __webpack_require__(/*! ./load-balancing-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst resolving_call_1 = __webpack_require__(/*! ./resolving-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst retrying_call_1 = __webpack_require__(/*! ./retrying-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */ const MAX_TIMEOUT_TIME = 2147483647;\nconst MIN_IDLE_TIMEOUT_MS = 1000;\n// 30 minutes\nconst DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;\nconst RETRY_THROTTLER_MAP = new Map();\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\nclass ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, channel){\n        super(childSubchannel);\n        this.channel = channel;\n        this.refCount = 0;\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime)=>{\n            channel.throttleKeepalive(keepaliveTime);\n        };\n        childSubchannel.addConnectivityStateListener(this.subchannelStateListener);\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            this.child.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channel.removeWrappedSubchannel(this);\n        }\n    }\n}\nclass InternalChannel {\n    constructor(target, credentials, options){\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */ this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        this.configSelector = null;\n        /**\n         * This is the error from the name resolver if it failed most recently. It\n         * is only used to end calls that start while there is no config selector\n         * and the name resolver is in backoff, so it should be nulled if\n         * configSelector becomes set or the channel state becomes anything other\n         * than TRANSIENT_FAILURE.\n         */ this.currentResolutionError = null;\n        this.wrappedSubchannels = new Set();\n        this.callCount = 0;\n        this.idleTimer = null;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        if (typeof target !== \"string\") {\n            throw new TypeError(\"Channel target must be a string\");\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError(\"Channel credentials must be a ChannelCredentials object\");\n        }\n        if (options) {\n            if (typeof options !== \"object\") {\n                throw new TypeError(\"Channel options must be an object\");\n            }\n        }\n        this.originalTarget = target;\n        const originalTargetUri = (0, uri_parser_1.parseUri)(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */ const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        this.callRefTimer = setInterval(()=>{}, MAX_TIMEOUT_TIME);\n        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (this.options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Channel created\");\n        }\n        if (this.options[\"grpc.default_authority\"]) {\n            this.defaultAuthority = this.options[\"grpc.default_authority\"];\n        } else {\n            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);\n        }\n        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */ this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c = options[\"grpc.use_local_subchannel_pool\"]) !== null && _c !== void 0 ? _c : 0) === 0);\n        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options[\"grpc.retry_buffer_size\"]) !== null && _d !== void 0 ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options[\"grpc.per_rpc_retry_buffer_size\"]) !== null && _e !== void 0 ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);\n        this.keepaliveTime = (_f = options[\"grpc.keepalive_time_ms\"]) !== null && _f !== void 0 ? _f : -1;\n        this.idleTimeoutMs = Math.max((_g = options[\"grpc.client_idle_timeout_ms\"]) !== null && _g !== void 0 ? _g : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs)=>{\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n                subchannel.throttleKeepalive(this.keepaliveTime);\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace(\"CT_INFO\", \"Created subchannel or used existing subchannel\", subchannel.getChannelzRef());\n                }\n                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);\n                this.wrappedSubchannels.add(wrappedSubchannel);\n                return wrappedSubchannel;\n            },\n            updateState: (connectivityState, picker)=>{\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                this.callRefTimerUnref();\n                for (const call of queueCopy){\n                    call.doPick();\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: ()=>{\n                // This should never be called.\n                throw new Error(\"Resolving load balancer should never call requestReresolution\");\n            },\n            addChannelzChild: (child)=>{\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(child);\n                }\n            },\n            removeChannelzChild: (child)=>{\n                if (this.channelzEnabled) {\n                    this.childrenTracker.unrefChild(child);\n                }\n            }\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector)=>{\n            if (serviceConfig.retryThrottling) {\n                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));\n            } else {\n                RETRY_THROTTLER_MAP.delete(this.getTarget());\n            }\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Address resolution succeeded\");\n            }\n            this.configSelector = configSelector;\n            this.currentResolutionError = null;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */ process.nextTick(()=>{\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                this.callRefTimerUnref();\n                for (const call of localQueue){\n                    call.getConfig();\n                }\n                this.configSelectionQueue = [];\n            });\n        }, (status)=>{\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_WARNING\", \"Address resolution failed with code \" + status.code + ' and details \"' + status.details + '\"');\n            }\n            if (this.configSelectionQueue.length > 0) {\n                this.trace(\"Name resolution failed with calls queued for config selection\");\n            }\n            if (this.configSelector === null) {\n                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), {\n                    metadata: status.metadata\n                });\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            this.callRefTimerUnref();\n            for (const call of localQueue){\n                call.reportResolverError(status);\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),\n            new compression_filter_1.CompressionFilterFactory(this, this.options)\n        ]);\n        this.trace(\"Channel constructed with options \" + JSON.stringify(options, undefined, 2));\n        const error = new Error();\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, \"channel_stacktrace\", \"(\" + this.channelzRef.id + \") \" + \"Channel constructed \\n\" + ((_h = error.stack) === null || _h === void 0 ? void 0 : _h.substring(error.stack.indexOf(\"\\n\") + 1)));\n    }\n    getChannelzInfo() {\n        return {\n            target: this.originalTarget,\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists()\n        };\n    }\n    trace(text, verbosityOverride) {\n        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, \"channel\", \"(\" + this.channelzRef.id + \") \" + (0, uri_parser_1.uriToString)(this.target) + \" \" + text);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            this.trace(\"callRefTimer.ref | configSelectionQueue.length=\" + this.configSelectionQueue.length + \" pickQueue.length=\" + this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b;\n        // If the hasRef function does not exist, always run the code\n        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n            this.trace(\"callRefTimer.unref | configSelectionQueue.length=\" + this.configSelectionQueue.length + \" pickQueue.length=\" + this.pickQueue.length);\n            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex((value)=>value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, \"connectivity_state\", \"(\" + this.channelzRef.id + \") \" + (0, uri_parser_1.uriToString)(this.target) + \" \" + connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Connectivity state change to \" + connectivity_state_1.ConnectivityState[newState]);\n        }\n        this.connectivityState = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy){\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            this.currentResolutionError = null;\n        }\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n            for (const wrappedSubchannel of this.wrappedSubchannels){\n                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\n            }\n        }\n    }\n    removeWrappedSubchannel(wrappedSubchannel) {\n        this.wrappedSubchannels.delete(wrappedSubchannel);\n    }\n    doPick(metadata, extraPickInfo) {\n        return this.currentPicker.pick({\n            metadata: metadata,\n            extraPickInfo: extraPickInfo\n        });\n    }\n    queueCallForPick(call) {\n        this.pickQueue.push(call);\n        this.callRefTimerRef();\n    }\n    getConfig(method, metadata) {\n        this.resolvingLoadBalancer.exitIdle();\n        if (this.configSelector) {\n            return {\n                type: \"SUCCESS\",\n                config: this.configSelector(method, metadata)\n            };\n        } else {\n            if (this.currentResolutionError) {\n                return {\n                    type: \"ERROR\",\n                    error: this.currentResolutionError\n                };\n            } else {\n                return {\n                    type: \"NONE\"\n                };\n            }\n        }\n    }\n    queueCallForConfig(call) {\n        this.configSelectionQueue.push(call);\n        this.callRefTimerRef();\n    }\n    enterIdle() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE);\n        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);\n    }\n    maybeStartIdleTimer() {\n        var _a, _b;\n        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN && this.callCount === 0) {\n            this.idleTimer = setTimeout(()=>{\n                this.trace(\"Idle timer triggered after \" + this.idleTimeoutMs + \"ms of inactivity\");\n                this.enterIdle();\n            }, this.idleTimeoutMs);\n            (_b = (_a = this.idleTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    onCallStart() {\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n        }\n        this.callCount += 1;\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n            this.idleTimer = null;\n        }\n    }\n    onCallEnd(status) {\n        if (this.channelzEnabled) {\n            if (status.code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            } else {\n                this.callTracker.addCallFailed();\n            }\n        }\n        this.callCount -= 1;\n        this.maybeStartIdleTimer();\n    }\n    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace(\"createLoadBalancingCall [\" + callNumber + '] method=\"' + method + '\"');\n        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);\n    }\n    createRetryingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace(\"createRetryingCall [\" + callNumber + '] method=\"' + method + '\"');\n        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));\n    }\n    createInnerCall(callConfig, method, host, credentials, deadline) {\n        // Create a RetryingCall if retries are enabled\n        if (this.options[\"grpc.enable_retries\"] === 0) {\n            return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);\n        } else {\n            return this.createRetryingCall(callConfig, method, host, credentials, deadline);\n        }\n    }\n    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace(\"createResolvingCall [\" + callNumber + '] method=\"' + method + '\", deadline=' + (0, deadline_1.deadlineToString)(deadline));\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall\n        };\n        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);\n        this.onCallStart();\n        call.addStatusWatcher((status)=>{\n            this.onCallEnd(status);\n        });\n        return call;\n    }\n    close() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n        clearInterval(this.callRefTimer);\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n        }\n        if (this.channelzEnabled) {\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        }\n        this.subchannelPool.unrefUnusedSubchannels();\n    }\n    getTarget() {\n        return (0, uri_parser_1.uriToString)(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n            this.maybeStartIdleTimer();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error(\"Channel has been shut down\");\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error(\"Deadline passed without connectivity state change\"));\n                return;\n            }\n            timer = setTimeout(()=>{\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error(\"Deadline passed without connectivity state change\"));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== \"string\") {\n            throw new TypeError(\"Channel#createCall: method must be a string\");\n        }\n        if (!(typeof deadline === \"number\" || deadline instanceof Date)) {\n            throw new TypeError(\"Channel#createCall: deadline must be a number or Date\");\n        }\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error(\"Channel has been shut down\");\n        }\n        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);\n    }\n}\nexports.InternalChannel = InternalChannel; //# sourceMappingURL=internal-channel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW50ZXJuYWwtY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHLEtBQUs7QUFDL0IsTUFBTUcsd0JBQXdCQyxtQkFBT0EsQ0FBQyxrR0FBdUI7QUFDN0QsTUFBTUMsNEJBQTRCRCxtQkFBT0EsQ0FBQywwR0FBMkI7QUFDckUsTUFBTUUsb0JBQW9CRixtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUksY0FBY0osbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUssaUJBQWlCTCxtQkFBT0EsQ0FBQyxvRkFBZ0I7QUFDL0MsTUFBTU0sdUJBQXVCTixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTVEsWUFBWVIsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTVMsNEJBQTRCVCxtQkFBT0EsQ0FBQywwR0FBMkI7QUFDckUsTUFBTVUsZUFBZVYsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVcsZUFBZVgsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVksdUJBQXVCWixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTWEsYUFBYWIsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTWMsd0JBQXdCZCxtQkFBT0EsQ0FBQyxrR0FBdUI7QUFDN0QsTUFBTWUsYUFBYWYsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTWdCLG1CQUFtQmhCLG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNuRCxNQUFNaUIsZ0JBQWdCakIsbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0MsTUFBTWtCLHlCQUF5QmxCLG1CQUFP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LElBQUlsSCxNQUFNO1FBQ3BCO1FBQ0EsT0FBTyxJQUFJLENBQUNxSSxtQkFBbUIsQ0FBQzVCLFFBQVFxQixVQUFVRCxNQUFNUyxZQUFZQztJQUN4RTtBQUNKO0FBQ0E1Tix1QkFBdUIsR0FBR0UsaUJBQzFCLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2ludGVybmFsLWNoYW5uZWwuanM/MzRkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRlcm5hbENoYW5uZWwgPSB2b2lkIDA7XG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgcmVzb2x2aW5nX2xvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmluZy1sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9wb29sXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLXBvb2xcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZmlsdGVyX3N0YWNrXzEgPSByZXF1aXJlKFwiLi9maWx0ZXItc3RhY2tcIik7XG5jb25zdCBjb21wcmVzc2lvbl9maWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWZpbHRlclwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBtYXhfbWVzc2FnZV9zaXplX2ZpbHRlcl8xID0gcmVxdWlyZShcIi4vbWF4LW1lc3NhZ2Utc2l6ZS1maWx0ZXJcIik7XG5jb25zdCBodHRwX3Byb3h5XzEgPSByZXF1aXJlKFwiLi9odHRwX3Byb3h5XCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgbG9hZF9iYWxhbmNpbmdfY2FsbF8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNpbmctY2FsbFwiKTtcbmNvbnN0IGRlYWRsaW5lXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZVwiKTtcbmNvbnN0IHJlc29sdmluZ19jYWxsXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZpbmctY2FsbFwiKTtcbmNvbnN0IGNhbGxfbnVtYmVyXzEgPSByZXF1aXJlKFwiLi9jYWxsLW51bWJlclwiKTtcbmNvbnN0IGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEgPSByZXF1aXJlKFwiLi9jb250cm9sLXBsYW5lLXN0YXR1c1wiKTtcbmNvbnN0IHJldHJ5aW5nX2NhbGxfMSA9IHJlcXVpcmUoXCIuL3JldHJ5aW5nLWNhbGxcIik7XG5jb25zdCBzdWJjaGFubmVsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1pbnRlcmZhY2VcIik7XG4vKipcbiAqIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3RpbWVycy5odG1sI3RpbWVyc19zZXRpbnRlcnZhbF9jYWxsYmFja19kZWxheV9hcmdzXG4gKi9cbmNvbnN0IE1BWF9USU1FT1VUX1RJTUUgPSAyMTQ3NDgzNjQ3O1xuY29uc3QgTUlOX0lETEVfVElNRU9VVF9NUyA9IDEwMDA7XG4vLyAzMCBtaW51dGVzXG5jb25zdCBERUZBVUxUX0lETEVfVElNRU9VVF9NUyA9IDMwICogNjAgKiAxMDAwO1xuY29uc3QgUkVUUllfVEhST1RUTEVSX01BUCA9IG5ldyBNYXAoKTtcbmNvbnN0IERFRkFVTFRfUkVUUllfQlVGRkVSX1NJWkVfQllURVMgPSAxIDw8IDI0OyAvLyAxNiBNQlxuY29uc3QgREVGQVVMVF9QRVJfUlBDX1JFVFJZX0JVRkZFUl9TSVpFX0JZVEVTID0gMSA8PCAyMDsgLy8gMSBNQlxuY2xhc3MgQ2hhbm5lbFN1YmNoYW5uZWxXcmFwcGVyIGV4dGVuZHMgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMS5CYXNlU3ViY2hhbm5lbFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkU3ViY2hhbm5lbCwgY2hhbm5lbCkge1xuICAgICAgICBzdXBlcihjaGlsZFN1YmNoYW5uZWwpO1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lciA9IChzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwga2VlcGFsaXZlVGltZSkgPT4ge1xuICAgICAgICAgICAgY2hhbm5lbC50aHJvdHRsZUtlZXBhbGl2ZShrZWVwYWxpdmVUaW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGRTdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCArPSAxO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC51bnJlZigpO1xuICAgICAgICB0aGlzLnJlZkNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLnJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5yZW1vdmVXcmFwcGVkU3ViY2hhbm5lbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEludGVybmFsQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjcmVkZW50aWFscywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxzIHF1ZXVlZCB1cCB0byBnZXQgYSBjYWxsIGNvbmZpZy4gU2hvdWxkIG9ubHkgYmUgcG9wdWxhdGVkIGJlZm9yZSB0aGVcbiAgICAgICAgICogZmlyc3QgdGltZSB0aGUgcmVzb2x2ZXIgcmV0dXJucyBhIHJlc3VsdCwgd2hpY2ggaW5jbHVkZXMgdGhlIENvbmZpZ1NlbGVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnBpY2tRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3RvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBlcnJvciBmcm9tIHRoZSBuYW1lIHJlc29sdmVyIGlmIGl0IGZhaWxlZCBtb3N0IHJlY2VudGx5LiBJdFxuICAgICAgICAgKiBpcyBvbmx5IHVzZWQgdG8gZW5kIGNhbGxzIHRoYXQgc3RhcnQgd2hpbGUgdGhlcmUgaXMgbm8gY29uZmlnIHNlbGVjdG9yXG4gICAgICAgICAqIGFuZCB0aGUgbmFtZSByZXNvbHZlciBpcyBpbiBiYWNrb2ZmLCBzbyBpdCBzaG91bGQgYmUgbnVsbGVkIGlmXG4gICAgICAgICAqIGNvbmZpZ1NlbGVjdG9yIGJlY29tZXMgc2V0IG9yIHRoZSBjaGFubmVsIHN0YXRlIGJlY29tZXMgYW55dGhpbmcgb3RoZXJcbiAgICAgICAgICogdGhhbiBUUkFOU0lFTlRfRkFJTFVSRS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMud3JhcHBlZFN1YmNoYW5uZWxzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmNhbGxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgLy8gQ2hhbm5lbHogaW5mb1xuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIHRhcmdldCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY3JlZGVudGlhbHMgaW5zdGFuY2VvZiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBjcmVkZW50aWFscyBtdXN0IGJlIGEgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmlnaW5hbFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUYXJnZXRVcmkgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKSh0YXJnZXQpO1xuICAgICAgICBpZiAob3JpZ2luYWxUYXJnZXRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIHNjaGVtZSB0aGF0IGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGVcbiAgICAgICAgICogcmVzb2x2ZXIgKi9cbiAgICAgICAgY29uc3QgZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCA9ICgwLCByZXNvbHZlcl8xLm1hcFVyaURlZmF1bHRTY2hlbWUpKG9yaWdpbmFsVGFyZ2V0VXJpKTtcbiAgICAgICAgaWYgKGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBkZWZhdWx0IHNjaGVtZSBmb3IgdGFyZ2V0IG5hbWUgXCIke3RhcmdldH1cImApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB9LCBNQVhfVElNRU9VVF9USU1FKTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYWxsUmVmVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwpKHRhcmdldCwgKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDaGFubmVsIGNyZWF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmRlZmF1bHRfYXV0aG9yaXR5J10pIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEF1dGhvcml0eSA9IHRoaXMub3B0aW9uc1snZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QXV0aG9yaXR5ID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJveHlNYXBSZXN1bHQgPSAoMCwgaHR0cF9wcm94eV8xLm1hcFByb3h5TmFtZSkoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gcHJveHlNYXBSZXN1bHQudGFyZ2V0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHByb3h5TWFwUmVzdWx0LmV4dHJhT3B0aW9ucyk7XG4gICAgICAgIC8qIFRoZSBnbG9iYWwgYm9vbGVhbiBwYXJhbWV0ZXIgdG8gZ2V0U3ViY2hhbm5lbFBvb2wgaGFzIHRoZSBpbnZlcnNlIG1lYW5pbmcgdG8gd2hhdFxuICAgICAgICAgKiB0aGUgZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sIGNoYW5uZWwgb3B0aW9uIG1lYW5zLiAqL1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxQb29sID0gKDAsIHN1YmNoYW5uZWxfcG9vbF8xLmdldFN1YmNoYW5uZWxQb29sKSgoKF9jID0gb3B0aW9uc1snZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sJ10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDApID09PSAwKTtcbiAgICAgICAgdGhpcy5yZXRyeUJ1ZmZlclRyYWNrZXIgPSBuZXcgcmV0cnlpbmdfY2FsbF8xLk1lc3NhZ2VCdWZmZXJUcmFja2VyKChfZCA9IG9wdGlvbnNbJ2dycGMucmV0cnlfYnVmZmVyX3NpemUnXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogREVGQVVMVF9SRVRSWV9CVUZGRVJfU0laRV9CWVRFUywgKF9lID0gb3B0aW9uc1snZ3JwYy5wZXJfcnBjX3JldHJ5X2J1ZmZlcl9zaXplJ10pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IERFRkFVTFRfUEVSX1JQQ19SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IChfZiA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogLTE7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXRNcyA9IE1hdGgubWF4KChfZyA9IG9wdGlvbnNbJ2dycGMuY2xpZW50X2lkbGVfdGltZW91dF9tcyddKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBERUZBVUxUX0lETEVfVElNRU9VVF9NUywgTUlOX0lETEVfVElNRU9VVF9NUyk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxDb250cm9sSGVscGVyID0ge1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWwgPSB0aGlzLnN1YmNoYW5uZWxQb29sLmdldE9yQ3JlYXRlU3ViY2hhbm5lbCh0aGlzLnRhcmdldCwgc3ViY2hhbm5lbEFkZHJlc3MsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgc3ViY2hhbm5lbEFyZ3MpLCB0aGlzLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKHRoaXMua2VlcGFsaXZlVGltZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDcmVhdGVkIHN1YmNoYW5uZWwgb3IgdXNlZCBleGlzdGluZyBzdWJjaGFubmVsJywgc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZFN1YmNoYW5uZWwgPSBuZXcgQ2hhbm5lbFN1YmNoYW5uZWxXcmFwcGVyKHN1YmNoYW5uZWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlZFN1YmNoYW5uZWxzLmFkZCh3cmFwcGVkU3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRTdWJjaGFubmVsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZUNvcHkgPSB0aGlzLnBpY2tRdWV1ZS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGlja1F1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJVbnJlZigpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBxdWV1ZUNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5kb1BpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBsb2FkIGJhbGFuY2VyIHNob3VsZCBuZXZlciBjYWxsIHJlcXVlc3RSZXJlc29sdXRpb24nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkOiAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIgPSBuZXcgcmVzb2x2aW5nX2xvYWRfYmFsYW5jZXJfMS5SZXNvbHZpbmdMb2FkQmFsYW5jZXIodGhpcy50YXJnZXQsIGNoYW5uZWxDb250cm9sSGVscGVyLCBvcHRpb25zLCAoc2VydmljZUNvbmZpZywgY29uZmlnU2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZykge1xuICAgICAgICAgICAgICAgIFJFVFJZX1RIUk9UVExFUl9NQVAuc2V0KHRoaXMuZ2V0VGFyZ2V0KCksIG5ldyByZXRyeWluZ19jYWxsXzEuUmV0cnlUaHJvdHRsZXIoc2VydmljZUNvbmZpZy5yZXRyeVRocm90dGxpbmcubWF4VG9rZW5zLCBzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZy50b2tlblJhdGlvLCBSRVRSWV9USFJPVFRMRVJfTUFQLmdldCh0aGlzLmdldFRhcmdldCgpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUkVUUllfVEhST1RUTEVSX01BUC5kZWxldGUodGhpcy5nZXRUYXJnZXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQWRkcmVzcyByZXNvbHV0aW9uIHN1Y2NlZWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3RvciA9IGNvbmZpZ1NlbGVjdG9yO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIC8qIFdlIHByb2Nlc3MgdGhlIHF1ZXVlIGFzeW5jaHJvbm91c2x5IHRvIGVuc3VyZSB0aGF0IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAgKiBsb2FkIGJhbGFuY2VyIHVwZGF0ZSBoYXMgY29tcGxldGVkLiAqL1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxRdWV1ZSA9IHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyVW5yZWYoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgbG9jYWxRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgc3RhdHVzID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfV0FSTklORycsICdBZGRyZXNzIHJlc29sdXRpb24gZmFpbGVkIHdpdGggY29kZSAnICtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmNvZGUgK1xuICAgICAgICAgICAgICAgICAgICAnIGFuZCBkZXRhaWxzIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnTmFtZSByZXNvbHV0aW9uIGZhaWxlZCB3aXRoIGNhbGxzIHF1ZXVlZCBmb3IgY29uZmlnIHNlbGVjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkoc3RhdHVzLmNvZGUsIHN0YXR1cy5kZXRhaWxzKSksIHsgbWV0YWRhdGE6IHN0YXR1cy5tZXRhZGF0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsUXVldWUgPSB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlO1xuICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJVbnJlZigpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIGxvY2FsUXVldWUpIHtcbiAgICAgICAgICAgICAgICBjYWxsLnJlcG9ydFJlc29sdmVyRXJyb3Ioc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5ID0gbmV3IGZpbHRlcl9zdGFja18xLkZpbHRlclN0YWNrRmFjdG9yeShbXG4gICAgICAgICAgICBuZXcgbWF4X21lc3NhZ2Vfc2l6ZV9maWx0ZXJfMS5NYXhNZXNzYWdlU2l6ZUZpbHRlckZhY3RvcnkodGhpcy5vcHRpb25zKSxcbiAgICAgICAgICAgIG5ldyBjb21wcmVzc2lvbl9maWx0ZXJfMS5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkodGhpcywgdGhpcy5vcHRpb25zKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMudHJhY2UoJ0NoYW5uZWwgY29uc3RydWN0ZWQgd2l0aCBvcHRpb25zICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgdW5kZWZpbmVkLCAyKSk7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgICgwLCBsb2dnaW5nXzEudHJhY2UpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2NoYW5uZWxfc3RhY2t0cmFjZScsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgJ0NoYW5uZWwgY29uc3RydWN0ZWQgXFxuJyArXG4gICAgICAgICAgICAoKF9oID0gZXJyb3Iuc3RhY2spID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5zdWJzdHJpbmcoZXJyb3Iuc3RhY2suaW5kZXhPZignXFxuJykgKyAxKSkpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMub3JpZ2luYWxUYXJnZXQsXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSxcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXG4gICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLmNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlKHRleHQsIHZlcmJvc2l0eU92ZXJyaWRlKSB7XG4gICAgICAgICgwLCBsb2dnaW5nXzEudHJhY2UpKHZlcmJvc2l0eU92ZXJyaWRlICE9PSBudWxsICYmIHZlcmJvc2l0eU92ZXJyaWRlICE9PSB2b2lkIDAgPyB2ZXJib3NpdHlPdmVycmlkZSA6IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2NoYW5uZWwnLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArICcgJyArIHRleHQpO1xuICAgIH1cbiAgICBjYWxsUmVmVGltZXJSZWYoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gSWYgdGhlIGhhc1JlZiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCwgYWx3YXlzIHJ1biB0aGUgY29kZVxuICAgICAgICBpZiAoISgoX2IgPSAoX2EgPSB0aGlzLmNhbGxSZWZUaW1lcikuaGFzUmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjYWxsUmVmVGltZXIucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAnIHBpY2tRdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMuY2FsbFJlZlRpbWVyKS5yZWYpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsUmVmVGltZXJVbnJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gSWYgdGhlIGhhc1JlZiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCwgYWx3YXlzIHJ1biB0aGUgY29kZVxuICAgICAgICBpZiAoIXRoaXMuY2FsbFJlZlRpbWVyLmhhc1JlZiB8fCB0aGlzLmNhbGxSZWZUaW1lci5oYXNSZWYoKSkge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2FsbFJlZlRpbWVyLnVucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAnIHBpY2tRdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHdhdGNoZXJJbmRleCA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPT09IHdhdGNoZXJPYmplY3QpO1xuICAgICAgICBpZiAod2F0Y2hlckluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5zcGxpY2Uod2F0Y2hlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICAoMCwgbG9nZ2luZ18xLnRyYWNlKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjb25uZWN0aXZpdHlfc3RhdGUnLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UgdG8gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBjb25zdCB3YXRjaGVyc0NvcHkgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yIChjb25zdCB3YXRjaGVyT2JqZWN0IG9mIHdhdGNoZXJzQ29weSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB3YXRjaGVyT2JqZWN0LmN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICh3YXRjaGVyT2JqZWN0LnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh3YXRjaGVyT2JqZWN0LnRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXIod2F0Y2hlck9iamVjdCk7XG4gICAgICAgICAgICAgICAgd2F0Y2hlck9iamVjdC5jYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3R0bGVLZWVwYWxpdmUobmV3S2VlcGFsaXZlVGltZSkge1xuICAgICAgICBpZiAobmV3S2VlcGFsaXZlVGltZSA+IHRoaXMua2VlcGFsaXZlVGltZSkge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gbmV3S2VlcGFsaXZlVGltZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd3JhcHBlZFN1YmNoYW5uZWwgb2YgdGhpcy53cmFwcGVkU3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkU3ViY2hhbm5lbC50aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVXcmFwcGVkU3ViY2hhbm5lbCh3cmFwcGVkU3ViY2hhbm5lbCkge1xuICAgICAgICB0aGlzLndyYXBwZWRTdWJjaGFubmVscy5kZWxldGUod3JhcHBlZFN1YmNoYW5uZWwpO1xuICAgIH1cbiAgICBkb1BpY2sobWV0YWRhdGEsIGV4dHJhUGlja0luZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBpY2tlci5waWNrKHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YSxcbiAgICAgICAgICAgIGV4dHJhUGlja0luZm86IGV4dHJhUGlja0luZm8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBxdWV1ZUNhbGxGb3JQaWNrKGNhbGwpIHtcbiAgICAgICAgdGhpcy5waWNrUXVldWUucHVzaChjYWxsKTtcbiAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJSZWYoKTtcbiAgICB9XG4gICAgZ2V0Q29uZmlnKG1ldGhvZCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1NVQ0NFU1MnLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWdTZWxlY3RvcihtZXRob2QsIG1ldGFkYXRhKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0VSUk9SJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ05PTkUnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWVDYWxsRm9yQ29uZmlnKGNhbGwpIHtcbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5wdXNoKGNhbGwpO1xuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclJlZigpO1xuICAgIH1cbiAgICBlbnRlcklkbGUoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyKTtcbiAgICB9XG4gICAgbWF5YmVTdGFydElkbGVUaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOICYmIHRoaXMuY2FsbENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0lkbGUgdGltZXIgdHJpZ2dlcmVkIGFmdGVyICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkbGVUaW1lb3V0TXMgK1xuICAgICAgICAgICAgICAgICAgICAnbXMgb2YgaW5hY3Rpdml0eScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJJZGxlKCk7XG4gICAgICAgICAgICB9LCB0aGlzLmlkbGVUaW1lb3V0TXMpO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5pZGxlVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DYWxsU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbENvdW50ICs9IDE7XG4gICAgICAgIGlmICh0aGlzLmlkbGVUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNhbGxFbmQoc3RhdHVzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbENvdW50IC09IDE7XG4gICAgICAgIHRoaXMubWF5YmVTdGFydElkbGVUaW1lcigpO1xuICAgIH1cbiAgICBjcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSkge1xuICAgICAgICBjb25zdCBjYWxsTnVtYmVyID0gKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsIFsnICsgY2FsbE51bWJlciArICddIG1ldGhvZD1cIicgKyBtZXRob2QgKyAnXCInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBsb2FkX2JhbGFuY2luZ19jYWxsXzEuTG9hZEJhbGFuY2luZ0NhbGwodGhpcywgY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIpO1xuICAgIH1cbiAgICBjcmVhdGVSZXRyeWluZ0NhbGwoY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUpIHtcbiAgICAgICAgY29uc3QgY2FsbE51bWJlciA9ICgwLCBjYWxsX251bWJlcl8xLmdldE5leHRDYWxsTnVtYmVyKSgpO1xuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVSZXRyeWluZ0NhbGwgWycgKyBjYWxsTnVtYmVyICsgJ10gbWV0aG9kPVwiJyArIG1ldGhvZCArICdcIicpO1xuICAgICAgICByZXR1cm4gbmV3IHJldHJ5aW5nX2NhbGxfMS5SZXRyeWluZ0NhbGwodGhpcywgY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIsIHRoaXMucmV0cnlCdWZmZXJUcmFja2VyLCBSRVRSWV9USFJPVFRMRVJfTUFQLmdldCh0aGlzLmdldFRhcmdldCgpKSk7XG4gICAgfVxuICAgIGNyZWF0ZUlubmVyQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBSZXRyeWluZ0NhbGwgaWYgcmV0cmllcyBhcmUgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmVuYWJsZV9yZXRyaWVzJ10gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsKGNhbGxDb25maWcsIG1ldGhvZCwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJldHJ5aW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlUmVzb2x2aW5nQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xuICAgICAgICBjb25zdCBjYWxsTnVtYmVyID0gKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZVJlc29sdmluZ0NhbGwgWycgK1xuICAgICAgICAgICAgY2FsbE51bWJlciArXG4gICAgICAgICAgICAnXSBtZXRob2Q9XCInICtcbiAgICAgICAgICAgIG1ldGhvZCArXG4gICAgICAgICAgICAnXCIsIGRlYWRsaW5lPScgK1xuICAgICAgICAgICAgKDAsIGRlYWRsaW5lXzEuZGVhZGxpbmVUb1N0cmluZykoZGVhZGxpbmUpKTtcbiAgICAgICAgY29uc3QgZmluYWxPcHRpb25zID0ge1xuICAgICAgICAgICAgZGVhZGxpbmU6IGRlYWRsaW5lLFxuICAgICAgICAgICAgZmxhZ3M6IHByb3BhZ2F0ZUZsYWdzICE9PSBudWxsICYmIHByb3BhZ2F0ZUZsYWdzICE9PSB2b2lkIDAgPyBwcm9wYWdhdGVGbGFncyA6IGNvbnN0YW50c18xLlByb3BhZ2F0ZS5ERUZBVUxUUyxcbiAgICAgICAgICAgIGhvc3Q6IGhvc3QgIT09IG51bGwgJiYgaG9zdCAhPT0gdm9pZCAwID8gaG9zdCA6IHRoaXMuZGVmYXVsdEF1dGhvcml0eSxcbiAgICAgICAgICAgIHBhcmVudENhbGw6IHBhcmVudENhbGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSBuZXcgcmVzb2x2aW5nX2NhbGxfMS5SZXNvbHZpbmdDYWxsKHRoaXMsIG1ldGhvZCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeS5jbG9uZSgpLCB0aGlzLmNyZWRlbnRpYWxzLl9nZXRDYWxsQ3JlZGVudGlhbHMoKSwgY2FsbE51bWJlcik7XG4gICAgICAgIHRoaXMub25DYWxsU3RhcnQoKTtcbiAgICAgICAgY2FsbC5hZGRTdGF0dXNXYXRjaGVyKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQ2FsbEVuZChzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2FsbFJlZlRpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKSh0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxQb29sLnVucmVmVW51c2VkU3ViY2hhbm5lbHMoKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnlUb0Nvbm5lY3QpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGl2aXR5U3RhdGUgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xuICAgICAgICBpZiAodHJ5VG9Db25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SWRsZVRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpdml0eVN0YXRlO1xuICAgIH1cbiAgICB3YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFubmVsIGhhcyBiZWVuIHNodXQgZG93bicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGlmIChkZWFkbGluZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lRGF0ZSA9IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSA/IGRlYWRsaW5lIDogbmV3IERhdGUoZGVhZGxpbmUpO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGlmIChkZWFkbGluZSA9PT0gLUluZmluaXR5IHx8IGRlYWRsaW5lRGF0ZSA8PSBub3cpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XG4gICAgICAgICAgICB9LCBkZWFkbGluZURhdGUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2F0Y2hlck9iamVjdCA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgdGltZXIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5wdXNoKHdhdGNoZXJPYmplY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5uZWx6IHJlZmVyZW5jZSBvYmplY3QgZm9yIHRoaXMgY2hhbm5lbC4gVGhlIHJldHVybmVkIHZhbHVlIGlzXG4gICAgICogZ2FyYmFnZSBpZiBjaGFubmVseiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjaGFubmVsLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBtZXRob2QgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHR5cGVvZiBkZWFkbGluZSA9PT0gJ251bWJlcicgfHwgZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBkZWFkbGluZSBtdXN0IGJlIGEgbnVtYmVyIG9yIERhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhbm5lbCBoYXMgYmVlbiBzaHV0IGRvd24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXNvbHZpbmdDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKTtcbiAgICB9XG59XG5leHBvcnRzLkludGVybmFsQ2hhbm5lbCA9IEludGVybmFsQ2hhbm5lbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLWNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW50ZXJuYWxDaGFubmVsIiwiY2hhbm5lbF9jcmVkZW50aWFsc18xIiwicmVxdWlyZSIsInJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEiLCJzdWJjaGFubmVsX3Bvb2xfMSIsInBpY2tlcl8xIiwiY29uc3RhbnRzXzEiLCJmaWx0ZXJfc3RhY2tfMSIsImNvbXByZXNzaW9uX2ZpbHRlcl8xIiwicmVzb2x2ZXJfMSIsImxvZ2dpbmdfMSIsIm1heF9tZXNzYWdlX3NpemVfZmlsdGVyXzEiLCJodHRwX3Byb3h5XzEiLCJ1cmlfcGFyc2VyXzEiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsImNoYW5uZWx6XzEiLCJsb2FkX2JhbGFuY2luZ19jYWxsXzEiLCJkZWFkbGluZV8xIiwicmVzb2x2aW5nX2NhbGxfMSIsImNhbGxfbnVtYmVyXzEiLCJjb250cm9sX3BsYW5lX3N0YXR1c18xIiwicmV0cnlpbmdfY2FsbF8xIiwic3ViY2hhbm5lbF9pbnRlcmZhY2VfMSIsIk1BWF9USU1FT1VUX1RJTUUiLCJNSU5fSURMRV9USU1FT1VUX01TIiwiREVGQVVMVF9JRExFX1RJTUVPVVRfTVMiLCJSRVRSWV9USFJPVFRMRVJfTUFQIiwiTWFwIiwiREVGQVVMVF9SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyIsIkRFRkFVTFRfUEVSX1JQQ19SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyIsIkNoYW5uZWxTdWJjaGFubmVsV3JhcHBlciIsIkJhc2VTdWJjaGFubmVsV3JhcHBlciIsImNvbnN0cnVjdG9yIiwiY2hpbGRTdWJjaGFubmVsIiwiY2hhbm5lbCIsInJlZkNvdW50Iiwic3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIiLCJzdWJjaGFubmVsIiwicHJldmlvdXNTdGF0ZSIsIm5ld1N0YXRlIiwia2VlcGFsaXZlVGltZSIsInRocm90dGxlS2VlcGFsaXZlIiwiYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInJlZiIsImNoaWxkIiwidW5yZWYiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwicmVtb3ZlV3JhcHBlZFN1YmNoYW5uZWwiLCJ0YXJnZXQiLCJjcmVkZW50aWFscyIsIm9wdGlvbnMiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsIl9oIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJjdXJyZW50UGlja2VyIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJjb25maWdTZWxlY3Rpb25RdWV1ZSIsInBpY2tRdWV1ZSIsImNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMiLCJjb25maWdTZWxlY3RvciIsImN1cnJlbnRSZXNvbHV0aW9uRXJyb3IiLCJ3cmFwcGVkU3ViY2hhbm5lbHMiLCJTZXQiLCJjYWxsQ291bnQiLCJpZGxlVGltZXIiLCJjaGFubmVsekVuYWJsZWQiLCJjYWxsVHJhY2tlciIsIkNoYW5uZWx6Q2FsbFRyYWNrZXIiLCJjaGlsZHJlblRyYWNrZXIiLCJDaGFubmVsekNoaWxkcmVuVHJhY2tlciIsIlR5cGVFcnJvciIsIkNoYW5uZWxDcmVkZW50aWFscyIsIm9yaWdpbmFsVGFyZ2V0Iiwib3JpZ2luYWxUYXJnZXRVcmkiLCJwYXJzZVVyaSIsIkVycm9yIiwiZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCIsIm1hcFVyaURlZmF1bHRTY2hlbWUiLCJjYWxsUmVmVGltZXIiLCJzZXRJbnRlcnZhbCIsImNhbGwiLCJjaGFubmVselRyYWNlIiwiQ2hhbm5lbHpUcmFjZSIsImNoYW5uZWx6UmVmIiwicmVnaXN0ZXJDaGFubmVsekNoYW5uZWwiLCJnZXRDaGFubmVsekluZm8iLCJhZGRUcmFjZSIsImRlZmF1bHRBdXRob3JpdHkiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicHJveHlNYXBSZXN1bHQiLCJtYXBQcm94eU5hbWUiLCJhc3NpZ24iLCJleHRyYU9wdGlvbnMiLCJzdWJjaGFubmVsUG9vbCIsImdldFN1YmNoYW5uZWxQb29sIiwicmV0cnlCdWZmZXJUcmFja2VyIiwiTWVzc2FnZUJ1ZmZlclRyYWNrZXIiLCJpZGxlVGltZW91dE1zIiwiTWF0aCIsIm1heCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwiY3JlYXRlU3ViY2hhbm5lbCIsInN1YmNoYW5uZWxBZGRyZXNzIiwic3ViY2hhbm5lbEFyZ3MiLCJnZXRPckNyZWF0ZVN1YmNoYW5uZWwiLCJnZXRDaGFubmVselJlZiIsIndyYXBwZWRTdWJjaGFubmVsIiwiYWRkIiwidXBkYXRlU3RhdGUiLCJwaWNrZXIiLCJxdWV1ZUNvcHkiLCJzbGljZSIsImNhbGxSZWZUaW1lclVucmVmIiwiZG9QaWNrIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZWZDaGlsZCIsInJlbW92ZUNoYW5uZWx6Q2hpbGQiLCJ1bnJlZkNoaWxkIiwicmVzb2x2aW5nTG9hZEJhbGFuY2VyIiwiUmVzb2x2aW5nTG9hZEJhbGFuY2VyIiwic2VydmljZUNvbmZpZyIsInJldHJ5VGhyb3R0bGluZyIsInNldCIsImdldFRhcmdldCIsIlJldHJ5VGhyb3R0bGVyIiwibWF4VG9rZW5zIiwidG9rZW5SYXRpbyIsImdldCIsImRlbGV0ZSIsInByb2Nlc3MiLCJuZXh0VGljayIsImxvY2FsUXVldWUiLCJnZXRDb25maWciLCJzdGF0dXMiLCJjb2RlIiwiZGV0YWlscyIsImxlbmd0aCIsInRyYWNlIiwicmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlIiwibWV0YWRhdGEiLCJyZXBvcnRSZXNvbHZlckVycm9yIiwiZmlsdGVyU3RhY2tGYWN0b3J5IiwiRmlsdGVyU3RhY2tGYWN0b3J5IiwiTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5IiwiQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVuZGVmaW5lZCIsImVycm9yIiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJpZCIsInN0YWNrIiwic3Vic3RyaW5nIiwiaW5kZXhPZiIsInN0YXRlIiwiY2hpbGRyZW4iLCJnZXRDaGlsZExpc3RzIiwidGV4dCIsInZlcmJvc2l0eU92ZXJyaWRlIiwidXJpVG9TdHJpbmciLCJjYWxsUmVmVGltZXJSZWYiLCJoYXNSZWYiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXIiLCJ3YXRjaGVyT2JqZWN0Iiwid2F0Y2hlckluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwid2F0Y2hlcnNDb3B5IiwiY3VycmVudFN0YXRlIiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJjYWxsYmFjayIsIlRSQU5TSUVOVF9GQUlMVVJFIiwibmV3S2VlcGFsaXZlVGltZSIsImV4dHJhUGlja0luZm8iLCJwaWNrIiwicXVldWVDYWxsRm9yUGljayIsInB1c2giLCJtZXRob2QiLCJleGl0SWRsZSIsInR5cGUiLCJjb25maWciLCJxdWV1ZUNhbGxGb3JDb25maWciLCJlbnRlcklkbGUiLCJkZXN0cm95IiwiUXVldWVQaWNrZXIiLCJtYXliZVN0YXJ0SWRsZVRpbWVyIiwiU0hVVERPV04iLCJzZXRUaW1lb3V0Iiwib25DYWxsU3RhcnQiLCJhZGRDYWxsU3RhcnRlZCIsIm9uQ2FsbEVuZCIsIlN0YXR1cyIsIk9LIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsImFkZENhbGxGYWlsZWQiLCJjcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbCIsImNhbGxDb25maWciLCJob3N0IiwiZGVhZGxpbmUiLCJjYWxsTnVtYmVyIiwiZ2V0TmV4dENhbGxOdW1iZXIiLCJMb2FkQmFsYW5jaW5nQ2FsbCIsImNyZWF0ZVJldHJ5aW5nQ2FsbCIsIlJldHJ5aW5nQ2FsbCIsImNyZWF0ZUlubmVyQ2FsbCIsImNyZWF0ZVJlc29sdmluZ0NhbGwiLCJwYXJlbnRDYWxsIiwicHJvcGFnYXRlRmxhZ3MiLCJkZWFkbGluZVRvU3RyaW5nIiwiZmluYWxPcHRpb25zIiwiZmxhZ3MiLCJQcm9wYWdhdGUiLCJERUZBVUxUUyIsIlJlc29sdmluZ0NhbGwiLCJjbG9uZSIsIl9nZXRDYWxsQ3JlZGVudGlhbHMiLCJhZGRTdGF0dXNXYXRjaGVyIiwiY2xvc2UiLCJjbGVhckludGVydmFsIiwidW5yZWdpc3RlckNoYW5uZWx6UmVmIiwidW5yZWZVbnVzZWRTdWJjaGFubmVscyIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwidHJ5VG9Db25uZWN0Iiwid2F0Y2hDb25uZWN0aXZpdHlTdGF0ZSIsIkluZmluaXR5IiwiZGVhZGxpbmVEYXRlIiwiRGF0ZSIsIm5vdyIsImdldFRpbWUiLCJjcmVhdGVDYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChildLoadBalancerHandler = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst TYPE_NAME = \"child_load_balancer_helper\";\nclass ChildLoadBalancerHandler {\n    constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        this.currentChild = null;\n        this.pendingChild = null;\n        this.latestConfig = null;\n        this.ChildPolicyHelper = class {\n            constructor(parent){\n                this.parent = parent;\n                this.child = null;\n            }\n            createSubchannel(subchannelAddress, subchannelArgs) {\n                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n            }\n            updateState(connectivityState, picker) {\n                var _a;\n                if (this.calledByPendingChild()) {\n                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                        return;\n                    }\n                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n                    this.parent.currentChild = this.parent.pendingChild;\n                    this.parent.pendingChild = null;\n                } else if (!this.calledByCurrentChild()) {\n                    return;\n                }\n                this.parent.channelControlHelper.updateState(connectivityState, picker);\n            }\n            requestReresolution() {\n                var _a;\n                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n                if (this.child === latestChild) {\n                    this.parent.channelControlHelper.requestReresolution();\n                }\n            }\n            setChild(newChild) {\n                this.child = newChild;\n            }\n            addChannelzChild(child) {\n                this.parent.channelControlHelper.addChannelzChild(child);\n            }\n            removeChannelzChild(child) {\n                this.parent.channelControlHelper.removeChannelzChild(child);\n            }\n            calledByPendingChild() {\n                return this.child === this.parent.pendingChild;\n            }\n            calledByCurrentChild() {\n                return this.child === this.parent.currentChild;\n            }\n        };\n    }\n    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {\n        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();\n    }\n    /**\n     * Prerequisites: lbConfig !== null and lbConfig.name is registered\n     * @param addressList\n     * @param lbConfig\n     * @param attributes\n     */ updateAddressList(addressList, lbConfig, attributes) {\n        let childToUpdate;\n        if (this.currentChild === null || this.latestConfig === null || this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {\n            const newHelper = new this.ChildPolicyHelper(this);\n            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper);\n            newHelper.setChild(newChild);\n            if (this.currentChild === null) {\n                this.currentChild = newChild;\n                childToUpdate = this.currentChild;\n            } else {\n                if (this.pendingChild) {\n                    this.pendingChild.destroy();\n                }\n                this.pendingChild = newChild;\n                childToUpdate = this.pendingChild;\n            }\n        } else {\n            if (this.pendingChild === null) {\n                childToUpdate = this.currentChild;\n            } else {\n                childToUpdate = this.pendingChild;\n            }\n        }\n        this.latestConfig = lbConfig;\n        childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n    }\n    exitIdle() {\n        if (this.currentChild) {\n            this.currentChild.exitIdle();\n            if (this.pendingChild) {\n                this.pendingChild.exitIdle();\n            }\n        }\n    }\n    resetBackoff() {\n        if (this.currentChild) {\n            this.currentChild.resetBackoff();\n            if (this.pendingChild) {\n                this.pendingChild.resetBackoff();\n            }\n        }\n    }\n    destroy() {\n        /* Note: state updates are only propagated from the child balancer if that\n         * object is equal to this.currentChild or this.pendingChild. Since this\n         * function sets both of those to null, no further state updates will\n         * occur after this function returns. */ if (this.currentChild) {\n            this.currentChild.destroy();\n            this.currentChild = null;\n        }\n        if (this.pendingChild) {\n            this.pendingChild.destroy();\n            this.pendingChild = null;\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler; //# sourceMappingURL=load-balancer-child-handler.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBRyxLQUFLO0FBQ3hDLE1BQU1HLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1FLFlBQVk7QUFDbEIsTUFBTUo7SUFDRkssWUFBWUMsb0JBQW9CLENBQUU7UUFDOUIsSUFBSSxDQUFDQSxvQkFBb0IsR0FBR0E7UUFDNUIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztZQUNyQkwsWUFBWU0sTUFBTSxDQUFFO2dCQUNoQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7Z0JBQ2QsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDakI7WUFDQUMsaUJBQWlCQyxpQkFBaUIsRUFBRUMsY0FBYyxFQUFFO2dCQUNoRCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDTCxvQkFBb0IsQ0FBQ08sZ0JBQWdCLENBQUNDLG1CQUFtQkM7WUFDaEY7WUFDQUMsWUFBWUMsaUJBQWlCLEVBQUVDLE1BQU0sRUFBRTtnQkFDbkMsSUFBSUM7Z0JBQ0osSUFBSSxJQUFJLENBQUNDLG9CQUFvQixJQUFJO29CQUM3QixJQUFJSCxzQkFBc0JkLHFCQUFxQmtCLGlCQUFpQixDQUFDQyxVQUFVLEVBQUU7d0JBQ3pFO29CQUNKO29CQUNDSCxDQUFBQSxLQUFLLElBQUksQ0FBQ1IsTUFBTSxDQUFDSixZQUFZLE1BQU0sUUFBUVksT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxH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QUFJLENBQUNBLFlBQVksQ0FBQ21DLFFBQVE7WUFDMUIsSUFBSSxJQUFJLENBQUNsQyxZQUFZLEVBQUU7Z0JBQ25CLElBQUksQ0FBQ0EsWUFBWSxDQUFDa0MsUUFBUTtZQUM5QjtRQUNKO0lBQ0o7SUFDQUMsZUFBZTtRQUNYLElBQUksSUFBSSxDQUFDcEMsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsWUFBWSxDQUFDb0MsWUFBWTtZQUM5QixJQUFJLElBQUksQ0FBQ25DLFlBQVksRUFBRTtnQkFDbkIsSUFBSSxDQUFDQSxZQUFZLENBQUNtQyxZQUFZO1lBQ2xDO1FBQ0o7SUFDSjtJQUNBcEIsVUFBVTtRQUNOOzs7OENBR3NDLEdBQ3RDLElBQUksSUFBSSxDQUFDaEIsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsWUFBWSxDQUFDZ0IsT0FBTztZQUN6QixJQUFJLENBQUNoQixZQUFZLEdBQUc7UUFDeEI7UUFDQSxJQUFJLElBQUksQ0FBQ0MsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsWUFBWSxDQUFDZSxPQUFPO1lBQ3pCLElBQUksQ0FBQ2YsWUFBWSxHQUFHO1FBQ3hCO0lBQ0o7SUFDQW9DLGNBQWM7UUFDVixPQUFPeEM7SUFDWDtBQUNKO0FBQ0FOLGdDQUFnQyxHQUFHRSwwQkFDbkMsdURBQXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzPzdlMTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgVFlQRV9OQU1FID0gJ2NoaWxkX2xvYWRfYmFsYW5jZXJfaGVscGVyJztcbmNsYXNzIENoaWxkTG9hZEJhbGFuY2VySGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLkNoaWxkUG9saWN5SGVscGVyID0gY2xhc3Mge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxlZEJ5UGVuZGluZ0NoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5wYXJlbnQuY3VycmVudENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQgPSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNhbGxlZEJ5Q3VycmVudENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdENoaWxkID0gKF9hID0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGQgPT09IGxhdGVzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDaGlsZChuZXdDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxlZEJ5UGVuZGluZ0NoaWxkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkID09PSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsZWRCeUN1cnJlbnRDaGlsZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZCA9PT0gdGhpcy5wYXJlbnQuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25maWdVcGRhdGVSZXF1aXJlc05ld1BvbGljeUluc3RhbmNlKG9sZENvbmZpZywgbmV3Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiBvbGRDb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpICE9PSBuZXdDb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVyZXF1aXNpdGVzOiBsYkNvbmZpZyAhPT0gbnVsbCBhbmQgbGJDb25maWcubmFtZSBpcyByZWdpc3RlcmVkXG4gICAgICogQHBhcmFtIGFkZHJlc3NMaXN0XG4gICAgICogQHBhcmFtIGxiQ29uZmlnXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbGV0IGNoaWxkVG9VcGRhdGU7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnVXBkYXRlUmVxdWlyZXNOZXdQb2xpY3lJbnN0YW5jZSh0aGlzLmxhdGVzdENvbmZpZywgbGJDb25maWcpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdIZWxwZXIgPSBuZXcgdGhpcy5DaGlsZFBvbGljeUhlbHBlcih0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gKDAsIGxvYWRfYmFsYW5jZXJfMS5jcmVhdGVMb2FkQmFsYW5jZXIpKGxiQ29uZmlnLCBuZXdIZWxwZXIpO1xuICAgICAgICAgICAgbmV3SGVscGVyLnNldENoaWxkKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBsYkNvbmZpZztcbiAgICAgICAgY2hpbGRUb1VwZGF0ZS51cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5leGl0SWRsZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQucmVzZXRCYWNrb2ZmKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5yZXNldEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvKiBOb3RlOiBzdGF0ZSB1cGRhdGVzIGFyZSBvbmx5IHByb3BhZ2F0ZWQgZnJvbSB0aGUgY2hpbGQgYmFsYW5jZXIgaWYgdGhhdFxuICAgICAgICAgKiBvYmplY3QgaXMgZXF1YWwgdG8gdGhpcy5jdXJyZW50Q2hpbGQgb3IgdGhpcy5wZW5kaW5nQ2hpbGQuIFNpbmNlIHRoaXNcbiAgICAgICAgICogZnVuY3Rpb24gc2V0cyBib3RoIG9mIHRob3NlIHRvIG51bGwsIG5vIGZ1cnRoZXIgc3RhdGUgdXBkYXRlcyB3aWxsXG4gICAgICAgICAqIG9jY3VyIGFmdGVyIHRoaXMgZnVuY3Rpb24gcmV0dXJucy4gKi9cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIgPSBDaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIiwibG9hZF9iYWxhbmNlcl8xIiwicmVxdWlyZSIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwiVFlQRV9OQU1FIiwiY29uc3RydWN0b3IiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImN1cnJlbnRDaGlsZCIsInBlbmRpbmdDaGlsZCIsImxhdGVzdENvbmZpZyIsIkNoaWxkUG9saWN5SGVscGVyIiwicGFyZW50IiwiY2hpbGQiLCJjcmVhdGVTdWJjaGFubmVsIiwic3ViY2hhbm5lbEFkZHJlc3MiLCJzdWJjaGFubmVsQXJncyIsInVwZGF0ZVN0YXRlIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJwaWNrZXIiLCJfYSIsImNhbGxlZEJ5UGVuZGluZ0NoaWxkIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJDT05ORUNUSU5HIiwiZGVzdHJveSIsImNhbGxlZEJ5Q3VycmVudENoaWxkIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImxhdGVzdENoaWxkIiwic2V0Q2hpbGQiLCJuZXdDaGlsZCIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZW1vdmVDaGFubmVsekNoaWxkIiwiY29uZmlnVXBkYXRlUmVxdWlyZXNOZXdQb2xpY3lJbnN0YW5jZSIsIm9sZENvbmZpZyIsIm5ld0NvbmZpZyIsImdldExvYWRCYWxhbmNlck5hbWUiLCJ1cGRhdGVBZGRyZXNzTGlzdCIsImFkZHJlc3NMaXN0IiwibGJDb25maWciLCJhdHRyaWJ1dGVzIiwiY2hpbGRUb1VwZGF0ZSIsIm5ld0hlbHBlciIsImNyZWF0ZUxvYWRCYWxhbmNlciIsImV4aXRJZGxlIiwicmVzZXRCYWNrb2ZmIiwiZ2V0VHlwZU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var _a;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nconst experimental_1 = __webpack_require__(/*! ./experimental */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"outlier_detection\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"outlier_detection\";\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : \"true\") === \"true\";\nconst defaultSuccessRateEjectionConfig = {\n    stdev_factor: 1900,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 100\n};\nconst defaultFailurePercentageEjectionConfig = {\n    threshold: 85,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 50\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n    if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n    }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    if (fieldName in obj) {\n        if (!(0, duration_1.isDuration)(obj[fieldName])) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n        }\n        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n        }\n    }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    validateFieldType(obj, fieldName, \"number\", objectName);\n    if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n    }\n}\nclass OutlierDetectionLoadBalancingConfig {\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy){\n        this.childPolicy = childPolicy;\n        if (childPolicy.length > 0 && childPolicy[0].getLoadBalancerName() === \"pick_first\") {\n            throw new Error(\"outlier_detection LB policy cannot have a pick_first child policy\");\n        }\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n        this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            interval: (0, duration_1.msToDuration)(this.intervalMs),\n            base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),\n            max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),\n            max_ejection_percent: this.maxEjectionPercent,\n            success_rate_ejection: this.successRateEjection,\n            failure_percentage_ejection: this.failurePercentageEjection,\n            child_policy: this.childPolicy.map((policy)=>policy.toJsonObject())\n        };\n    }\n    getIntervalMs() {\n        return this.intervalMs;\n    }\n    getBaseEjectionTimeMs() {\n        return this.baseEjectionTimeMs;\n    }\n    getMaxEjectionTimeMs() {\n        return this.maxEjectionTimeMs;\n    }\n    getMaxEjectionPercent() {\n        return this.maxEjectionPercent;\n    }\n    getSuccessRateEjectionConfig() {\n        return this.successRateEjection;\n    }\n    getFailurePercentageEjectionConfig() {\n        return this.failurePercentageEjection;\n    }\n    getChildPolicy() {\n        return this.childPolicy;\n    }\n    copyWithChildPolicy(childPolicy) {\n        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n    }\n    static createFromJson(obj) {\n        var _a;\n        validatePositiveDuration(obj, \"interval\");\n        validatePositiveDuration(obj, \"base_ejection_time\");\n        validatePositiveDuration(obj, \"max_ejection_time\");\n        validatePercentage(obj, \"max_ejection_percent\");\n        if (\"success_rate_ejection\" in obj) {\n            if (typeof obj.success_rate_ejection !== \"object\") {\n                throw new Error(\"outlier detection config success_rate_ejection must be an object\");\n            }\n            validateFieldType(obj.success_rate_ejection, \"stdev_factor\", \"number\", \"success_rate_ejection\");\n            validatePercentage(obj.success_rate_ejection, \"enforcement_percentage\", \"success_rate_ejection\");\n            validateFieldType(obj.success_rate_ejection, \"minimum_hosts\", \"number\", \"success_rate_ejection\");\n            validateFieldType(obj.success_rate_ejection, \"request_volume\", \"number\", \"success_rate_ejection\");\n        }\n        if (\"failure_percentage_ejection\" in obj) {\n            if (typeof obj.failure_percentage_ejection !== \"object\") {\n                throw new Error(\"outlier detection config failure_percentage_ejection must be an object\");\n            }\n            validatePercentage(obj.failure_percentage_ejection, \"threshold\", \"failure_percentage_ejection\");\n            validatePercentage(obj.failure_percentage_ejection, \"enforcement_percentage\", \"failure_percentage_ejection\");\n            validateFieldType(obj.failure_percentage_ejection, \"minimum_hosts\", \"number\", \"failure_percentage_ejection\");\n            validateFieldType(obj.failure_percentage_ejection, \"request_volume\", \"number\", \"failure_percentage_ejection\");\n        }\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n    }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, mapEntry){\n        super(childSubchannel);\n        this.mapEntry = mapEntry;\n        this.stateListeners = [];\n        this.ejected = false;\n        this.refCount = 0;\n        this.childSubchannelState = childSubchannel.getConnectivityState();\n        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState, keepaliveTime)=>{\n            this.childSubchannelState = newState;\n            if (!this.ejected) {\n                for (const listener of this.stateListeners){\n                    listener(this, previousState, newState, keepaliveTime);\n                }\n            }\n        });\n    }\n    getConnectivityState() {\n        if (this.ejected) {\n            return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n        } else {\n            return this.childSubchannelState;\n        }\n    }\n    /**\n     * Add a listener function to be called whenever the wrapper's\n     * connectivity state changes.\n     * @param listener\n     */ addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */ removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            if (this.mapEntry) {\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\n                if (index >= 0) {\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\n                }\n            }\n        }\n    }\n    eject() {\n        this.ejected = true;\n        for (const listener of this.stateListeners){\n            listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, -1);\n        }\n    }\n    uneject() {\n        this.ejected = false;\n        for (const listener of this.stateListeners){\n            listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState, -1);\n        }\n    }\n    getMapEntry() {\n        return this.mapEntry;\n    }\n    getWrappedSubchannel() {\n        return this.child;\n    }\n}\nfunction createEmptyBucket() {\n    return {\n        success: 0,\n        failure: 0\n    };\n}\nclass CallCounter {\n    constructor(){\n        this.activeBucket = createEmptyBucket();\n        this.inactiveBucket = createEmptyBucket();\n    }\n    addSuccess() {\n        this.activeBucket.success += 1;\n    }\n    addFailure() {\n        this.activeBucket.failure += 1;\n    }\n    switchBuckets() {\n        this.inactiveBucket = this.activeBucket;\n        this.activeBucket = createEmptyBucket();\n    }\n    getLastSuccesses() {\n        return this.inactiveBucket.success;\n    }\n    getLastFailures() {\n        return this.inactiveBucket.failure;\n    }\n}\nclass OutlierDetectionPicker {\n    constructor(wrappedPicker, countCalls){\n        this.wrappedPicker = wrappedPicker;\n        this.countCalls = countCalls;\n    }\n    pick(pickArgs) {\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n            const subchannelWrapper = wrappedPick.subchannel;\n            const mapEntry = subchannelWrapper.getMapEntry();\n            if (mapEntry) {\n                let onCallEnded = wrappedPick.onCallEnded;\n                if (this.countCalls) {\n                    onCallEnded = (statusCode)=>{\n                        var _a;\n                        if (statusCode === constants_1.Status.OK) {\n                            mapEntry.counter.addSuccess();\n                        } else {\n                            mapEntry.counter.addFailure();\n                        }\n                        (_a = wrappedPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(wrappedPick, statusCode);\n                    };\n                }\n                return Object.assign(Object.assign({}, wrappedPick), {\n                    subchannel: subchannelWrapper.getWrappedSubchannel(),\n                    onCallEnded: onCallEnded\n                });\n            } else {\n                return Object.assign(Object.assign({}, wrappedPick), {\n                    subchannel: subchannelWrapper.getWrappedSubchannel()\n                });\n            }\n        } else {\n            return wrappedPick;\n        }\n    }\n}\nclass OutlierDetectionLoadBalancer {\n    constructor(channelControlHelper){\n        this.addressMap = new Map();\n        this.latestConfig = null;\n        this.timerStartTime = null;\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {\n            createSubchannel: (subchannelAddress, subchannelArgs)=>{\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n                const mapEntry = this.addressMap.get((0, subchannel_address_1.subchannelAddressToString)(subchannelAddress));\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n                    // If the address is ejected, propagate that to the new subchannel wrapper\n                    subchannelWrapper.eject();\n                }\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n                return subchannelWrapper;\n            },\n            updateState: (connectivityState, picker)=>{\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\n                } else {\n                    channelControlHelper.updateState(connectivityState, picker);\n                }\n            }\n        }));\n        this.ejectionTimer = setInterval(()=>{}, 0);\n        clearInterval(this.ejectionTimer);\n    }\n    isCountingEnabled() {\n        return this.latestConfig !== null && (this.latestConfig.getSuccessRateEjectionConfig() !== null || this.latestConfig.getFailurePercentageEjectionConfig() !== null);\n    }\n    getCurrentEjectionPercent() {\n        let ejectionCount = 0;\n        for (const mapEntry of this.addressMap.values()){\n            if (mapEntry.currentEjectionTimestamp !== null) {\n                ejectionCount += 1;\n            }\n        }\n        return ejectionCount * 100 / this.addressMap.size;\n    }\n    runSuccessRateCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n        if (!successRateConfig) {\n            return;\n        }\n        trace(\"Running success rate check\");\n        // Step 1\n        const targetRequestVolume = successRateConfig.request_volume;\n        let addresesWithTargetVolume = 0;\n        const successRates = [];\n        for (const [address, mapEntry] of this.addressMap){\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace(\"Stats for \" + address + \": successes=\" + successes + \" failures=\" + failures + \" targetRequestVolume=\" + targetRequestVolume);\n            if (successes + failures >= targetRequestVolume) {\n                addresesWithTargetVolume += 1;\n                successRates.push(successes / (successes + failures));\n            }\n        }\n        trace(\"Found \" + addresesWithTargetVolume + \" success rate candidates; currentEjectionPercent=\" + this.getCurrentEjectionPercent() + \" successRates=[\" + successRates + \"]\");\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        const successRateMean = successRates.reduce((a, b)=>a + b) / successRates.length;\n        let successRateDeviationSum = 0;\n        for (const rate of successRates){\n            const deviation = rate - successRateMean;\n            successRateDeviationSum += deviation * deviation;\n        }\n        const successRateVariance = successRateDeviationSum / successRates.length;\n        const successRateStdev = Math.sqrt(successRateVariance);\n        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n        trace(\"stdev=\" + successRateStdev + \" ejectionThreshold=\" + ejectionThreshold);\n        // Step 3\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            // Step 3.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 3.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures < targetRequestVolume) {\n                continue;\n            }\n            // Step 3.iii\n            const successRate = successes / (successes + failures);\n            trace(\"Checking candidate \" + address + \" successRate=\" + successRate);\n            if (successRate < ejectionThreshold) {\n                const randomNumber = Math.random() * 100;\n                trace(\"Candidate \" + address + \" randomNumber=\" + randomNumber + \" enforcement_percentage=\" + successRateConfig.enforcement_percentage);\n                if (randomNumber < successRateConfig.enforcement_percentage) {\n                    trace(\"Ejecting candidate \" + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    runFailurePercentageCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n        if (!failurePercentageConfig) {\n            return;\n        }\n        trace(\"Running failure percentage check. threshold=\" + failurePercentageConfig.threshold + \" request volume threshold=\" + failurePercentageConfig.request_volume);\n        // Step 1\n        let addressesWithTargetVolume = 0;\n        for (const mapEntry of this.addressMap.values()){\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= failurePercentageConfig.request_volume) {\n                addressesWithTargetVolume += 1;\n            }\n        }\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            // Step 2.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 2.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace(\"Candidate successes=\" + successes + \" failures=\" + failures);\n            if (successes + failures < failurePercentageConfig.request_volume) {\n                continue;\n            }\n            // Step 2.iii\n            const failurePercentage = failures * 100 / (failures + successes);\n            if (failurePercentage > failurePercentageConfig.threshold) {\n                const randomNumber = Math.random() * 100;\n                trace(\"Candidate \" + address + \" randomNumber=\" + randomNumber + \" enforcement_percentage=\" + failurePercentageConfig.enforcement_percentage);\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n                    trace(\"Ejecting candidate \" + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    eject(mapEntry, ejectionTimestamp) {\n        mapEntry.currentEjectionTimestamp = new Date();\n        mapEntry.ejectionTimeMultiplier += 1;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers){\n            subchannelWrapper.eject();\n        }\n    }\n    uneject(mapEntry) {\n        mapEntry.currentEjectionTimestamp = null;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers){\n            subchannelWrapper.uneject();\n        }\n    }\n    switchAllBuckets() {\n        for (const mapEntry of this.addressMap.values()){\n            mapEntry.counter.switchBuckets();\n        }\n    }\n    startTimer(delayMs) {\n        var _a, _b;\n        this.ejectionTimer = setTimeout(()=>this.runChecks(), delayMs);\n        (_b = (_a = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    runChecks() {\n        const ejectionTimestamp = new Date();\n        trace(\"Ejection timer running\");\n        this.switchAllBuckets();\n        if (!this.latestConfig) {\n            return;\n        }\n        this.timerStartTime = ejectionTimestamp;\n        this.startTimer(this.latestConfig.getIntervalMs());\n        this.runSuccessRateCheck(ejectionTimestamp);\n        this.runFailurePercentageCheck(ejectionTimestamp);\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            if (mapEntry.currentEjectionTimestamp === null) {\n                if (mapEntry.ejectionTimeMultiplier > 0) {\n                    mapEntry.ejectionTimeMultiplier -= 1;\n                }\n            } else {\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n                returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n                if (returnTime < new Date()) {\n                    trace(\"Unejecting \" + address);\n                    this.uneject(mapEntry);\n                }\n            }\n        }\n    }\n    updateAddressList(addressList, lbConfig, attributes) {\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n            return;\n        }\n        const subchannelAddresses = new Set();\n        for (const address of addressList){\n            subchannelAddresses.add((0, subchannel_address_1.subchannelAddressToString)(address));\n        }\n        for (const address of subchannelAddresses){\n            if (!this.addressMap.has(address)) {\n                trace(\"Adding map entry for \" + address);\n                this.addressMap.set(address, {\n                    counter: new CallCounter(),\n                    currentEjectionTimestamp: null,\n                    ejectionTimeMultiplier: 0,\n                    subchannelWrappers: []\n                });\n            }\n        }\n        for (const key of this.addressMap.keys()){\n            if (!subchannelAddresses.has(key)) {\n                trace(\"Removing map entry for \" + key);\n                this.addressMap.delete(key);\n            }\n        }\n        const childPolicy = (0, load_balancer_1.getFirstUsableConfig)(lbConfig.getChildPolicy(), true);\n        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n        if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {\n            if (this.timerStartTime) {\n                trace(\"Previous timer existed. Replacing timer\");\n                clearTimeout(this.ejectionTimer);\n                const remainingDelay = lbConfig.getIntervalMs() - (new Date().getTime() - this.timerStartTime.getTime());\n                this.startTimer(remainingDelay);\n            } else {\n                trace(\"Starting new timer\");\n                this.timerStartTime = new Date();\n                this.startTimer(lbConfig.getIntervalMs());\n                this.switchAllBuckets();\n            }\n        } else {\n            trace(\"Counting disabled. Cancelling timer.\");\n            this.timerStartTime = null;\n            clearTimeout(this.ejectionTimer);\n            for (const mapEntry of this.addressMap.values()){\n                this.uneject(mapEntry);\n                mapEntry.ejectionTimeMultiplier = 0;\n            }\n        }\n        this.latestConfig = lbConfig;\n    }\n    exitIdle() {\n        this.childBalancer.exitIdle();\n    }\n    resetBackoff() {\n        this.childBalancer.resetBackoff();\n    }\n    destroy() {\n        clearTimeout(this.ejectionTimer);\n        this.childBalancer.destroy();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n    if (OUTLIER_DETECTION_ENABLED) {\n        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n    }\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-outlier-detection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxJQUFJQTtBQUNKQyw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSxvQ0FBb0MsR0FBR0EsMkNBQTJDLEdBQUcsS0FBSztBQUMxRyxNQUFNSyx1QkFBdUJDLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRyxpQkFBaUJILG1CQUFPQSxDQUFDLG9GQUFnQjtBQUMvQyxNQUFNSSxrQkFBa0JKLG1CQUFPQSxDQUFDLHNGQUFpQjtBQUNqRCxNQUFNSyxnQ0FBZ0NMLG1CQUFPQSxDQUFDLGtIQUErQjtBQUM3RSxNQUFNTSxXQUFXTixtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNTyx1QkFBdUJQLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNUSx5QkFBeUJSLG1CQUFPQSxDQUFDLG9HQUF3QjtBQUMvRCxNQUFNUyxVQUFVVCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNVSxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZkgsUUFBUUUsS0FBSyxDQUFDVixZQUFZWSxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQSxNQUFNRyxZQUFZO0FBQ2xCLE1BQU1DLDRCQUE0QixDQUFDLENBQUN6QixLQUFLMEIsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQywwQ0FBMEMsTUFBTSxRQUFRNUIsT0FBTyxLQUFLLElBQUlBLEtBQUssTUFBSyxNQUFPO0FBQzlJLE1BQU02QixtQ0FBbUM7SUFDckNDLGNBQWM7SUFDZEMsd0JBQXdCO0lBQ3hC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VixPQUFPM007SUFDWDtBQUNKO0FBQ0FyQixvQ0FBb0MsR0FBR0c7QUFDdkMsU0FBU0Q7SUFDTCxJQUFJb0IsMkJBQTJCO1FBQzFCLElBQUdiLGVBQWV3Tix3QkFBd0IsRUFBRTVNLFdBQVdsQiw4QkFBOEJDO0lBQzFGO0FBQ0o7QUFDQUosYUFBYSxHQUFHRSxPQUNoQiwyREFBMkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzPzAwNmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIgPSBleHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnID0gdm9pZCAwO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGR1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi9kdXJhdGlvblwiKTtcbmNvbnN0IGV4cGVyaW1lbnRhbF8xID0gcmVxdWlyZShcIi4vZXhwZXJpbWVudGFsXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWludGVyZmFjZVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnb3V0bGllcl9kZXRlY3Rpb24nO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBUWVBFX05BTUUgPSAnb3V0bGllcl9kZXRlY3Rpb24nO1xuY29uc3QgT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCA9ICgoX2EgPSBwcm9jZXNzLmVudi5HUlBDX0VYUEVSSU1FTlRBTF9FTkFCTEVfT1VUTElFUl9ERVRFQ1RJT04pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd0cnVlJykgPT09ICd0cnVlJztcbmNvbnN0IGRlZmF1bHRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnID0ge1xuICAgIHN0ZGV2X2ZhY3RvcjogMTkwMCxcbiAgICBlbmZvcmNlbWVudF9wZXJjZW50YWdlOiAxMDAsXG4gICAgbWluaW11bV9ob3N0czogNSxcbiAgICByZXF1ZXN0X3ZvbHVtZTogMTAwLFxufTtcbmNvbnN0IGRlZmF1bHRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnID0ge1xuICAgIHRocmVzaG9sZDogODUsXG4gICAgZW5mb3JjZW1lbnRfcGVyY2VudGFnZTogMTAwLFxuICAgIG1pbmltdW1faG9zdHM6IDUsXG4gICAgcmVxdWVzdF92b2x1bWU6IDUwLFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGRUeXBlKG9iaiwgZmllbGROYW1lLCBleHBlY3RlZFR5cGUsIG9iamVjdE5hbWUpIHtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpZWxkTmFtZV0gIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IGV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlfSwgZ290ICR7dHlwZW9mIG9ialtmaWVsZE5hbWVdfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosIGZpZWxkTmFtZSwgb2JqZWN0TmFtZSkge1xuICAgIGNvbnN0IGZ1bGxGaWVsZE5hbWUgPSBvYmplY3ROYW1lID8gYCR7b2JqZWN0TmFtZX0uJHtmaWVsZE5hbWV9YCA6IGZpZWxkTmFtZTtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaikge1xuICAgICAgICBpZiAoISgwLCBkdXJhdGlvbl8xLmlzRHVyYXRpb24pKG9ialtmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogZXhwZWN0ZWQgRHVyYXRpb24sIGdvdCAke3R5cGVvZiBvYmpbZmllbGROYW1lXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvYmpbZmllbGROYW1lXS5zZWNvbmRzID49IDAgJiZcbiAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdLnNlY29uZHMgPD0gMzE1NTc2MDAwMDAwICYmXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5uYW5vcyA+PSAwICYmXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5uYW5vcyA8PSA5OTk5OTk5OTkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiB2YWx1ZXMgb3V0IG9mIHJhbmdlIGZvciBub24tbmVnYXRpdmUgRHVhcmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCBmaWVsZE5hbWUsIG9iamVjdE5hbWUpIHtcbiAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsICdudW1iZXInLCBvYmplY3ROYW1lKTtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJiAhKG9ialtmaWVsZE5hbWVdID49IDAgJiYgb2JqW2ZpZWxkTmFtZV0gPD0gMTAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiB2YWx1ZSBvdXQgb2YgcmFuZ2UgZm9yIHBlcmNlbnRhZ2UgKDAtMTAwKWApO1xuICAgIH1cbn1cbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnZhbE1zLCBiYXNlRWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uVGltZU1zLCBtYXhFamVjdGlvblBlcmNlbnQsIHN1Y2Nlc3NSYXRlRWplY3Rpb24sIGZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24sIGNoaWxkUG9saWN5KSB7XG4gICAgICAgIHRoaXMuY2hpbGRQb2xpY3kgPSBjaGlsZFBvbGljeTtcbiAgICAgICAgaWYgKGNoaWxkUG9saWN5Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGNoaWxkUG9saWN5WzBdLmdldExvYWRCYWxhbmNlck5hbWUoKSA9PT0gJ3BpY2tfZmlyc3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXJfZGV0ZWN0aW9uIExCIHBvbGljeSBjYW5ub3QgaGF2ZSBhIHBpY2tfZmlyc3QgY2hpbGQgcG9saWN5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcnZhbE1zID0gaW50ZXJ2YWxNcyAhPT0gbnVsbCAmJiBpbnRlcnZhbE1zICE9PSB2b2lkIDAgPyBpbnRlcnZhbE1zIDogMTAwMDA7XG4gICAgICAgIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zID0gYmFzZUVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIGJhc2VFamVjdGlvblRpbWVNcyAhPT0gdm9pZCAwID8gYmFzZUVqZWN0aW9uVGltZU1zIDogMzAwMDA7XG4gICAgICAgIHRoaXMubWF4RWplY3Rpb25UaW1lTXMgPSBtYXhFamVjdGlvblRpbWVNcyAhPT0gbnVsbCAmJiBtYXhFamVjdGlvblRpbWVNcyAhPT0gdm9pZCAwID8gbWF4RWplY3Rpb25UaW1lTXMgOiAzMDAwMDA7XG4gICAgICAgIHRoaXMubWF4RWplY3Rpb25QZXJjZW50ID0gbWF4RWplY3Rpb25QZXJjZW50ICE9PSBudWxsICYmIG1heEVqZWN0aW9uUGVyY2VudCAhPT0gdm9pZCAwID8gbWF4RWplY3Rpb25QZXJjZW50IDogMTA7XG4gICAgICAgIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbiA9IHN1Y2Nlc3NSYXRlRWplY3Rpb25cbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZyksIHN1Y2Nlc3NSYXRlRWplY3Rpb24pIDogbnVsbDtcbiAgICAgICAgdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uID0gZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvblxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKSwgZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXRMb2FkQmFsYW5jZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbiAgICB0b0pzb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnZhbDogKDAsIGR1cmF0aW9uXzEubXNUb0R1cmF0aW9uKSh0aGlzLmludGVydmFsTXMpLFxuICAgICAgICAgICAgYmFzZV9lamVjdGlvbl90aW1lOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zKSxcbiAgICAgICAgICAgIG1heF9lamVjdGlvbl90aW1lOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMubWF4RWplY3Rpb25UaW1lTXMpLFxuICAgICAgICAgICAgbWF4X2VqZWN0aW9uX3BlcmNlbnQ6IHRoaXMubWF4RWplY3Rpb25QZXJjZW50LFxuICAgICAgICAgICAgc3VjY2Vzc19yYXRlX2VqZWN0aW9uOiB0aGlzLnN1Y2Nlc3NSYXRlRWplY3Rpb24sXG4gICAgICAgICAgICBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb246IHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbixcbiAgICAgICAgICAgIGNoaWxkX3BvbGljeTogdGhpcy5jaGlsZFBvbGljeS5tYXAocG9saWN5ID0+IHBvbGljeS50b0pzb25PYmplY3QoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEludGVydmFsTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVydmFsTXM7XG4gICAgfVxuICAgIGdldEJhc2VFamVjdGlvblRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zO1xuICAgIH1cbiAgICBnZXRNYXhFamVjdGlvblRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RWplY3Rpb25UaW1lTXM7XG4gICAgfVxuICAgIGdldE1heEVqZWN0aW9uUGVyY2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RWplY3Rpb25QZXJjZW50O1xuICAgIH1cbiAgICBnZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uO1xuICAgIH1cbiAgICBnZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uO1xuICAgIH1cbiAgICBnZXRDaGlsZFBvbGljeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRQb2xpY3k7XG4gICAgfVxuICAgIGNvcHlXaXRoQ2hpbGRQb2xpY3koY2hpbGRQb2xpY3kpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyh0aGlzLmludGVydmFsTXMsIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zLCB0aGlzLm1heEVqZWN0aW9uVGltZU1zLCB0aGlzLm1heEVqZWN0aW9uUGVyY2VudCwgdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uLCB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24sIGNoaWxkUG9saWN5KTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21Kc29uKG9iaikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdpbnRlcnZhbCcpO1xuICAgICAgICB2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24ob2JqLCAnYmFzZV9lamVjdGlvbl90aW1lJyk7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdtYXhfZWplY3Rpb25fdGltZScpO1xuICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCAnbWF4X2VqZWN0aW9uX3BlcmNlbnQnKTtcbiAgICAgICAgaWYgKCdzdWNjZXNzX3JhdGVfZWplY3Rpb24nIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0bGllciBkZXRlY3Rpb24gY29uZmlnIHN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ3N0ZGV2X2ZhY3RvcicsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ2VuZm9yY2VtZW50X3BlcmNlbnRhZ2UnLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAnbWluaW11bV9ob3N0cycsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAncmVxdWVzdF92b2x1bWUnLCAnbnVtYmVyJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAndGhyZXNob2xkJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICdlbmZvcmNlbWVudF9wZXJjZW50YWdlJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ21pbmltdW1faG9zdHMnLCAnbnVtYmVyJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ3JlcXVlc3Rfdm9sdW1lJywgJ251bWJlcicsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKG9iai5pbnRlcnZhbCA/ICgwLCBkdXJhdGlvbl8xLmR1cmF0aW9uVG9Ncykob2JqLmludGVydmFsKSA6IG51bGwsIG9iai5iYXNlX2VqZWN0aW9uX3RpbWUgPyAoMCwgZHVyYXRpb25fMS5kdXJhdGlvblRvTXMpKG9iai5iYXNlX2VqZWN0aW9uX3RpbWUpIDogbnVsbCwgb2JqLm1heF9lamVjdGlvbl90aW1lID8gKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKShvYmoubWF4X2VqZWN0aW9uX3RpbWUpIDogbnVsbCwgKF9hID0gb2JqLm1heF9lamVjdGlvbl9wZXJjZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLCBvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCBvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCBvYmouY2hpbGRfcG9saWN5Lm1hcChsb2FkX2JhbGFuY2VyXzEudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKSk7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyA9IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnO1xuY2xhc3MgT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyIGV4dGVuZHMgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMS5CYXNlU3ViY2hhbm5lbFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkU3ViY2hhbm5lbCwgbWFwRW50cnkpIHtcbiAgICAgICAgc3VwZXIoY2hpbGRTdWJjaGFubmVsKTtcbiAgICAgICAgdGhpcy5tYXBFbnRyeSA9IG1hcEVudHJ5O1xuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZSA9IGNoaWxkU3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgICAgICBjaGlsZFN1YmNoYW5uZWwuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcigoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGtlZXBhbGl2ZVRpbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5lamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBrZWVwYWxpdmVUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWplY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSB3cmFwcGVyJ3NcbiAgICAgKiBjb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIHByZXZpb3VzbHkgYWRkZWQgd2l0aCBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQSByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHBhc3NlZCB0b1xuICAgICAqICAgICBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKi9cbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVySW5kZXggPSB0aGlzLnN0YXRlTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAobGlzdGVuZXJJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzLnNwbGljZShsaXN0ZW5lckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XG4gICAgICAgIHRoaXMucmVmQ291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXBFbnRyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlamVjdCgpIHtcbiAgICAgICAgdGhpcy5lamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcih0aGlzLCB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgLTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuZWplY3QoKSB7XG4gICAgICAgIHRoaXMuZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlLCAtMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWFwRW50cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcEVudHJ5O1xuICAgIH1cbiAgICBnZXRXcmFwcGVkU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQ7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlCdWNrZXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogMCxcbiAgICAgICAgZmFpbHVyZTogMCxcbiAgICB9O1xufVxuY2xhc3MgQ2FsbENvdW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgICAgIHRoaXMuaW5hY3RpdmVCdWNrZXQgPSBjcmVhdGVFbXB0eUJ1Y2tldCgpO1xuICAgIH1cbiAgICBhZGRTdWNjZXNzKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldC5zdWNjZXNzICs9IDE7XG4gICAgfVxuICAgIGFkZEZhaWx1cmUoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0LmZhaWx1cmUgKz0gMTtcbiAgICB9XG4gICAgc3dpdGNoQnVja2V0cygpIHtcbiAgICAgICAgdGhpcy5pbmFjdGl2ZUJ1Y2tldCA9IHRoaXMuYWN0aXZlQnVja2V0O1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgfVxuICAgIGdldExhc3RTdWNjZXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluYWN0aXZlQnVja2V0LnN1Y2Nlc3M7XG4gICAgfVxuICAgIGdldExhc3RGYWlsdXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5hY3RpdmVCdWNrZXQuZmFpbHVyZTtcbiAgICB9XG59XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uUGlja2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih3cmFwcGVkUGlja2VyLCBjb3VudENhbGxzKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZFBpY2tlciA9IHdyYXBwZWRQaWNrZXI7XG4gICAgICAgIHRoaXMuY291bnRDYWxscyA9IGNvdW50Q2FsbHM7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZFBpY2sgPSB0aGlzLndyYXBwZWRQaWNrZXIucGljayhwaWNrQXJncyk7XG4gICAgICAgIGlmICh3cmFwcGVkUGljay5waWNrUmVzdWx0VHlwZSA9PT0gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyID0gd3JhcHBlZFBpY2suc3ViY2hhbm5lbDtcbiAgICAgICAgICAgIGNvbnN0IG1hcEVudHJ5ID0gc3ViY2hhbm5lbFdyYXBwZXIuZ2V0TWFwRW50cnkoKTtcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeSkge1xuICAgICAgICAgICAgICAgIGxldCBvbkNhbGxFbmRlZCA9IHdyYXBwZWRQaWNrLm9uQ2FsbEVuZGVkO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvdW50Q2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DYWxsRW5kZWQgPSBzdGF0dXNDb2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBFbnRyeS5jb3VudGVyLmFkZFN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuYWRkRmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gd3JhcHBlZFBpY2sub25DYWxsRW5kZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHdyYXBwZWRQaWNrLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JhcHBlZFBpY2spLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxXcmFwcGVyLmdldFdyYXBwZWRTdWJjaGFubmVsKCksIG9uQ2FsbEVuZGVkOiBvbkNhbGxFbmRlZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyYXBwZWRQaWNrKSwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsV3JhcHBlci5nZXRXcmFwcGVkU3ViY2hhbm5lbCgpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRQaWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIgPSBuZXcgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyKCgwLCBleHBlcmltZW50YWxfMS5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKShjaGFubmVsQ29udHJvbEhlbHBlciwge1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3ViY2hhbm5lbCA9IGNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBFbnRyeSA9IHRoaXMuYWRkcmVzc01hcC5nZXQoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKHN1YmNoYW5uZWxBZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSBuZXcgT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyKG9yaWdpbmFsU3ViY2hhbm5lbCwgbWFwRW50cnkpO1xuICAgICAgICAgICAgICAgIGlmICgobWFwRW50cnkgPT09IG51bGwgfHwgbWFwRW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFkZHJlc3MgaXMgZWplY3RlZCwgcHJvcGFnYXRlIHRoYXQgdG8gdGhlIG5ldyBzdWJjaGFubmVsIHdyYXBwZXJcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRW50cnkgPT09IG51bGwgfHwgbWFwRW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5wdXNoKHN1YmNoYW5uZWxXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbFdyYXBwZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgbmV3IE91dGxpZXJEZXRlY3Rpb25QaWNrZXIocGlja2VyLCB0aGlzLmlzQ291bnRpbmdFbmFibGVkKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5lamVjdGlvblRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmVqZWN0aW9uVGltZXIpO1xuICAgIH1cbiAgICBpc0NvdW50aW5nRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxhdGVzdENvbmZpZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgKHRoaXMubGF0ZXN0Q29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSAhPT0gbnVsbCkpO1xuICAgIH1cbiAgICBnZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkge1xuICAgICAgICBsZXQgZWplY3Rpb25Db3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWplY3Rpb25Db3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZWplY3Rpb25Db3VudCAqIDEwMCkgLyB0aGlzLmFkZHJlc3NNYXAuc2l6ZTtcbiAgICB9XG4gICAgcnVuU3VjY2Vzc1JhdGVDaGVjayhlamVjdGlvblRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoIXRoaXMubGF0ZXN0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVDb25maWcgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCk7XG4gICAgICAgIGlmICghc3VjY2Vzc1JhdGVDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUnVubmluZyBzdWNjZXNzIHJhdGUgY2hlY2snKTtcbiAgICAgICAgLy8gU3RlcCAxXG4gICAgICAgIGNvbnN0IHRhcmdldFJlcXVlc3RWb2x1bWUgPSBzdWNjZXNzUmF0ZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZTtcbiAgICAgICAgbGV0IGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSA9IDA7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBtYXBFbnRyeV0gb2YgdGhpcy5hZGRyZXNzTWFwKSB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIHRyYWNlKCdTdGF0cyBmb3IgJyArXG4gICAgICAgICAgICAgICAgYWRkcmVzcyArXG4gICAgICAgICAgICAgICAgJzogc3VjY2Vzc2VzPScgK1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NlcyArXG4gICAgICAgICAgICAgICAgJyBmYWlsdXJlcz0nICtcbiAgICAgICAgICAgICAgICBmYWlsdXJlcyArXG4gICAgICAgICAgICAgICAgJyB0YXJnZXRSZXF1ZXN0Vm9sdW1lPScgK1xuICAgICAgICAgICAgICAgIHRhcmdldFJlcXVlc3RWb2x1bWUpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzID49IHRhcmdldFJlcXVlc3RWb2x1bWUpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgKz0gMTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZXMucHVzaChzdWNjZXNzZXMgLyAoc3VjY2Vzc2VzICsgZmFpbHVyZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnRm91bmQgJyArXG4gICAgICAgICAgICBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgK1xuICAgICAgICAgICAgJyBzdWNjZXNzIHJhdGUgY2FuZGlkYXRlczsgY3VycmVudEVqZWN0aW9uUGVyY2VudD0nICtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpICtcbiAgICAgICAgICAgICcgc3VjY2Vzc1JhdGVzPVsnICtcbiAgICAgICAgICAgIHN1Y2Nlc3NSYXRlcyArXG4gICAgICAgICAgICAnXScpO1xuICAgICAgICBpZiAoYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lIDwgc3VjY2Vzc1JhdGVDb25maWcubWluaW11bV9ob3N0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMlxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZU1lYW4gPSBzdWNjZXNzUmF0ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyBzdWNjZXNzUmF0ZXMubGVuZ3RoO1xuICAgICAgICBsZXQgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHJhdGUgb2Ygc3VjY2Vzc1JhdGVzKSB7XG4gICAgICAgICAgICBjb25zdCBkZXZpYXRpb24gPSByYXRlIC0gc3VjY2Vzc1JhdGVNZWFuO1xuICAgICAgICAgICAgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gKz0gZGV2aWF0aW9uICogZGV2aWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlVmFyaWFuY2UgPSBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSAvIHN1Y2Nlc3NSYXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlU3RkZXYgPSBNYXRoLnNxcnQoc3VjY2Vzc1JhdGVWYXJpYW5jZSk7XG4gICAgICAgIGNvbnN0IGVqZWN0aW9uVGhyZXNob2xkID0gc3VjY2Vzc1JhdGVNZWFuIC1cbiAgICAgICAgICAgIHN1Y2Nlc3NSYXRlU3RkZXYgKiAoc3VjY2Vzc1JhdGVDb25maWcuc3RkZXZfZmFjdG9yIC8gMTAwMCk7XG4gICAgICAgIHRyYWNlKCdzdGRldj0nICsgc3VjY2Vzc1JhdGVTdGRldiArICcgZWplY3Rpb25UaHJlc2hvbGQ9JyArIGVqZWN0aW9uVGhyZXNob2xkKTtcbiAgICAgICAgLy8gU3RlcCAzXG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBTdGVwIDMuaVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpID49XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMy5paVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPCB0YXJnZXRSZXF1ZXN0Vm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIDMuaWlpXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9IHN1Y2Nlc3NlcyAvIChzdWNjZXNzZXMgKyBmYWlsdXJlcyk7XG4gICAgICAgICAgICB0cmFjZSgnQ2hlY2tpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzICsgJyBzdWNjZXNzUmF0ZT0nICsgc3VjY2Vzc1JhdGUpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NSYXRlIDwgZWplY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgK1xuICAgICAgICAgICAgICAgICAgICAnIHJhbmRvbU51bWJlcj0nICtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tTnVtYmVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBlbmZvcmNlbWVudF9wZXJjZW50YWdlPScgK1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZG9tTnVtYmVyIDwgc3VjY2Vzc1JhdGVDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRWplY3RpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5GYWlsdXJlUGVyY2VudGFnZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKTtcbiAgICAgICAgaWYgKCFmYWlsdXJlUGVyY2VudGFnZUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSdW5uaW5nIGZhaWx1cmUgcGVyY2VudGFnZSBjaGVjay4gdGhyZXNob2xkPScgK1xuICAgICAgICAgICAgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcudGhyZXNob2xkICtcbiAgICAgICAgICAgICcgcmVxdWVzdCB2b2x1bWUgdGhyZXNob2xkPScgK1xuICAgICAgICAgICAgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpO1xuICAgICAgICAvLyBTdGVwIDFcbiAgICAgICAgbGV0IGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPj0gZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgPCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5taW5pbXVtX2hvc3RzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RlcCAyXG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBTdGVwIDIuaVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpID49XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMi5paVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICB0cmFjZSgnQ2FuZGlkYXRlIHN1Y2Nlc3Nlcz0nICsgc3VjY2Vzc2VzICsgJyBmYWlsdXJlcz0nICsgZmFpbHVyZXMpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMi5paWlcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVQZXJjZW50YWdlID0gKGZhaWx1cmVzICogMTAwKSAvIChmYWlsdXJlcyArIHN1Y2Nlc3Nlcyk7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZVBlcmNlbnRhZ2UgPiBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgK1xuICAgICAgICAgICAgICAgICAgICAnIHJhbmRvbU51bWJlcj0nICtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tTnVtYmVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBlbmZvcmNlbWVudF9wZXJjZW50YWdlPScgK1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZG9tTnVtYmVyIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRWplY3RpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApIHtcbiAgICAgICAgbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciArPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyIG9mIG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmVqZWN0KG1hcEVudHJ5KSB7XG4gICAgICAgIG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgb2YgbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlci51bmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoQWxsQnVja2V0cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmFkZHJlc3NNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuc3dpdGNoQnVja2V0cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VGltZXIoZGVsYXlNcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmVqZWN0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucnVuQ2hlY2tzKCksIGRlbGF5TXMpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmVqZWN0aW9uVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIHJ1bkNoZWNrcygpIHtcbiAgICAgICAgY29uc3QgZWplY3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0cmFjZSgnRWplY3Rpb24gdGltZXIgcnVubmluZycpO1xuICAgICAgICB0aGlzLnN3aXRjaEFsbEJ1Y2tldHMoKTtcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBlamVjdGlvblRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWVyKHRoaXMubGF0ZXN0Q29uZmlnLmdldEludGVydmFsTXMoKSk7XG4gICAgICAgIHRoaXMucnVuU3VjY2Vzc1JhdGVDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgIHRoaXMucnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlRWplY3Rpb25UaW1lTXMgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRCYXNlRWplY3Rpb25UaW1lTXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhFamVjdGlvblRpbWVNcyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldE1heEVqZWN0aW9uVGltZU1zKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVGltZSA9IG5ldyBEYXRlKG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcC5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIHJldHVyblRpbWUuc2V0TWlsbGlzZWNvbmRzKHJldHVyblRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihiYXNlRWplY3Rpb25UaW1lTXMgKiBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyLCBNYXRoLm1heChiYXNlRWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uVGltZU1zKSkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UaW1lIDwgbmV3IERhdGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnVW5lamVjdGluZyAnICsgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5lamVjdChtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZywgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIShsYkNvbmZpZyBpbnN0YW5jZW9mIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWxBZGRyZXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBhZGRyZXNzTGlzdCkge1xuICAgICAgICAgICAgc3ViY2hhbm5lbEFkZHJlc3Nlcy5hZGQoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2Ygc3ViY2hhbm5lbEFkZHJlc3Nlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkZHJlc3NNYXAuaGFzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ0FkZGluZyBtYXAgZW50cnkgZm9yICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZHJlc3NNYXAuc2V0KGFkZHJlc3MsIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcjogbmV3IENhbGxDb3VudGVyKCksXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFamVjdGlvblRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZWplY3Rpb25UaW1lTXVsdGlwbGllcjogMCxcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXJzOiBbXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmFkZHJlc3NNYXAua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAoIXN1YmNoYW5uZWxBZGRyZXNzZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUmVtb3ZpbmcgbWFwIGVudHJ5IGZvciAnICsga2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZHJlc3NNYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRQb2xpY3kgPSAoMCwgbG9hZF9iYWxhbmNlcl8xLmdldEZpcnN0VXNhYmxlQ29uZmlnKShsYkNvbmZpZy5nZXRDaGlsZFBvbGljeSgpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLnVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBjaGlsZFBvbGljeSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChsYkNvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCkgfHxcbiAgICAgICAgICAgIGxiQ29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUHJldmlvdXMgdGltZXIgZXhpc3RlZC4gUmVwbGFjaW5nIHRpbWVyJyk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGVsYXkgPSBsYkNvbmZpZy5nZXRJbnRlcnZhbE1zKCkgLVxuICAgICAgICAgICAgICAgICAgICAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnRpbWVyU3RhcnRUaW1lLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKHJlbWFpbmluZ0RlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdTdGFydGluZyBuZXcgdGltZXInKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZXIobGJDb25maWcuZ2V0SW50ZXJ2YWxNcygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaEFsbEJ1Y2tldHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYWNlKCdDb3VudGluZyBkaXNhYmxlZC4gQ2FuY2VsbGluZyB0aW1lci4nKTtcbiAgICAgICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5lamVjdChtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBsYkNvbmZpZztcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5yZXNldEJhY2tvZmYoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciA9IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBpZiAoT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCkge1xuICAgICAgICAoMCwgZXhwZXJpbWVudGFsXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUsIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIsIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJfYSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2V0dXAiLCJPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyIiwiT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWciLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsImR1cmF0aW9uXzEiLCJleHBlcmltZW50YWxfMSIsImxvYWRfYmFsYW5jZXJfMSIsImxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xIiwicGlja2VyXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsInN1YmNoYW5uZWxfaW50ZXJmYWNlXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIk9VVExJRVJfREVURUNUSU9OX0VOQUJMRUQiLCJwcm9jZXNzIiwiZW52IiwiR1JQQ19FWFBFUklNRU5UQUxfRU5BQkxFX09VVExJRVJfREVURUNUSU9OIiwiZGVmYXVsdFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWciLCJzdGRldl9mYWN0b3IiLCJlbmZvcmNlbWVudF9wZXJjZW50YWdlIiwibWluaW11bV9ob3N0cyIsInJlcXVlc3Rfdm9sdW1lIiwiZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWciLCJ0aHJlc2hvbGQiLCJ2YWxpZGF0ZUZpZWxkVHlwZSIsIm9iaiIsImZpZWxkTmFtZSIsImV4cGVjdGVkVHlwZSIsIm9iamVjdE5hbWUiLCJmdWxsRmllbGROYW1lIiwiRXJyb3IiLCJ2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24iLCJpc0R1cmF0aW9uIiwic2Vjb25kcyIsIm5hbm9zIiwidmFsaWRhdGVQZXJjZW50YWdlIiwiY29uc3RydWN0b3IiLCJpbnRlcnZhbE1zIiwiYmFzZUVqZWN0aW9uVGltZU1zIiwibWF4RWplY3Rpb25UaW1lTXMiLCJtYXhFamVjdGlvblBlcmNlbnQiLCJzdWNjZXNzUmF0ZUVqZWN0aW9uIiwiZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiIsImNoaWxkUG9saWN5IiwibGVuZ3RoIiwiZ2V0TG9hZEJhbGFuY2VyTmFtZSIsImFzc2lnbiIsInRvSnNvbk9iamVjdCIsImludGVydmFsIiwibXNUb0R1cmF0aW9uIiwiYmFzZV9lamVjdGlvbl90aW1lIiwibWF4X2VqZWN0aW9uX3RpbWUiLCJtYXhfZWplY3Rpb25fcGVyY2VudCIsInN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiIsImZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiIsImNoaWxkX3BvbGljeSIsIm1hcCIsInBvbGljeSIsImdldEludGVydmFsTXMiLCJnZXRCYXNlRWplY3Rpb25UaW1lTXMiLCJnZXRNYXhFamVjdGlvblRpbWVNcyIsImdldE1heEVqZWN0aW9uUGVyY2VudCIsImdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWciLCJnZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnIiwiZ2V0Q2hpbGRQb2xpY3kiLCJjb3B5V2l0aENoaWxkUG9saWN5IiwiY3JlYXRlRnJvbUpzb24iLCJkdXJhdGlvblRvTXMiLCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWciLCJPdXRsaWVyRGV0ZWN0aW9uU3ViY2hhbm5lbFdyYXBwZXIiLCJCYXNlU3ViY2hhbm5lbFdyYXBwZXIiLCJjaGlsZFN1YmNoYW5uZWwiLCJtYXBFbnRyeSIsInN0YXRlTGlzdGVuZXJzIiwiZWplY3RlZCIsInJlZkNvdW50IiwiY2hpbGRTdWJjaGFubmVsU3RhdGUiLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsImFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJzdWJjaGFubmVsIiwicHJldmlvdXNTdGF0ZSIsIm5ld1N0YXRlIiwia2VlcGFsaXZlVGltZSIsImxpc3RlbmVyIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJUUkFOU0lFTlRfRkFJTFVSRSIsInB1c2giLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwibGlzdGVuZXJJbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJyZWYiLCJjaGlsZCIsInVucmVmIiwiaW5kZXgiLCJzdWJjaGFubmVsV3JhcHBlcnMiLCJlamVjdCIsInVuZWplY3QiLCJnZXRNYXBFbnRyeSIsImdldFdyYXBwZWRTdWJjaGFubmVsIiwiY3JlYXRlRW1wdHlCdWNrZXQiLCJzdWNjZXNzIiwiZmFpbHVyZSIsIkNhbGxDb3VudGVyIiwiYWN0aXZlQnVja2V0IiwiaW5hY3RpdmVCdWNrZXQiLCJhZGRTdWNjZXNzIiwiYWRkRmFpbHVyZSIsInN3aXRjaEJ1Y2tldHMiLCJnZXRMYXN0U3VjY2Vzc2VzIiwiZ2V0TGFzdEZhaWx1cmVzIiwiT3V0bGllckRldGVjdGlvblBpY2tlciIsIndyYXBwZWRQaWNrZXIiLCJjb3VudENhbGxzIiwicGljayIsInBpY2tBcmdzIiwid3JhcHBlZFBpY2siLCJwaWNrUmVzdWx0VHlwZSIsIlBpY2tSZXN1bHRUeXBlIiwiQ09NUExFVEUiLCJzdWJjaGFubmVsV3JhcHBlciIsIm9uQ2FsbEVuZGVkIiwic3RhdHVzQ29kZSIsIlN0YXR1cyIsIk9LIiwiY291bnRlciIsImNhbGwiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImFkZHJlc3NNYXAiLCJNYXAiLCJsYXRlc3RDb25maWciLCJ0aW1lclN0YXJ0VGltZSIsImNoaWxkQmFsYW5jZXIiLCJDaGlsZExvYWRCYWxhbmNlckhhbmRsZXIiLCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyIiwiY3JlYXRlU3ViY2hhbm5lbCIsInN1YmNoYW5uZWxBZGRyZXNzIiwic3ViY2hhbm5lbEFyZ3MiLCJvcmlnaW5hbFN1YmNoYW5uZWwiLCJnZXQiLCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nIiwiY3VycmVudEVqZWN0aW9uVGltZXN0YW1wIiwidXBkYXRlU3RhdGUiLCJjb25uZWN0aXZpdHlTdGF0ZSIsInBpY2tlciIsIlJFQURZIiwiaXNDb3VudGluZ0VuYWJsZWQiLCJlamVjdGlvblRpbWVyIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCIsImVqZWN0aW9uQ291bnQiLCJ2YWx1ZXMiLCJzaXplIiwicnVuU3VjY2Vzc1JhdGVDaGVjayIsImVqZWN0aW9uVGltZXN0YW1wIiwic3VjY2Vzc1JhdGVDb25maWciLCJ0YXJnZXRSZXF1ZXN0Vm9sdW1lIiwiYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lIiwic3VjY2Vzc1JhdGVzIiwiYWRkcmVzcyIsInN1Y2Nlc3NlcyIsImZhaWx1cmVzIiwic3VjY2Vzc1JhdGVNZWFuIiwicmVkdWNlIiwiYSIsImIiLCJzdWNjZXNzUmF0ZURldmlhdGlvblN1bSIsInJhdGUiLCJkZXZpYXRpb24iLCJzdWNjZXNzUmF0ZVZhcmlhbmNlIiwic3VjY2Vzc1JhdGVTdGRldiIsIk1hdGgiLCJzcXJ0IiwiZWplY3Rpb25UaHJlc2hvbGQiLCJlbnRyaWVzIiwic3VjY2Vzc1JhdGUiLCJyYW5kb21OdW1iZXIiLCJyYW5kb20iLCJydW5GYWlsdXJlUGVyY2VudGFnZUNoZWNrIiwiZmFpbHVyZVBlcmNlbnRhZ2VDb25maWciLCJhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lIiwiZmFpbHVyZVBlcmNlbnRhZ2UiLCJEYXRlIiwiZWplY3Rpb25UaW1lTXVsdGlwbGllciIsInN3aXRjaEFsbEJ1Y2tldHMiLCJzdGFydFRpbWVyIiwiZGVsYXlNcyIsIl9iIiwic2V0VGltZW91dCIsInJ1bkNoZWNrcyIsInJldHVyblRpbWUiLCJnZXRUaW1lIiwic2V0TWlsbGlzZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwibWluIiwibWF4IiwidXBkYXRlQWRkcmVzc0xpc3QiLCJhZGRyZXNzTGlzdCIsImxiQ29uZmlnIiwiYXR0cmlidXRlcyIsInN1YmNoYW5uZWxBZGRyZXNzZXMiLCJTZXQiLCJhZGQiLCJoYXMiLCJzZXQiLCJrZXkiLCJrZXlzIiwiZGVsZXRlIiwiZ2V0Rmlyc3RVc2FibGVDb25maWciLCJjbGVhclRpbWVvdXQiLCJyZW1haW5pbmdEZWxheSIsImV4aXRJZGxlIiwicmVzZXRCYWNrb2ZmIiwiZGVzdHJveSIsImdldFR5cGVOYW1lIiwicmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.PickFirstLoadBalancer = exports.shuffled = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"pick_first\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"pick_first\";\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */ const CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n    constructor(shuffleAddressList){\n        this.shuffleAddressList = shuffleAddressList;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {\n                shuffleAddressList: this.shuffleAddressList\n            }\n        };\n    }\n    getShuffleAddressList() {\n        return this.shuffleAddressList;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        if (\"shuffleAddressList\" in obj && !(typeof obj.shuffleAddressList === \"boolean\")) {\n            throw new Error(\"pick_first config field shuffleAddressList must be a boolean if provided\");\n        }\n        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n    }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */ class PickFirstPicker {\n    constructor(subchannel){\n        this.subchannel = subchannel;\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: this.subchannel,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n}\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */ function shuffled(list) {\n    const result = list.slice();\n    for(let i = result.length - 1; i > 1; i--){\n        const j = Math.floor(Math.random() * (i + 1));\n        const temp = result[i];\n        result[i] = result[j];\n        result[j] = temp;\n    }\n    return result;\n}\nexports.shuffled = shuffled;\nclass PickFirstLoadBalancer {\n    /**\n     * Load balancer that attempts to connect to each backend in the address list\n     * in order, and picks the first one that connects, using it for every\n     * request.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     */ constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        /**\n         * The list of subchannels this load balancer is currently attempting to\n         * connect to.\n         */ this.children = [];\n        /**\n         * The current connectivity state of the load balancer.\n         */ this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The index within the `subchannels` array of the subchannel with the most\n         * recently started connection attempt.\n         */ this.currentSubchannelIndex = 0;\n        /**\n         * The currently picked subchannel used for making calls. Populated if\n         * and only if the load balancer's current state is READY. In that case,\n         * the subchannel's current state is also READY.\n         */ this.currentPick = null;\n        /**\n         * Listener callback attached to each subchannel in the `subchannels` list\n         * while establishing a connection.\n         */ this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage)=>{\n            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\n        };\n        this.triedAllSubchannels = false;\n        /**\n         * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n         * subchannels have failed to connect at least once, and it stays in that\n         * mode until a connection attempt is successful. While in sticky TF mode,\n         * the LB policy continuously attempts to connect to all of its subchannels.\n         */ this.stickyTransientFailureMode = false;\n        /**\n         * Indicates whether we called channelControlHelper.requestReresolution since\n         * the last call to updateAddressList\n         */ this.requestedResolutionSinceLastUpdate = false;\n        /**\n         * The most recent error reported by any subchannel as it transitioned to\n         * TRANSIENT_FAILURE.\n         */ this.lastError = null;\n        this.latestAddressList = null;\n        this.connectionDelayTimeout = setTimeout(()=>{}, 0);\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    allChildrenHaveReportedTF() {\n        return this.children.every((child)=>child.hasReportedTransientFailure);\n    }\n    calculateAndReportNewState() {\n        if (this.currentPick) {\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));\n        } else if (this.children.length === 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        } else {\n            if (this.stickyTransientFailureMode) {\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                    details: `No connection established. Last error: ${this.lastError}`\n                }));\n            } else {\n                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n            }\n        }\n    }\n    requestReresolution() {\n        this.requestedResolutionSinceLastUpdate = true;\n        this.channelControlHelper.requestReresolution();\n    }\n    maybeEnterStickyTransientFailureMode() {\n        if (!this.allChildrenHaveReportedTF()) {\n            return;\n        }\n        if (!this.requestedResolutionSinceLastUpdate) {\n            /* Each time we get an update we reset each subchannel's\n             * hasReportedTransientFailure flag, so the next time we get to this\n             * point after that, each subchannel has reported TRANSIENT_FAILURE\n             * at least once since then. That is the trigger for requesting\n             * reresolution, whether or not the LB policy is already in sticky TF\n             * mode. */ this.requestReresolution();\n        }\n        if (this.stickyTransientFailureMode) {\n            return;\n        }\n        this.stickyTransientFailureMode = true;\n        for (const { subchannel } of this.children){\n            subchannel.startConnecting();\n        }\n        this.calculateAndReportNewState();\n    }\n    removeCurrentPick() {\n        if (this.currentPick !== null) {\n            /* Unref can cause a state change, which can cause a change in the value\n             * of this.currentPick, so we hold a local reference to make sure that\n             * does not impact this function. */ const currentPick = this.currentPick;\n            this.currentPick = null;\n            currentPick.unref();\n            currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n        }\n    }\n    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {\n        var _a;\n        if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\n                this.removeCurrentPick();\n                this.calculateAndReportNewState();\n                this.requestReresolution();\n            }\n            return;\n        }\n        for (const [index, child] of this.children.entries()){\n            if (subchannel.realSubchannelEquals(child.subchannel)) {\n                if (newState === connectivity_state_1.ConnectivityState.READY) {\n                    this.pickSubchannel(child.subchannel);\n                }\n                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    child.hasReportedTransientFailure = true;\n                    if (errorMessage) {\n                        this.lastError = errorMessage;\n                    }\n                    this.maybeEnterStickyTransientFailureMode();\n                    if (index === this.currentSubchannelIndex) {\n                        this.startNextSubchannelConnecting(index + 1);\n                    }\n                }\n                child.subchannel.startConnecting();\n                return;\n            }\n        }\n    }\n    startNextSubchannelConnecting(startIndex) {\n        clearTimeout(this.connectionDelayTimeout);\n        if (this.triedAllSubchannels) {\n            return;\n        }\n        for (const [index, child] of this.children.entries()){\n            if (index >= startIndex) {\n                const subchannelState = child.subchannel.getConnectivityState();\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                    this.startConnecting(index);\n                    return;\n                }\n            }\n        }\n        this.triedAllSubchannels = true;\n        this.maybeEnterStickyTransientFailureMode();\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */ startConnecting(subchannelIndex) {\n        var _a, _b;\n        clearTimeout(this.connectionDelayTimeout);\n        this.currentSubchannelIndex = subchannelIndex;\n        if (this.children[subchannelIndex].subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n            trace(\"Start connecting to subchannel with address \" + this.children[subchannelIndex].subchannel.getAddress());\n            process.nextTick(()=>{\n                var _a;\n                (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();\n            });\n        }\n        this.connectionDelayTimeout = (_b = (_a = setTimeout(()=>{\n            this.startNextSubchannelConnecting(subchannelIndex + 1);\n        }, CONNECTION_DELAY_INTERVAL_MS)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    pickSubchannel(subchannel) {\n        if (this.currentPick && subchannel.realSubchannelEquals(this.currentPick)) {\n            return;\n        }\n        trace(\"Pick subchannel with address \" + subchannel.getAddress());\n        this.stickyTransientFailureMode = false;\n        if (this.currentPick !== null) {\n            this.currentPick.unref();\n            this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\n            this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n        }\n        this.currentPick = subchannel;\n        subchannel.ref();\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        this.resetSubchannelList();\n        clearTimeout(this.connectionDelayTimeout);\n        this.calculateAndReportNewState();\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const child of this.children){\n            if (child.subchannel !== this.currentPick) {\n                /* The connectivity state listener is the same whether the subchannel\n                 * is in the list of children or it is the currentPick, so if it is in\n                 * both, removing it here would cause problems. In particular, that\n                 * always happens immediately after the subchannel is picked. */ child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            }\n            /* Refs are counted independently for the children list and the\n             * currentPick, so we call unref whether or not the child is the\n             * currentPick. Channelz child references are also refcounted, so\n             * removeChannelzChild can be handled the same way. */ child.subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\n        }\n        this.currentSubchannelIndex = 0;\n        this.children = [];\n        this.triedAllSubchannels = false;\n        this.requestedResolutionSinceLastUpdate = false;\n    }\n    connectToAddressList(addressList) {\n        const newChildrenList = addressList.map((address)=>({\n                subchannel: this.channelControlHelper.createSubchannel(address, {}),\n                hasReportedTransientFailure: false\n            }));\n        /* Ref each subchannel before resetting the list, to ensure that\n         * subchannels shared between the list don't drop to 0 refs during the\n         * transition. */ for (const { subchannel } of newChildrenList){\n            subchannel.ref();\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        }\n        this.resetSubchannelList();\n        this.children = newChildrenList;\n        for (const { subchannel } of this.children){\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                return;\n            }\n        }\n        for (const child of this.children){\n            if (child.subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                child.hasReportedTransientFailure = true;\n            }\n        }\n        this.startNextSubchannelConnecting(0);\n        this.calculateAndReportNewState();\n    }\n    updateAddressList(addressList, lbConfig) {\n        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n            return;\n        }\n        /* Previously, an update would be discarded if it was identical to the\n         * previous update, to minimize churn. Now the DNS resolver is\n         * rate-limited, so that is less of a concern. */ if (lbConfig.getShuffleAddressList()) {\n            addressList = shuffled(addressList);\n        }\n        this.latestAddressList = addressList;\n        this.connectToAddressList(addressList);\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {\n            this.connectToAddressList(this.latestAddressList);\n        }\n    }\n    resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */ }\n    destroy() {\n        this.resetSubchannelList();\n        this.removeCurrentPick();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-pick-first.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSw2QkFBNkIsR0FBR0EsZ0JBQWdCLEdBQUdBLG9DQUFvQyxHQUFHLEtBQUs7QUFDL0csTUFBTU0sa0JBQWtCQyxtQkFBT0EsQ0FBQyxzRkFBaUI7QUFDakQsTUFBTUMsdUJBQXVCRCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTUksY0FBY0osbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUssY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZKLFFBQVFHLEtBQUssQ0FBQ0YsWUFBWUksWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0EsTUFBTUcsWUFBWTtBQUNsQjs7O0NBR0MsR0FDRCxNQUFNQywrQkFBK0I7QUFDckMsTUFBTWI7SUFDRmMsWUFBWUMsa0JBQWtCLENBQUU7UUFDNUIsSUFBSSxDQUFDQSxrQkFBa0IsR0FBR0E7SUFDOUI7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU9KO0lBQ1g7SUFDQUssZUFBZTtRQUNYLE9BQU87WUFDSCxDQUFDTCxVQUFVLEVBQUU7Z0JBQ1RHLG9CQUFvQixJQUFJLENBQUNBLGtCQUFrQjtZQUMvQztRQUNKO0lBQ0o7SUFDQUcsd0JBQXdCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDSCxrQkFBa0I7SUFDbEM7SUFDQSw4REFBOEQ7SUFDOUQsT0FBT0ksZUFBZUMsR0FBRyxFQUFFO1FBQ3ZCLElBQUksd0JBQXdCQSxPQUN4QixDQUFFLFFBQU9BLElBQUlMLGtCQUFr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T0FBT3RHO0lBQ1g7QUFDSjtBQUNBakIsNkJBQTZCLEdBQUdHO0FBQ2hDLFNBQVNEO0lBQ0osSUFBR0ksZ0JBQWdCa0gsd0JBQXdCLEVBQUV2RyxXQUFXZCx1QkFBdUJFO0lBQy9FLElBQUdDLGdCQUFnQm1ILCtCQUErQixFQUFFeEc7QUFDekQ7QUFDQWpCLGFBQWEsR0FBR0UsT0FDaEIsb0RBQW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzPzUzODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNlciA9IGV4cG9ydHMuc2h1ZmZsZWQgPSBleHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcgPSB2b2lkIDA7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdwaWNrX2ZpcnN0JztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgVFlQRV9OQU1FID0gJ3BpY2tfZmlyc3QnO1xuLyoqXG4gKiBEZWxheSBhZnRlciBzdGFydGluZyBhIGNvbm5lY3Rpb24gb24gYSBzdWJjaGFubmVsIGJlZm9yZSBzdGFydGluZyBhXG4gKiBjb25uZWN0aW9uIG9uIHRoZSBuZXh0IHN1YmNoYW5uZWwgaW4gdGhlIGxpc3QsIGZvciBIYXBweSBFeWViYWxscyBhbGdvcml0aG0uXG4gKi9cbmNvbnN0IENPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMgPSAyNTA7XG5jbGFzcyBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihzaHVmZmxlQWRkcmVzc0xpc3QpIHtcbiAgICAgICAgdGhpcy5zaHVmZmxlQWRkcmVzc0xpc3QgPSBzaHVmZmxlQWRkcmVzc0xpc3Q7XG4gICAgfVxuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIHRvSnNvbk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtUWVBFX05BTUVdOiB7XG4gICAgICAgICAgICAgICAgc2h1ZmZsZUFkZHJlc3NMaXN0OiB0aGlzLnNodWZmbGVBZGRyZXNzTGlzdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFNodWZmbGVBZGRyZXNzTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2h1ZmZsZUFkZHJlc3NMaXN0O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcbiAgICAgICAgaWYgKCdzaHVmZmxlQWRkcmVzc0xpc3QnIGluIG9iaiAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqLnNodWZmbGVBZGRyZXNzTGlzdCA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwaWNrX2ZpcnN0IGNvbmZpZyBmaWVsZCBzaHVmZmxlQWRkcmVzc0xpc3QgbXVzdCBiZSBhIGJvb2xlYW4gaWYgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcob2JqLnNodWZmbGVBZGRyZXNzTGlzdCA9PT0gdHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnID0gUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZztcbi8qKlxuICogUGlja2VyIGZvciBhIGBQaWNrRmlyc3RMb2FkQmFsYW5jZXJgIGluIHRoZSBSRUFEWSBzdGF0ZS4gQWx3YXlzIHJldHVybnMgdGhlXG4gKiBwaWNrZWQgc3ViY2hhbm5lbC5cbiAqL1xuY2xhc3MgUGlja0ZpcnN0UGlja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzdWJjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbCA9IHN1YmNoYW5uZWw7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IHRoaXMuc3ViY2hhbm5lbCxcbiAgICAgICAgICAgIHN0YXR1czogbnVsbCxcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxFbmRlZDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybiBhIG5ldyBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyBvZiB0aGUgaW5wdXQgYXJyYXkgaW4gYSByYW5kb20gb3JkZXJcbiAqIEBwYXJhbSBsaXN0IFRoZSBpbnB1dCBhcnJheVxuICogQHJldHVybnMgQSBzaHVmZmxlZCBhcnJheSBvZiB0aGUgZWxlbWVudHMgb2YgbGlzdFxuICovXG5mdW5jdGlvbiBzaHVmZmxlZChsaXN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbGlzdC5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+IDE7IGktLSkge1xuICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgIGNvbnN0IHRlbXAgPSByZXN1bHRbaV07XG4gICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtqXTtcbiAgICAgICAgcmVzdWx0W2pdID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuc2h1ZmZsZWQgPSBzaHVmZmxlZDtcbmNsYXNzIFBpY2tGaXJzdExvYWRCYWxhbmNlciB7XG4gICAgLyoqXG4gICAgICogTG9hZCBiYWxhbmNlciB0aGF0IGF0dGVtcHRzIHRvIGNvbm5lY3QgdG8gZWFjaCBiYWNrZW5kIGluIHRoZSBhZGRyZXNzIGxpc3RcbiAgICAgKiBpbiBvcmRlciwgYW5kIHBpY2tzIHRoZSBmaXJzdCBvbmUgdGhhdCBjb25uZWN0cywgdXNpbmcgaXQgZm9yIGV2ZXJ5XG4gICAgICogcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbENvbnRyb2xIZWxwZXIgYENoYW5uZWxDb250cm9sSGVscGVyYCBpbnN0YW5jZSBwcm92aWRlZCBieVxuICAgICAqICAgICB0aGlzIGxvYWQgYmFsYW5jZXIncyBvd25lci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBzdWJjaGFubmVscyB0aGlzIGxvYWQgYmFsYW5jZXIgaXMgY3VycmVudGx5IGF0dGVtcHRpbmcgdG9cbiAgICAgICAgICogY29ubmVjdCB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZSBvZiB0aGUgbG9hZCBiYWxhbmNlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCB3aXRoaW4gdGhlIGBzdWJjaGFubmVsc2AgYXJyYXkgb2YgdGhlIHN1YmNoYW5uZWwgd2l0aCB0aGUgbW9zdFxuICAgICAgICAgKiByZWNlbnRseSBzdGFydGVkIGNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IHBpY2tlZCBzdWJjaGFubmVsIHVzZWQgZm9yIG1ha2luZyBjYWxscy4gUG9wdWxhdGVkIGlmXG4gICAgICAgICAqIGFuZCBvbmx5IGlmIHRoZSBsb2FkIGJhbGFuY2VyJ3MgY3VycmVudCBzdGF0ZSBpcyBSRUFEWS4gSW4gdGhhdCBjYXNlLFxuICAgICAgICAgKiB0aGUgc3ViY2hhbm5lbCdzIGN1cnJlbnQgc3RhdGUgaXMgYWxzbyBSRUFEWS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdGVuZXIgY2FsbGJhY2sgYXR0YWNoZWQgdG8gZWFjaCBzdWJjaGFubmVsIGluIHRoZSBgc3ViY2hhbm5lbHNgIGxpc3RcbiAgICAgICAgICogd2hpbGUgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIgPSAoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGtlZXBhbGl2ZVRpbWUsIGVycm9yTWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZShzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmllZEFsbFN1YmNoYW5uZWxzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgTEIgcG9saWN5IGVudGVycyBzdGlja3kgVFJBTlNJRU5UX0ZBSUxVUkUgbW9kZSB3aGVuIGFsbFxuICAgICAgICAgKiBzdWJjaGFubmVscyBoYXZlIGZhaWxlZCB0byBjb25uZWN0IGF0IGxlYXN0IG9uY2UsIGFuZCBpdCBzdGF5cyBpbiB0aGF0XG4gICAgICAgICAqIG1vZGUgdW50aWwgYSBjb25uZWN0aW9uIGF0dGVtcHQgaXMgc3VjY2Vzc2Z1bC4gV2hpbGUgaW4gc3RpY2t5IFRGIG1vZGUsXG4gICAgICAgICAqIHRoZSBMQiBwb2xpY3kgY29udGludW91c2x5IGF0dGVtcHRzIHRvIGNvbm5lY3QgdG8gYWxsIG9mIGl0cyBzdWJjaGFubmVscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHdlIGNhbGxlZCBjaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uIHNpbmNlXG4gICAgICAgICAqIHRoZSBsYXN0IGNhbGwgdG8gdXBkYXRlQWRkcmVzc0xpc3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVxdWVzdGVkUmVzb2x1dGlvblNpbmNlTGFzdFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vc3QgcmVjZW50IGVycm9yIHJlcG9ydGVkIGJ5IGFueSBzdWJjaGFubmVsIGFzIGl0IHRyYW5zaXRpb25lZCB0b1xuICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XG4gICAgfVxuICAgIGFsbENoaWxkcmVuSGF2ZVJlcG9ydGVkVEYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IGNoaWxkLmhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGljaykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSwgbmV3IFBpY2tGaXJzdFBpY2tlcih0aGlzLmN1cnJlbnRQaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHsgZGV0YWlsczogYE5vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuIExhc3QgZXJyb3I6ICR7dGhpcy5sYXN0RXJyb3J9YCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdFJlcmVzb2x1dGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWRSZXNvbHV0aW9uU2luY2VMYXN0VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgfVxuICAgIG1heWJlRW50ZXJTdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbENoaWxkcmVuSGF2ZVJlcG9ydGVkVEYoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0ZWRSZXNvbHV0aW9uU2luY2VMYXN0VXBkYXRlKSB7XG4gICAgICAgICAgICAvKiBFYWNoIHRpbWUgd2UgZ2V0IGFuIHVwZGF0ZSB3ZSByZXNldCBlYWNoIHN1YmNoYW5uZWwnc1xuICAgICAgICAgICAgICogaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlIGZsYWcsIHNvIHRoZSBuZXh0IHRpbWUgd2UgZ2V0IHRvIHRoaXNcbiAgICAgICAgICAgICAqIHBvaW50IGFmdGVyIHRoYXQsIGVhY2ggc3ViY2hhbm5lbCBoYXMgcmVwb3J0ZWQgVFJBTlNJRU5UX0ZBSUxVUkVcbiAgICAgICAgICAgICAqIGF0IGxlYXN0IG9uY2Ugc2luY2UgdGhlbi4gVGhhdCBpcyB0aGUgdHJpZ2dlciBmb3IgcmVxdWVzdGluZ1xuICAgICAgICAgICAgICogcmVyZXNvbHV0aW9uLCB3aGV0aGVyIG9yIG5vdCB0aGUgTEIgcG9saWN5IGlzIGFscmVhZHkgaW4gc3RpY2t5IFRGXG4gICAgICAgICAgICAgKiBtb2RlLiAqL1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKTtcbiAgICB9XG4gICAgcmVtb3ZlQ3VycmVudFBpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvKiBVbnJlZiBjYW4gY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIHdoaWNoIGNhbiBjYXVzZSBhIGNoYW5nZSBpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgICAqIG9mIHRoaXMuY3VycmVudFBpY2ssIHNvIHdlIGhvbGQgYSBsb2NhbCByZWZlcmVuY2UgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICAgICAgICAgICAqIGRvZXMgbm90IGltcGFjdCB0aGlzIGZ1bmN0aW9uLiAqL1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFBpY2sgPSB0aGlzLmN1cnJlbnRQaWNrO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGljayA9IG51bGw7XG4gICAgICAgICAgICBjdXJyZW50UGljay51bnJlZigpO1xuICAgICAgICAgICAgY3VycmVudFBpY2sucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChjdXJyZW50UGljay5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZShzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuY3VycmVudFBpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFsU3ViY2hhbm5lbEVxdWFscyhzdWJjaGFubmVsKSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ3VycmVudFBpY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkXSBvZiB0aGlzLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWwucmVhbFN1YmNoYW5uZWxFcXVhbHMoY2hpbGQuc3ViY2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGlja1N1YmNoYW5uZWwoY2hpbGQuc3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmcoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZC5zdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZyhzdGFydEluZGV4KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xuICAgICAgICBpZiAodGhpcy50cmllZEFsbFN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkXSBvZiB0aGlzLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RhdGUgPSBjaGlsZC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWxTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSB8fFxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydENvbm5lY3RpbmcoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZWRBbGxTdWJjaGFubmVscyA9IHRydWU7XG4gICAgICAgIHRoaXMubWF5YmVFbnRlclN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhdmUgYSBzaW5nbGUgc3ViY2hhbm5lbCBpbiB0aGUgYHN1YmNoYW5uZWxzYCBsaXN0IHN0YXJ0IGNvbm5lY3RpbmcuXG4gICAgICogQHBhcmFtIHN1YmNoYW5uZWxJbmRleCBUaGUgaW5kZXggaW50byB0aGUgYHN1YmNoYW5uZWxzYCBsaXN0LlxuICAgICAqL1xuICAgIHN0YXJ0Q29ubmVjdGluZyhzdWJjaGFubmVsSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IHN1YmNoYW5uZWxJbmRleDtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bc3ViY2hhbm5lbEluZGV4XS5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09XG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0cmFjZSgnU3RhcnQgY29ubmVjdGluZyB0byBzdWJjaGFubmVsIHdpdGggYWRkcmVzcyAnICtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW3N1YmNoYW5uZWxJbmRleF0uc3ViY2hhbm5lbC5nZXRBZGRyZXNzKCkpO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY2hpbGRyZW5bc3ViY2hhbm5lbEluZGV4XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQgPSAoX2IgPSAoX2EgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3Rpbmcoc3ViY2hhbm5lbEluZGV4ICsgMSk7XG4gICAgICAgIH0sIENPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMpKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH1cbiAgICBwaWNrU3ViY2hhbm5lbChzdWJjaGFubmVsKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrICYmIHN1YmNoYW5uZWwucmVhbFN1YmNoYW5uZWxFcXVhbHModGhpcy5jdXJyZW50UGljaykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUGljayBzdWJjaGFubmVsIHdpdGggYWRkcmVzcyAnICsgc3ViY2hhbm5lbC5nZXRBZGRyZXNzKCkpO1xuICAgICAgICB0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrLnVucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQodGhpcy5jdXJyZW50UGljay5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrID0gc3ViY2hhbm5lbDtcbiAgICAgICAgc3ViY2hhbm5lbC5yZWYoKTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKSB7XG4gICAgICAgIHRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY3VycmVudFN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKTtcbiAgICB9XG4gICAgcmVzZXRTdWJjaGFubmVsTGlzdCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuc3ViY2hhbm5lbCAhPT0gdGhpcy5jdXJyZW50UGljaykge1xuICAgICAgICAgICAgICAgIC8qIFRoZSBjb25uZWN0aXZpdHkgc3RhdGUgbGlzdGVuZXIgaXMgdGhlIHNhbWUgd2hldGhlciB0aGUgc3ViY2hhbm5lbFxuICAgICAgICAgICAgICAgICAqIGlzIGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuIG9yIGl0IGlzIHRoZSBjdXJyZW50UGljaywgc28gaWYgaXQgaXMgaW5cbiAgICAgICAgICAgICAgICAgKiBib3RoLCByZW1vdmluZyBpdCBoZXJlIHdvdWxkIGNhdXNlIHByb2JsZW1zLiBJbiBwYXJ0aWN1bGFyLCB0aGF0XG4gICAgICAgICAgICAgICAgICogYWx3YXlzIGhhcHBlbnMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHN1YmNoYW5uZWwgaXMgcGlja2VkLiAqL1xuICAgICAgICAgICAgICAgIGNoaWxkLnN1YmNoYW5uZWwucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFJlZnMgYXJlIGNvdW50ZWQgaW5kZXBlbmRlbnRseSBmb3IgdGhlIGNoaWxkcmVuIGxpc3QgYW5kIHRoZVxuICAgICAgICAgICAgICogY3VycmVudFBpY2ssIHNvIHdlIGNhbGwgdW5yZWYgd2hldGhlciBvciBub3QgdGhlIGNoaWxkIGlzIHRoZVxuICAgICAgICAgICAgICogY3VycmVudFBpY2suIENoYW5uZWx6IGNoaWxkIHJlZmVyZW5jZXMgYXJlIGFsc28gcmVmY291bnRlZCwgc29cbiAgICAgICAgICAgICAqIHJlbW92ZUNoYW5uZWx6Q2hpbGQgY2FuIGJlIGhhbmRsZWQgdGhlIHNhbWUgd2F5LiAqL1xuICAgICAgICAgICAgY2hpbGQuc3ViY2hhbm5lbC51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWRSZXNvbHV0aW9uU2luY2VMYXN0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbm5lY3RUb0FkZHJlc3NMaXN0KGFkZHJlc3NMaXN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuTGlzdCA9IGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICh7XG4gICAgICAgICAgICBzdWJjaGFubmVsOiB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoYWRkcmVzcywge30pLFxuICAgICAgICAgICAgaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlOiBmYWxzZSxcbiAgICAgICAgfSkpO1xuICAgICAgICAvKiBSZWYgZWFjaCBzdWJjaGFubmVsIGJlZm9yZSByZXNldHRpbmcgdGhlIGxpc3QsIHRvIGVuc3VyZSB0aGF0XG4gICAgICAgICAqIHN1YmNoYW5uZWxzIHNoYXJlZCBiZXR3ZWVuIHRoZSBsaXN0IGRvbid0IGRyb3AgdG8gMCByZWZzIGR1cmluZyB0aGVcbiAgICAgICAgICogdHJhbnNpdGlvbi4gKi9cbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiBuZXdDaGlsZHJlbkxpc3QpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuTGlzdDtcbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGlja1N1YmNoYW5uZWwoc3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT1cbiAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZygwKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgaWYgKCEobGJDb25maWcgaW5zdGFuY2VvZiBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIFByZXZpb3VzbHksIGFuIHVwZGF0ZSB3b3VsZCBiZSBkaXNjYXJkZWQgaWYgaXQgd2FzIGlkZW50aWNhbCB0byB0aGVcbiAgICAgICAgICogcHJldmlvdXMgdXBkYXRlLCB0byBtaW5pbWl6ZSBjaHVybi4gTm93IHRoZSBETlMgcmVzb2x2ZXIgaXNcbiAgICAgICAgICogcmF0ZS1saW1pdGVkLCBzbyB0aGF0IGlzIGxlc3Mgb2YgYSBjb25jZXJuLiAqL1xuICAgICAgICBpZiAobGJDb25maWcuZ2V0U2h1ZmZsZUFkZHJlc3NMaXN0KCkpIHtcbiAgICAgICAgICAgIGFkZHJlc3NMaXN0ID0gc2h1ZmZsZWQoYWRkcmVzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QgPSBhZGRyZXNzTGlzdDtcbiAgICAgICAgdGhpcy5jb25uZWN0VG9BZGRyZXNzTGlzdChhZGRyZXNzTGlzdCk7XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgJiYgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VG9BZGRyZXNzTGlzdCh0aGlzLmxhdGVzdEFkZHJlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIC8qIFRoZSBwaWNrIGZpcnN0IGxvYWQgYmFsYW5jZXIgZG9lcyBub3QgaGF2ZSBhIGNvbm5lY3Rpb24gYmFja29mZiwgc28gdGhpc1xuICAgICAgICAgKiBkb2VzIG5vdGhpbmcgKi9cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ3VycmVudFBpY2soKTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jZXIgPSBQaWNrRmlyc3RMb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAoMCwgbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSkoVFlQRV9OQU1FLCBQaWNrRmlyc3RMb2FkQmFsYW5jZXIsIFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcpO1xuICAgICgwLCBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSkoVFlQRV9OQU1FKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItcGljay1maXJzdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIlBpY2tGaXJzdExvYWRCYWxhbmNlciIsInNodWZmbGVkIiwiUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyIsImxvYWRfYmFsYW5jZXJfMSIsInJlcXVpcmUiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsInBpY2tlcl8xIiwibG9nZ2luZyIsImNvbnN0YW50c18xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIkNPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMiLCJjb25zdHJ1Y3RvciIsInNodWZmbGVBZGRyZXNzTGlzdCIsImdldExvYWRCYWxhbmNlck5hbWUiLCJ0b0pzb25PYmplY3QiLCJnZXRTaHVmZmxlQWRkcmVzc0xpc3QiLCJjcmVhdGVGcm9tSnNvbiIsIm9iaiIsIkVycm9yIiwiUGlja0ZpcnN0UGlja2VyIiwic3ViY2hhbm5lbCIsInBpY2siLCJwaWNrQXJncyIsInBpY2tSZXN1bHRUeXBlIiwiUGlja1Jlc3VsdFR5cGUiLCJDT01QTEVURSIsInN0YXR1cyIsIm9uQ2FsbFN0YXJ0ZWQiLCJvbkNhbGxFbmRlZCIsImxpc3QiLCJyZXN1bHQiLCJzbGljZSIsImkiLCJsZW5ndGgiLCJqIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwidGVtcCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwiY2hpbGRyZW4iLCJjdXJyZW50U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJjdXJyZW50U3ViY2hhbm5lbEluZGV4IiwiY3VycmVudFBpY2siLCJzdWJjaGFubmVsU3RhdGVMaXN0ZW5lciIsInByZXZpb3VzU3RhdGUiLCJuZXdTdGF0ZSIsImtlZXBhbGl2ZVRpbWUiLCJlcnJvck1lc3NhZ2UiLCJvblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZSIsInRyaWVkQWxsU3ViY2hhbm5lbHMiLCJzdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSIsInJlcXVlc3RlZFJlc29sdXRpb25TaW5jZUxhc3RVcGRhdGUiLCJsYXN0RXJyb3IiLCJsYXRlc3RBZGRyZXNzTGlzdCIsImNvbm5lY3Rpb25EZWxheVRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiYWxsQ2hpbGRyZW5IYXZlUmVwb3J0ZWRURiIsImV2ZXJ5IiwiY2hpbGQiLCJoYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUiLCJjYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSIsInVwZGF0ZVN0YXRlIiwiUkVBRFkiLCJRdWV1ZVBpY2tlciIsIlRSQU5TSUVOVF9GQUlMVVJFIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJkZXRhaWxzIiwiQ09OTkVDVElORyIsInJlcXVlc3RSZXJlc29sdXRpb24iLCJtYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUiLCJzdGFydENvbm5lY3RpbmciLCJyZW1vdmVDdXJyZW50UGljayIsInVucmVmIiwicmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInJlbW92ZUNoYW5uZWx6Q2hpbGQiLCJnZXRDaGFubmVselJlZiIsIl9hIiwicmVhbFN1YmNoYW5uZWxFcXVhbHMiLCJpbmRleCIsImVudHJpZXMiLCJwaWNrU3ViY2hhbm5lbCIsInN0YXJ0TmV4dFN1YmNoYW5uZWxDb25uZWN0aW5nIiwic3RhcnRJbmRleCIsInN1YmNoYW5uZWxTdGF0ZSIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwic3ViY2hhbm5lbEluZGV4IiwiX2IiLCJnZXRBZGRyZXNzIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2FsbCIsInJlZiIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZXNldFN1YmNoYW5uZWxMaXN0IiwicGlja2VyIiwiY29ubmVjdFRvQWRkcmVzc0xpc3QiLCJhZGRyZXNzTGlzdCIsIm5ld0NoaWxkcmVuTGlzdCIsIm1hcCIsImFkZHJlc3MiLCJjcmVhdGVTdWJjaGFubmVsIiwiYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInVwZGF0ZUFkZHJlc3NMaXN0IiwibGJDb25maWciLCJleGl0SWRsZSIsInJlc2V0QmFja29mZiIsImRlc3Ryb3kiLCJnZXRUeXBlTmFtZSIsInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSIsInJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"round_robin\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"round_robin\";\nclass RoundRobinLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor(){}\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {}\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new RoundRobinLoadBalancingConfig();\n    }\n}\nclass RoundRobinPicker {\n    constructor(subchannelList, nextIndex = 0){\n        this.subchannelList = subchannelList;\n        this.nextIndex = nextIndex;\n    }\n    pick(pickArgs) {\n        const pickedSubchannel = this.subchannelList[this.nextIndex];\n        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: pickedSubchannel,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */ peekNextSubchannel() {\n        return this.subchannelList[this.nextIndex];\n    }\n}\nclass RoundRobinLoadBalancer {\n    constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        this.subchannels = [];\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentReadyPicker = null;\n        this.lastError = null;\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage)=>{\n            this.calculateAndUpdateState();\n            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE || newState === connectivity_state_1.ConnectivityState.IDLE) {\n                if (errorMessage) {\n                    this.lastError = errorMessage;\n                }\n                this.channelControlHelper.requestReresolution();\n                subchannel.startConnecting();\n            }\n        };\n    }\n    countSubchannelsWithState(state) {\n        return this.subchannels.filter((subchannel)=>subchannel.getConnectivityState() === state).length;\n    }\n    calculateAndUpdateState() {\n        if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.READY) > 0) {\n            const readySubchannels = this.subchannels.filter((subchannel)=>subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n            let index = 0;\n            if (this.currentReadyPicker !== null) {\n                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n        } else if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        } else if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                details: `No connection established. Last error: ${this.lastError}`\n            }));\n        } else {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n            this.currentReadyPicker = picker;\n        } else {\n            this.currentReadyPicker = null;\n        }\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const subchannel of this.subchannels){\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.subchannels = [];\n    }\n    updateAddressList(addressList, lbConfig) {\n        this.resetSubchannelList();\n        trace(\"Connect to address list \" + addressList.map((address)=>(0, subchannel_address_1.subchannelAddressToString)(address)));\n        this.subchannels = addressList.map((address)=>this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels){\n            subchannel.ref();\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n            const subchannelState = subchannel.getConnectivityState();\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                subchannel.startConnecting();\n            }\n        }\n        this.calculateAndUpdateState();\n    }\n    exitIdle() {\n        for (const subchannel of this.subchannels){\n            subchannel.startConnecting();\n        }\n    }\n    resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */ }\n    destroy() {\n        this.resetSubchannelList();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-round-robin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQ3RELE1BQU1JLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1NLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmSixRQUFRRyxLQUFLLENBQUNGLFlBQVlJLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBLE1BQU1HLFlBQVk7QUFDbEIsTUFBTUM7SUFDRkMsc0JBQXNCO1FBQ2xCLE9BQU9GO0lBQ1g7SUFDQUcsYUFBYyxDQUFFO0lBQ2hCQyxlQUFlO1FBQ1gsT0FBTztZQUNILENBQUNKLFVBQVUsRUFBRSxDQUFDO1FBQ2xCO0lBQ0o7SUFDQSw4REFBOEQ7SUFDOUQsT0FBT0ssZUFBZUMsR0FBRyxFQUFFO1FBQ3ZCLE9BQU8sSUFBSUw7SUFDZjtBQUNKO0FBQ0EsTUFBTU07SUFDRkosWUFBWUssY0FBYyxFQUFFQyxZQUFZLENBQUMsQ0FBRTtRQUN2QyxJQUFJLENBQUNELGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0FDLEtBQUtDLFFBQVEsRUFBRTtRQUNYLE1BQU1DLG1CQUFtQixJQUFJLENBQUNKLGNBQWMsQ0FBQyxJQUFJLENBQUNDLFNBQVMsQ0FBQztRQUM1RCxJQUFJLENBQUNBLFNBQVMsR0FBRyxDQUFDLElBQUksQ0FBQ0EsU0FBUyxHQUFHLEtBQUssSUFBSSxDQUFDRCxjQUFjLENBQUNLLE1BQU07UUFDbEUsT0FBTztZQUNIQyxnQkFBZ0J2QixTQUFTd0IsY0FBYyxDQUFDQyxRQUFRO1lBQ2hEQyxZQUFZTDtZQUNaTSxRQUFRO1lBQ1JDLGVBQWU7WUFDZkMsYUFBYTtRQUNqQjtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNEQyxxQkFBcUI7UUFDakIsT0FBTyxJQUFJLENBQUNiLGNBQWMsQ0FBQyxJQUFJLENBQUNDLFNBQVMsQ0FBQztJQUM5QztBQUNKO0FBQ0EsTUFBTXRCO0lBQ0ZnQixZQUFZbUIsb0JBQW9CLENBQUU7UUFDOUIsSUFBSSxDQUFDQSxvQkFBb0IsR0FBR0E7UUFDNUIsSUFBSSxDQUFDQyxXQUFXLEdBQUcsRUFBRTtRQUNyQixJQUFJLENBQUNDLFlBQVksR0FBR2xDLHFCQUFxQm1DLGlCQUFpQixDQUFDQyxJQUFJO1FBQy9ELElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyx1QkFBdUIsR0FBRyxDQUFDWixZQUFZYSxlQUFlQyxVQUFVQyxlQUFlQztZQUNoRixJQUFJLENBQUNDLHVCQUF1QjtZQUM1QixJQUFJSCxhQUFhekMscUJBQXFCbUMsaUJBQWlCLENBQUNVLGlCQUFpQixJQUNyRUosYUFBYXpDLHFCQUFxQm1DLGlCQUFpQixDQUFDQyxJQUFJLEVBQUU7Z0JBQzFELElBQUlPLGNBQWM7b0JBQ2QsSUFBSSxDQUFDTCxTQUFTLEdBQUdLO2dCQUNyQjtnQkFDQSxJQUFJLENBQUNYLG9CQUFvQixDQUFDYyxtQkFBbUI7Z0JBQzdDbkIsV0FBV29CLGVBQWU7WUFDOUI7UUFDSjtJQUNKO0lBQ0FDLDBCQUEwQkMsS0FBSyxFQUFFO1FBQzdCLE9BQU8sSUFBSSxDQUFDaEIsV0FBVyxDQUFDaUIsTUFBTSxDQUFDdkIsQ0FBQUEsYUFBY0EsV0FBV3dCLG9CQUFvQixPQUFPRixPQUFPMUIsTUFBTTtJQUNwRztJQUNBcUIsMEJBQTBCO1FBQ3RCLElBQUksSUFBSSxDQUFDSSx5QkFBeUIsQ0FBQ2hELHFCQUFxQm1DLGlCQUFpQixDQUFDaUIsS0FBSyxJQUFJLEdBQUc7WUFDbEYsTUFBTUMsbUJBQW1CLElBQUksQ0FBQ3BCLFdBQVcsQ0FBQ2lCLE1BQU0sQ0FBQ3ZCLENBQUFBLGFBQWNBLFdBQVd3QixvQkFBb0IsT0FBT25ELHFCQUFxQm1DLGlCQUFpQixDQUFDaUIsS0FBSztZQUNqSixJQUFJRSxRQUFRO1lBQ1osSUFBSSxJQUFJLENBQUNqQixrQkFBa0IsS0FBSyxNQUFNO2dCQUNsQ2lCLFFBQVFELGlCQUFpQkUsT0FBTyxDQUFDLElBQUksQ0FBQ2xCLGtCQUFrQixDQUFDTixrQkFBa0I7Z0JBQzNFLElBQUl1QixRQUFRLEdBQUc7b0JBQ1hBLFFBQVE7Z0JBQ1o7WUFDSjtZQUNBLElBQUksQ0FBQ0UsV0FBVyxDQUFDeEQscUJBQXFCbUMsaUJBQWlCLENBQUNpQixLQUFLLEVBQUUsSUFBSW5DLGlCQUFpQm9DLGtCQUFrQkM7UUFDMUcsT0FDSyxJQUFJLElBQUksQ0FBQ04seUJBQXlCLENBQUNoRCxxQkFBcUJtQyxpQkFBaUIsQ0FBQ3NCLFVBQVUsSUFBSSxHQUFHO1lBQzVGLElBQUksQ0FBQ0QsV0FBVyxDQUFDeEQscUJBQXFCbUMsaUJBQWlCLENBQUNzQixVQUFVLEVBQUUsSUFBSXhELFNBQVN5RCxXQUFXLENBQUMsSUFBSTtRQUNyRyxPQUNLLElBQUksSUFBSSxDQUFDVix5QkFBeUIsQ0FBQ2hELHFCQUFxQm1DLGlCQUFpQixDQUFDVSxpQkFBaUIsSUFBSSxHQUFHO1lBQ25HLElBQUksQ0FBQ1csV0FBVyxDQUFDeEQscUJBQXFCbUMsaUJBQWlCLENBQUNVLGlCQUFpQixFQUFFLElBQUk1QyxTQUFTMEQsaUJBQWlCLENBQUM7Z0JBQUVDLFNBQVMsQ0FBQyx1Q0FBdUMsRUFBRSxJQUFJLENBQUN0QixTQUFTLENBQUMsQ0FBQztZQUFDO1FBQ3BMLE9BQ0s7WUFDRCxJQUFJLENBQUNrQixXQUFXLENBQUN4RCxxQkFBcUJtQyxpQkFBaUIsQ0FBQ0MsSUFBSSxFQUFFLElBQUluQyxTQUFTeUQsV0FBVyxDQUFDLElBQUk7UUFDL0Y7SUFDSjtJQUNBRixZQUFZZixRQUFRLEVBQUVvQixNQUFNLEVBQUU7UUFDMUJ2RCxNQUFNTixxQkFBcUJtQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUNELFlBQVksQ0FBQyxHQUMzRCxTQUNBbEMscUJBQXFCbUMsaUJBQWlCLENBQUNNLFNBQVM7UUFDcEQsSUFBSUEsYUFBYXpDLHFCQUFxQm1DLGlCQUFpQixDQUFDaUIsS0FBSyxFQUFFO1lBQzNELElBQUksQ0FBQ2Ysa0JBQWtCLEdBQUd3QjtRQUM5QixPQUNLO1lBQ0QsSUFBSSxDQUFDeEIsa0JBQWtCLEdBQUc7UUFDOUI7UUFDQSxJQUFJLENBQUNILFlBQVksR0FBR087UUFDcEIsSUFBSSxDQUFDVCxvQkFBb0IsQ0FBQ3dCLFdBQVcsQ0FBQ2YsVUFBVW9CO0lBQ3BEO0lBQ0FDLHNCQUFzQjtRQUNsQixLQUFLLE1BQU1uQyxjQUFjLElBQUksQ0FBQ00sV0FBVyxDQUFFO1lBQ3ZDTixXQUFXb0MsK0JBQStCLENBQUMsSUFBSSxDQUFDeEIsdUJBQXVCO1lBQ3ZFWixXQUFXcUMsS0FBSztZQUNoQixJQUFJLENBQUNoQyxvQkFBb0IsQ0FBQ2lDLG1CQUFtQixDQUFDdEMsV0FBV3VDLGNBQWM7UUFDM0U7UUFDQSxJQUFJLENBQUNqQyxXQUFXLEdBQUcsRUFBRTtJQUN6QjtJQUNBa0Msa0JBQWtCQyxXQUFXLEVBQUVDLFFBQVEsRUFBRTtRQUNyQyxJQUFJLENBQUNQLG1CQUFtQjtRQUN4QnhELE1BQU0sNkJBQ0Y4RCxZQUFZRSxHQUFHLENBQUNDLENBQUFBLFVBQVcsQ0FBQyxHQUFHckUscUJBQXFCc0UseUJBQXlCLEVBQUVEO1FBQ25GLElBQUksQ0FBQ3RDLFdBQVcsR0FBR21DLFlBQVlFLEdBQUcsQ0FBQ0MsQ0FBQUEsVUFBVyxJQUFJLENBQUN2QyxvQkFBb0IsQ0FBQ3lDLGdCQUFnQixDQUFDRixTQUFTLENBQUM7UUFDbkcsS0FBSyxNQUFNNUMsY0FBYyxJQUFJLENBQUNNLFdBQVcsQ0FBRTtZQUN2Q04sV0FBVytDLEdBQUc7WUFDZC9DLFdBQVdnRCw0QkFBNEIsQ0FBQyxJQUFJLENBQUNwQyx1QkFBdUI7WUFDcEUsSUFBSSxDQUFDUCxvQkFBb0IsQ0FBQzRDLGdCQUFnQixDQUFDakQsV0FBV3VDLGNBQWM7WUFDcEUsTUFBTVcsa0JBQWtCbEQsV0FBV3dCLG9CQUFvQjtZQUN2RCxJQUFJMEIsb0JBQW9CN0UscUJBQXFCbUMsaUJBQWlCLENBQUNDLElBQUksSUFDL0R5QyxvQkFBb0I3RSxxQkFBcUJtQyxpQkFBaUIsQ0FBQ1UsaUJBQWlCLEVBQUU7Z0JBQzlFbEIsV0FBV29CLGVBQWU7WUFDOUI7UUFDSjtRQUNBLElBQUksQ0FBQ0gsdUJBQXVCO0lBQ2hDO0lBQ0FrQyxXQUFXO1FBQ1AsS0FBSyxNQUFNbkQsY0FBYyxJQUFJLENBQUNNLFdBQVcsQ0FBRTtZQUN2Q04sV0FBV29CLGVBQWU7UUFDOUI7SUFDSjtJQUNBZ0MsZUFBZTtJQUNYO3dCQUNnQixHQUNwQjtJQUNBQyxVQUFVO1FBQ04sSUFBSSxDQUFDbEIsbUJBQW1CO0lBQzVCO0lBQ0FtQixjQUFjO1FBQ1YsT0FBT3ZFO0lBQ1g7QUFDSjtBQUNBaEIsOEJBQThCLEdBQUdHO0FBQ2pDLFNBQVNEO0lBQ0osSUFBR0UsZ0JBQWdCb0Ysd0JBQXdCLEVBQUV4RSxXQUFXYix3QkFBd0JjO0FBQ3JGO0FBQ0FqQixhQUFhLEdBQUdFLE9BQ2hCLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItcm91bmQtcm9iaW4uanM/OWVkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuUm91bmRSb2JpbkxvYWRCYWxhbmNlciA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncm91bmRfcm9iaW4nO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBUWVBFX05BTUUgPSAncm91bmRfcm9iaW4nO1xuY2xhc3MgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcge1xuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgdG9Kc29uT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW1RZUEVfTkFNRV06IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xuICAgIH1cbn1cbmNsYXNzIFJvdW5kUm9iaW5QaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHN1YmNoYW5uZWxMaXN0LCBuZXh0SW5kZXggPSAwKSB7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbExpc3QgPSBzdWJjaGFubmVsTGlzdDtcbiAgICAgICAgdGhpcy5uZXh0SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgY29uc3QgcGlja2VkU3ViY2hhbm5lbCA9IHRoaXMuc3ViY2hhbm5lbExpc3RbdGhpcy5uZXh0SW5kZXhdO1xuICAgICAgICB0aGlzLm5leHRJbmRleCA9ICh0aGlzLm5leHRJbmRleCArIDEpICUgdGhpcy5zdWJjaGFubmVsTGlzdC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaWNrUmVzdWx0VHlwZTogcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUsXG4gICAgICAgICAgICBzdWJjaGFubmVsOiBwaWNrZWRTdWJjaGFubmVsLFxuICAgICAgICAgICAgc3RhdHVzOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsU3RhcnRlZDogbnVsbCxcbiAgICAgICAgICAgIG9uQ2FsbEVuZGVkOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGF0IHRoZSBuZXh0IHN1YmNoYW5uZWwgcmV0dXJuZWQgd291bGQgYmUuIFVzZWQgYnkgdGhlIGxvYWRcbiAgICAgKiBiYWxhbmNlciBpbXBsZW1lbnRhdGlvbiB0byBwcmVzZXJ2ZSB0aGlzIHBhcnQgb2YgdGhlIHBpY2tlciBzdGF0ZSBpZlxuICAgICAqIHBvc3NpYmxlIHdoZW4gYSBzdWJjaGFubmVsIGNvbm5lY3RzIG9yIGRpc2Nvbm5lY3RzLlxuICAgICAqL1xuICAgIHBlZWtOZXh0U3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbExpc3RbdGhpcy5uZXh0SW5kZXhdO1xuICAgIH1cbn1cbmNsYXNzIFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBrZWVwYWxpdmVUaW1lLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUgfHxcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvdW50U3ViY2hhbm5lbHNXaXRoU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbHMuZmlsdGVyKHN1YmNoYW5uZWwgPT4gc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBzdGF0ZSkubGVuZ3RoO1xuICAgIH1cbiAgICBjYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY291bnRTdWJjaGFubmVsc1dpdGhTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkeVN1YmNoYW5uZWxzID0gdGhpcy5zdWJjaGFubmVscy5maWx0ZXIoc3ViY2hhbm5lbCA9PiBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVhZHlQaWNrZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHJlYWR5U3ViY2hhbm5lbHMuaW5kZXhPZih0aGlzLmN1cnJlbnRSZWFkeVBpY2tlci5wZWVrTmV4dFN1YmNoYW5uZWwoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSwgbmV3IFJvdW5kUm9iaW5QaWNrZXIocmVhZHlTdWJjaGFubmVscywgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvdW50U3ViY2hhbm5lbHNXaXRoU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb3VudFN1YmNoYW5uZWxzV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcih7IGRldGFpbHM6IGBObyBjb25uZWN0aW9uIGVzdGFibGlzaGVkLiBMYXN0IGVycm9yOiAke3RoaXMubGFzdEVycm9yfWAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpIHtcbiAgICAgICAgdHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpO1xuICAgIH1cbiAgICByZXNldFN1YmNoYW5uZWxMaXN0KCkge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgc3ViY2hhbm5lbC51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRyYWNlKCdDb25uZWN0IHRvIGFkZHJlc3MgbGlzdCAnICtcbiAgICAgICAgICAgIGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSkpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxzID0gYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4gdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKGFkZHJlc3MsIHt9KSk7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RhdGUgPSBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsIG9mIHRoaXMuc3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICAvKiBUaGUgcGljayBmaXJzdCBsb2FkIGJhbGFuY2VyIGRvZXMgbm90IGhhdmUgYSBjb25uZWN0aW9uIGJhY2tvZmYsIHNvIHRoaXNcbiAgICAgICAgICogZG9lcyBub3RoaW5nICovXG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgIH1cbiAgICBnZXRUeXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG59XG5leHBvcnRzLlJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIgPSBSb3VuZFJvYmluTG9hZEJhbGFuY2VyO1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIGxvYWRfYmFsYW5jZXJfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSwgUm91bmRSb2JpbkxvYWRCYWxhbmNlciwgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIlJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIiLCJsb2FkX2JhbGFuY2VyXzEiLCJyZXF1aXJlIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJwaWNrZXJfMSIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwibG9nZ2luZyIsImNvbnN0YW50c18xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIlJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnIiwiZ2V0TG9hZEJhbGFuY2VyTmFtZSIsImNvbnN0cnVjdG9yIiwidG9Kc29uT2JqZWN0IiwiY3JlYXRlRnJvbUpzb24iLCJvYmoiLCJSb3VuZFJvYmluUGlja2VyIiwic3ViY2hhbm5lbExpc3QiLCJuZXh0SW5kZXgiLCJwaWNrIiwicGlja0FyZ3MiLCJwaWNrZWRTdWJjaGFubmVsIiwibGVuZ3RoIiwicGlja1Jlc3VsdFR5cGUiLCJQaWNrUmVzdWx0VHlwZSIsIkNPTVBMRVRFIiwic3ViY2hhbm5lbCIsInN0YXR1cyIsIm9uQ2FsbFN0YXJ0ZWQiLCJvbkNhbGxFbmRlZCIsInBlZWtOZXh0U3ViY2hhbm5lbCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwic3ViY2hhbm5lbHMiLCJjdXJyZW50U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJjdXJyZW50UmVhZHlQaWNrZXIiLCJsYXN0RXJyb3IiLCJzdWJjaGFubmVsU3RhdGVMaXN0ZW5lciIsInByZXZpb3VzU3RhdGUiLCJuZXdTdGF0ZSIsImtlZXBhbGl2ZVRpbWUiLCJlcnJvck1lc3NhZ2UiLCJjYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSIsIlRSQU5TSUVOVF9GQUlMVVJFIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsInN0YXJ0Q29ubmVjdGluZyIsImNvdW50U3ViY2hhbm5lbHNXaXRoU3RhdGUiLCJzdGF0ZSIsImZpbHRlciIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwiUkVBRFkiLCJyZWFkeVN1YmNoYW5uZWxzIiwiaW5kZXgiLCJpbmRleE9mIiwidXBkYXRlU3RhdGUiLCJDT05ORUNUSU5HIiwiUXVldWVQaWNrZXIiLCJVbmF2YWlsYWJsZVBpY2tlciIsImRldGFpbHMiLCJwaWNrZXIiLCJyZXNldFN1YmNoYW5uZWxMaXN0IiwicmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInVucmVmIiwicmVtb3ZlQ2hhbm5lbHpDaGlsZCIsImdldENoYW5uZWx6UmVmIiwidXBkYXRlQWRkcmVzc0xpc3QiLCJhZGRyZXNzTGlzdCIsImxiQ29uZmlnIiwibWFwIiwiYWRkcmVzcyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJjcmVhdGVTdWJjaGFubmVsIiwicmVmIiwiYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsImFkZENoYW5uZWx6Q2hpbGQiLCJzdWJjaGFubmVsU3RhdGUiLCJleGl0SWRsZSIsInJlc2V0QmFja29mZiIsImRlc3Ryb3kiLCJnZXRUeXBlTmFtZSIsInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.isLoadBalancerNameRegistered = exports.createLoadBalancer = exports.registerDefaultLoadBalancerType = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = void 0;\n/**\n * Create a child ChannelControlHelper that overrides some methods of the\n * parent while letting others pass through to the parent unmodified. This\n * allows other code to create these children without needing to know about\n * all of the methods to be passed through.\n * @param parent\n * @param overrides\n */ function createChildChannelControlHelper(parent, overrides) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    return {\n        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),\n        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),\n        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),\n        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),\n        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent)\n    };\n}\nexports.createChildChannelControlHelper = createChildChannelControlHelper;\nconst registeredLoadBalancerTypes = {};\nlet defaultLoadBalancerType = null;\nfunction registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {\n    registeredLoadBalancerTypes[typeName] = {\n        LoadBalancer: loadBalancerType,\n        LoadBalancingConfig: loadBalancingConfigType\n    };\n}\nexports.registerLoadBalancerType = registerLoadBalancerType;\nfunction registerDefaultLoadBalancerType(typeName) {\n    defaultLoadBalancerType = typeName;\n}\nexports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;\nfunction createLoadBalancer(config, channelControlHelper) {\n    const typeName = config.getLoadBalancerName();\n    if (typeName in registeredLoadBalancerTypes) {\n        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);\n    } else {\n        return null;\n    }\n}\nexports.createLoadBalancer = createLoadBalancer;\nfunction isLoadBalancerNameRegistered(typeName) {\n    return typeName in registeredLoadBalancerTypes;\n}\nexports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;\nfunction getFirstUsableConfig(configs, fallbackTodefault = false) {\n    for (const config of configs){\n        if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {\n            return config;\n        }\n    }\n    if (fallbackTodefault) {\n        if (defaultLoadBalancerType) {\n            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\n        } else {\n            return null;\n        }\n    } else {\n        return null;\n    }\n}\nexports.getFirstUsableConfig = getFirstUsableConfig;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validateLoadBalancingConfig(obj) {\n    if (!(obj !== null && typeof obj === \"object\")) {\n        throw new Error(\"Load balancing config must be an object\");\n    }\n    const keys = Object.keys(obj);\n    if (keys.length !== 1) {\n        throw new Error(\"Provided load balancing config has multiple conflicting entries\");\n    }\n    const typeName = keys[0];\n    if (typeName in registeredLoadBalancerTypes) {\n        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);\n    } else {\n        throw new Error(`Unrecognized load balancing config name ${typeName}`);\n    }\n}\nexports.validateLoadBalancingConfig = validateLoadBalancingConfig; //# sourceMappingURL=load-balancer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUNBQW1DLEdBQUdBLDRCQUE0QixHQUFHQSxvQ0FBb0MsR0FBR0EsMEJBQTBCLEdBQUdBLHVDQUF1QyxHQUFHQSxnQ0FBZ0MsR0FBR0EsdUNBQXVDLEdBQUcsS0FBSztBQUNyUTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1EsZ0NBQWdDQyxNQUFNLEVBQUVDLFNBQVM7SUFDdEQsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7SUFDeEMsT0FBTztRQUNIQyxrQkFBa0IsQ0FBQ1QsS0FBSyxDQUFDRCxLQUFLRCxVQUFVVyxnQkFBZ0IsTUFBTSxRQUFRVixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdXLElBQUksQ0FBQ1osVUFBUyxNQUFPLFFBQVFFLE9BQU8sS0FBSyxJQUFJQSxLQUFLSCxPQUFPWSxnQkFBZ0IsQ0FBQ0MsSUFBSSxDQUFDYjtRQUNqTGMsYUFBYSxDQUFDVCxLQUFLLENBQUNELEtBQUtILFVBQVVhLFdBQVcsTUFBTSxRQUFRVixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdTLElBQUksQ0FBQ1osVUFBUyxNQUFPLFFBQVFJLE9BQU8sS0FBSyxJQUFJQSxLQUFLTCxPQUFPYyxXQUFXLENBQUNELElBQUksQ0FBQ2I7UUFDbEtlLHFCQUFxQixDQUFDUixLQUFLLENBQUNELEtBQUtMLFVBQVVjLG1CQUFtQixNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR08sSUFBSSxDQUFDWixVQUFTLE1BQU8sUUFBUU0sT0FBTyxLQUFLLElBQUlBLEtBQUtQLE9BQU9lLG1CQUFtQixDQUFDRixJQUFJLENBQUNiO1FBQzFMZ0Isa0JBQWtCLENBQUNQLEtBQUssQ0FBQ0QsS0FBS1AsVUFBVWUsZ0JBQWdCLE1BQU0sUUFBUVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSyxJQUFJLENBQUNaLFVBQVMsTUFBTyxRQUFRUSxPQUFPLEtBQUssSUFBSUEsS0FBS1QsT0FBT2dCLGdCQUFnQixDQUFDSCxJQUFJLENBQUNiO1FBQ2pMaUIscUJBQXFCLENBQUNOLEtBQUssQ0FBQ0QsS0FBS1QsVUFBVWdCLG1CQUFtQixNQUFNLFFBQVFQLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0csSUFBSSxDQUFDWixVQUFTLE1BQU8sUUFBUVUsT0FBTyxLQUFLLElBQUlBLEtBQUtYLE9BQU9pQixtQkFBbUIsQ0FBQ0osSUFBSSxDQUFDYjtJQUM5TDtBQUNKO0FBQ0FULHVDQUF1QyxHQUFHUTtBQUMxQyxNQUFNbUIsOEJBQThCLENBQUM7QUFDckMsSUFBSUMsMEJBQTBCO0FBQzlCLFNBQVNyQix5QkFBeUJzQixRQUFRLEVBQUVDLGdCQUFnQixFQUFFQyx1QkFBdUI7SUFDakZKLDJCQUEyQixDQUFDRSxTQUFTLEdBQUc7UUFDcENHLGNBQWNGO1FBQ2RHLHFCQUFxQkY7SUFDekI7QUFDSjtBQUNBL0IsZ0NBQWdDLEdBQUdPO0FBQ25DLFNBQVNELGdDQUFnQ3VCLFFBQVE7SUFDN0NELDBCQUEwQkM7QUFDOUI7QUFDQTdCLHVDQUF1QyxHQUFHTTtBQUMxQyxTQUFTRCxtQkFBbUI2QixNQUFNLEVBQUVDLG9CQUFvQjtJQUNwRCxNQUFNTixXQUFXSyxPQUFPRSxtQkFBbUI7SUFDM0MsSUFBSVAsWUFBWUYsNkJBQTZCO1FBQ3pDLE9BQU8sSUFBSUEsMkJBQTJCLENBQUNFLFNBQVMsQ0FBQ0csWUFBWSxDQUFDRztJQUNsRSxPQUNLO1FBQ0QsT0FBTztJQUNYO0FBQ0o7QUFDQW5DLDBCQUEwQixHQUFHSztBQUM3QixTQUFTRCw2QkFBNkJ5QixRQUFRO0lBQzFDLE9BQU9BLFlBQVlGO0FBQ3ZCO0FBQ0EzQixvQ0FBb0MsR0FBR0k7QUFDdkMsU0FBU0QscUJBQXFCa0MsT0FBTyxFQUFFQyxvQkFBb0IsS0FBSztJQUM1RCxLQUFLLE1BQU1KLFVBQVVHLFFBQVM7UUFDMUIsSUFBSUgsT0FBT0UsbUJBQW1CLE1BQU1ULDZCQUE2QjtZQUM3RCxPQUFPTztRQUNYO0lBQ0o7SUFDQSxJQUFJSSxtQkFBbUI7UUFDbkIsSUFBSVYseUJBQXlCO1lBQ3pCLE9BQU8sSUFBSUQsMkJBQTJCLENBQUNDLHdCQUF3QixDQUFDSyxtQkFBbUI7UUFDdkYsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKLE9BQ0s7UUFDRCxPQUFPO0lBQ1g7QUFDSjtBQUNBakMsNEJBQTRCLEdBQUdHO0FBQy9CLDhEQUE4RDtBQUM5RCxTQUFTRCw0QkFBNEJxQyxHQUFHO0lBQ3BDLElBQUksQ0FBRUEsQ0FBQUEsUUFBUSxRQUFRLE9BQU9BLFFBQVEsUUFBTyxHQUFJO1FBQzVDLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBLE1BQU1DLE9BQU8zQyxPQUFPMkMsSUFBSSxDQUFDRjtJQUN6QixJQUFJRSxLQUFLQyxNQUFNLEtBQUssR0FBRztRQUNuQixNQUFNLElBQUlGLE1BQU07SUFDcEI7SUFDQSxNQUFNWCxXQUFXWSxJQUFJLENBQUMsRUFBRTtJQUN4QixJQUFJWixZQUFZRiw2QkFBNkI7UUFDekMsT0FBT0EsMkJBQTJCLENBQUNFLFNBQVMsQ0FBQ0ksbUJBQW1CLENBQUNVLGNBQWMsQ0FBQ0osR0FBRyxDQUFDVixTQUFTO0lBQ2pHLE9BQ0s7UUFDRCxNQUFNLElBQUlXLE1BQU0sQ0FBQyx3Q0FBd0MsRUFBRVgsU0FBUyxDQUFDO0lBQ3pFO0FBQ0o7QUFDQTdCLG1DQUFtQyxHQUFHRSw2QkFDdEMseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcz8yN2NhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyA9IGV4cG9ydHMuZ2V0Rmlyc3RVc2FibGVDb25maWcgPSBleHBvcnRzLmlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQgPSBleHBvcnRzLmNyZWF0ZUxvYWRCYWxhbmNlciA9IGV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IGV4cG9ydHMucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlID0gZXhwb3J0cy5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyID0gdm9pZCAwO1xuLyoqXG4gKiBDcmVhdGUgYSBjaGlsZCBDaGFubmVsQ29udHJvbEhlbHBlciB0aGF0IG92ZXJyaWRlcyBzb21lIG1ldGhvZHMgb2YgdGhlXG4gKiBwYXJlbnQgd2hpbGUgbGV0dGluZyBvdGhlcnMgcGFzcyB0aHJvdWdoIHRvIHRoZSBwYXJlbnQgdW5tb2RpZmllZC4gVGhpc1xuICogYWxsb3dzIG90aGVyIGNvZGUgdG8gY3JlYXRlIHRoZXNlIGNoaWxkcmVuIHdpdGhvdXQgbmVlZGluZyB0byBrbm93IGFib3V0XG4gKiBhbGwgb2YgdGhlIG1ldGhvZHMgdG8gYmUgcGFzc2VkIHRocm91Z2guXG4gKiBAcGFyYW0gcGFyZW50XG4gKiBAcGFyYW0gb3ZlcnJpZGVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIocGFyZW50LCBvdmVycmlkZXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKF9iID0gKF9hID0gb3ZlcnJpZGVzLmNyZWF0ZVN1YmNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHBhcmVudC5jcmVhdGVTdWJjaGFubmVsLmJpbmQocGFyZW50KSxcbiAgICAgICAgdXBkYXRlU3RhdGU6IChfZCA9IChfYyA9IG92ZXJyaWRlcy51cGRhdGVTdGF0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogcGFyZW50LnVwZGF0ZVN0YXRlLmJpbmQocGFyZW50KSxcbiAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKF9mID0gKF9lID0gb3ZlcnJpZGVzLnJlcXVlc3RSZXJlc29sdXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHBhcmVudC5yZXF1ZXN0UmVyZXNvbHV0aW9uLmJpbmQocGFyZW50KSxcbiAgICAgICAgYWRkQ2hhbm5lbHpDaGlsZDogKF9oID0gKF9nID0gb3ZlcnJpZGVzLmFkZENoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHBhcmVudC5hZGRDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KSxcbiAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogKF9rID0gKF9qID0gb3ZlcnJpZGVzLnJlbW92ZUNoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHBhcmVudC5yZW1vdmVDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KSxcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyID0gY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcjtcbmNvbnN0IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcyA9IHt9O1xubGV0IGRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlID0gbnVsbDtcbmZ1bmN0aW9uIHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSh0eXBlTmFtZSwgbG9hZEJhbGFuY2VyVHlwZSwgbG9hZEJhbGFuY2luZ0NvbmZpZ1R5cGUpIHtcbiAgICByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbdHlwZU5hbWVdID0ge1xuICAgICAgICBMb2FkQmFsYW5jZXI6IGxvYWRCYWxhbmNlclR5cGUsXG4gICAgICAgIExvYWRCYWxhbmNpbmdDb25maWc6IGxvYWRCYWxhbmNpbmdDb25maWdUeXBlLFxuICAgIH07XG59XG5leHBvcnRzLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSA9IHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTtcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUodHlwZU5hbWUpIHtcbiAgICBkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IHR5cGVOYW1lO1xufVxuZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlID0gcmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZTtcbmZ1bmN0aW9uIGNyZWF0ZUxvYWRCYWxhbmNlcihjb25maWcsIGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgY29uc3QgdHlwZU5hbWUgPSBjb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpO1xuICAgIGlmICh0eXBlTmFtZSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbdHlwZU5hbWVdLkxvYWRCYWxhbmNlcihjaGFubmVsQ29udHJvbEhlbHBlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUxvYWRCYWxhbmNlciA9IGNyZWF0ZUxvYWRCYWxhbmNlcjtcbmZ1bmN0aW9uIGlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQodHlwZU5hbWUpIHtcbiAgICByZXR1cm4gdHlwZU5hbWUgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzO1xufVxuZXhwb3J0cy5pc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkID0gaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZDtcbmZ1bmN0aW9uIGdldEZpcnN0VXNhYmxlQ29uZmlnKGNvbmZpZ3MsIGZhbGxiYWNrVG9kZWZhdWx0ID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBjb25maWdzKSB7XG4gICAgICAgIGlmIChjb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmFsbGJhY2tUb2RlZmF1bHQpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1tkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZV0uTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Rmlyc3RVc2FibGVDb25maWcgPSBnZXRGaXJzdFVzYWJsZUNvbmZpZztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcob2JqKSB7XG4gICAgaWYgKCEob2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWQgYmFsYW5jaW5nIGNvbmZpZyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBsb2FkIGJhbGFuY2luZyBjb25maWcgaGFzIG11bHRpcGxlIGNvbmZsaWN0aW5nIGVudHJpZXMnKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZU5hbWUgPSBrZXlzWzBdO1xuICAgIGlmICh0eXBlTmFtZSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0uTG9hZEJhbGFuY2luZ0NvbmZpZy5jcmVhdGVGcm9tSnNvbihvYmpbdHlwZU5hbWVdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGxvYWQgYmFsYW5jaW5nIGNvbmZpZyBuYW1lICR7dHlwZU5hbWV9YCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcgPSB2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyIsImdldEZpcnN0VXNhYmxlQ29uZmlnIiwiaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCIsImNyZWF0ZUxvYWRCYWxhbmNlciIsInJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUiLCJyZWdpc3RlckxvYWRCYWxhbmNlclR5cGUiLCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyIiwicGFyZW50Iiwib3ZlcnJpZGVzIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9qIiwiX2siLCJjcmVhdGVTdWJjaGFubmVsIiwiYmluZCIsInVwZGF0ZVN0YXRlIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZW1vdmVDaGFubmVsekNoaWxkIiwicmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzIiwiZGVmYXVsdExvYWRCYWxhbmNlclR5cGUiLCJ0eXBlTmFtZSIsImxvYWRCYWxhbmNlclR5cGUiLCJsb2FkQmFsYW5jaW5nQ29uZmlnVHlwZSIsIkxvYWRCYWxhbmNlciIsIkxvYWRCYWxhbmNpbmdDb25maWciLCJjb25maWciLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImdldExvYWRCYWxhbmNlck5hbWUiLCJjb25maWdzIiwiZmFsbGJhY2tUb2RlZmF1bHQiLCJvYmoiLCJFcnJvciIsImtleXMiLCJsZW5ndGgiLCJjcmVhdGVGcm9tSnNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LoadBalancingCall = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst TRACER_NAME = \"load_balancing_call\";\nclass LoadBalancingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber){\n        var _a, _b;\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.metadata = null;\n        this.listener = null;\n        this.onCallEnded = null;\n        const splitPath = this.methodName.split(\"/\");\n        let serviceName = \"\";\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */ if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : \"localhost\";\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */ this.serviceUrl = `https://${hostname}/${serviceName}`;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callNumber + \"] \" + text);\n    }\n    outputStatus(status, progress) {\n        var _a, _b;\n        if (!this.ended) {\n            this.ended = true;\n            this.trace(\"ended with status: code=\" + status.code + ' details=\"' + status.details + '\"');\n            const finalStatus = Object.assign(Object.assign({}, status), {\n                progress\n            });\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);\n            (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);\n        }\n    }\n    doPick() {\n        var _a, _b;\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata) {\n            throw new Error(\"doPick called before start\");\n        }\n        this.trace(\"Pick called\");\n        const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);\n        const subchannelString = pickResult.subchannel ? \"(\" + pickResult.subchannel.getChannelzRef().id + \") \" + pickResult.subchannel.getAddress() : \"\" + pickResult.subchannel;\n        this.trace(\"Pick result: \" + picker_1.PickResultType[pickResult.pickResultType] + \" subchannel: \" + subchannelString + \" status: \" + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + \" \" + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n        switch(pickResult.pickResultType){\n            case picker_1.PickResultType.COMPLETE:\n                this.credentials.generateMetadata({\n                    service_url: this.serviceUrl\n                }).then((credsMetadata)=>{\n                    var _a, _b, _c;\n                    /* If this call was cancelled (e.g. by the deadline) before\n                     * metadata generation finished, we shouldn't do anything with\n                     * it. */ if (this.ended) {\n                        this.trace(\"Credentials metadata generation finished after call ended\");\n                        return;\n                    }\n                    const finalMetadata = this.metadata.clone();\n                    finalMetadata.merge(credsMetadata);\n                    if (finalMetadata.get(\"authorization\").length > 1) {\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: '\"authorization\" metadata cannot have multiple values',\n                            metadata: new metadata_1.Metadata()\n                        }, \"PROCESSED\");\n                    }\n                    if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n                        this.trace(\"Picked subchannel \" + subchannelString + \" has state \" + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] + \" after getting credentials metadata. Retrying pick\");\n                        this.doPick();\n                        return;\n                    }\n                    if (this.deadline !== Infinity) {\n                        finalMetadata.set(\"grpc-timeout\", (0, deadline_1.getDeadlineTimeoutString)(this.deadline));\n                    }\n                    try {\n                        this.child = pickResult.subchannel.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {\n                            onReceiveMetadata: (metadata)=>{\n                                this.trace(\"Received metadata\");\n                                this.listener.onReceiveMetadata(metadata);\n                            },\n                            onReceiveMessage: (message)=>{\n                                this.trace(\"Received message\");\n                                this.listener.onReceiveMessage(message);\n                            },\n                            onReceiveStatus: (status)=>{\n                                this.trace(\"Received status\");\n                                if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {\n                                    this.outputStatus(status, \"REFUSED\");\n                                } else {\n                                    this.outputStatus(status, \"PROCESSED\");\n                                }\n                            }\n                        });\n                    } catch (error) {\n                        this.trace(\"Failed to start call on picked subchannel \" + subchannelString + \" with error \" + error.message);\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: \"Failed to start HTTP/2 stream with error \" + error.message,\n                            metadata: new metadata_1.Metadata()\n                        }, \"NOT_STARTED\");\n                        return;\n                    }\n                    (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n                    this.onCallEnded = pickResult.onCallEnded;\n                    this.trace(\"Created child call [\" + this.child.getCallNumber() + \"]\");\n                    if (this.readPending) {\n                        this.child.startRead();\n                    }\n                    if (this.pendingMessage) {\n                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n                    }\n                    if (this.pendingHalfClose) {\n                        this.child.halfClose();\n                    }\n                }, (error)=>{\n                    // We assume the error code isn't 0 (Status.OK)\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === \"number\" ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                    this.outputStatus({\n                        code: code,\n                        details: details,\n                        metadata: new metadata_1.Metadata()\n                    }, \"PROCESSED\");\n                });\n                break;\n            case picker_1.PickResultType.DROP:\n                const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                setImmediate(()=>{\n                    this.outputStatus({\n                        code,\n                        details,\n                        metadata: pickResult.status.metadata\n                    }, \"DROP\");\n                });\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (this.metadata.getOptions().waitForReady) {\n                    this.channel.queueCallForPick(this);\n                } else {\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                    setImmediate(()=>{\n                        this.outputStatus({\n                            code,\n                            details,\n                            metadata: pickResult.status.metadata\n                        }, \"PROCESSED\");\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.channel.queueCallForPick(this);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({\n            code: status,\n            details: details,\n            metadata: new metadata_1.Metadata()\n        }, \"PROCESSED\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace(\"start called\");\n        this.listener = listener;\n        this.metadata = metadata;\n        this.doPick();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace(\"write() called with message of length \" + message.length);\n        if (this.child) {\n            this.child.sendMessageWithContext(context, message);\n        } else {\n            this.pendingMessage = {\n                context,\n                message\n            };\n        }\n    }\n    startRead() {\n        this.trace(\"startRead called\");\n        if (this.child) {\n            this.child.startRead();\n        } else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace(\"halfClose called\");\n        if (this.child) {\n            this.child.halfClose();\n        } else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        throw new Error(\"Method not implemented.\");\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n}\nexports.LoadBalancingCall = LoadBalancingCall; //# sourceMappingURL=load-balancing-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUcsS0FBSztBQUNqQyxNQUFNRyx1QkFBdUJDLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSSxXQUFXSixtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNSyxlQUFlTCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTyx5QkFBeUJQLG1CQUFPQSxDQUFDLG9HQUF3QjtBQUMvRCxNQUFNUSxRQUFRUixtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNUyxjQUFjO0FBQ3BCLE1BQU1YO0lBQ0ZZLFlBQVlDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLElBQUksRUFBRUMsV0FBVyxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsQ0FBRTtRQUNsRixJQUFJQyxJQUFJQztRQUNSLElBQUksQ0FBQ1IsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDRyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsTUFBTUMsWUFBWSxJQUFJLENBQUNmLFVBQVUsQ0FBQ2dCLEtBQUssQ0FBQztRQUN4QyxJQUFJQyxjQUFjO1FBQ2xCOzt3QkFFZ0IsR0FDaEIsSUFBSUYsVUFBVUcsTUFBTSxJQUFJLEdBQUc7WUFDdkJELGNBQWNGLFNBQVMsQ0FBQyxFQUFFO1FBQzlCO1FBQ0EsTUFBTUksV0FBVyxDQUFDYixLQUFLLENBQUNELEtBQUssQ0FBQyxHQUFHYixhQUFhNEIsYUFBYSxFQUFFLElBQUksQ0FBQ25CLElBQUksT0FBTyxRQUFRSSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLElBQUksTUFBTSxRQUFRSyxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUN4SjtpREFDeUMsR0FDekMsSUFBSSxDQUFDZSxVQUFVLEdBQUcsQ0FBQyxRQUFRLEVBQUVGLFNBQVMsQ0FBQyxFQUFFRixZQUFZLENBQUM7SUFDMUQ7SUFDQUssTUFBTUMsSUFBSSxFQUFFO1FBQ1I5QixRQUFRNkIsS0FBSyxDQUFDbEMsWUFBWW9DLFlBQVksQ0FBQ0MsS0FBSyxFQUFFN0IsYUFBYSxNQUFNLElBQUksQ0FBQ1EsVUFBVSxHQUFHLE9BQU9tQjtJQUM5RjtJQUNBRyxhQUFhQyxNQUFNLEVBQUVDLFFBQVEsRUFBRTtRQUMzQixJQUFJdkIsSUFBSUM7UUFDUixJQUFJLENBQUMsSUFBSSxDQUFDSyxLQUFLLEVBQUU7WUFDYixJQUFJLENBQUNBLEtBQUssR0FBRztZQUNiLElBQUksQ0FBQ1csS0FBSyxDQUFDLDZCQUNQSyxPQUFPRSxJQUFJLEdBQ1gsZUFDQUYsT0FBT0csT0FBTyxHQUNkO1lBQ0osTUFBTUMsY0FBY2xELE9BQU9tRCxNQUFNLENBQUNuRCxPQUFPbUQsTUFBTSxDQUFDLENBQUMsR0FBR0wsU0FBUztnQkFBRUM7WUFBUztZQUN2RXZCLENBQUFBLEtBQUssSUFBSSxDQUFDUSxRQUFRLE1BQU0sUUFBUVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNEIsZUFBZSxDQUFDRjtZQUM1RXpCLENBQUFBLEtBQUssSUFBSSxDQUFDUSxXQUFXLE1BQU0sUUFBUVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNEIsSUFBSSxDQUFDLElBQUksRUFBRUgsWUFBWUYsSUFBSTtRQUMvRjtJQUNKO0lBQ0FNLFNBQVM7UUFDTCxJQUFJOUIsSUFBSUM7UUFDUixJQUFJLElBQUksQ0FBQ0ssS0FBSyxFQUFFO1lBQ1o7UUFDSjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNDLFFBQVEsRUFBRTtZQUNoQixNQUFNLElBQUl3QixNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDZCxLQUFLLENBQUM7UUFDWCxNQUFNZSxhQUFhLElBQUksQ0FBQ3ZDLE9BQU8sQ0FBQ3FDLE1BQU0sQ0FBQyxJQUFJLENBQUN2QixRQUFRLEVBQUUsSUFBSSxDQUFDYixVQUFVLENBQUN1QyxlQUFlO1FBQ3JGLE1BQU1DLG1CQUFtQkYsV0FBV0csVUFBVSxHQUN4QyxNQUNFSCxXQUFXRyxVQUFVLENBQUNDLGNBQWMsR0FBR0MsRUFBRSxHQUN6QyxPQUNBTCxXQUFXRyxVQUFVLENBQUNHLFVBQVUsS0FDbEMsS0FBS04sV0FBV0csVUFBVTtRQUNoQyxJQUFJLENBQUNsQixLQUFLLENBQUMsa0JBQ1AvQixTQUFTcUQsY0FBYyxDQUFDUCxXQUFXUSxjQUFjLENBQUMsR0FDbEQsa0JBQ0FOLG1CQUNBLGNBQ0MsRUFBQ2xDLEtBQUtnQyxXQUFXVixNQUFNLE1BQU0sUUFBUXRCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3dCLElBQUksSUFDdEUsTUFDQyxFQUFDdkIsS0FBSytCLFdBQVdWLE1BQU0sTUFBTSxRQUFRckIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHd0IsT0FBTztRQUM3RSxPQUFRTyxXQUFXUSxjQUFjO1lBQzdCLEtBQUt0RCxTQUFTcUQsY0FBYyxDQUFDRSxRQUFRO2dCQUNqQyxJQUFJLENBQUM1QyxXQUFXLENBQ1g2QyxnQkFBZ0IsQ0FBQztvQkFBRUMsYUFBYSxJQUFJLENBQUMzQixVQUFVO2dCQUFDLEdBQ2hENEIsSUFBSSxDQUFDQyxDQUFBQTtvQkFDTixJQUFJN0MsSUFBSUMsSUFBSTZDO29CQUNaOzsyQkFFTyxHQUNQLElBQUksSUFBSSxDQUFDeEMsS0FBSyxFQUFFO3dCQUNaLElBQUksQ0FBQ1csS0FBSyxDQUFDO3dCQUNYO29CQUNKO29CQUNBLE1BQU04QixnQkFBZ0IsSUFBSSxDQUFDeEMsUUFBUSxDQUFDeUMsS0FBSztvQkFDekNELGNBQWNFLEtBQUssQ0FBQ0o7b0JBQ3BCLElBQUlFLGNBQWNHLEdBQUcsQ0FBQyxpQkFBaUJyQyxNQUFNLEdBQUcsR0FBRzt3QkFDL0MsSUFBSSxDQUFDUSxZQUFZLENBQUM7NEJBQ2RHLE1BQU16QyxZQUFZb0UsTUFBTSxDQUFDQyxRQUFROzRCQUNqQzNCLFNBQVM7NEJBQ1RsQixVQUFVLElBQUl0QixXQUFXb0UsUUFBUTt3QkFDckMsR0FBRztvQkFDUDtvQkFDQSxJQUFJckIsV0FBV0csVUFBVSxDQUFDbUIsb0JBQW9CLE9BQzFDekUscUJBQXFCMEUsaUJBQWlCLENBQUNDLEtBQUssRUFBRTt3QkFDOUMsSUFBSSxDQUFDdkMsS0FBSyxDQUFDLHVCQUNQaUIsbUJBQ0EsZ0JBQ0FyRCxxQkFBcUIwRSxpQkFBaUIsQ0FBQ3ZCLFdBQVdHLFVBQVUsQ0FBQ21CLG9CQUFvQixHQUFHLEdBQ3BGO3dCQUNKLElBQUksQ0FBQ3hCLE1BQU07d0JBQ1g7b0JBQ0o7b0JBQ0EsSUFBSSxJQUFJLENBQUNoQyxRQUFRLEtBQUsyRCxVQUFVO3dCQUM1QlYsY0FBY1csR0FBRyxDQUFDLGdCQUFnQixDQUFDLEdBQUcxRSxXQUFXMkUsd0JBQXdCLEVBQUUsSUFBSSxDQUFDN0QsUUFBUTtvQkFDNUY7b0JBQ0EsSUFBSTt3QkFDQSxJQUFJLENBQUNJLEtBQUssR0FBRzhCLFdBQ1JHLFVBQVUsQ0FBQ3lCLGlCQUFpQixHQUM1QkMsVUFBVSxDQUFDZCxlQUFlLElBQUksQ0FBQ25ELElBQUksRUFBRSxJQUFJLENBQUNELFVBQVUsRUFBRTs0QkFDdkRtRSxtQkFBbUJ2RCxDQUFBQTtnQ0FDZixJQUFJLENBQUNVLEtBQUssQ0FBQztnQ0FDWCxJQUFJLENBQUNULFFBQVEsQ0FBQ3NELGlCQUFpQixDQUFDdkQ7NEJBQ3BDOzRCQUNBd0Qsa0JBQWtCQyxDQUFBQTtnQ0FDZCxJQUFJLENBQUMvQyxLQUFLLENBQUM7Z0NBQ1gsSUFBSSxDQUFDVCxRQUFRLENBQUN1RCxnQkFBZ0IsQ0FBQ0M7NEJBQ25DOzRCQUNBcEMsaUJBQWlCTixDQUFBQTtnQ0FDYixJQUFJLENBQUNMLEtBQUssQ0FBQztnQ0FDWCxJQUFJSyxPQUFPMkMsT0FBTyxLQUNkM0UsTUFBTTRFLFNBQVMsQ0FBQ0Msc0JBQXNCLEVBQUU7b0NBQ3hDLElBQUksQ0FBQzlDLFlBQVksQ0FBQ0MsUUFBUTtnQ0FDOUIsT0FDSztvQ0FDRCxJQUFJLENBQUNELFlBQVksQ0FBQ0MsUUFBUTtnQ0FDOUI7NEJBQ0o7d0JBQ0o7b0JBQ0osRUFDQSxPQUFPOEMsT0FBTzt3QkFDVixJQUFJLENBQUNuRCxLQUFLLENBQUMsK0NBQ1BpQixtQkFDQSxpQkFDQWtDLE1BQU1KLE9BQU87d0JBQ2pCLElBQUksQ0FBQzNDLFlBQVksQ0FBQzs0QkFDZEcsTUFBTXpDLFlBQVlvRSxNQUFNLENBQUNDLFFBQVE7NEJBQ2pDM0IsU0FBUyw4Q0FDTDJDLE1BQU1KLE9BQU87NEJBQ2pCekQsVUFBVSxJQUFJdEIsV0FBV29FLFFBQVE7d0JBQ3JDLEdBQUc7d0JBQ0g7b0JBQ0o7b0JBQ0NwRCxDQUFBQSxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDTixVQUFVLEVBQUUyRSxXQUFXLE1BQU0sUUFBUXBFLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRCLElBQUksQ0FBQzdCO29CQUN0RjhDLENBQUFBLEtBQUtkLFdBQVdzQyxhQUFhLE1BQU0sUUFBUXhCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pCLElBQUksQ0FBQ0c7b0JBQzdFLElBQUksQ0FBQ3ZCLFdBQVcsR0FBR3VCLFdBQVd2QixXQUFXO29CQUN6QyxJQUFJLENBQUNRLEtBQUssQ0FBQyx5QkFBeUIsSUFBSSxDQUFDZixLQUFLLENBQUNxRSxhQUFhLEtBQUs7b0JBQ2pFLElBQUksSUFBSSxDQUFDcEUsV0FBVyxFQUFFO3dCQUNsQixJQUFJLENBQUNELEtBQUssQ0FBQ3NFLFNBQVM7b0JBQ3hCO29CQUNBLElBQUksSUFBSSxDQUFDcEUsY0FBYyxFQUFFO3dCQUNyQixJQUFJLENBQUNGLEtBQUssQ0FBQ3VFLHNCQUFzQixDQUFDLElBQUksQ0FBQ3JFLGNBQWMsQ0FBQ3NFLE9BQU8sRUFBRSxJQUFJLENBQUN0RSxjQUFjLENBQUM0RCxPQUFPO29CQUM5RjtvQkFDQSxJQUFJLElBQUksQ0FBQzNELGdCQUFnQixFQUFFO3dCQUN2QixJQUFJLENBQUNILEtBQUssQ0FBQ3lFLFNBQVM7b0JBQ3hCO2dCQUNKLEdBQUcsQ0FBQ1A7b0JBQ0EsK0NBQStDO29CQUMvQyxNQUFNLEVBQUU1QyxJQUFJLEVBQUVDLE9BQU8sRUFBRSxHQUFHLENBQUMsR0FBR3BDLHVCQUF1QnVGLDhCQUE4QixFQUFFLE9BQU9SLE1BQU01QyxJQUFJLEtBQUssV0FBVzRDLE1BQU01QyxJQUFJLEdBQUd6QyxZQUFZb0UsTUFBTSxDQUFDMEIsT0FBTyxFQUFFLENBQUMsZ0RBQWdELEVBQUVULE1BQU1KLE9BQU8sQ0FBQyxDQUFDO29CQUNqTyxJQUFJLENBQUMzQyxZQUFZLENBQUM7d0JBQ2RHLE1BQU1BO3dCQUNOQyxTQUFTQTt3QkFDVGxCLFVBQVUsSUFBSXRCLFdBQVdvRSxRQUFRO29CQUNyQyxHQUFHO2dCQUNQO2dCQUNBO1lBQ0osS0FBS25FLFNBQVNxRCxjQUFjLENBQUN1QyxJQUFJO2dCQUM3QixNQUFNLEVBQUV0RCxJQUFJLEVBQUVDLE9BQU8sRUFBRSxHQUFHLENBQUMsR0FBR3BDLHVCQUF1QnVGLDhCQUE4QixFQUFFNUMsV0FBV1YsTUFBTSxDQUFDRSxJQUFJLEVBQUVRLFdBQVdWLE1BQU0sQ0FBQ0csT0FBTztnQkFDdElzRCxhQUFhO29CQUNULElBQUksQ0FBQzFELFlBQVksQ0FBQzt3QkFBRUc7d0JBQU1DO3dCQUFTbEIsVUFBVXlCLFdBQVdWLE1BQU0sQ0FBQ2YsUUFBUTtvQkFBQyxHQUFHO2dCQUMvRTtnQkFDQTtZQUNKLEtBQUtyQixTQUFTcUQsY0FBYyxDQUFDeUMsaUJBQWlCO2dCQUMxQyxJQUFJLElBQUksQ0FBQ3pFLFFBQVEsQ0FBQzBFLFVBQVUsR0FBR0MsWUFBWSxFQUFFO29CQUN6QyxJQUFJLENBQUN6RixPQUFPLENBQUMwRixnQkFBZ0IsQ0FBQyxJQUFJO2dCQUN0QyxPQUNLO29CQUNELE1BQU0sRUFBRTNELElBQUksRUFBRUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxHQUFHcEMsdUJBQXVCdUYsOEJBQThCLEVBQUU1QyxXQUFXVixNQUFNLENBQUNFLElBQUksRUFBRVEsV0FBV1YsTUFBTSxDQUFDRyxPQUFPO29CQUN0SXNELGFBQWE7d0JBQ1QsSUFBSSxDQUFDMUQsWUFBWSxDQUFDOzRCQUFFRzs0QkFBTUM7NEJBQVNsQixVQUFVeUIsV0FBV1YsTUFBTSxDQUFDZixRQUFRO3dCQUFDLEdBQUc7b0JBQy9FO2dCQUNKO2dCQUNBO1lBQ0osS0FBS3JCLFNBQVNxRCxjQUFjLENBQUM2QyxLQUFLO2dCQUM5QixJQUFJLENBQUMzRixPQUFPLENBQUMwRixnQkFBZ0IsQ0FBQyxJQUFJO1FBQzFDO0lBQ0o7SUFDQUUsaUJBQWlCL0QsTUFBTSxFQUFFRyxPQUFPLEVBQUU7UUFDOUIsSUFBSXpCO1FBQ0osSUFBSSxDQUFDaUIsS0FBSyxDQUFDLDRCQUE0QkssU0FBUyxnQkFBZ0JHLFVBQVU7UUFDekV6QixDQUFBQSxLQUFLLElBQUksQ0FBQ0UsS0FBSyxNQUFNLFFBQVFGLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3FGLGdCQUFnQixDQUFDL0QsUUFBUUc7UUFDbkYsSUFBSSxDQUFDSixZQUFZLENBQUM7WUFBRUcsTUFBTUY7WUFBUUcsU0FBU0E7WUFBU2xCLFVBQVUsSUFBSXRCLFdBQVdvRSxRQUFRO1FBQUcsR0FBRztJQUMvRjtJQUNBaUMsVUFBVTtRQUNOLElBQUl0RixJQUFJQztRQUNSLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ0UsS0FBSyxNQUFNLFFBQVFGLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3NGLE9BQU8sRUFBQyxNQUFPLFFBQVFyRixPQUFPLEtBQUssSUFBSUEsS0FBSyxJQUFJLENBQUNSLE9BQU8sQ0FBQzhGLFNBQVM7SUFDN0k7SUFDQUMsTUFBTWpGLFFBQVEsRUFBRUMsUUFBUSxFQUFFO1FBQ3RCLElBQUksQ0FBQ1MsS0FBSyxDQUFDO1FBQ1gsSUFBSSxDQUFDVCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUN1QixNQUFNO0lBQ2Y7SUFDQTJDLHVCQUF1QkMsT0FBTyxFQUFFVixPQUFPLEVBQUU7UUFDckMsSUFBSSxDQUFDL0MsS0FBSyxDQUFDLDJDQUEyQytDLFFBQVFuRCxNQUFNO1FBQ3BFLElBQUksSUFBSSxDQUFDWCxLQUFLLEVBQUU7WUFDWixJQUFJLENBQUNBLEtBQUssQ0FBQ3VFLHNCQUFzQixDQUFDQyxTQUFTVjtRQUMvQyxPQUNLO1lBQ0QsSUFBSSxDQUFDNUQsY0FBYyxHQUFHO2dCQUFFc0U7Z0JBQVNWO1lBQVE7UUFDN0M7SUFDSjtJQUNBUSxZQUFZO1FBQ1IsSUFBSSxDQUFDdkQsS0FBSyxDQUFDO1FBQ1gsSUFBSSxJQUFJLENBQUNmLEtBQUssRUFBRTtZQUNaLElBQUksQ0FBQ0EsS0FBSyxDQUFDc0UsU0FBUztRQUN4QixPQUNLO1lBQ0QsSUFBSSxDQUFDckUsV0FBVyxHQUFHO1FBQ3ZCO0lBQ0o7SUFDQXdFLFlBQVk7UUFDUixJQUFJLENBQUMxRCxLQUFLLENBQUM7UUFDWCxJQUFJLElBQUksQ0FBQ2YsS0FBSyxFQUFFO1lBQ1osSUFBSSxDQUFDQSxLQUFLLENBQUN5RSxTQUFTO1FBQ3hCLE9BQ0s7WUFDRCxJQUFJLENBQUN0RSxnQkFBZ0IsR0FBRztRQUM1QjtJQUNKO0lBQ0FvRixlQUFlNUYsV0FBVyxFQUFFO1FBQ3hCLE1BQU0sSUFBSWtDLE1BQU07SUFDcEI7SUFDQXdDLGdCQUFnQjtRQUNaLE9BQU8sSUFBSSxDQUFDeEUsVUFBVTtJQUMxQjtBQUNKO0FBQ0FyQix5QkFBeUIsR0FBR0UsbUJBQzVCLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jaW5nLWNhbGwuanM/MjhmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2FkQmFsYW5jaW5nQ2FsbCA9IHZvaWQgMDtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBkZWFkbGluZV8xID0gcmVxdWlyZShcIi4vZGVhZGxpbmVcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEgPSByZXF1aXJlKFwiLi9jb250cm9sLXBsYW5lLXN0YXR1c1wiKTtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnbG9hZF9iYWxhbmNpbmdfY2FsbCc7XG5jbGFzcyBMb2FkQmFsYW5jaW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgY2FsbENvbmZpZywgbWV0aG9kTmFtZSwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuY2FsbENvbmZpZyA9IGNhbGxDb25maWc7XG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWU7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IGRlYWRsaW5lO1xuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xuICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm9uQ2FsbEVuZGVkID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc3BsaXRQYXRoID0gdGhpcy5tZXRob2ROYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgIGxldCBzZXJ2aWNlTmFtZSA9ICcnO1xuICAgICAgICAvKiBUaGUgc3RhbmRhcmQgcGF0aCBmb3JtYXQgaXMgXCIve3NlcnZpY2VOYW1lfS97bWV0aG9kTmFtZX1cIiwgc28gaWYgd2Ugc3BsaXRcbiAgICAgICAgICogYnkgJy8nLCB0aGUgZmlyc3QgaXRlbSBzaG91bGQgYmUgZW1wdHkgYW5kIHRoZSBzZWNvbmQgc2hvdWxkIGJlIHRoZVxuICAgICAgICAgKiBzZXJ2aWNlIG5hbWUgKi9cbiAgICAgICAgaWYgKHNwbGl0UGF0aC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgc2VydmljZU5hbWUgPSBzcGxpdFBhdGhbMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSAoX2IgPSAoX2EgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRoaXMuaG9zdCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ob3N0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnbG9jYWxob3N0JztcbiAgICAgICAgLyogQ3VycmVudGx5LCBjYWxsIGNyZWRlbnRpYWxzIGFyZSBvbmx5IGFsbG93ZWQgb24gSFRUUFMgY29ubmVjdGlvbnMsIHNvIHdlXG4gICAgICAgICAqIGNhbiBhc3N1bWUgdGhhdCB0aGUgc2NoZW1lIGlzIFwiaHR0cHNcIiAqL1xuICAgICAgICB0aGlzLnNlcnZpY2VVcmwgPSBgaHR0cHM6Ly8ke2hvc3RuYW1lfS8ke3NlcnZpY2VOYW1lfWA7XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxOdW1iZXIgKyAnXSAnICsgdGV4dCk7XG4gICAgfVxuICAgIG91dHB1dFN0YXR1cyhzdGF0dXMsIHByb2dyZXNzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICBzdGF0dXMuY29kZSArXG4gICAgICAgICAgICAgICAgJyBkZXRhaWxzPVwiJyArXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgK1xuICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgICAgY29uc3QgZmluYWxTdGF0dXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXR1cyksIHsgcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlU3RhdHVzKGZpbmFsU3RhdHVzKTtcbiAgICAgICAgICAgIChfYiA9IHRoaXMub25DYWxsRW5kZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIGZpbmFsU3RhdHVzLmNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvUGljaygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9QaWNrIGNhbGxlZCBiZWZvcmUgc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdQaWNrIGNhbGxlZCcpO1xuICAgICAgICBjb25zdCBwaWNrUmVzdWx0ID0gdGhpcy5jaGFubmVsLmRvUGljayh0aGlzLm1ldGFkYXRhLCB0aGlzLmNhbGxDb25maWcucGlja0luZm9ybWF0aW9uKTtcbiAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFN0cmluZyA9IHBpY2tSZXN1bHQuc3ViY2hhbm5lbFxuICAgICAgICAgICAgPyAnKCcgK1xuICAgICAgICAgICAgICAgIHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpLmlkICtcbiAgICAgICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgICAgICBwaWNrUmVzdWx0LnN1YmNoYW5uZWwuZ2V0QWRkcmVzcygpXG4gICAgICAgICAgICA6ICcnICsgcGlja1Jlc3VsdC5zdWJjaGFubmVsO1xuICAgICAgICB0aGlzLnRyYWNlKCdQaWNrIHJlc3VsdDogJyArXG4gICAgICAgICAgICBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZVtwaWNrUmVzdWx0LnBpY2tSZXN1bHRUeXBlXSArXG4gICAgICAgICAgICAnIHN1YmNoYW5uZWw6ICcgK1xuICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAnIHN0YXR1czogJyArXG4gICAgICAgICAgICAoKF9hID0gcGlja1Jlc3VsdC5zdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgKChfYiA9IHBpY2tSZXN1bHQuc3RhdHVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGV0YWlscykpO1xuICAgICAgICBzd2l0Y2ggKHBpY2tSZXN1bHQucGlja1Jlc3VsdFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEU6XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFsc1xuICAgICAgICAgICAgICAgICAgICAuZ2VuZXJhdGVNZXRhZGF0YSh7IHNlcnZpY2VfdXJsOiB0aGlzLnNlcnZpY2VVcmwgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oY3JlZHNNZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGlzIGNhbGwgd2FzIGNhbmNlbGxlZCAoZS5nLiBieSB0aGUgZGVhZGxpbmUpIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgKiBtZXRhZGF0YSBnZW5lcmF0aW9uIGZpbmlzaGVkLCB3ZSBzaG91bGRuJ3QgZG8gYW55dGhpbmcgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgKiBpdC4gKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0NyZWRlbnRpYWxzIG1ldGFkYXRhIGdlbmVyYXRpb24gZmluaXNoZWQgYWZ0ZXIgY2FsbCBlbmRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsTWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWV0YWRhdGEubWVyZ2UoY3JlZHNNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE1ldGFkYXRhLmdldCgnYXV0aG9yaXphdGlvbicpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ1wiYXV0aG9yaXphdGlvblwiIG1ldGFkYXRhIGNhbm5vdCBoYXZlIG11bHRpcGxlIHZhbHVlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1BpY2tlZCBzdWJjaGFubmVsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaGFzIHN0YXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3BpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBhZnRlciBnZXR0aW5nIGNyZWRlbnRpYWxzIG1ldGFkYXRhLiBSZXRyeWluZyBwaWNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvUGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYWRsaW5lICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxNZXRhZGF0YS5zZXQoJ2dycGMtdGltZW91dCcsICgwLCBkZWFkbGluZV8xLmdldERlYWRsaW5lVGltZW91dFN0cmluZykodGhpcy5kZWFkbGluZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkID0gcGlja1Jlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJjaGFubmVsLmdldFJlYWxTdWJjaGFubmVsKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3JlYXRlQ2FsbChmaW5hbE1ldGFkYXRhLCB0aGlzLmhvc3QsIHRoaXMubWV0aG9kTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1ldGFkYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzdGF0dXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5yc3RDb2RlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfUkVGVVNFRF9TVFJFQU0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cywgJ1JFRlVTRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cywgJ1BST0NFU1NFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIHN0YXJ0IGNhbGwgb24gcGlja2VkIHN1YmNoYW5uZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnRmFpbGVkIHRvIHN0YXJ0IEhUVFAvMiBzdHJlYW0gd2l0aCBlcnJvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICdOT1RfU1RBUlRFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbENvbmZpZykub25Db21taXR0ZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgICAgICAgICAgKF9jID0gcGlja1Jlc3VsdC5vbkNhbGxTdGFydGVkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChwaWNrUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNhbGxFbmRlZCA9IHBpY2tSZXN1bHQub25DYWxsRW5kZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0NyZWF0ZWQgY2hpbGQgY2FsbCBbJyArIHRoaXMuY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZFBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh0aGlzLnBlbmRpbmdNZXNzYWdlLmNvbnRleHQsIHRoaXMucGVuZGluZ01lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhlIGVycm9yIGNvZGUgaXNuJ3QgMCAoU3RhdHVzLk9LKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkodHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInID8gZXJyb3IuY29kZSA6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLCBgR2V0dGluZyBtZXRhZGF0YSBmcm9tIHBsdWdpbiBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICB9LCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkRST1A6XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKHBpY2tSZXN1bHQuc3RhdHVzLmNvZGUsIHBpY2tSZXN1bHQuc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHsgY29kZSwgZGV0YWlscywgbWV0YWRhdGE6IHBpY2tSZXN1bHQuc3RhdHVzLm1ldGFkYXRhIH0sICdEUk9QJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLlRSQU5TSUVOVF9GQUlMVVJFOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvclBpY2sodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkocGlja1Jlc3VsdC5zdGF0dXMuY29kZSwgcGlja1Jlc3VsdC5zdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7IGNvZGUsIGRldGFpbHMsIG1ldGFkYXRhOiBwaWNrUmVzdWx0LnN0YXR1cy5tZXRhZGF0YSB9LCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuUVVFVUU6XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvclBpY2sodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoeyBjb2RlOiBzdGF0dXMsIGRldGFpbHM6IGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0sICdQUk9DRVNTRUQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY2hhbm5lbC5nZXRUYXJnZXQoKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5kb1BpY2soKTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3dyaXRlKCkgY2FsbGVkIHdpdGggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSB7IGNvbnRleHQsIG1lc3NhZ2UgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0UmVhZCBjYWxsZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2hhbGZDbG9zZSBjYWxsZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcbiAgICB9XG59XG5leHBvcnRzLkxvYWRCYWxhbmNpbmdDYWxsID0gTG9hZEJhbGFuY2luZ0NhbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2luZy1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxvYWRCYWxhbmNpbmdDYWxsIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJkZWFkbGluZV8xIiwibWV0YWRhdGFfMSIsInBpY2tlcl8xIiwidXJpX3BhcnNlcl8xIiwibG9nZ2luZyIsImNvbnRyb2xfcGxhbmVfc3RhdHVzXzEiLCJodHRwMiIsIlRSQUNFUl9OQU1FIiwiY29uc3RydWN0b3IiLCJjaGFubmVsIiwiY2FsbENvbmZpZyIsIm1ldGhvZE5hbWUiLCJob3N0IiwiY3JlZGVudGlhbHMiLCJkZWFkbGluZSIsImNhbGxOdW1iZXIiLCJfYSIsIl9iIiwiY2hpbGQiLCJyZWFkUGVuZGluZyIsInBlbmRpbmdNZXNzYWdlIiwicGVuZGluZ0hhbGZDbG9zZSIsImVuZGVkIiwibWV0YWRhdGEiLCJsaXN0ZW5lciIsIm9uQ2FsbEVuZGVkIiwic3BsaXRQYXRoIiwic3BsaXQiLCJzZXJ2aWNlTmFtZSIsImxlbmd0aCIsImhvc3RuYW1lIiwic3BsaXRIb3N0UG9ydCIsInNlcnZpY2VVcmwiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIm91dHB1dFN0YXR1cyIsInN0YXR1cyIsInByb2dyZXNzIiwiY29kZSIsImRldGFpbHMiLCJmaW5hbFN0YXR1cyIsImFzc2lnbiIsIm9uUmVjZWl2ZVN0YXR1cyIsImNhbGwiLCJkb1BpY2siLCJFcnJvciIsInBpY2tSZXN1bHQiLCJwaWNrSW5mb3JtYXRpb24iLCJzdWJjaGFubmVsU3RyaW5nIiwic3ViY2hhbm5lbCIsImdldENoYW5uZWx6UmVmIiwiaWQiLCJnZXRBZGRyZXNzIiwiUGlja1Jlc3VsdFR5cGUiLCJwaWNrUmVzdWx0VHlwZSIsIkNPTVBMRVRFIiwiZ2VuZXJhdGVNZXRhZGF0YSIsInNlcnZpY2VfdXJsIiwidGhlbiIsImNyZWRzTWV0YWRhdGEiLCJfYyIsImZpbmFsTWV0YWRhdGEiLCJjbG9uZSIsIm1lcmdlIiwiZ2V0IiwiU3RhdHVzIiwiSU5URVJOQUwiLCJNZXRhZGF0YSIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJSRUFEWSIsIkluZmluaXR5Iiwic2V0IiwiZ2V0RGVhZGxpbmVUaW1lb3V0U3RyaW5nIiwiZ2V0UmVhbFN1YmNoYW5uZWwiLCJjcmVhdGVDYWxsIiwib25SZWNlaXZlTWV0YWRhdGEiLCJvblJlY2VpdmVNZXNzYWdlIiwibWVzc2FnZSIsInJzdENvZGUiLCJjb25zdGFudHMiLCJOR0hUVFAyX1JFRlVTRURfU1RSRUFNIiwiZXJyb3IiLCJvbkNvbW1pdHRlZCIsIm9uQ2FsbFN0YXJ0ZWQiLCJnZXRDYWxsTnVtYmVyIiwic3RhcnRSZWFkIiwic2VuZE1lc3NhZ2VXaXRoQ29udGV4dCIsImNvbnRleHQiLCJoYWxmQ2xvc2UiLCJyZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUiLCJVTktOT1dOIiwiRFJPUCIsInNldEltbWVkaWF0ZSIsIlRSQU5TSUVOVF9GQUlMVVJFIiwiZ2V0T3B0aW9ucyIsIndhaXRGb3JSZWFkeSIsInF1ZXVlQ2FsbEZvclBpY2siLCJRVUVVRSIsImNhbmNlbFdpdGhTdGF0dXMiLCJnZXRQZWVyIiwiZ2V0VGFyZ2V0Iiwic3RhcnQiLCJzZXRDcmVkZW50aWFscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var _a, _b, _c, _d;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst process_1 = __webpack_require__(/*! process */ \"process\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst DEFAULT_LOGGER = {\n    error: (message, ...optionalParams)=>{\n        console.error(\"E \" + message, ...optionalParams);\n    },\n    info: (message, ...optionalParams)=>{\n        console.error(\"I \" + message, ...optionalParams);\n    },\n    debug: (message, ...optionalParams)=>{\n        console.error(\"D \" + message, ...optionalParams);\n    }\n};\nlet _logger = DEFAULT_LOGGER;\nlet _logVerbosity = constants_1.LogVerbosity.ERROR;\nconst verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : \"\";\nswitch(verbosityString.toUpperCase()){\n    case \"DEBUG\":\n        _logVerbosity = constants_1.LogVerbosity.DEBUG;\n        break;\n    case \"INFO\":\n        _logVerbosity = constants_1.LogVerbosity.INFO;\n        break;\n    case \"ERROR\":\n        _logVerbosity = constants_1.LogVerbosity.ERROR;\n        break;\n    case \"NONE\":\n        _logVerbosity = constants_1.LogVerbosity.NONE;\n        break;\n    default:\n}\nconst getLogger = ()=>{\n    return _logger;\n};\nexports.getLogger = getLogger;\nconst setLogger = (logger)=>{\n    _logger = logger;\n};\nexports.setLogger = setLogger;\nconst setLoggerVerbosity = (verbosity)=>{\n    _logVerbosity = verbosity;\n};\nexports.setLoggerVerbosity = setLoggerVerbosity;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst log = (severity, ...args)=>{\n    let logFunction;\n    if (severity >= _logVerbosity) {\n        switch(severity){\n            case constants_1.LogVerbosity.DEBUG:\n                logFunction = _logger.debug;\n                break;\n            case constants_1.LogVerbosity.INFO:\n                logFunction = _logger.info;\n                break;\n            case constants_1.LogVerbosity.ERROR:\n                logFunction = _logger.error;\n                break;\n        }\n        /* Fall back to _logger.error when other methods are not available for\n         * compatiblity with older behavior that always logged to _logger.error */ if (!logFunction) {\n            logFunction = _logger.error;\n        }\n        if (logFunction) {\n            logFunction.bind(_logger)(...args);\n        }\n    }\n};\nexports.log = log;\nconst tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : \"\";\nconst enabledTracers = new Set();\nconst disabledTracers = new Set();\nfor (const tracerName of tracersString.split(\",\")){\n    if (tracerName.startsWith(\"-\")) {\n        disabledTracers.add(tracerName.substring(1));\n    } else {\n        enabledTracers.add(tracerName);\n    }\n}\nconst allEnabled = enabledTracers.has(\"all\");\nfunction trace(severity, tracer, text) {\n    if (isTracerEnabled(tracer)) {\n        (0, exports.log)(severity, new Date().toISOString() + \" | v\" + clientVersion + \" \" + process_1.pid + \" | \" + tracer + \" | \" + text);\n    }\n}\nexports.trace = trace;\nfunction isTracerEnabled(tracer) {\n    return !disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer));\n}\nexports.isTracerEnabled = isTracerEnabled; //# sourceMappingURL=logging.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxJQUFJQSxJQUFJQyxJQUFJQyxJQUFJQztBQUNoQkMsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSxhQUFhLEdBQUdBLFdBQVcsR0FBR0EsMEJBQTBCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQ2xJLE1BQU1RLGNBQWNDLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1DLFlBQVlELG1CQUFPQSxDQUFDLHdCQUFTO0FBQ25DLE1BQU1FLGdCQUFnQkYsMEdBQXFDO0FBQzNELE1BQU1JLGlCQUFpQjtJQUNuQkMsT0FBTyxDQUFDQyxTQUFTLEdBQUdDO1FBQ2hCQyxRQUFRSCxLQUFLLENBQUMsT0FBT0MsWUFBWUM7SUFDckM7SUFDQUUsTUFBTSxDQUFDSCxTQUFTLEdBQUdDO1FBQ2ZDLFFBQVFILEtBQUssQ0FBQyxPQUFPQyxZQUFZQztJQUNyQztJQUNBRyxPQUFPLENBQUNKLFNBQVMsR0FBR0M7UUFDaEJDLFFBQVFILEtBQUssQ0FBQyxPQUFPQyxZQUFZQztJQUNyQztBQUNKO0FBQ0EsSUFBSUksVUFBVVA7QUFDZCxJQUFJUSxnQkFBZ0JiLFlBQVljLFlBQVksQ0FBQ0MsS0FBSztBQUNsRCxNQUFNQyxrQkFBa0IsQ0FBQzdCLEtBQUssQ0FBQ0QsS0FBSytCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLE1BQU0sUUFBUWpDLE9BQU8sS0FBSyxJQUFJQSxLQUFLK0IsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRSxjQUFjLE1BQU0sUUFBUWpDLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0FBQ25LLE9BQVE2QixnQkFBZ0JLLFdBQVc7SUFDL0IsS0FBSztRQUNEUixnQkFBZ0JiLFlBQVljLFlBQVksQ0FBQ1EsS0FBSztRQUM5QztJQUNKLEtBQUs7UUFDRFQsZ0JBQWdCYixZQUFZYyxZQUFZLENBQUNTLElBQUk7UUFDN0M7SUFDSixLQUFLO1FBQ0RWLGdCQUFnQmIsWUFBWWMsWUFBWSxDQUFDQyxLQUFLO1FBQzlDO0lBQ0osS0FBSztRQUNERixnQkFBZ0JiLFlBQVljLFlBQVksQ0FBQ1UsSUFBSTtRQUM3QztJQUNKO0FBRUo7QUFDQSxNQUFNekIsWUFBWTtJQUNkLE9BQU9hO0FBQ1g7QUFDQXBCLGlCQUFpQixHQUFHTztBQUNwQixNQUFNRCxZQUFZLENBQUMyQjtJQUNmYixVQUFVYTtBQUNkO0FBQ0FqQyxpQkFBaUIsR0FBR007QUFDcEIsTUFBTUQscUJBQXFCLENBQUM2QjtJQUN4QmIsZ0JBQWdCYTtBQUNwQjtBQUNBbEMsMEJBQTBCLEdBQUdLO0FBQzdCLDhEQUE4RDtBQUM5RCxNQUFNRCxNQUFNLENBQUMrQixVQUFVLEdBQUdDO0lBQ3RCLElBQUlDO0lBQ0osSUFBSUYsWUFBWWQsZUFBZTtRQUMzQixPQUFRYztZQUNKLEtBQUszQixZQUFZYyxZQUFZLENBQUNRLEtBQUs7Z0JBQy9CTyxjQUFjakIsUUFBUUQsS0FBSztnQkFDM0I7WUFDSixLQUFLWCxZQUFZYyxZQUFZLENBQUNTLElBQUk7Z0JBQzlCTSxjQUFjakIsUUFBUUYsSUFBSTtnQkFDMUI7WUFDSixLQUFLVixZQUFZYyxZQUFZLENBQUNDLEtBQUs7Z0JBQy9CYyxjQUFjakIsUUFBUU4sS0FBSztnQkFDM0I7UUFDUjtRQUNBO2dGQUN3RSxHQUN4RSxJQUFJLENBQUN1QixhQUFhO1lBQ2RBLGNBQWNqQixRQUFRTixLQUFLO1FBQy9CO1FBQ0EsSUFBSXVCLGFBQWE7WUFDYkEsWUFBWUMsSUFBSSxDQUFDbEIsWUFBWWdCO1FBQ2pDO0lBQ0o7QUFDSjtBQUNBcEMsV0FBVyxHQUFHSTtBQUNkLE1BQU1tQyxnQkFBZ0IsQ0FBQzFDLEtBQUssQ0FBQ0QsS0FBSzZCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ2MsZUFBZSxNQUFNLFFBQVE1QyxPQUFPLEtBQUssSUFBSUEsS0FBSzZCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ2UsVUFBVSxNQUFNLFFBQVE1QyxPQUFPLEtBQUssSUFBSUEsS0FBSztBQUN6SixNQUFNNkMsaUJBQWlCLElBQUlDO0FBQzNCLE1BQU1DLGtCQUFrQixJQUFJRDtBQUM1QixLQUFLLE1BQU1FLGNBQWNOLGNBQWNPLEtBQUssQ0FBQyxLQUFNO0lBQy9DLElBQUlELFdBQVdFLFVBQVUsQ0FBQyxNQUFNO1FBQzVCSCxnQkFBZ0JJLEdBQUcsQ0FBQ0gsV0FBV0ksU0FBUyxDQUFDO0lBQzdDLE9BQ0s7UUFDRFAsZUFBZU0sR0FBRyxDQUFDSDtJQUN2QjtBQUNKO0FBQ0EsTUFBTUssYUFBYVIsZUFBZVMsR0FBRyxDQUFDO0FBQ3RDLFNBQVNoRCxNQUFNZ0MsUUFBUSxFQUFFaUIsTUFBTSxFQUFFQyxJQUFJO0lBQ2pDLElBQUluRCxnQkFBZ0JrRCxTQUFTO1FBQ3hCLElBQUdwRCxRQUFRSSxHQUFHLEVBQUUrQixVQUFVLElBQUltQixPQUFPQyxXQUFXLEtBQUssU0FBUzVDLGdCQUFnQixNQUFNRCxVQUFVOEMsR0FBRyxHQUFHLFFBQVFKLFNBQVMsUUFBUUM7SUFDbEk7QUFDSjtBQUNBckQsYUFBYSxHQUFHRztBQUNoQixTQUFTRCxnQkFBZ0JrRCxNQUFNO0lBQzNCLE9BQVEsQ0FBQ1IsZ0JBQWdCTyxHQUFHLENBQUNDLFdBQVlGLENBQUFBLGNBQWNSLGVBQWVTLEdBQUcsQ0FBQ0MsT0FBTTtBQUNwRjtBQUNBcEQsdUJBQXVCLEdBQUdFLGlCQUMxQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2dnaW5nLmpzPzQ1M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbnZhciBfYSwgX2IsIF9jLCBfZDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNUcmFjZXJFbmFibGVkID0gZXhwb3J0cy50cmFjZSA9IGV4cG9ydHMubG9nID0gZXhwb3J0cy5zZXRMb2dnZXJWZXJib3NpdHkgPSBleHBvcnRzLnNldExvZ2dlciA9IGV4cG9ydHMuZ2V0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBwcm9jZXNzXzEgPSByZXF1aXJlKFwicHJvY2Vzc1wiKTtcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuY29uc3QgREVGQVVMVF9MT0dHRVIgPSB7XG4gICAgZXJyb3I6IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfSxcbiAgICBpbmZvOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSSAnICsgbWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgIH0sXG4gICAgZGVidWc6IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdEICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfSxcbn07XG5sZXQgX2xvZ2dlciA9IERFRkFVTFRfTE9HR0VSO1xubGV0IF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1I7XG5jb25zdCB2ZXJib3NpdHlTdHJpbmcgPSAoX2IgPSAoX2EgPSBwcm9jZXNzLmVudi5HUlBDX05PREVfVkVSQk9TSVRZKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwcm9jZXNzLmVudi5HUlBDX1ZFUkJPU0lUWSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG5zd2l0Y2ggKHZlcmJvc2l0eVN0cmluZy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgY2FzZSAnREVCVUcnOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdJTkZPJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdFUlJPUic6XG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1I7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ05PTkUnOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5Lk5PTkU7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgLy8gSWdub3JlIGFueSBvdGhlciB2YWx1ZXNcbn1cbmNvbnN0IGdldExvZ2dlciA9ICgpID0+IHtcbiAgICByZXR1cm4gX2xvZ2dlcjtcbn07XG5leHBvcnRzLmdldExvZ2dlciA9IGdldExvZ2dlcjtcbmNvbnN0IHNldExvZ2dlciA9IChsb2dnZXIpID0+IHtcbiAgICBfbG9nZ2VyID0gbG9nZ2VyO1xufTtcbmV4cG9ydHMuc2V0TG9nZ2VyID0gc2V0TG9nZ2VyO1xuY29uc3Qgc2V0TG9nZ2VyVmVyYm9zaXR5ID0gKHZlcmJvc2l0eSkgPT4ge1xuICAgIF9sb2dWZXJib3NpdHkgPSB2ZXJib3NpdHk7XG59O1xuZXhwb3J0cy5zZXRMb2dnZXJWZXJib3NpdHkgPSBzZXRMb2dnZXJWZXJib3NpdHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgbG9nID0gKHNldmVyaXR5LCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IGxvZ0Z1bmN0aW9uO1xuICAgIGlmIChzZXZlcml0eSA+PSBfbG9nVmVyYm9zaXR5KSB7XG4gICAgICAgIHN3aXRjaCAoc2V2ZXJpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHOlxuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5kZWJ1ZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk86XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmluZm87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUjpcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuZXJyb3I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyogRmFsbCBiYWNrIHRvIF9sb2dnZXIuZXJyb3Igd2hlbiBvdGhlciBtZXRob2RzIGFyZSBub3QgYXZhaWxhYmxlIGZvclxuICAgICAgICAgKiBjb21wYXRpYmxpdHkgd2l0aCBvbGRlciBiZWhhdmlvciB0aGF0IGFsd2F5cyBsb2dnZWQgdG8gX2xvZ2dlci5lcnJvciAqL1xuICAgICAgICBpZiAoIWxvZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICBsb2dGdW5jdGlvbi5iaW5kKF9sb2dnZXIpKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMubG9nID0gbG9nO1xuY29uc3QgdHJhY2Vyc1N0cmluZyA9IChfZCA9IChfYyA9IHByb2Nlc3MuZW52LkdSUENfTk9ERV9UUkFDRSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogcHJvY2Vzcy5lbnYuR1JQQ19UUkFDRSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJyc7XG5jb25zdCBlbmFibGVkVHJhY2VycyA9IG5ldyBTZXQoKTtcbmNvbnN0IGRpc2FibGVkVHJhY2VycyA9IG5ldyBTZXQoKTtcbmZvciAoY29uc3QgdHJhY2VyTmFtZSBvZiB0cmFjZXJzU3RyaW5nLnNwbGl0KCcsJykpIHtcbiAgICBpZiAodHJhY2VyTmFtZS5zdGFydHNXaXRoKCctJykpIHtcbiAgICAgICAgZGlzYWJsZWRUcmFjZXJzLmFkZCh0cmFjZXJOYW1lLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbmFibGVkVHJhY2Vycy5hZGQodHJhY2VyTmFtZSk7XG4gICAgfVxufVxuY29uc3QgYWxsRW5hYmxlZCA9IGVuYWJsZWRUcmFjZXJzLmhhcygnYWxsJyk7XG5mdW5jdGlvbiB0cmFjZShzZXZlcml0eSwgdHJhY2VyLCB0ZXh0KSB7XG4gICAgaWYgKGlzVHJhY2VyRW5hYmxlZCh0cmFjZXIpKSB7XG4gICAgICAgICgwLCBleHBvcnRzLmxvZykoc2V2ZXJpdHksIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArICcgfCB2JyArIGNsaWVudFZlcnNpb24gKyAnICcgKyBwcm9jZXNzXzEucGlkICsgJyB8ICcgKyB0cmFjZXIgKyAnIHwgJyArIHRleHQpO1xuICAgIH1cbn1cbmV4cG9ydHMudHJhY2UgPSB0cmFjZTtcbmZ1bmN0aW9uIGlzVHJhY2VyRW5hYmxlZCh0cmFjZXIpIHtcbiAgICByZXR1cm4gKCFkaXNhYmxlZFRyYWNlcnMuaGFzKHRyYWNlcikgJiYgKGFsbEVuYWJsZWQgfHwgZW5hYmxlZFRyYWNlcnMuaGFzKHRyYWNlcikpKTtcbn1cbmV4cG9ydHMuaXNUcmFjZXJFbmFibGVkID0gaXNUcmFjZXJFbmFibGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5qcy5tYXAiXSwibmFtZXMiOlsiX2EiLCJfYiIsIl9jIiwiX2QiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzVHJhY2VyRW5hYmxlZCIsInRyYWNlIiwibG9nIiwic2V0TG9nZ2VyVmVyYm9zaXR5Iiwic2V0TG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiY29uc3RhbnRzXzEiLCJyZXF1aXJlIiwicHJvY2Vzc18xIiwiY2xpZW50VmVyc2lvbiIsInZlcnNpb24iLCJERUZBVUxUX0xPR0dFUiIsImVycm9yIiwibWVzc2FnZSIsIm9wdGlvbmFsUGFyYW1zIiwiY29uc29sZSIsImluZm8iLCJkZWJ1ZyIsIl9sb2dnZXIiLCJfbG9nVmVyYm9zaXR5IiwiTG9nVmVyYm9zaXR5IiwiRVJST1IiLCJ2ZXJib3NpdHlTdHJpbmciLCJwcm9jZXNzIiwiZW52IiwiR1JQQ19OT0RFX1ZFUkJPU0lUWSIsIkdSUENfVkVSQk9TSVRZIiwidG9VcHBlckNhc2UiLCJERUJVRyIsIklORk8iLCJOT05FIiwibG9nZ2VyIiwidmVyYm9zaXR5Iiwic2V2ZXJpdHkiLCJhcmdzIiwibG9nRnVuY3Rpb24iLCJiaW5kIiwidHJhY2Vyc1N0cmluZyIsIkdSUENfTk9ERV9UUkFDRSIsIkdSUENfVFJBQ0UiLCJlbmFibGVkVHJhY2VycyIsIlNldCIsImRpc2FibGVkVHJhY2VycyIsInRyYWNlck5hbWUiLCJzcGxpdCIsInN0YXJ0c1dpdGgiLCJhZGQiLCJzdWJzdHJpbmciLCJhbGxFbmFibGVkIiwiaGFzIiwidHJhY2VyIiwidGV4dCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInBpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/make-client.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.loadPackageDefinition = exports.makeClientConstructor = void 0;\nconst client_1 = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */ const requesterFuncs = {\n    unary: client_1.Client.prototype.makeUnaryRequest,\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\n    bidi: client_1.Client.prototype.makeBidiStreamRequest\n};\n/**\n * Returns true, if given key is included in the blacklisted\n * keys.\n * @param key key for check, string.\n */ function isPrototypePolluted(key) {\n    return [\n        \"__proto__\",\n        \"prototype\",\n        \"constructor\"\n    ].includes(key);\n}\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */ function makeClientConstructor(methods, serviceName, classOptions) {\n    if (!classOptions) {\n        classOptions = {};\n    }\n    class ServiceClientImpl extends client_1.Client {\n    }\n    Object.keys(methods).forEach((name)=>{\n        if (isPrototypePolluted(name)) {\n            return;\n        }\n        const attrs = methods[name];\n        let methodType;\n        // TODO(murgatroid99): Verify that we don't need this anymore\n        if (typeof name === \"string\" && name.charAt(0) === \"$\") {\n            throw new Error(\"Method names cannot start with $\");\n        }\n        if (attrs.requestStream) {\n            if (attrs.responseStream) {\n                methodType = \"bidi\";\n            } else {\n                methodType = \"client_stream\";\n            }\n        } else {\n            if (attrs.responseStream) {\n                methodType = \"server_stream\";\n            } else {\n                methodType = \"unary\";\n            }\n        }\n        const serialize = attrs.requestSerialize;\n        const deserialize = attrs.responseDeserialize;\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n        ServiceClientImpl.prototype[name] = methodFunc;\n        // Associate all provided attributes with the method\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\n        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\n            ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];\n        }\n    });\n    ServiceClientImpl.service = methods;\n    ServiceClientImpl.serviceName = serviceName;\n    return ServiceClientImpl;\n}\nexports.makeClientConstructor = makeClientConstructor;\nfunction partial(fn, path, serialize, deserialize) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function(...args) {\n        return fn.call(this, path, serialize, deserialize, ...args);\n    };\n}\nfunction isProtobufTypeDefinition(obj) {\n    return \"format\" in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */ function loadPackageDefinition(packageDef) {\n    const result = {};\n    for(const serviceFqn in packageDef){\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\n            const service = packageDef[serviceFqn];\n            const nameComponents = serviceFqn.split(\".\");\n            if (nameComponents.some((comp)=>isPrototypePolluted(comp))) {\n                continue;\n            }\n            const serviceName = nameComponents[nameComponents.length - 1];\n            let current = result;\n            for (const packageName of nameComponents.slice(0, -1)){\n                if (!current[packageName]) {\n                    current[packageName] = {};\n                }\n                current = current[packageName];\n            }\n            if (isProtobufTypeDefinition(service)) {\n                current[serviceName] = service;\n            } else {\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\n            }\n        }\n    }\n    return result;\n}\nexports.loadPackageDefinition = loadPackageDefinition; //# sourceMappingURL=make-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWFrZS1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSw2QkFBNkIsR0FBRyxLQUFLO0FBQ3JFLE1BQU1JLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DOzs7O0NBSUMsR0FDRCxNQUFNQyxpQkFBaUI7SUFDbkJDLE9BQU9ILFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDQyxnQkFBZ0I7SUFDakRDLGVBQWVQLFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDRyx1QkFBdUI7SUFDaEVDLGVBQWVULFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDSyx1QkFBdUI7SUFDaEVDLE1BQU1YLFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDTyxxQkFBcUI7QUFDekQ7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0Msb0JBQW9CQyxHQUFHO0lBQzVCLE9BQU87UUFBQztRQUFhO1FBQWE7S0FBYyxDQUFDQyxRQUFRLENBQUNEO0FBQzlEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNmLHNCQUFzQmlCLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxZQUFZO0lBQzdELElBQUksQ0FBQ0EsY0FBYztRQUNmQSxlQUFlLENBQUM7SUFDcEI7SUFDQSxNQUFNQywwQkFBMEJuQixTQUFTSSxNQUFNO0lBQy9DO0lBQ0FWLE9BQU8wQixJQUFJLENBQUNKLFNBQVNLLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDekIsSUFBSVQsb0JBQW9CUyxPQUFPO1lBQzNCO1FBQ0o7UUFDQSxNQUFNQyxRQUFRUCxPQUFPLENBQUNNLEtBQUs7UUFDM0IsSUFBSUU7UUFDSiw2REFBNkQ7UUFDN0QsSUFBSSxPQUFPRixTQUFTLFlBQVlBLEtBQUtHLE1BQU0sQ0FBQyxPQUFPLEtBQUs7WUFDcEQsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSUgsTUFBTUksYUFBYSxFQUFFO1lBQ3JCLElBQUlKLE1BQU1LLGNBQWMsRUFBRTtnQkFDdEJKLGFBQWE7WUFDakIsT0FDSztnQkFDREEsYUFBYTtZQUNqQjtRQUNKLE9BQ0s7WUFDRCxJQUFJRCxNQUFNSyxjQUFjLEVBQUU7Z0JBQ3RCSixhQUFhO1lBQ2pCLE9BQ0s7Z0JBQ0RBLGFBQWE7WUFDakI7UUFDSjtRQUNBLE1BQU1LLFlBQVlOLE1BQU1PLGdCQUFnQjtRQUN4QyxNQUFNQyxjQUFjUixNQUFNUyxtQkFBbUI7UUFDN0MsTUFBTUMsYUFBYUMsUUFBUWhDLGNBQWMsQ0FBQ3NCLFdBQVcsRUFBRUQsTUFBTVksSUFBSSxFQUFFTixXQUFXRTtRQUM5RVosa0JBQWtCZCxTQUFTLENBQUNpQixLQUFLLEdBQUdXO1FBQ3BDLG9EQUFvRDtRQUNwRHZDLE9BQU8wQyxNQUFNLENBQUNqQixrQkFBa0JkLFNBQVMsQ0FBQ2lCLEtBQUssRUFBRUM7UUFDakQsSUFBSUEsTUFBTWMsWUFBWSxJQUFJLENBQUN4QixvQkFBb0JVLE1BQU1jLFlBQVksR0FBRztZQUNoRWxCLGtCQUFrQmQsU0FBUyxDQUFDa0IsTUFBTWMsWUFBWSxDQUFDLEdBQzNDbEIsa0JBQWtCZCxTQUFTLENBQUNpQixLQUFLO1FBQ3pDO0lBQ0o7SUFDQUgsa0JBQWtCbUIsT0FBTyxHQUFHdEI7SUFDNUJHLGtCQUFrQkYsV0FBVyxHQUFHQTtJQUNoQyxPQUFPRTtBQUNYO0FBQ0F2Qiw2QkFBNkIsR0FBR0c7QUFDaEMsU0FBU21DLFFBQVFLLEVBQUUsRUFBRUosSUFBSSxFQUFFTixTQUFTLEVBQUVFLFdBQVc7SUFDN0MsOERBQThEO0lBQzlELE9BQU8sU0FBVSxHQUFHUyxJQUFJO1FBQ3BCLE9BQU9ELEdBQUdFLElBQUksQ0FBQyxJQUFJLEVBQUVOLE1BQU1OLFdBQVdFLGdCQUFnQlM7SUFDMUQ7QUFDSjtBQUNBLFNBQVNFLHlCQUF5QkMsR0FBRztJQUNqQyxPQUFPLFlBQVlBO0FBQ3ZCO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVM3QyxzQkFBc0I4QyxVQUFVO0lBQ3JDLE1BQU1DLFNBQVMsQ0FBQztJQUNoQixJQUFLLE1BQU1DLGNBQWNGLFdBQVk7UUFDakMsSUFBSWxELE9BQU9XLFNBQVMsQ0FBQzBDLGNBQWMsQ0FBQ04sSUFBSSxDQUFDRyxZQUFZRSxhQUFhO1lBQzlELE1BQU1SLFVBQVVNLFVBQVUsQ0FBQ0UsV0FBVztZQUN0QyxNQUFNRSxpQkFBaUJGLFdBQVdHLEtBQUssQ0FBQztZQUN4QyxJQUFJRCxlQUFlRSxJQUFJLENBQUMsQ0FBQ0MsT0FBU3RDLG9CQUFvQnNDLFFBQVE7Z0JBQzFEO1lBQ0o7WUFDQSxNQUFNbEMsY0FBYytCLGNBQWMsQ0FBQ0EsZUFBZUksTUFBTSxHQUFHLEVBQUU7WUFDN0QsSUFBSUMsVUFBVVI7WUFDZCxLQUFLLE1BQU1TLGVBQWVOLGVBQWVPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBSTtnQkFDbkQsSUFBSSxDQUFDRixPQUFPLENBQUNDLFlBQVksRUFBRTtvQkFDdkJELE9BQU8sQ0FBQ0MsWUFBWSxHQUFHLENBQUM7Z0JBQzVCO2dCQUNBRCxVQUFVQSxPQUFPLENBQUNDLFlBQVk7WUFDbEM7WUFDQSxJQUFJWix5QkFBeUJKLFVBQVU7Z0JBQ25DZSxPQUFPLENBQUNwQyxZQUFZLEdBQUdxQjtZQUMzQixPQUNLO2dCQUNEZSxPQUFPLENBQUNwQyxZQUFZLEdBQUdsQixzQkFBc0J1QyxTQUFTckIsYUFBYSxDQUFDO1lBQ3hFO1FBQ0o7SUFDSjtJQUNBLE9BQU80QjtBQUNYO0FBQ0FqRCw2QkFBNkIsR0FBR0UsdUJBQ2hDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21ha2UtY2xpZW50LmpzPzZiYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSB2b2lkIDA7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbi8qKlxuICogTWFwIHdpdGggc2hvcnQgbmFtZXMgZm9yIGVhY2ggb2YgdGhlIHJlcXVlc3RlciBtYWtlciBmdW5jdGlvbnMuIFVzZWQgaW5cbiAqIG1ha2VDbGllbnRDb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcmVxdWVzdGVyRnVuY3MgPSB7XG4gICAgdW5hcnk6IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZVVuYXJ5UmVxdWVzdCxcbiAgICBzZXJ2ZXJfc3RyZWFtOiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0LFxuICAgIGNsaWVudF9zdHJlYW06IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZUNsaWVudFN0cmVhbVJlcXVlc3QsXG4gICAgYmlkaTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlQmlkaVN0cmVhbVJlcXVlc3QsXG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUsIGlmIGdpdmVuIGtleSBpcyBpbmNsdWRlZCBpbiB0aGUgYmxhY2tsaXN0ZWRcbiAqIGtleXMuXG4gKiBAcGFyYW0ga2V5IGtleSBmb3IgY2hlY2ssIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGVQb2xsdXRlZChrZXkpIHtcbiAgICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5jbHVkZXMoa2V5KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGNvbnN0cnVjdG9yIGZvciBhIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBtZXRob2RzLCBhcyBzcGVjaWZpZWQgaW5cbiAqIHRoZSBtZXRob2RzIGFyZ3VtZW50LiBUaGUgcmVzdWx0aW5nIGNsYXNzIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBtZXRob2QgZm9yXG4gKiBlYWNoIG1ldGhvZCBpbiB0aGUgc2VydmljZSwgd2hpY2ggaXMgYSBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIG9uZSBvZiB0aGVcbiAqIFtDbGllbnRde0BsaW5rIGdycGMuQ2xpZW50fSByZXF1ZXN0IG1ldGhvZHMsIGRlcGVuZGluZyBvbiBgcmVxdWVzdFNlcmlhbGl6ZWBcbiAqIGFuZCBgcmVzcG9uc2VTZXJpYWxpemVgLCB3aXRoIHRoZSBgbWV0aG9kYCwgYHNlcmlhbGl6ZWAsIGFuZCBgZGVzZXJpYWxpemVgXG4gKiBhcmd1bWVudHMgcHJlZGVmaW5lZC5cbiAqIEBwYXJhbSBtZXRob2RzIEFuIG9iamVjdCBtYXBwaW5nIG1ldGhvZCBuYW1lcyB0b1xuICogICAgIG1ldGhvZCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gc2VydmljZU5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoZSBzZXJ2aWNlXG4gKiBAcGFyYW0gY2xhc3NPcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybiBOZXcgY2xpZW50IGNvbnN0cnVjdG9yLCB3aGljaCBpcyBhIHN1YmNsYXNzIG9mXG4gKiAgICAge0BsaW5rIGdycGMuQ2xpZW50fSwgYW5kIGhhcyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhhdCBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gbWFrZUNsaWVudENvbnN0cnVjdG9yKG1ldGhvZHMsIHNlcnZpY2VOYW1lLCBjbGFzc09wdGlvbnMpIHtcbiAgICBpZiAoIWNsYXNzT3B0aW9ucykge1xuICAgICAgICBjbGFzc09wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY2xhc3MgU2VydmljZUNsaWVudEltcGwgZXh0ZW5kcyBjbGllbnRfMS5DbGllbnQge1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBpZiAoaXNQcm90b3R5cGVQb2xsdXRlZChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJzID0gbWV0aG9kc1tuYW1lXTtcbiAgICAgICAgbGV0IG1ldGhvZFR5cGU7XG4gICAgICAgIC8vIFRPRE8obXVyZ2F0cm9pZDk5KTogVmVyaWZ5IHRoYXQgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiBuYW1lLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCAkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzLnJlcXVlc3RTdHJlYW0pIHtcbiAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnYmlkaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ2NsaWVudF9zdHJlYW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGF0dHJzLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdzZXJ2ZXJfc3RyZWFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAndW5hcnknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZSA9IGF0dHJzLnJlcXVlc3RTZXJpYWxpemU7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplID0gYXR0cnMucmVzcG9uc2VEZXNlcmlhbGl6ZTtcbiAgICAgICAgY29uc3QgbWV0aG9kRnVuYyA9IHBhcnRpYWwocmVxdWVzdGVyRnVuY3NbbWV0aG9kVHlwZV0sIGF0dHJzLnBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpO1xuICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2RGdW5jO1xuICAgICAgICAvLyBBc3NvY2lhdGUgYWxsIHByb3ZpZGVkIGF0dHJpYnV0ZXMgd2l0aCB0aGUgbWV0aG9kXG4gICAgICAgIE9iamVjdC5hc3NpZ24oU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW25hbWVdLCBhdHRycyk7XG4gICAgICAgIGlmIChhdHRycy5vcmlnaW5hbE5hbWUgJiYgIWlzUHJvdG90eXBlUG9sbHV0ZWQoYXR0cnMub3JpZ2luYWxOYW1lKSkge1xuICAgICAgICAgICAgU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW2F0dHJzLm9yaWdpbmFsTmFtZV0gPVxuICAgICAgICAgICAgICAgIFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFNlcnZpY2VDbGllbnRJbXBsLnNlcnZpY2UgPSBtZXRob2RzO1xuICAgIFNlcnZpY2VDbGllbnRJbXBsLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgcmV0dXJuIFNlcnZpY2VDbGllbnRJbXBsO1xufVxuZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSBtYWtlQ2xpZW50Q29uc3RydWN0b3I7XG5mdW5jdGlvbiBwYXJ0aWFsKGZuLCBwYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgcGF0aCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgLi4uYXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzUHJvdG9idWZUeXBlRGVmaW5pdGlvbihvYmopIHtcbiAgICByZXR1cm4gJ2Zvcm1hdCcgaW4gb2JqO1xufVxuLyoqXG4gKiBMb2FkIGEgZ1JQQyBwYWNrYWdlIGRlZmluaXRpb24gYXMgYSBnUlBDIG9iamVjdCBoaWVyYXJjaHkuXG4gKiBAcGFyYW0gcGFja2FnZURlZiBUaGUgcGFja2FnZSBkZWZpbml0aW9uIG9iamVjdC5cbiAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBnUlBDIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gbG9hZFBhY2thZ2VEZWZpbml0aW9uKHBhY2thZ2VEZWYpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHNlcnZpY2VGcW4gaW4gcGFja2FnZURlZikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhY2thZ2VEZWYsIHNlcnZpY2VGcW4pKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gcGFja2FnZURlZltzZXJ2aWNlRnFuXTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVDb21wb25lbnRzID0gc2VydmljZUZxbi5zcGxpdCgnLicpO1xuICAgICAgICAgICAgaWYgKG5hbWVDb21wb25lbnRzLnNvbWUoKGNvbXApID0+IGlzUHJvdG90eXBlUG9sbHV0ZWQoY29tcCkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlTmFtZSA9IG5hbWVDb21wb25lbnRzW25hbWVDb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSByZXN1bHQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhY2thZ2VOYW1lIG9mIG5hbWVDb21wb25lbnRzLnNsaWNlKDAsIC0xKSkge1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFtwYWNrYWdlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFtwYWNrYWdlTmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFja2FnZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJvdG9idWZUeXBlRGVmaW5pdGlvbihzZXJ2aWNlKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbc2VydmljZU5hbWVdID0gc2VydmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbc2VydmljZU5hbWVdID0gbWFrZUNsaWVudENvbnN0cnVjdG9yKHNlcnZpY2UsIHNlcnZpY2VOYW1lLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gbG9hZFBhY2thZ2VEZWZpbml0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibG9hZFBhY2thZ2VEZWZpbml0aW9uIiwibWFrZUNsaWVudENvbnN0cnVjdG9yIiwiY2xpZW50XzEiLCJyZXF1aXJlIiwicmVxdWVzdGVyRnVuY3MiLCJ1bmFyeSIsIkNsaWVudCIsInByb3RvdHlwZSIsIm1ha2VVbmFyeVJlcXVlc3QiLCJzZXJ2ZXJfc3RyZWFtIiwibWFrZVNlcnZlclN0cmVhbVJlcXVlc3QiLCJjbGllbnRfc3RyZWFtIiwibWFrZUNsaWVudFN0cmVhbVJlcXVlc3QiLCJiaWRpIiwibWFrZUJpZGlTdHJlYW1SZXF1ZXN0IiwiaXNQcm90b3R5cGVQb2xsdXRlZCIsImtleSIsImluY2x1ZGVzIiwibWV0aG9kcyIsInNlcnZpY2VOYW1lIiwiY2xhc3NPcHRpb25zIiwiU2VydmljZUNsaWVudEltcGwiLCJrZXlzIiwiZm9yRWFjaCIsIm5hbWUiLCJhdHRycyIsIm1ldGhvZFR5cGUiLCJjaGFyQXQiLCJFcnJvciIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsInNlcmlhbGl6ZSIsInJlcXVlc3RTZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJtZXRob2RGdW5jIiwicGFydGlhbCIsInBhdGgiLCJhc3NpZ24iLCJvcmlnaW5hbE5hbWUiLCJzZXJ2aWNlIiwiZm4iLCJhcmdzIiwiY2FsbCIsImlzUHJvdG9idWZUeXBlRGVmaW5pdGlvbiIsIm9iaiIsInBhY2thZ2VEZWYiLCJyZXN1bHQiLCJzZXJ2aWNlRnFuIiwiaGFzT3duUHJvcGVydHkiLCJuYW1lQ29tcG9uZW50cyIsInNwbGl0Iiwic29tZSIsImNvbXAiLCJsZW5ndGgiLCJjdXJyZW50IiwicGFja2FnZU5hbWUiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MaxMessageSizeFilterFactory = exports.MaxMessageSizeFilter = void 0;\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nclass MaxMessageSizeFilter extends filter_1.BaseFilter {\n    constructor(options){\n        super();\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        if (\"grpc.max_send_message_length\" in options) {\n            this.maxSendMessageSize = options[\"grpc.max_send_message_length\"];\n        }\n        if (\"grpc.max_receive_message_length\" in options) {\n            this.maxReceiveMessageSize = options[\"grpc.max_receive_message_length\"];\n        }\n    }\n    async sendMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */ if (this.maxSendMessageSize === -1) {\n            return message;\n        } else {\n            const concreteMessage = await message;\n            if (concreteMessage.message.length > this.maxSendMessageSize) {\n                throw {\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\n                    details: `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`,\n                    metadata: new metadata_1.Metadata()\n                };\n            } else {\n                return concreteMessage;\n            }\n        }\n    }\n    async receiveMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */ if (this.maxReceiveMessageSize === -1) {\n            return message;\n        } else {\n            const concreteMessage = await message;\n            if (concreteMessage.length > this.maxReceiveMessageSize) {\n                throw {\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\n                    details: `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`,\n                    metadata: new metadata_1.Metadata()\n                };\n            } else {\n                return concreteMessage;\n            }\n        }\n    }\n}\nexports.MaxMessageSizeFilter = MaxMessageSizeFilter;\nclass MaxMessageSizeFilterFactory {\n    constructor(options){\n        this.options = options;\n    }\n    createFilter() {\n        return new MaxMessageSizeFilter(this.options);\n    }\n}\nexports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory; //# sourceMappingURL=max-message-size-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWF4LW1lc3NhZ2Utc2l6ZS1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1DQUFtQyxHQUFHQSw0QkFBNEIsR0FBRyxLQUFLO0FBQzFFLE1BQU1JLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1GLDZCQUE2QkMsU0FBU0ksVUFBVTtJQUNsREMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUs7UUFDTCxJQUFJLENBQUNDLGtCQUFrQixHQUFHTCxZQUFZTSwrQkFBK0I7UUFDckUsSUFBSSxDQUFDQyxxQkFBcUIsR0FBR1AsWUFBWVEsa0NBQWtDO1FBQzNFLElBQUksa0NBQWtDSixTQUFTO1lBQzNDLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUdELE9BQU8sQ0FBQywrQkFBK0I7UUFDckU7UUFDQSxJQUFJLHFDQUFxQ0EsU0FBUztZQUM5QyxJQUFJLENBQUNHLHFCQUFxQixHQUFHSCxPQUFPLENBQUMsa0NBQWtDO1FBQzNFO0lBQ0o7SUFDQSxNQUFNSyxZQUFZQyxPQUFPLEVBQUU7UUFDdkI7b0JBQ1ksR0FDWixJQUFJLElBQUksQ0FBQ0wsa0JBQWtCLEtBQUssQ0FBQyxHQUFHO1lBQ2hDLE9BQU9LO1FBQ1gsT0FDSztZQUNELE1BQU1DLGtCQUFrQixNQUFNRDtZQUM5QixJQUFJQyxnQkFBZ0JELE9BQU8sQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ1Asa0JBQWtCLEVBQUU7Z0JBQzFELE1BQU07b0JBQ0ZRLE1BQU1iLFlBQVljLE1BQU0sQ0FBQ0Msa0JBQWtCO29CQUMzQ0MsU0FBUyxDQUFDLDhCQUE4QixFQUFFTCxnQkFBZ0JELE9BQU8sQ0FBQ0UsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUNQLGtCQUFrQixDQUFDLENBQUMsQ0FBQztvQkFDMUdZLFVBQVUsSUFBSWhCLFdBQVdpQixRQUFRO2dCQUNyQztZQUNKLE9BQ0s7Z0JBQ0QsT0FBT1A7WUFDWDtRQUNKO0lBQ0o7SUFDQSxNQUFNUSxlQUFlVCxPQUFPLEVBQUU7UUFDMUI7b0JBQ1ksR0FDWixJQUFJLElBQUksQ0FBQ0gscUJBQXFCLEtBQUssQ0FBQyxHQUFHO1lBQ25DLE9BQU9HO1FBQ1gsT0FDSztZQUNELE1BQU1DLGtCQUFrQixNQUFNRDtZQUM5QixJQUFJQyxnQkFBZ0JDLE1BQU0sR0FBRyxJQUFJLENBQUNMLHFCQUFxQixFQUFFO2dCQUNyRCxNQUFNO29CQUNGTSxNQUFNYixZQUFZYyxNQUFNLENBQUNDLGtCQUFrQjtvQkFDM0NDLFNBQVMsQ0FBQyxrQ0FBa0MsRUFBRUwsZ0JBQWdCQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQ0wscUJBQXFCLENBQUMsQ0FBQyxDQUFDO29CQUN6R1UsVUFBVSxJQUFJaEIsV0FBV2lCLFFBQVE7Z0JBQ3JDO1lBQ0osT0FDSztnQkFDRCxPQUFPUDtZQUNYO1FBQ0o7SUFDSjtBQUNKO0FBQ0FqQiw0QkFBNEIsR0FBR0c7QUFDL0IsTUFBTUQ7SUFDRk8sWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNuQjtJQUNBZ0IsZUFBZTtRQUNYLE9BQU8sSUFBSXZCLHFCQUFxQixJQUFJLENBQUNPLE9BQU87SUFDaEQ7QUFDSjtBQUNBVixtQ0FBbUMsR0FBR0UsNkJBQ3RDLG1EQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21heC1tZXNzYWdlLXNpemUtZmlsdGVyLmpzP2FjNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5NYXhNZXNzYWdlU2l6ZUZpbHRlciA9IHZvaWQgMDtcbmNvbnN0IGZpbHRlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jbGFzcyBNYXhNZXNzYWdlU2l6ZUZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPSBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSA9IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSA9IG9wdGlvbnNbJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIC8qIEEgY29uZmlndXJlZCBzaXplIG9mIC0xIG1lYW5zIHRoYXQgdGhlcmUgaXMgbm8gbGltaXQsIHNvIHNraXAgdGhlIGNoZWNrXG4gICAgICAgICAqIGVudGlyZWx5ICovXG4gICAgICAgIGlmICh0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29uY3JldGVNZXNzYWdlID0gYXdhaXQgbWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChjb25jcmV0ZU1lc3NhZ2UubWVzc2FnZS5sZW5ndGggPiB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFNlbnQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7Y29uY3JldGVNZXNzYWdlLm1lc3NhZ2UubGVuZ3RofSB2cy4gJHt0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZX0pYCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jcmV0ZU1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBBIGNvbmZpZ3VyZWQgc2l6ZSBvZiAtMSBtZWFucyB0aGF0IHRoZXJlIGlzIG5vIGxpbWl0LCBzbyBza2lwIHRoZSBjaGVja1xuICAgICAgICAgKiBlbnRpcmVseSAqL1xuICAgICAgICBpZiAodGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmNyZXRlTWVzc2FnZSA9IGF3YWl0IG1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoY29uY3JldGVNZXNzYWdlLmxlbmd0aCA+IHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7Y29uY3JldGVNZXNzYWdlLmxlbmd0aH0gdnMuICR7dGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemV9KWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY3JldGVNZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5NYXhNZXNzYWdlU2l6ZUZpbHRlciA9IE1heE1lc3NhZ2VTaXplRmlsdGVyO1xuY2xhc3MgTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGNyZWF0ZUZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXhNZXNzYWdlU2l6ZUZpbHRlcih0aGlzLm9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5ID0gTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF4LW1lc3NhZ2Utc2l6ZS1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5IiwiTWF4TWVzc2FnZVNpemVGaWx0ZXIiLCJmaWx0ZXJfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsIm1ldGFkYXRhXzEiLCJCYXNlRmlsdGVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwibWF4U2VuZE1lc3NhZ2VTaXplIiwiREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCIsIm1heFJlY2VpdmVNZXNzYWdlU2l6ZSIsIkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEgiLCJzZW5kTWVzc2FnZSIsIm1lc3NhZ2UiLCJjb25jcmV0ZU1lc3NhZ2UiLCJsZW5ndGgiLCJjb2RlIiwiU3RhdHVzIiwiUkVTT1VSQ0VfRVhIQVVTVEVEIiwiZGV0YWlscyIsIm1ldGFkYXRhIiwiTWV0YWRhdGEiLCJyZWNlaXZlTWVzc2FnZSIsImNyZWF0ZUZpbHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Metadata = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith(\"-bin\");\n}\nfunction isCustomMetadata(key) {\n    return !key.startsWith(\"grpc-\");\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value !== null && value !== undefined) {\n        if (isBinaryKey(key)) {\n            if (!Buffer.isBuffer(value)) {\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\n            }\n        } else {\n            if (Buffer.isBuffer(value)) {\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */ class Metadata {\n    constructor(options = {}){\n        this.internalRepr = new Map();\n        this.options = options;\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */ set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [\n            value\n        ]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */ add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [\n                value\n            ]);\n        } else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */ remove(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */ get(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */ getMap() {\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n            }\n        }\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */ clone() {\n        const newMetadata = new Metadata(this.options);\n        const newInternalRepr = newMetadata.internalRepr;\n        for (const [key, value] of this.internalRepr){\n            const clonedValue = value.map((v)=>{\n                if (Buffer.isBuffer(v)) {\n                    return Buffer.from(v);\n                } else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        }\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */ merge(other) {\n        for (const [key, values] of other.internalRepr){\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        }\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */ toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map(bufToString);\n        }\n        return result;\n    }\n    /**\n     * This modifies the behavior of JSON.stringify to show an object\n     * representation of the metadata map.\n     */ toJSON() {\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            result[key] = values;\n        }\n        return result;\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */ static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        for (const key of Object.keys(headers)){\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === \":\") {\n                continue;\n            }\n            const values = headers[key];\n            try {\n                if (isBinaryKey(key)) {\n                    if (Array.isArray(values)) {\n                        values.forEach((value)=>{\n                            result.add(key, Buffer.from(value, \"base64\"));\n                        });\n                    } else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(\",\").forEach((v)=>{\n                                result.add(key, Buffer.from(v.trim(), \"base64\"));\n                            });\n                        } else {\n                            result.add(key, Buffer.from(values, \"base64\"));\n                        }\n                    }\n                } else {\n                    if (Array.isArray(values)) {\n                        values.forEach((value)=>{\n                            result.add(key, value);\n                        });\n                    } else if (values !== undefined) {\n                        result.add(key, values);\n                    }\n                }\n            } catch (error) {\n                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);\n            }\n        }\n        return result;\n    }\n}\nexports.Metadata = Metadata;\nconst bufToString = (val)=>{\n    return Buffer.isBuffer(val) ? val.toString(\"base64\") : val;\n}; //# sourceMappingURL=metadata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3hCLE1BQU1HLFlBQVlDLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ3JDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLHNFQUFTO0FBQ2pDLE1BQU1HLGtCQUFrQjtBQUN4QixNQUFNQywrQkFBK0I7QUFDckMsU0FBU0MsV0FBV0MsR0FBRztJQUNuQixPQUFPSCxnQkFBZ0JJLElBQUksQ0FBQ0Q7QUFDaEM7QUFDQSxTQUFTRSxzQkFBc0JYLEtBQUs7SUFDaEMsT0FBT08sNkJBQTZCRyxJQUFJLENBQUNWO0FBQzdDO0FBQ0EsU0FBU1ksWUFBWUgsR0FBRztJQUNwQixPQUFPQSxJQUFJSSxRQUFRLENBQUM7QUFDeEI7QUFDQSxTQUFTQyxpQkFBaUJMLEdBQUc7SUFDekIsT0FBTyxDQUFDQSxJQUFJTSxVQUFVLENBQUM7QUFDM0I7QUFDQSxTQUFTQyxhQUFhUCxHQUFHO0lBQ3JCLE9BQU9BLElBQUlRLFdBQVc7QUFDMUI7QUFDQSxTQUFTQyxTQUFTVCxHQUFHLEVBQUVULEtBQUs7SUFDeEIsSUFBSSxDQUFDUSxXQUFXQyxNQUFNO1FBQ2xCLE1BQU0sSUFBSVUsTUFBTSxtQkFBbUJWLE1BQU07SUFDN0M7SUFDQSxJQUFJVCxVQUFVLFFBQVFBLFVBQVVvQixXQUFXO1FBQ3ZDLElBQUlSLFlBQVlILE1BQU07WUFDbEIsSUFBSSxDQUFDWSxNQUFNQSxDQUFDQyxRQUFRLENBQUN0QixRQUFRO2dCQUN6QixNQUFNLElBQUltQixNQUFNO1lBQ3BCO1FBQ0osT0FDSztZQUNELElBQUlFLE1BQU1BLENBQUNDLFFBQVEsQ0FBQ3RCLFFBQVE7Z0JBQ3hCLE1BQU0sSUFBSW1CLE1BQU07WUFDcEI7WUFDQSxJQUFJLENBQUNSLHNCQUFzQlgsUUFBUTtnQkFDL0IsTUFBTSxJQUFJbUIsTUFBTSw0QkFBNEJuQixRQUFRO1lBQ3hEO1FBQ0o7SUFDSjtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNQztJQUNGc0IsWUFBWUMsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUN0QixJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJQztRQUN4QixJQUFJLENBQUNGLE9BQU8sR0FBR0E7SUFDbkI7SUFDQTs7Ozs7O0tBTUMsR0FDREcsSUFBSWxCLEdBQUcsRUFBRVQsS0FBSyxFQUFFO1FBQ1pTLE1BQU1PLGFBQWFQO1FBQ25CUyxTQUFTVCxLQUFLVDtRQUNkLElBQUksQ0FBQ3lCLFlBQVksQ0FBQ0UsR0FBRyxDQUFDbEIsS0FBSztZQUFDVDtTQUFNO0lBQ3RDO0lBQ0E7Ozs7OztLQU1DLEdBQ0Q0QixJQUFJbkIsR0FBRyxFQUFFVCxLQUFLLEVBQUU7UUFDWlMsTUFBTU8sYUFBYVA7UUFDbkJTLFNBQVNULEtBQUtUO1FBQ2QsTUFBTTZCLGdCQUFnQixJQUFJLENBQUNKLFlBQVksQ0FBQ0ssR0FBRyxDQUFDckI7UUFDNUMsSUFBSW9CLGtCQUFrQlQsV0FBVztZQUM3QixJQUFJLENBQUNLLFlBQVksQ0FBQ0UsR0FBRyxDQUFDbEIsS0FBSztnQkFBQ1Q7YUFBTTtRQUN0QyxPQUNLO1lBQ0Q2QixjQUFjRSxJQUFJLENBQUMvQjtRQUN2QjtJQUNKO0lBQ0E7OztLQUdDLEdBQ0RnQyxPQUFPdkIsR0FBRyxFQUFFO1FBQ1JBLE1BQU1PLGFBQWFQO1FBQ25CLGlCQUFpQjtRQUNqQixJQUFJLENBQUNnQixZQUFZLENBQUNRLE1BQU0sQ0FBQ3hCO0lBQzdCO0lBQ0E7Ozs7S0FJQyxHQUNEcUIsSUFBSXJCLEdBQUcsRUFBRTtRQUNMQSxNQUFNTyxhQUFhUDtRQUNuQixpQkFBaUI7UUFDakIsT0FBTyxJQUFJLENBQUNnQixZQUFZLENBQUNLLEdBQUcsQ0FBQ3JCLFFBQVEsRUFBRTtJQUMzQztJQUNBOzs7O0tBSUMsR0FDRHlCLFNBQVM7UUFDTCxNQUFNQyxTQUFTLENBQUM7UUFDaEIsS0FBSyxNQUFNLENBQUMxQixLQUFLMkIsT0FBTyxJQUFJLElBQUksQ0FBQ1gsWUFBWSxDQUFFO1lBQzNDLElBQUlXLE9BQU9DLE1BQU0sR0FBRyxHQUFHO2dCQUNuQixNQUFNQyxJQUFJRixNQUFNLENBQUMsRUFBRTtnQkFDbkJELE1BQU0sQ0FBQzFCLElBQUksR0FBR1ksTUFBTUEsQ0FBQ0MsUUFBUSxDQUFDZ0IsS0FBS2pCLE1BQU1BLENBQUNrQixJQUFJLENBQUNELEtBQUtBO1lBQ3hEO1FBQ0o7UUFDQSxPQUFPSDtJQUNYO0lBQ0E7OztLQUdDLEdBQ0RLLFFBQVE7UUFDSixNQUFNQyxjQUFjLElBQUl4QyxTQUFTLElBQUksQ0FBQ3VCLE9BQU87UUFDN0MsTUFBTWtCLGtCQUFrQkQsWUFBWWhCLFlBQVk7UUFDaEQsS0FBSyxNQUFNLENBQUNoQixLQUFLVCxNQUFNLElBQUksSUFBSSxDQUFDeUIsWUFBWSxDQUFFO1lBQzFDLE1BQU1rQixjQUFjM0MsTUFBTTRDLEdBQUcsQ0FBQ04sQ0FBQUE7Z0JBQzFCLElBQUlqQixNQUFNQSxDQUFDQyxRQUFRLENBQUNnQixJQUFJO29CQUNwQixPQUFPakIsTUFBTUEsQ0FBQ2tCLElBQUksQ0FBQ0Q7Z0JBQ3ZCLE9BQ0s7b0JBQ0QsT0FBT0E7Z0JBQ1g7WUFDSjtZQUNBSSxnQkFBZ0JmLEdBQUcsQ0FBQ2xCLEtBQUtrQztRQUM3QjtRQUNBLE9BQU9GO0lBQ1g7SUFDQTs7Ozs7O0tBTUMsR0FDREksTUFBTUMsS0FBSyxFQUFFO1FBQ1QsS0FBSyxNQUFNLENBQUNyQyxLQUFLMkIsT0FBTyxJQUFJVSxNQUFNckIsWUFBWSxDQUFFO1lBQzVDLE1BQU1zQixjQUFjLENBQUMsSUFBSSxDQUFDdEIsWUFBWSxDQUFDSyxHQUFHLENBQUNyQixRQUFRLEVBQUUsRUFBRXVDLE1BQU0sQ0FBQ1o7WUFDOUQsSUFBSSxDQUFDWCxZQUFZLENBQUNFLEdBQUcsQ0FBQ2xCLEtBQUtzQztRQUMvQjtJQUNKO0lBQ0FFLFdBQVd6QixPQUFPLEVBQUU7UUFDaEIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0EwQixhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUMxQixPQUFPO0lBQ3ZCO0lBQ0E7O0tBRUMsR0FDRDJCLGlCQUFpQjtRQUNiLHFEQUFxRDtRQUNyRCxNQUFNaEIsU0FBUyxDQUFDO1FBQ2hCLEtBQUssTUFBTSxDQUFDMUIsS0FBSzJCLE9BQU8sSUFBSSxJQUFJLENBQUNYLFlBQVksQ0FBRTtZQUMzQyx1RUFBdUU7WUFDdkUsdUVBQXVFO1lBQ3ZFVSxNQUFNLENBQUMxQixJQUFJLEdBQUcyQixPQUFPUSxHQUFHLENBQUNRO1FBQzdCO1FBQ0EsT0FBT2pCO0lBQ1g7SUFDQTs7O0tBR0MsR0FDRGtCLFNBQVM7UUFDTCxNQUFNbEIsU0FBUyxDQUFDO1FBQ2hCLEtBQUssTUFBTSxDQUFDMUIsS0FBSzJCLE9BQU8sSUFBSSxJQUFJLENBQUNYLFlBQVksQ0FBRTtZQUMzQ1UsTUFBTSxDQUFDMUIsSUFBSSxHQUFHMkI7UUFDbEI7UUFDQSxPQUFPRDtJQUNYO0lBQ0E7Ozs7S0FJQyxHQUNELE9BQU9tQixpQkFBaUJDLE9BQU8sRUFBRTtRQUM3QixNQUFNcEIsU0FBUyxJQUFJbEM7UUFDbkIsS0FBSyxNQUFNUSxPQUFPWixPQUFPMkQsSUFBSSxDQUFDRCxTQUFVO1lBQ3BDLDREQUE0RDtZQUM1RCxJQUFJOUMsSUFBSWdELE1BQU0sQ0FBQyxPQUFPLEtBQUs7Z0JBQ3ZCO1lBQ0o7WUFDQSxNQUFNckIsU0FBU21CLE9BQU8sQ0FBQzlDLElBQUk7WUFDM0IsSUFBSTtnQkFDQSxJQUFJRyxZQUFZSCxNQUFNO29CQUNsQixJQUFJaUQsTUFBTUMsT0FBTyxDQUFDdkIsU0FBUzt3QkFDdkJBLE9BQU93QixPQUFPLENBQUM1RCxDQUFBQTs0QkFDWG1DLE9BQU9QLEdBQUcsQ0FBQ25CLEtBQUtZLE1BQU1BLENBQUNrQixJQUFJLENBQUN2QyxPQUFPO3dCQUN2QztvQkFDSixPQUNLLElBQUlvQyxXQUFXaEIsV0FBVzt3QkFDM0IsSUFBSU4saUJBQWlCTCxNQUFNOzRCQUN2QjJCLE9BQU95QixLQUFLLENBQUMsS0FBS0QsT0FBTyxDQUFDdEIsQ0FBQUE7Z0NBQ3RCSCxPQUFPUCxHQUFHLENBQUNuQixLQUFLWSxNQUFNQSxDQUFDa0IsSUFBSSxDQUFDRCxFQUFFd0IsSUFBSSxJQUFJOzRCQUMxQzt3QkFDSixPQUNLOzRCQUNEM0IsT0FBT1AsR0FBRyxDQUFDbkIsS0FBS1ksTUFBTUEsQ0FBQ2tCLElBQUksQ0FBQ0gsUUFBUTt3QkFDeEM7b0JBQ0o7Z0JBQ0osT0FDSztvQkFDRCxJQUFJc0IsTUFBTUMsT0FBTyxDQUFDdkIsU0FBUzt3QkFDdkJBLE9BQU93QixPQUFPLENBQUM1RCxDQUFBQTs0QkFDWG1DLE9BQU9QLEdBQUcsQ0FBQ25CLEtBQUtUO3dCQUNwQjtvQkFDSixPQUNLLElBQUlvQyxXQUFXaEIsV0FBVzt3QkFDM0JlLE9BQU9QLEdBQUcsQ0FBQ25CLEtBQUsyQjtvQkFDcEI7Z0JBQ0o7WUFDSixFQUNBLE9BQU8yQixPQUFPO2dCQUNWLE1BQU1DLFVBQVUsQ0FBQyw2QkFBNkIsRUFBRXZELElBQUksRUFBRSxFQUFFMkIsT0FBTyxFQUFFLEVBQUUsQ0FBQyxHQUFHL0IsUUFBUTRELGVBQWUsRUFBRUYsT0FBTyx3RUFBd0UsQ0FBQztnQkFDL0ssSUFBRzdELFVBQVVnRSxHQUFHLEVBQUU5RCxZQUFZK0QsWUFBWSxDQUFDQyxLQUFLLEVBQUVKO1lBQ3ZEO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtBQUNKO0FBQ0FwQyxnQkFBZ0IsR0FBR0U7QUFDbkIsTUFBTW1ELGNBQWMsQ0FBQ2lCO0lBQ2pCLE9BQU9oRCxNQUFNQSxDQUFDQyxRQUFRLENBQUMrQyxPQUFPQSxJQUFJQyxRQUFRLENBQUMsWUFBWUQ7QUFDM0QsR0FDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tZXRhZGF0YS5qcz8xYzVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1ldGFkYXRhID0gdm9pZCAwO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuY29uc3QgTEVHQUxfS0VZX1JFR0VYID0gL15bMC05YS16Xy4tXSskLztcbmNvbnN0IExFR0FMX05PTl9CSU5BUllfVkFMVUVfUkVHRVggPSAvXlsgLX5dKiQvO1xuZnVuY3Rpb24gaXNMZWdhbEtleShrZXkpIHtcbiAgICByZXR1cm4gTEVHQUxfS0VZX1JFR0VYLnRlc3Qoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzTGVnYWxOb25CaW5hcnlWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBMRUdBTF9OT05fQklOQVJZX1ZBTFVFX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNCaW5hcnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5lbmRzV2l0aCgnLWJpbicpO1xufVxuZnVuY3Rpb24gaXNDdXN0b21NZXRhZGF0YShrZXkpIHtcbiAgICByZXR1cm4gIWtleS5zdGFydHNXaXRoKCdncnBjLScpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzTGVnYWxLZXkoa2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIGtleSBcIicgKyBrZXkgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc0JpbmFyeUtleShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBCdWZmZXIgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZG9uJ3QgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBTdHJpbmcgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0xlZ2FsTm9uQmluYXJ5VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhZGF0YSBzdHJpbmcgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgZm9yIHN0b3JpbmcgbWV0YWRhdGEuIEtleXMgYXJlIG5vcm1hbGl6ZWQgdG8gbG93ZXJjYXNlIEFTQ0lJLlxuICovXG5jbGFzcyBNZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSByZXBsYWNpbmcgYW55IG90aGVyIHZhbHVlc1xuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgc2V0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLnNldChrZXksIFt2YWx1ZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSBhcHBlbmRpbmcgdG8gYSBsaXN0IG9mIHByZXZpb3VzXG4gICAgICogdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBmb3Igd2hpY2ggYSBuZXcgdmFsdWUgc2hvdWxkIGJlIGFwcGVuZGVkLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cbiAgICAgKi9cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSB0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGlzdGluZ1ZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGtleSBhbmQgYW55IGFzc29jaWF0ZWQgdmFsdWVzLiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHdob3NlIHZhbHVlcyBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICAvLyB2YWxpZGF0ZShrZXkpO1xuICAgICAgICB0aGlzLmludGVybmFsUmVwci5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgYWxsIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4gQSBsaXN0IG9mIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICAvLyB2YWxpZGF0ZShrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSkgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBwbGFpbiBvYmplY3QgbWFwcGluZyBlYWNoIGtleSB0byB0aGUgZmlyc3QgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICAqIFRoaXMgcmVmbGVjdHMgdGhlIG1vc3QgY29tbW9uIHdheSB0aGF0IHBlb3BsZSB3aWxsIHdhbnQgdG8gc2VlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm4gQSBrZXkvdmFsdWUgbWFwcGluZyBvZiB0aGUgbWV0YWRhdGEuXG4gICAgICovXG4gICAgZ2V0TWFwKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVzWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gQnVmZmVyLmlzQnVmZmVyKHYpID8gQnVmZmVyLmZyb20odikgOiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgbWV0YWRhdGEgb2JqZWN0LlxuICAgICAqIEByZXR1cm4gVGhlIG5ld2x5IGNsb25lZCBvYmplY3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IG5ld01ldGFkYXRhID0gbmV3IE1ldGFkYXRhKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG5ld0ludGVybmFsUmVwciA9IG5ld01ldGFkYXRhLmludGVybmFsUmVwcjtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZFZhbHVlID0gdmFsdWUubWFwKHYgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdJbnRlcm5hbFJlcHIuc2V0KGtleSwgY2xvbmVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdNZXRhZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFsbCBrZXktdmFsdWUgcGFpcnMgZnJvbSBhIGdpdmVuIE1ldGFkYXRhIG9iamVjdCBpbnRvIHRoaXMgb25lLlxuICAgICAqIElmIGJvdGggdGhpcyBvYmplY3QgYW5kIHRoZSBnaXZlbiBvYmplY3QgaGF2ZSB2YWx1ZXMgaW4gdGhlIHNhbWUga2V5LFxuICAgICAqIHZhbHVlcyBmcm9tIHRoZSBvdGhlciBNZXRhZGF0YSBvYmplY3Qgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzIG9iamVjdCdzXG4gICAgICogdmFsdWVzLlxuICAgICAqIEBwYXJhbSBvdGhlciBBIE1ldGFkYXRhIG9iamVjdC5cbiAgICAgKi9cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2Ygb3RoZXIuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRWYWx1ZSA9ICh0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KSB8fCBbXSkuY29uY2F0KHZhbHVlcyk7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVwci5zZXQoa2V5LCBtZXJnZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT3V0Z29pbmdIdHRwSGVhZGVycyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoZSBodHRwMiBBUEkuXG4gICAgICovXG4gICAgdG9IdHRwMkhlYWRlcnMoKSB7XG4gICAgICAgIC8vIE5PVEU6IE5vZGUgPDguOSBmb3JtYXRzIGh0dHAyIGhlYWRlcnMgaW5jb3JyZWN0bHkuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGlzIG9iamVjdCBpcyBsaW1pdGVkIHRvXG4gICAgICAgICAgICAvLyB0aHJvdWdoIGl0cyBwdWJsaWMgQVBJIChpLmUuIGtleXMgYW5kIHZhbHVlcyBhcmUgYWxyZWFkeSB2YWxpZGF0ZWQpLlxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXMubWFwKGJ1ZlRvU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGlmaWVzIHRoZSBiZWhhdmlvciBvZiBKU09OLnN0cmluZ2lmeSB0byBzaG93IGFuIG9iamVjdFxuICAgICAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXRhZGF0YSBtYXAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IE1ldGFkYXRhIG9iamVjdCBiYXNlZCBmaWVsZHMgaW4gYSBnaXZlbiBJbmNvbWluZ0h0dHBIZWFkZXJzXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSBoZWFkZXJzIEFuIEluY29taW5nSHR0cEhlYWRlcnMgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1ldGFkYXRhKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAvLyBSZXNlcnZlZCBoZWFkZXJzIChiZWdpbm5pbmcgd2l0aCBgOmApIGFyZSBub3QgdmFsaWQga2V5cy5cbiAgICAgICAgICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmluYXJ5S2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2YWx1ZSwgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXN0b21NZXRhZGF0YShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNwbGl0KCcsJykuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHYudHJpbSgpLCAnYmFzZTY0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHZhbHVlcywgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZhaWxlZCB0byBhZGQgbWV0YWRhdGEgZW50cnkgJHtrZXl9OiAke3ZhbHVlc30uICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnJvcil9LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL2lzc3Vlcy8xMTczYDtcbiAgICAgICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuTWV0YWRhdGEgPSBNZXRhZGF0YTtcbmNvbnN0IGJ1ZlRvU3RyaW5nID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsKSA/IHZhbC50b1N0cmluZygnYmFzZTY0JykgOiB2YWw7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTWV0YWRhdGEiLCJsb2dnaW5nXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJlcnJvcl8xIiwiTEVHQUxfS0VZX1JFR0VYIiwiTEVHQUxfTk9OX0JJTkFSWV9WQUxVRV9SRUdFWCIsImlzTGVnYWxLZXkiLCJrZXkiLCJ0ZXN0IiwiaXNMZWdhbE5vbkJpbmFyeVZhbHVlIiwiaXNCaW5hcnlLZXkiLCJlbmRzV2l0aCIsImlzQ3VzdG9tTWV0YWRhdGEiLCJzdGFydHNXaXRoIiwibm9ybWFsaXplS2V5IiwidG9Mb3dlckNhc2UiLCJ2YWxpZGF0ZSIsIkVycm9yIiwidW5kZWZpbmVkIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJpbnRlcm5hbFJlcHIiLCJNYXAiLCJzZXQiLCJhZGQiLCJleGlzdGluZ1ZhbHVlIiwiZ2V0IiwicHVzaCIsInJlbW92ZSIsImRlbGV0ZSIsImdldE1hcCIsInJlc3VsdCIsInZhbHVlcyIsImxlbmd0aCIsInYiLCJmcm9tIiwiY2xvbmUiLCJuZXdNZXRhZGF0YSIsIm5ld0ludGVybmFsUmVwciIsImNsb25lZFZhbHVlIiwibWFwIiwibWVyZ2UiLCJvdGhlciIsIm1lcmdlZFZhbHVlIiwiY29uY2F0Iiwic2V0T3B0aW9ucyIsImdldE9wdGlvbnMiLCJ0b0h0dHAySGVhZGVycyIsImJ1ZlRvU3RyaW5nIiwidG9KU09OIiwiZnJvbUh0dHAySGVhZGVycyIsImhlYWRlcnMiLCJrZXlzIiwiY2hhckF0IiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInNwbGl0IiwidHJpbSIsImVycm9yIiwibWVzc2FnZSIsImdldEVycm9yTWVzc2FnZSIsImxvZyIsIkxvZ1ZlcmJvc2l0eSIsIkVSUk9SIiwidmFsIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/picker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nvar PickResultType;\n(function(PickResultType) {\n    PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\n    PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\n    PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n    PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\n})(PickResultType || (exports.PickResultType = PickResultType = {}));\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */ class UnavailablePicker {\n    constructor(status){\n        this.status = Object.assign({\n            code: constants_1.Status.UNAVAILABLE,\n            details: \"No connection established\",\n            metadata: new metadata_1.Metadata()\n        }, status);\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: PickResultType.TRANSIENT_FAILURE,\n            subchannel: null,\n            status: this.status,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n}\nexports.UnavailablePicker = UnavailablePicker;\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n */ class QueuePicker {\n    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n    constructor(loadBalancer){\n        this.loadBalancer = loadBalancer;\n        this.calledExitIdle = false;\n    }\n    pick(pickArgs) {\n        if (!this.calledExitIdle) {\n            process.nextTick(()=>{\n                this.loadBalancer.exitIdle();\n            });\n            this.calledExitIdle = true;\n        }\n        return {\n            pickResultType: PickResultType.QUEUE,\n            subchannel: null,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n}\nexports.QueuePicker = QueuePicker; //# sourceMappingURL=picker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLHlCQUF5QixHQUFHQSxzQkFBc0IsR0FBRyxLQUFLO0FBQ2hGLE1BQU1LLGFBQWFDLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLElBQUlGO0FBQ0gsVUFBVUEsY0FBYztJQUNyQkEsY0FBYyxDQUFDQSxjQUFjLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztJQUNqREEsY0FBYyxDQUFDQSxjQUFjLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQzFEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0FBQ2pELEdBQUdBLGtCQUFtQkosQ0FBQUEsc0JBQXNCLEdBQUdJLGlCQUFpQixDQUFDO0FBQ2pFOzs7Q0FHQyxHQUNELE1BQU1EO0lBQ0ZLLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQixJQUFJLENBQUNBLE1BQU0sR0FBR1gsT0FBT1ksTUFBTSxDQUFDO1lBQUVDLE1BQU1KLFlBQVlLLE1BQU0sQ0FBQ0MsV0FBVztZQUFFQyxTQUFTO1lBQTZCQyxVQUFVLElBQUlWLFdBQVdXLFFBQVE7UUFBRyxHQUFHUDtJQUNySjtJQUNBUSxLQUFLQyxRQUFRLEVBQUU7UUFDWCxPQUFPO1lBQ0hDLGdCQUFnQmYsZUFBZWdCLGlCQUFpQjtZQUNoREMsWUFBWTtZQUNaWixRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQmEsZUFBZTtZQUNmQyxhQUFhO1FBQ2pCO0lBQ0o7QUFDSjtBQUNBdkIseUJBQXlCLEdBQUdHO0FBQzVCOzs7Ozs7Q0FNQyxHQUNELE1BQU1EO0lBQ0YsdUZBQXVGO0lBQ3ZGTSxZQUFZZ0IsWUFBWSxDQUFFO1FBQ3RCLElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNDLGNBQWMsR0FBRztJQUMxQjtJQUNBUixLQUFLQyxRQUFRLEVBQUU7UUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDTyxjQUFjLEVBQUU7WUFDdEJDLE9BQU9BLENBQUNDLFFBQVEsQ0FBQztnQkFDYixJQUFJLENBQUNILFlBQVksQ0FBQ0ksUUFBUTtZQUM5QjtZQUNBLElBQUksQ0FBQ0gsY0FBYyxHQUFHO1FBQzFCO1FBQ0EsT0FBTztZQUNITixnQkFBZ0JmLGVBQWV5QixLQUFLO1lBQ3BDUixZQUFZO1lBQ1paLFFBQVE7WUFDUmEsZUFBZTtZQUNmQyxhQUFhO1FBQ2pCO0lBQ0o7QUFDSjtBQUNBdkIsbUJBQW1CLEdBQUdFLGFBQ3RCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3BpY2tlci5qcz81N2U2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1ZXVlUGlja2VyID0gZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSB2b2lkIDA7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBQaWNrUmVzdWx0VHlwZTtcbihmdW5jdGlvbiAoUGlja1Jlc3VsdFR5cGUpIHtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkNPTVBMRVRFXCJdID0gMF0gPSBcIkNPTVBMRVRFXCI7XG4gICAgUGlja1Jlc3VsdFR5cGVbUGlja1Jlc3VsdFR5cGVbXCJRVUVVRVwiXSA9IDFdID0gXCJRVUVVRVwiO1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiVFJBTlNJRU5UX0ZBSUxVUkVcIl0gPSAyXSA9IFwiVFJBTlNJRU5UX0ZBSUxVUkVcIjtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkRST1BcIl0gPSAzXSA9IFwiRFJPUFwiO1xufSkoUGlja1Jlc3VsdFR5cGUgfHwgKGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSBQaWNrUmVzdWx0VHlwZSA9IHt9KSk7XG4vKipcbiAqIEEgc3RhbmRhcmQgcGlja2VyIHJlcHJlc2VudGluZyBhIGxvYWQgYmFsYW5jZXIgaW4gdGhlIFRSQU5TSUVOVF9GQUlMVVJFXG4gKiBzdGF0ZS4gQWx3YXlzIHJlc3BvbmRzIHRvIGV2ZXJ5IHBpY2sgcmVxdWVzdCB3aXRoIGFuIFVOQVZBSUxBQkxFIHN0YXR1cy5cbiAqL1xuY2xhc3MgVW5hdmFpbGFibGVQaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IE9iamVjdC5hc3NpZ24oeyBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsIGRldGFpbHM6ICdObyBjb25uZWN0aW9uIGVzdGFibGlzaGVkJywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSwgc3RhdHVzKTtcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IFBpY2tSZXN1bHRUeXBlLlRSQU5TSUVOVF9GQUlMVVJFLFxuICAgICAgICAgICAgc3ViY2hhbm5lbDogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IFVuYXZhaWxhYmxlUGlja2VyO1xuLyoqXG4gKiBBIHN0YW5kYXJkIHBpY2tlciByZXByZXNlbnRpbmcgYSBsb2FkIGJhbGFuY2VyIGluIHRoZSBJRExFIG9yIENPTk5FQ1RJTkdcbiAqIHN0YXRlLiBBbHdheXMgcmVzcG9uZHMgdG8gZXZlcnkgcGljayByZXF1ZXN0IHdpdGggYSBRVUVVRSBwaWNrIHJlc3VsdFxuICogaW5kaWNhdGluZyB0aGF0IHRoZSBwaWNrIHNob3VsZCBiZSB0cmllZCBhZ2FpbiB3aXRoIHRoZSBuZXh0IGBQaWNrZXJgLiBBbHNvXG4gKiByZXBvcnRzIGJhY2sgdG8gdGhlIGxvYWQgYmFsYW5jZXIgdGhhdCBhIGNvbm5lY3Rpb24gc2hvdWxkIGJlIGVzdGFibGlzaGVkXG4gKiBvbmNlIGFueSBwaWNrIGlzIGF0dGVtcHRlZC5cbiAqL1xuY2xhc3MgUXVldWVQaWNrZXIge1xuICAgIC8vIENvbnN0cnVjdGVkIHdpdGggYSBsb2FkIGJhbGFuY2VyLiBDYWxscyBleGl0SWRsZSBvbiBpdCB0aGUgZmlyc3QgdGltZSBwaWNrIGlzIGNhbGxlZFxuICAgIGNvbnN0cnVjdG9yKGxvYWRCYWxhbmNlcikge1xuICAgICAgICB0aGlzLmxvYWRCYWxhbmNlciA9IGxvYWRCYWxhbmNlcjtcbiAgICAgICAgdGhpcy5jYWxsZWRFeGl0SWRsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsZWRFeGl0SWRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWRFeGl0SWRsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBQaWNrUmVzdWx0VHlwZS5RVUVVRSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5RdWV1ZVBpY2tlciA9IFF1ZXVlUGlja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlja2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlF1ZXVlUGlja2VyIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJQaWNrUmVzdWx0VHlwZSIsIm1ldGFkYXRhXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJjb25zdHJ1Y3RvciIsInN0YXR1cyIsImFzc2lnbiIsImNvZGUiLCJTdGF0dXMiLCJVTkFWQUlMQUJMRSIsImRldGFpbHMiLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwicGljayIsInBpY2tBcmdzIiwicGlja1Jlc3VsdFR5cGUiLCJUUkFOU0lFTlRfRkFJTFVSRSIsInN1YmNoYW5uZWwiLCJvbkNhbGxTdGFydGVkIiwib25DYWxsRW5kZWQiLCJsb2FkQmFsYW5jZXIiLCJjYWxsZWRFeGl0SWRsZSIsInByb2Nlc3MiLCJuZXh0VGljayIsImV4aXRJZGxlIiwiUVVFVUUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-dns.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.DEFAULT_PORT = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst dns = __webpack_require__(/*! dns */ \"dns\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst TRACER_NAME = \"dns_resolver\";\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */ exports.DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */ function mergeArrays(...arrays) {\n    const result = [];\n    for(let i = 0; i < Math.max.apply(null, arrays.map((array)=>array.length)); i++){\n        for (const array of arrays){\n            if (i < array.length) {\n                result.push(array[i]);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */ class DnsResolver {\n    constructor(target, listener, channelOptions){\n        var _a, _b, _c;\n        this.target = target;\n        this.listener = listener;\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.continueResolving = false;\n        this.isNextResolutionTimerRunning = false;\n        this.isServiceConfigEnabled = true;\n        this.returnedIpResult = false;\n        trace(\"Resolver constructed for target \" + (0, uri_parser_1.uriToString)(target));\n        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n        if (hostPort === null) {\n            this.ipResult = null;\n            this.dnsHostname = null;\n            this.port = null;\n        } else {\n            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {\n                this.ipResult = [\n                    {\n                        host: hostPort.host,\n                        port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : exports.DEFAULT_PORT\n                    }\n                ];\n                this.dnsHostname = null;\n                this.port = null;\n            } else {\n                this.ipResult = null;\n                this.dnsHostname = hostPort.host;\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : exports.DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        if (channelOptions[\"grpc.service_config_disable_resolution\"] === 1) {\n            this.isServiceConfigEnabled = false;\n        }\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,\n            metadata: new metadata_1.Metadata()\n        };\n        const backoffOptions = {\n            initialDelay: channelOptions[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: channelOptions[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoff = new backoff_timeout_1.BackoffTimeout(()=>{\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, backoffOptions);\n        this.backoff.unref();\n        this.minTimeBetweenResolutionsMs = (_c = channelOptions[\"grpc.dns_min_time_between_resolutions_ms\"]) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n        this.nextResolutionTimer = setTimeout(()=>{}, 0);\n        clearTimeout(this.nextResolutionTimer);\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT lookups\n     */ startResolution() {\n        if (this.ipResult !== null) {\n            if (!this.returnedIpResult) {\n                trace(\"Returning IP address for target \" + (0, uri_parser_1.uriToString)(this.target));\n                setImmediate(()=>{\n                    this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n                });\n                this.returnedIpResult = true;\n            }\n            this.backoff.stop();\n            this.backoff.reset();\n            this.stopNextResolutionTimer();\n            return;\n        }\n        if (this.dnsHostname === null) {\n            trace(\"Failed to parse DNS address \" + (0, uri_parser_1.uriToString)(this.target));\n            setImmediate(()=>{\n                this.listener.onError({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,\n                    metadata: new metadata_1.Metadata()\n                });\n            });\n            this.stopNextResolutionTimer();\n        } else {\n            if (this.pendingLookupPromise !== null) {\n                return;\n            }\n            trace(\"Looking up DNS hostname \" + this.dnsHostname);\n            /* We clear out latestLookupResult here to ensure that it contains the\n             * latest result since the last time we started resolving. That way, the\n             * TXT resolution handler can use it, but only if it finishes second. We\n             * don't clear out any previous service config results because it's\n             * better to use a service config that's slightly out of date than to\n             * revert to an effectively blank one. */ this.latestLookupResult = null;\n            const hostname = this.dnsHostname;\n            /* We lookup both address families here and then split them up later\n             * because when looking up a single family, dns.lookup outputs an error\n             * if the name exists but there are no records for that family, and that\n             * error is indistinguishable from other kinds of errors */ this.pendingLookupPromise = dnsLookupPromise(hostname, {\n                all: true\n            });\n            this.pendingLookupPromise.then((addressList)=>{\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                this.pendingLookupPromise = null;\n                this.backoff.reset();\n                this.backoff.stop();\n                const ip4Addresses = addressList.filter((addr)=>addr.family === 4);\n                const ip6Addresses = addressList.filter((addr)=>addr.family === 6);\n                this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr)=>({\n                        host: addr.address,\n                        port: +this.port\n                    }));\n                const allAddressesString = \"[\" + this.latestLookupResult.map((addr)=>addr.host + \":\" + addr.port).join(\",\") + \"]\";\n                trace(\"Resolved addresses for target \" + (0, uri_parser_1.uriToString)(this.target) + \": \" + allAddressesString);\n                if (this.latestLookupResult.length === 0) {\n                    this.listener.onError(this.defaultResolutionError);\n                    return;\n                }\n                /* If the TXT lookup has not yet finished, both of the last two\n                 * arguments will be null, which is the equivalent of getting an\n                 * empty TXT response. When the TXT lookup does finish, its handler\n                 * can update the service config by using the same address list */ this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n            }, (err)=>{\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                trace(\"Resolution error for target \" + (0, uri_parser_1.uriToString)(this.target) + \": \" + err.message);\n                this.pendingLookupPromise = null;\n                this.stopNextResolutionTimer();\n                this.listener.onError(this.defaultResolutionError);\n            });\n            /* If there already is a still-pending TXT resolution, we can just use\n             * that result when it comes in */ if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {\n                /* We handle the TXT query promise differently than the others because\n                 * the name resolution attempt as a whole is a success even if the TXT\n                 * lookup fails */ this.pendingTxtPromise = resolveTxtPromise(hostname);\n                this.pendingTxtPromise.then((txtRecord)=>{\n                    if (this.pendingTxtPromise === null) {\n                        return;\n                    }\n                    this.pendingTxtPromise = null;\n                    try {\n                        this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);\n                    } catch (err) {\n                        this.latestServiceConfigError = {\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: `Parsing service config failed with error ${err.message}`,\n                            metadata: new metadata_1.Metadata()\n                        };\n                    }\n                    if (this.latestLookupResult !== null) {\n                        /* We rely here on the assumption that calling this function with\n                         * identical parameters will be essentialy idempotent, and calling\n                         * it with the same address list and a different service config\n                         * should result in a fast and seamless switchover. */ this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n                    }\n                }, (err)=>{\n                /* If TXT lookup fails we should do nothing, which means that we\n                     * continue to use the result of the most recent successful lookup,\n                     * or the default null config object if there has never been a\n                     * successful lookup. We do not set the latestServiceConfigError\n                     * here because that is specifically used for response validation\n                     * errors. We still need to handle this error so that it does not\n                     * bubble up as an unhandled promise rejection. */ });\n            }\n        }\n    }\n    startNextResolutionTimer() {\n        var _a, _b;\n        clearTimeout(this.nextResolutionTimer);\n        this.nextResolutionTimer = (_b = (_a = setTimeout(()=>{\n            this.stopNextResolutionTimer();\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.isNextResolutionTimerRunning = true;\n    }\n    stopNextResolutionTimer() {\n        clearTimeout(this.nextResolutionTimer);\n        this.isNextResolutionTimerRunning = false;\n    }\n    startResolutionWithBackoff() {\n        if (this.pendingLookupPromise === null) {\n            this.continueResolving = false;\n            this.backoff.runOnce();\n            this.startNextResolutionTimer();\n            this.startResolution();\n        }\n    }\n    updateResolution() {\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\n         * nextResolutionTimer or backoff timer is running, set the\n         * continueResolving flag to resolve when whichever of those timers\n         * fires. Otherwise, start resolving immediately. */ if (this.pendingLookupPromise === null) {\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n                if (this.isNextResolutionTimerRunning) {\n                    trace('resolution update delayed by \"min time between resolutions\" rate limit');\n                } else {\n                    trace(\"resolution update delayed by backoff timer until \" + this.backoff.getEndTime().toISOString());\n                }\n                this.continueResolving = true;\n            } else {\n                this.startResolutionWithBackoff();\n            }\n        }\n    }\n    /**\n     * Reset the resolver to the same state it had when it was created. In-flight\n     * DNS requests cannot be cancelled, but they are discarded and their results\n     * will be ignored.\n     */ destroy() {\n        this.continueResolving = false;\n        this.backoff.reset();\n        this.backoff.stop();\n        this.stopNextResolutionTimer();\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.returnedIpResult = false;\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */ static getDefaultAuthority(target) {\n        return target.path;\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */ function setup() {\n    (0, resolver_1.registerResolver)(\"dns\", DnsResolver);\n    (0, resolver_1.registerDefaultScheme)(\"dns\");\n}\nexports.setup = setup; //# sourceMappingURL=resolver-dns.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUM1QyxNQUFNSSxhQUFhQyxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNQyxNQUFNRCxtQkFBT0EsQ0FBQyxnQkFBSztBQUN6QixNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNRyxtQkFBbUJILG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNuRCxNQUFNSSxjQUFjSixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNSyxhQUFhTCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTyxjQUFjUCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNUSxlQUFlUixtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNUyxRQUFRVCxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNVSxvQkFBb0JWLG1CQUFPQSxDQUFDLDBGQUFtQjtBQUNyRCxNQUFNVyxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZlAsUUFBUU0sS0FBSyxDQUFDTCxZQUFZTyxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQTs7Q0FFQyxHQUNEbEIsb0JBQW9CLEdBQUc7QUFDdkIsTUFBTXFCLDBDQUEwQztBQUNoRCxNQUFNQyxvQkFBb0JmLEtBQUtnQixTQUFTLENBQUNqQixJQUFJa0IsVUFBVTtBQUN2RCxNQUFNQyxtQkFBbUJsQixLQUFLZ0IsU0FBUyxDQUFDakIsSUFBSW9CLE1BQU07QUFDbEQ7OztDQUdDLEdBQ0QsU0FBU0MsWUFBWSxHQUFHQyxNQUFNO0lBQzFC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QixHQUFHO1FBQ3pCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztRQUMzQixJQUFJLENBQUNDLHdCQUF3QixHQUFHO1FBQ2hDLElBQUksQ0FBQ0ksZ0JBQWdCLEdBQUc7SUFDNUI7SUFDQTs7OztLQUlDLEdBQ0QsT0FBTzhELG9CQUFvQjVFLE1BQU0sRUFBRTtRQUMvQixPQUFPQSxPQUFPa0IsSUFBSTtJQUN0QjtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU3hEO0lBQ0osSUFBR0UsV0FBV2lILGdCQUFnQixFQUFFLE9BQU8vRTtJQUN2QyxJQUFHbEMsV0FBV2tILHFCQUFxQixFQUFFO0FBQzFDO0FBQ0F0SCxhQUFhLEdBQUdFLE9BQ2hCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLWRucy5qcz83MWU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLkRFRkFVTFRfUE9SVCA9IHZvaWQgMDtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGRucyA9IHJlcXVpcmUoXCJkbnNcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBzZXJ2aWNlX2NvbmZpZ18xID0gcmVxdWlyZShcIi4vc2VydmljZS1jb25maWdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdkbnNfcmVzb2x2ZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IFRDUCBwb3J0IHRvIGNvbm5lY3QgdG8gaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZSB0YXJnZXQuXG4gKi9cbmV4cG9ydHMuREVGQVVMVF9QT1JUID0gNDQzO1xuY29uc3QgREVGQVVMVF9NSU5fVElNRV9CRVRXRUVOX1JFU09MVVRJT05TX01TID0gMzAwMDA7XG5jb25zdCByZXNvbHZlVHh0UHJvbWlzZSA9IHV0aWwucHJvbWlzaWZ5KGRucy5yZXNvbHZlVHh0KTtcbmNvbnN0IGRuc0xvb2t1cFByb21pc2UgPSB1dGlsLnByb21pc2lmeShkbnMubG9va3VwKTtcbi8qKlxuICogTWVyZ2UgYW55IG51bWJlciBvZiBhcnJheXMgaW50byBhIHNpbmdsZSBhbHRlcm5hdGluZyBhcnJheVxuICogQHBhcmFtIGFycmF5c1xuICovXG5mdW5jdGlvbiBtZXJnZUFycmF5cyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8XG4gICAgICAgIE1hdGgubWF4LmFwcGx5KG51bGwsIGFycmF5cy5tYXAoYXJyYXkgPT4gYXJyYXkubGVuZ3RoKSk7IGkrKykge1xuICAgICAgICBmb3IgKGNvbnN0IGFycmF5IG9mIGFycmF5cykge1xuICAgICAgICAgICAgaWYgKGkgPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmVzb2x2ZXIgaW1wbGVtZW50YXRpb24gdGhhdCBoYW5kbGVzIEROUyBuYW1lcyBhbmQgSVAgYWRkcmVzc2VzLlxuICovXG5jbGFzcyBEbnNSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTZXJ2aWNlQ29uZmlnRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucmV0dXJuZWRJcFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB0cmFjZSgnUmVzb2x2ZXIgY29uc3RydWN0ZWQgZm9yIHRhcmdldCAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSk7XG4gICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXQucGF0aCk7XG4gICAgICAgIGlmIChob3N0UG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKDAsIG5ldF8xLmlzSVB2NCkoaG9zdFBvcnQuaG9zdCkgfHwgKDAsIG5ldF8xLmlzSVB2NikoaG9zdFBvcnQuaG9zdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlwUmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogKF9hID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhwb3J0cy5ERUZBVUxUX1BPUlQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IGhvc3RQb3J0Lmhvc3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gKF9iID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXhwb3J0cy5ERUZBVUxUX1BPUlQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZXJjZW50YWdlID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgICAgaWYgKGNoYW5uZWxPcHRpb25zWydncnBjLnNlcnZpY2VfY29uZmlnX2Rpc2FibGVfcmVzb2x1dGlvbiddID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmlzU2VydmljZUNvbmZpZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IgPSB7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICBkZXRhaWxzOiBgTmFtZSByZXNvbHV0aW9uIGZhaWxlZCBmb3IgdGFyZ2V0ICR7KDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpfWAsXG4gICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYmFja29mZk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlc29sdXRpb25XaXRoQmFja29mZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFja29mZi51bnJlZigpO1xuICAgICAgICB0aGlzLm1pblRpbWVCZXR3ZWVuUmVzb2x1dGlvbnNNcyA9XG4gICAgICAgICAgICAoX2MgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5kbnNfbWluX3RpbWVfYmV0d2Vlbl9yZXNvbHV0aW9uc19tcyddKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01JTl9USU1FX0JFVFdFRU5fUkVTT0xVVElPTlNfTVM7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB0YXJnZXQgaXMgYW4gSVAgYWRkcmVzcywganVzdCBwcm92aWRlIHRoYXQgYWRkcmVzcyBhcyBhIHJlc3VsdC5cbiAgICAgKiBPdGhlcndpc2UsIGluaXRpYXRlIEEsIEFBQUEsIGFuZCBUWFQgbG9va3Vwc1xuICAgICAqL1xuICAgIHN0YXJ0UmVzb2x1dGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXBSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXR1cm5lZElwUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1JldHVybmluZyBJUCBhZGRyZXNzIGZvciB0YXJnZXQgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMuaXBSZXN1bHQsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybmVkSXBSZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRuc0hvc3RuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFjZSgnRmFpbGVkIHRvIHBhcnNlIEROUyBhZGRyZXNzICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkpO1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgRE5TIGFkZHJlc3MgJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCl9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2UoJ0xvb2tpbmcgdXAgRE5TIGhvc3RuYW1lICcgKyB0aGlzLmRuc0hvc3RuYW1lKTtcbiAgICAgICAgICAgIC8qIFdlIGNsZWFyIG91dCBsYXRlc3RMb29rdXBSZXN1bHQgaGVyZSB0byBlbnN1cmUgdGhhdCBpdCBjb250YWlucyB0aGVcbiAgICAgICAgICAgICAqIGxhdGVzdCByZXN1bHQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzdGFydGVkIHJlc29sdmluZy4gVGhhdCB3YXksIHRoZVxuICAgICAgICAgICAgICogVFhUIHJlc29sdXRpb24gaGFuZGxlciBjYW4gdXNlIGl0LCBidXQgb25seSBpZiBpdCBmaW5pc2hlcyBzZWNvbmQuIFdlXG4gICAgICAgICAgICAgKiBkb24ndCBjbGVhciBvdXQgYW55IHByZXZpb3VzIHNlcnZpY2UgY29uZmlnIHJlc3VsdHMgYmVjYXVzZSBpdCdzXG4gICAgICAgICAgICAgKiBiZXR0ZXIgdG8gdXNlIGEgc2VydmljZSBjb25maWcgdGhhdCdzIHNsaWdodGx5IG91dCBvZiBkYXRlIHRoYW4gdG9cbiAgICAgICAgICAgICAqIHJldmVydCB0byBhbiBlZmZlY3RpdmVseSBibGFuayBvbmUuICovXG4gICAgICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBob3N0bmFtZSA9IHRoaXMuZG5zSG9zdG5hbWU7XG4gICAgICAgICAgICAvKiBXZSBsb29rdXAgYm90aCBhZGRyZXNzIGZhbWlsaWVzIGhlcmUgYW5kIHRoZW4gc3BsaXQgdGhlbSB1cCBsYXRlclxuICAgICAgICAgICAgICogYmVjYXVzZSB3aGVuIGxvb2tpbmcgdXAgYSBzaW5nbGUgZmFtaWx5LCBkbnMubG9va3VwIG91dHB1dHMgYW4gZXJyb3JcbiAgICAgICAgICAgICAqIGlmIHRoZSBuYW1lIGV4aXN0cyBidXQgdGhlcmUgYXJlIG5vIHJlY29yZHMgZm9yIHRoYXQgZmFtaWx5LCBhbmQgdGhhdFxuICAgICAgICAgICAgICogZXJyb3IgaXMgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBvdGhlciBraW5kcyBvZiBlcnJvcnMgKi9cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBkbnNMb29rdXBQcm9taXNlKGhvc3RuYW1lLCB7IGFsbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UudGhlbihhZGRyZXNzTGlzdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYuc3RvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlwNEFkZHJlc3NlcyA9IGFkZHJlc3NMaXN0LmZpbHRlcihhZGRyID0+IGFkZHIuZmFtaWx5ID09PSA0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpcDZBZGRyZXNzZXMgPSBhZGRyZXNzTGlzdC5maWx0ZXIoYWRkciA9PiBhZGRyLmZhbWlseSA9PT0gNik7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBtZXJnZUFycmF5cyhpcDZBZGRyZXNzZXMsIGlwNEFkZHJlc3NlcykubWFwKGFkZHIgPT4gKHsgaG9zdDogYWRkci5hZGRyZXNzLCBwb3J0OiArdGhpcy5wb3J0IH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxBZGRyZXNzZXNTdHJpbmcgPSAnWycgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChhZGRyID0+IGFkZHIuaG9zdCArICc6JyArIGFkZHIucG9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsJykgK1xuICAgICAgICAgICAgICAgICAgICAnXSc7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1Jlc29sdmVkIGFkZHJlc3NlcyBmb3IgdGFyZ2V0ICcgK1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgYWxsQWRkcmVzc2VzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXRlc3RMb29rdXBSZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBUWFQgbG9va3VwIGhhcyBub3QgeWV0IGZpbmlzaGVkLCBib3RoIG9mIHRoZSBsYXN0IHR3b1xuICAgICAgICAgICAgICAgICAqIGFyZ3VtZW50cyB3aWxsIGJlIG51bGwsIHdoaWNoIGlzIHRoZSBlcXVpdmFsZW50IG9mIGdldHRpbmcgYW5cbiAgICAgICAgICAgICAgICAgKiBlbXB0eSBUWFQgcmVzcG9uc2UuIFdoZW4gdGhlIFRYVCBsb29rdXAgZG9lcyBmaW5pc2gsIGl0cyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICogY2FuIHVwZGF0ZSB0aGUgc2VydmljZSBjb25maWcgYnkgdXNpbmcgdGhlIHNhbWUgYWRkcmVzcyBsaXN0ICovXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0LCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yLCBudWxsLCB7fSk7XG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1Jlc29sdXRpb24gZXJyb3IgZm9yIHRhcmdldCAnICtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHRoaXMuZGVmYXVsdFJlc29sdXRpb25FcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qIElmIHRoZXJlIGFscmVhZHkgaXMgYSBzdGlsbC1wZW5kaW5nIFRYVCByZXNvbHV0aW9uLCB3ZSBjYW4ganVzdCB1c2VcbiAgICAgICAgICAgICAqIHRoYXQgcmVzdWx0IHdoZW4gaXQgY29tZXMgaW4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2VydmljZUNvbmZpZ0VuYWJsZWQgJiYgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8qIFdlIGhhbmRsZSB0aGUgVFhUIHF1ZXJ5IHByb21pc2UgZGlmZmVyZW50bHkgdGhhbiB0aGUgb3RoZXJzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgKiB0aGUgbmFtZSByZXNvbHV0aW9uIGF0dGVtcHQgYXMgYSB3aG9sZSBpcyBhIHN1Y2Nlc3MgZXZlbiBpZiB0aGUgVFhUXG4gICAgICAgICAgICAgICAgICogbG9va3VwIGZhaWxzICovXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9IHJlc29sdmVUeHRQcm9taXNlKGhvc3RuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlLnRoZW4odHh0UmVjb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1R4dFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZyA9ICgwLCBzZXJ2aWNlX2NvbmZpZ18xLmV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnKSh0eHRSZWNvcmQsIHRoaXMucGVyY2VudGFnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBQYXJzaW5nIHNlcnZpY2UgY29uZmlnIGZhaWxlZCB3aXRoIGVycm9yICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBXZSByZWx5IGhlcmUgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICogaWRlbnRpY2FsIHBhcmFtZXRlcnMgd2lsbCBiZSBlc3NlbnRpYWx5IGlkZW1wb3RlbnQsIGFuZCBjYWxsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCB3aXRoIHRoZSBzYW1lIGFkZHJlc3MgbGlzdCBhbmQgYSBkaWZmZXJlbnQgc2VydmljZSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNob3VsZCByZXN1bHQgaW4gYSBmYXN0IGFuZCBzZWFtbGVzcyBzd2l0Y2hvdmVyLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0LCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yLCBudWxsLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiBUWFQgbG9va3VwIGZhaWxzIHdlIHNob3VsZCBkbyBub3RoaW5nLCB3aGljaCBtZWFucyB0aGF0IHdlXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnRpbnVlIHRvIHVzZSB0aGUgcmVzdWx0IG9mIHRoZSBtb3N0IHJlY2VudCBzdWNjZXNzZnVsIGxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICogb3IgdGhlIGRlZmF1bHQgbnVsbCBjb25maWcgb2JqZWN0IGlmIHRoZXJlIGhhcyBuZXZlciBiZWVuIGFcbiAgICAgICAgICAgICAgICAgICAgICogc3VjY2Vzc2Z1bCBsb29rdXAuIFdlIGRvIG5vdCBzZXQgdGhlIGxhdGVzdFNlcnZpY2VDb25maWdFcnJvclxuICAgICAgICAgICAgICAgICAgICAgKiBoZXJlIGJlY2F1c2UgdGhhdCBpcyBzcGVjaWZpY2FsbHkgdXNlZCBmb3IgcmVzcG9uc2UgdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiBlcnJvcnMuIFdlIHN0aWxsIG5lZWQgdG8gaGFuZGxlIHRoaXMgZXJyb3Igc28gdGhhdCBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgICAgKiBidWJibGUgdXAgYXMgYW4gdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uLiAqL1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0TmV4dFJlc29sdXRpb25UaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IChfYiA9IChfYSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMubWluVGltZUJldHdlZW5SZXNvbHV0aW9uc01zKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xuICAgICAgICB0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucnVuT25jZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFydE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgLyogSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGxvb2t1cCwganVzdCBsZXQgaXQgZmluaXNoLiBPdGhlcndpc2UsIGlmIHRoZVxuICAgICAgICAgKiBuZXh0UmVzb2x1dGlvblRpbWVyIG9yIGJhY2tvZmYgdGltZXIgaXMgcnVubmluZywgc2V0IHRoZVxuICAgICAgICAgKiBjb250aW51ZVJlc29sdmluZyBmbGFnIHRvIHJlc29sdmUgd2hlbiB3aGljaGV2ZXIgb2YgdGhvc2UgdGltZXJzXG4gICAgICAgICAqIGZpcmVzLiBPdGhlcndpc2UsIHN0YXJ0IHJlc29sdmluZyBpbW1lZGlhdGVseS4gKi9cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgfHwgdGhpcy5iYWNrb2ZmLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgncmVzb2x1dGlvbiB1cGRhdGUgZGVsYXllZCBieSBcIm1pbiB0aW1lIGJldHdlZW4gcmVzb2x1dGlvbnNcIiByYXRlIGxpbWl0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgncmVzb2x1dGlvbiB1cGRhdGUgZGVsYXllZCBieSBiYWNrb2ZmIHRpbWVyIHVudGlsICcgKyB0aGlzLmJhY2tvZmYuZ2V0RW5kVGltZSgpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcmVzb2x2ZXIgdG8gdGhlIHNhbWUgc3RhdGUgaXQgaGFkIHdoZW4gaXQgd2FzIGNyZWF0ZWQuIEluLWZsaWdodFxuICAgICAqIEROUyByZXF1ZXN0cyBjYW5ub3QgYmUgY2FuY2VsbGVkLCBidXQgdGhleSBhcmUgZGlzY2FyZGVkIGFuZCB0aGVpciByZXN1bHRzXG4gICAgICogd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XG4gICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXR1cm5lZElwUmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCBhdXRob3JpdHkgZm9yIHRoZSBnaXZlbiB0YXJnZXQuIEZvciBJUCB0YXJnZXRzLCB0aGF0IGlzXG4gICAgICogdGhlIElQIGFkZHJlc3MuIEZvciBETlMgdGFyZ2V0cywgaXQgaXMgdGhlIGhvc3RuYW1lLlxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoO1xuICAgIH1cbn1cbi8qKlxuICogU2V0IHVwIHRoZSBETlMgcmVzb2x2ZXIgY2xhc3MgYnkgcmVnaXN0ZXJpbmcgaXQgYXMgdGhlIGhhbmRsZXIgZm9yIHRoZVxuICogXCJkbnM6XCIgcHJlZml4IGFuZCBhcyB0aGUgZGVmYXVsdCByZXNvbHZlci5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoJ2RucycsIERuc1Jlc29sdmVyKTtcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlckRlZmF1bHRTY2hlbWUpKCdkbnMnKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLWRucy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIkRFRkFVTFRfUE9SVCIsInJlc29sdmVyXzEiLCJyZXF1aXJlIiwiZG5zIiwidXRpbCIsInNlcnZpY2VfY29uZmlnXzEiLCJjb25zdGFudHNfMSIsIm1ldGFkYXRhXzEiLCJsb2dnaW5nIiwiY29uc3RhbnRzXzIiLCJ1cmlfcGFyc2VyXzEiLCJuZXRfMSIsImJhY2tvZmZfdGltZW91dF8xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIkRFRkFVTFRfTUlOX1RJTUVfQkVUV0VFTl9SRVNPTFVUSU9OU19NUyIsInJlc29sdmVUeHRQcm9taXNlIiwicHJvbWlzaWZ5IiwicmVzb2x2ZVR4dCIsImRuc0xvb2t1cFByb21pc2UiLCJsb29rdXAiLCJtZXJnZUFycmF5cyIsImFycmF5cyIsInJlc3VsdCIsImkiLCJNYXRoIiwibWF4IiwiYXBwbHkiLCJtYXAiLCJhcnJheSIsImxlbmd0aCIsInB1c2giLCJEbnNSZXNvbHZlciIsImNvbnN0cnVjdG9yIiwidGFyZ2V0IiwibGlzdGVuZXIiLCJjaGFubmVsT3B0aW9ucyIsIl9hIiwiX2IiLCJfYyIsInBlbmRpbmdMb29rdXBQcm9taXNlIiwicGVuZGluZ1R4dFByb21pc2UiLCJsYXRlc3RMb29rdXBSZXN1bHQiLCJsYXRlc3RTZXJ2aWNlQ29uZmlnIiwibGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yIiwiY29udGludWVSZXNvbHZpbmciLCJpc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nIiwiaXNTZXJ2aWNlQ29uZmlnRW5hYmxlZCIsInJldHVybmVkSXBSZXN1bHQiLCJ1cmlUb1N0cmluZyIsImhvc3RQb3J0Iiwic3BsaXRIb3N0UG9ydCIsInBhdGgiLCJpcFJlc3VsdCIsImRuc0hvc3RuYW1lIiwicG9ydCIsImlzSVB2NCIsImhvc3QiLCJpc0lQdjYiLCJwZXJjZW50YWdlIiwicmFuZG9tIiwiZGVmYXVsdFJlc29sdXRpb25FcnJvciIsImNvZGUiLCJTdGF0dXMiLCJVTkFWQUlMQUJMRSIsImRldGFpbHMiLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwiYmFja29mZk9wdGlvbnMiLCJpbml0aWFsRGVsYXkiLCJtYXhEZWxheSIsImJhY2tvZmYiLCJCYWNrb2ZmVGltZW91dCIsInN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmIiwidW5yZWYiLCJtaW5UaW1lQmV0d2VlblJlc29sdXRpb25zTXMiLCJuZXh0UmVzb2x1dGlvblRpbWVyIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInN0YXJ0UmVzb2x1dGlvbiIsInNldEltbWVkaWF0ZSIsIm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24iLCJzdG9wIiwicmVzZXQiLCJzdG9wTmV4dFJlc29sdXRpb25UaW1lciIsIm9uRXJyb3IiLCJob3N0bmFtZSIsImFsbCIsInRoZW4iLCJhZGRyZXNzTGlzdCIsImlwNEFkZHJlc3NlcyIsImZpbHRlciIsImFkZHIiLCJmYW1pbHkiLCJpcDZBZGRyZXNzZXMiLCJhZGRyZXNzIiwiYWxsQWRkcmVzc2VzU3RyaW5nIiwiam9pbiIsImVyciIsIm1lc3NhZ2UiLCJ0eHRSZWNvcmQiLCJleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyIsInN0YXJ0TmV4dFJlc29sdXRpb25UaW1lciIsImNhbGwiLCJydW5PbmNlIiwidXBkYXRlUmVzb2x1dGlvbiIsImlzUnVubmluZyIsImdldEVuZFRpbWUiLCJ0b0lTT1N0cmluZyIsImRlc3Ryb3kiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicmVnaXN0ZXJSZXNvbHZlciIsInJlZ2lzdGVyRGVmYXVsdFNjaGVtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"ip_resolver\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst IPV4_SCHEME = \"ipv4\";\nconst IPV6_SCHEME = \"ipv6\";\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */ const DEFAULT_PORT = 443;\nclass IpResolver {\n    constructor(target, listener, channelOptions){\n        var _a;\n        this.listener = listener;\n        this.addresses = [];\n        this.error = null;\n        this.hasReturnedResult = false;\n        trace(\"Resolver constructed for target \" + (0, uri_parser_1.uriToString)(target));\n        const addresses = [];\n        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\n            this.error = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Unrecognized scheme ${target.scheme} in IP resolver`,\n                metadata: new metadata_1.Metadata()\n            };\n            return;\n        }\n        const pathList = target.path.split(\",\");\n        for (const path of pathList){\n            const hostPort = (0, uri_parser_1.splitHostPort)(path);\n            if (hostPort === null) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata()\n                };\n                return;\n            }\n            if (target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host) || target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host)) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata()\n                };\n                return;\n            }\n            addresses.push({\n                host: hostPort.host,\n                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT\n            });\n        }\n        this.addresses = addresses;\n        trace(\"Parsed \" + target.scheme + \" address list \" + this.addresses);\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(()=>{\n                if (this.error) {\n                    this.listener.onError(this.error);\n                } else {\n                    this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});\n                }\n            });\n        }\n    }\n    destroy() {\n        this.hasReturnedResult = false;\n    }\n    static getDefaultAuthority(target) {\n        return target.path.split(\",\")[0];\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);\n    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);\n}\nexports.setup = setup; //# sourceMappingURL=resolver-ip.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBRyxLQUFLO0FBQ3JCLE1BQU1HLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1JLGVBQWVKLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1NLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmSCxRQUFRRSxLQUFLLENBQUNOLFlBQVlRLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBLE1BQU1HLGNBQWM7QUFDcEIsTUFBTUMsY0FBYztBQUNwQjs7Q0FFQyxHQUNELE1BQU1DLGVBQWU7QUFDckIsTUFBTUM7SUFDRkMsWUFBWUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLGNBQWMsQ0FBRTtRQUMxQyxJQUFJQztRQUNKLElBQUksQ0FBQ0YsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNHLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QmYsTUFBTSxxQ0FBcUMsQ0FBQyxHQUFHSCxhQUFhbUIsV0FBVyxFQUFFUDtRQUN6RSxNQUFNSSxZQUFZLEVBQUU7UUFDcEIsSUFBSSxDQUFFSixDQUFBQSxPQUFPUSxNQUFNLEtBQUtiLGVBQWVLLE9BQU9RLE1BQU0sS0FBS1osV0FBVSxHQUFJO1lBQ25FLElBQUksQ0FBQ1MsS0FBSyxHQUFHO2dCQUNUSSxNQUFNeEIsWUFBWXlCLE1BQU0sQ0FBQ0MsV0FBVztnQkFDcENDLFNBQVMsQ0FBQyxvQkFBb0IsRUFBRVosT0FBT1EsTUFBTSxDQUFDLGVBQWUsQ0FBQztnQkFDOURLLFVBQVUsSUFBSTNCLFdBQVc0QixRQUFRO1lBQ3JDO1lBQ0E7UUFDSjtRQUNBLE1BQU1DLFdBQVdmLE9BQU9nQixJQUFJLENBQUNDLEtBQUssQ0FBQztRQUNuQyxLQUFLLE1BQU1ELFFBQVFELFNBQVU7WUFDekIsTUFBTUcsV0FBVyxDQUFDLEdBQUc5QixhQUFhK0IsYUFBYSxFQUFFSDtZQUNqRCxJQUFJRSxhQUFhLE1BQU07Z0JBQ25CLElBQUksQ0FBQ2IsS0FBSyxHQUFHO29CQUNUSSxNQUFNeEIsWUFBWXlCLE1BQU0sQ0FBQ0MsV0FBVztvQkFDcENDLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRVosT0FBT1EsTUFBTSxDQUFDLFNBQVMsRUFBRVEsS0FBSyxDQUFDO29CQUMzREgsVUFBVSxJQUFJM0IsV0FBVzRCLFFBQVE7Z0JBQ3JDO2dCQUNBO1lBQ0o7WUFDQSxJQUFJLE9BQVFOLE1BQU0sS0FBS2IsZUFBZSxDQUFDLENBQUMsR0FBR1osTUFBTXFDLE1BQU0sRUFBRUYsU0FBU0csSUFBSSxLQUNqRXJCLE9BQU9RLE1BQU0sS0FBS1osZUFBZSxDQUFDLENBQUMsR0FBR2IsTUFBTXVDLE1BQU0sRUFBRUosU0FBU0csSUFBSSxHQUFJO2dCQUN0RSxJQUFJLENBQUNoQixLQUFLLEdBQUc7b0JBQ1RJLE1BQU14QixZQUFZeUIsTUFBTSxDQUFDQyxXQUFXO29CQUNwQ0MsU0FBUyxDQUFDLGdCQUFnQixFQUFFWixPQUFPUSxNQUFNLENBQUMsU0FBUyxFQUFFUSxLQUFLLENBQUM7b0JBQzNESCxVQUFVLElBQUkzQixXQUFXNEIsUUFBUTtnQkFDckM7Z0JBQ0E7WUFDSjtZQUNBVixVQUFVbUIsSUFBSSxDQUFDO2dCQUNYRixNQUFNSCxTQUFTRyxJQUFJO2dCQUNuQkcsTUFBTSxDQUFDckIsS0FBS2UsU0FBU00sSUFBSSxNQUFNLFFBQVFyQixPQUFPLEtBQUssSUFBSUEsS0FBS047WUFDaEU7UUFDSjtRQUNBLElBQUksQ0FBQ08sU0FBUyxHQUFHQTtRQUNqQmIsTUFBTSxZQUFZUyxPQUFPUSxNQUFNLEdBQUcsbUJBQW1CLElBQUksQ0FBQ0osU0FBUztJQUN2RTtJQUNBcUIsbUJBQW1CO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQ25CLGlCQUFpQixFQUFFO1lBQ3pCLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUc7WUFDekJvQixPQUFPQSxDQUFDQyxRQUFRLENBQUM7Z0JBQ2IsSUFBSSxJQUFJLENBQUN0QixLQUFLLEVBQUU7b0JBQ1osSUFBSSxDQUFDSixRQUFRLENBQUMyQixPQUFPLENBQUMsSUFBSSxDQUFDdkIsS0FBSztnQkFDcEMsT0FDSztvQkFDRCxJQUFJLENBQUNKLFFBQVEsQ0FBQzRCLHNCQUFzQixDQUFDLElBQUksQ0FBQ3pCLFNBQVMsRUFBRSxNQUFNLE1BQU0sTUFBTSxDQUFDO2dCQUM1RTtZQUNKO1FBQ0o7SUFDSjtJQUNBMEIsVUFBVTtRQUNOLElBQUksQ0FBQ3hCLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0EsT0FBT3lCLG9CQUFvQi9CLE1BQU0sRUFBRTtRQUMvQixPQUFPQSxPQUFPZ0IsSUFBSSxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDcEM7QUFDSjtBQUNBLFNBQVNuQztJQUNKLElBQUdLLFdBQVc2QyxnQkFBZ0IsRUFBRXJDLGFBQWFHO0lBQzdDLElBQUdYLFdBQVc2QyxnQkFBZ0IsRUFBRXBDLGFBQWFFO0FBQ2xEO0FBQ0FsQixhQUFhLEdBQUdFLE9BQ2hCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLWlwLmpzPzdkMjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IHZvaWQgMDtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnaXBfcmVzb2x2ZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBJUFY0X1NDSEVNRSA9ICdpcHY0JztcbmNvbnN0IElQVjZfU0NIRU1FID0gJ2lwdjYnO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGUgdGFyZ2V0LlxuICovXG5jb25zdCBERUZBVUxUX1BPUlQgPSA0NDM7XG5jbGFzcyBJcFJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxpc3RlbmVyLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdHJhY2UoJ1Jlc29sdmVyIGNvbnN0cnVjdGVkIGZvciB0YXJnZXQgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCkpO1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNF9TQ0hFTUUgfHwgdGFyZ2V0LnNjaGVtZSA9PT0gSVBWNl9TQ0hFTUUpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgVW5yZWNvZ25pemVkIHNjaGVtZSAke3RhcmdldC5zY2hlbWV9IGluIElQIHJlc29sdmVyYCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aExpc3QgPSB0YXJnZXQucGF0aC5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aExpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KShwYXRoKTtcbiAgICAgICAgICAgIGlmIChob3N0UG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYEZhaWxlZCB0byBwYXJzZSAke3RhcmdldC5zY2hlbWV9IGFkZHJlc3MgJHtwYXRofWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YXJnZXQuc2NoZW1lID09PSBJUFY0X1NDSEVNRSAmJiAhKDAsIG5ldF8xLmlzSVB2NCkoaG9zdFBvcnQuaG9zdCkpIHx8XG4gICAgICAgICAgICAgICAgKHRhcmdldC5zY2hlbWUgPT09IElQVjZfU0NIRU1FICYmICEoMCwgbmV0XzEuaXNJUHY2KShob3N0UG9ydC5ob3N0KSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgJHt0YXJnZXQuc2NoZW1lfSBhZGRyZXNzICR7cGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxuICAgICAgICAgICAgICAgIHBvcnQ6IChfYSA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRfUE9SVCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gYWRkcmVzc2VzO1xuICAgICAgICB0cmFjZSgnUGFyc2VkICcgKyB0YXJnZXQuc2NoZW1lICsgJyBhZGRyZXNzIGxpc3QgJyArIHRoaXMuYWRkcmVzc2VzKTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JldHVybmVkUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmFkZHJlc3NlcywgbnVsbCwgbnVsbCwgbnVsbCwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQucGF0aC5zcGxpdCgnLCcpWzBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKElQVjRfU0NIRU1FLCBJcFJlc29sdmVyKTtcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyKShJUFY2X1NDSEVNRSwgSXBSZXNvbHZlcik7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci1pcC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIm5ldF8xIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwibWV0YWRhdGFfMSIsInJlc29sdmVyXzEiLCJ1cmlfcGFyc2VyXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIklQVjRfU0NIRU1FIiwiSVBWNl9TQ0hFTUUiLCJERUZBVUxUX1BPUlQiLCJJcFJlc29sdmVyIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJsaXN0ZW5lciIsImNoYW5uZWxPcHRpb25zIiwiX2EiLCJhZGRyZXNzZXMiLCJlcnJvciIsImhhc1JldHVybmVkUmVzdWx0IiwidXJpVG9TdHJpbmciLCJzY2hlbWUiLCJjb2RlIiwiU3RhdHVzIiwiVU5BVkFJTEFCTEUiLCJkZXRhaWxzIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsInBhdGhMaXN0IiwicGF0aCIsInNwbGl0IiwiaG9zdFBvcnQiLCJzcGxpdEhvc3RQb3J0IiwiaXNJUHY0IiwiaG9zdCIsImlzSVB2NiIsInB1c2giLCJwb3J0IiwidXBkYXRlUmVzb2x1dGlvbiIsInByb2Nlc3MiLCJuZXh0VGljayIsIm9uRXJyb3IiLCJvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uIiwiZGVzdHJveSIsImdldERlZmF1bHRBdXRob3JpdHkiLCJyZWdpc3RlclJlc29sdmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-uds.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nclass UdsResolver {\n    constructor(target, listener, channelOptions){\n        this.listener = listener;\n        this.addresses = [];\n        this.hasReturnedResult = false;\n        let path;\n        if (target.authority === \"\") {\n            path = \"/\" + target.path;\n        } else {\n            path = target.path;\n        }\n        this.addresses = [\n            {\n                path\n            }\n        ];\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});\n        }\n    }\n    destroy() {\n    // This resolver owns no resources, so we do nothing here.\n    }\n    static getDefaultAuthority(target) {\n        return \"localhost\";\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)(\"unix\", UdsResolver);\n}\nexports.setup = setup; //# sourceMappingURL=resolver-uds.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxhQUFhLEdBQUcsS0FBSztBQUNyQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNQztJQUNGQyxZQUFZQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsY0FBYyxDQUFFO1FBQzFDLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNFLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSUM7UUFDSixJQUFJTCxPQUFPTSxTQUFTLEtBQUssSUFBSTtZQUN6QkQsT0FBTyxNQUFNTCxPQUFPSyxJQUFJO1FBQzVCLE9BQ0s7WUFDREEsT0FBT0wsT0FBT0ssSUFBSTtRQUN0QjtRQUNBLElBQUksQ0FBQ0YsU0FBUyxHQUFHO1lBQUM7Z0JBQUVFO1lBQUs7U0FBRTtJQUMvQjtJQUNBRSxtQkFBbUI7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDSCxpQkFBaUIsRUFBRTtZQUN6QixJQUFJLENBQUNBLGlCQUFpQixHQUFHO1lBQ3pCSSxPQUFPQSxDQUFDQyxRQUFRLENBQUMsSUFBSSxDQUFDUixRQUFRLENBQUNTLHNCQUFzQixFQUFFLElBQUksQ0FBQ1AsU0FBUyxFQUFFLE1BQU0sTUFBTSxNQUFNLENBQUM7UUFDOUY7SUFDSjtJQUNBUSxVQUFVO0lBQ04sMERBQTBEO0lBQzlEO0lBQ0EsT0FBT0Msb0JBQW9CWixNQUFNLEVBQUU7UUFDL0IsT0FBTztJQUNYO0FBQ0o7QUFDQSxTQUFTTDtJQUNKLElBQUdDLFdBQVdpQixnQkFBZ0IsRUFBRSxRQUFRZjtBQUM3QztBQUNBTCxhQUFhLEdBQUdFLE9BQ2hCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLXVkcy5qcz82OTU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSB2b2lkIDA7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jbGFzcyBVZHNSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IFtdO1xuICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGxldCBwYXRoO1xuICAgICAgICBpZiAodGFyZ2V0LmF1dGhvcml0eSA9PT0gJycpIHtcbiAgICAgICAgICAgIHBhdGggPSAnLycgKyB0YXJnZXQucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSB0YXJnZXQucGF0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IFt7IHBhdGggfV07XG4gICAgfVxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgdGhpcy5hZGRyZXNzZXMsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBUaGlzIHJlc29sdmVyIG93bnMgbm8gcmVzb3VyY2VzLCBzbyB3ZSBkbyBub3RoaW5nIGhlcmUuXG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCkge1xuICAgICAgICByZXR1cm4gJ2xvY2FsaG9zdCc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoJ3VuaXgnLCBVZHNSZXNvbHZlcik7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci11ZHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2V0dXAiLCJyZXNvbHZlcl8xIiwicmVxdWlyZSIsIlVkc1Jlc29sdmVyIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJsaXN0ZW5lciIsImNoYW5uZWxPcHRpb25zIiwiYWRkcmVzc2VzIiwiaGFzUmV0dXJuZWRSZXN1bHQiLCJwYXRoIiwiYXV0aG9yaXR5IiwidXBkYXRlUmVzb2x1dGlvbiIsInByb2Nlc3MiLCJuZXh0VGljayIsIm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24iLCJkZXN0cm95IiwiZ2V0RGVmYXVsdEF1dGhvcml0eSIsInJlZ2lzdGVyUmVzb2x2ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */ function registerResolver(scheme, resolverClass) {\n    registeredResolvers[scheme] = resolverClass;\n}\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */ function registerDefaultScheme(scheme) {\n    defaultScheme = scheme;\n}\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */ function createResolver(target, listener, options) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return new registeredResolvers[target.scheme](target, listener, options);\n    } else {\n        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */ function getDefaultAuthority(target) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\n    } else {\n        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\nexports.getDefaultAuthority = getDefaultAuthority;\nfunction mapUriDefaultScheme(target) {\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n        if (defaultScheme !== null) {\n            return {\n                scheme: defaultScheme,\n                authority: undefined,\n                path: (0, uri_parser_1.uriToString)(target)\n            };\n        } else {\n            return null;\n        }\n    }\n    return target;\n}\nexports.mapUriDefaultScheme = mapUriDefaultScheme; //# sourceMappingURL=resolver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSwyQkFBMkIsR0FBR0Esc0JBQXNCLEdBQUdBLDZCQUE2QixHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQ3JKLE1BQU1PLGVBQWVDLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1DLHNCQUFzQixDQUFDO0FBQzdCLElBQUlDLGdCQUFnQjtBQUNwQjs7Ozs7O0NBTUMsR0FDRCxTQUFTSixpQkFBaUJLLE1BQU0sRUFBRUMsYUFBYTtJQUMzQ0gsbUJBQW1CLENBQUNFLE9BQU8sR0FBR0M7QUFDbEM7QUFDQVosd0JBQXdCLEdBQUdNO0FBQzNCOzs7O0NBSUMsR0FDRCxTQUFTRCxzQkFBc0JNLE1BQU07SUFDakNELGdCQUFnQkM7QUFDcEI7QUFDQVgsNkJBQTZCLEdBQUdLO0FBQ2hDOzs7OztDQUtDLEdBQ0QsU0FBU0QsZUFBZVMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLE9BQU87SUFDN0MsSUFBSUYsT0FBT0YsTUFBTSxLQUFLSyxhQUFhSCxPQUFPRixNQUFNLElBQUlGLHFCQUFxQjtRQUNyRSxPQUFPLElBQUlBLG1CQUFtQixDQUFDSSxPQUFPRixNQUFNLENBQUMsQ0FBQ0UsUUFBUUMsVUFBVUM7SUFDcEUsT0FDSztRQUNELE1BQU0sSUFBSUUsTUFBTSxDQUFDLHdDQUF3QyxFQUFFLENBQUMsR0FBR1YsYUFBYVcsV0FBVyxFQUFFTCxRQUFRLENBQUM7SUFDdEc7QUFDSjtBQUNBYixzQkFBc0IsR0FBR0k7QUFDekI7Ozs7Q0FJQyxHQUNELFNBQVNELG9CQUFvQlUsTUFBTTtJQUMvQixJQUFJQSxPQUFPRixNQUFNLEtBQUtLLGFBQWFILE9BQU9GLE1BQU0sSUFBSUYscUJBQXFCO1FBQ3JFLE9BQU9BLG1CQUFtQixDQUFDSSxPQUFPRixNQUFNLENBQUMsQ0FBQ1IsbUJBQW1CLENBQUNVO0lBQ2xFLE9BQ0s7UUFDRCxNQUFNLElBQUlJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxHQUFHVixhQUFhVyxXQUFXLEVBQUVMLFFBQVEsQ0FBQztJQUM3RTtBQUNKO0FBQ0FiLDJCQUEyQixHQUFHRztBQUM5QixTQUFTRCxvQkFBb0JXLE1BQU07SUFDL0IsSUFBSUEsT0FBT0YsTUFBTSxLQUFLSyxhQUFhLENBQUVILENBQUFBLE9BQU9GLE1BQU0sSUFBSUYsbUJBQWtCLEdBQUk7UUFDeEUsSUFBSUMsa0JBQWtCLE1BQU07WUFDeEIsT0FBTztnQkFDSEMsUUFBUUQ7Z0JBQ1JTLFdBQVdIO2dCQUNYSSxNQUFNLENBQUMsR0FBR2IsYUFBYVcsV0FBVyxFQUFFTDtZQUN4QztRQUNKLE9BQ0s7WUFDRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU9BO0FBQ1g7QUFDQWIsMkJBQTJCLEdBQUdFLHFCQUM5QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci5qcz8xZDk3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hcFVyaURlZmF1bHRTY2hlbWUgPSBleHBvcnRzLmdldERlZmF1bHRBdXRob3JpdHkgPSBleHBvcnRzLmNyZWF0ZVJlc29sdmVyID0gZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRTY2hlbWUgPSBleHBvcnRzLnJlZ2lzdGVyUmVzb2x2ZXIgPSB2b2lkIDA7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgcmVnaXN0ZXJlZFJlc29sdmVycyA9IHt9O1xubGV0IGRlZmF1bHRTY2hlbWUgPSBudWxsO1xuLyoqXG4gKiBSZWdpc3RlciBhIHJlc29sdmVyIGNsYXNzIHRvIGhhbmRsZSB0YXJnZXQgbmFtZXMgcHJlZml4ZWQgd2l0aCB0aGUgYHByZWZpeGBcbiAqIHN0cmluZy4gVGhpcyBwcmVmaXggc2hvdWxkIGNvcnJlc3BvbmQgdG8gYSBVUkkgc2NoZW1lIG5hbWUgbGlzdGVkIGluIHRoZVxuICogW2dSUEMgTmFtZSBSZXNvbHV0aW9uIGRvY3VtZW50XShodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2RvYy9uYW1pbmcubWQpXG4gKiBAcGFyYW0gcHJlZml4XG4gKiBAcGFyYW0gcmVzb2x2ZXJDbGFzc1xuICovXG5mdW5jdGlvbiByZWdpc3RlclJlc29sdmVyKHNjaGVtZSwgcmVzb2x2ZXJDbGFzcykge1xuICAgIHJlZ2lzdGVyZWRSZXNvbHZlcnNbc2NoZW1lXSA9IHJlc29sdmVyQ2xhc3M7XG59XG5leHBvcnRzLnJlZ2lzdGVyUmVzb2x2ZXIgPSByZWdpc3RlclJlc29sdmVyO1xuLyoqXG4gKiBSZWdpc3RlciBhIGRlZmF1bHQgcmVzb2x2ZXIgdG8gaGFuZGxlIHRhcmdldCBuYW1lcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoXG4gKiBhbnkgcmVnaXN0ZXJlZCBwcmVmaXguXG4gKiBAcGFyYW0gcmVzb2x2ZXJDbGFzc1xuICovXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRTY2hlbWUoc2NoZW1lKSB7XG4gICAgZGVmYXVsdFNjaGVtZSA9IHNjaGVtZTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0U2NoZW1lID0gcmVnaXN0ZXJEZWZhdWx0U2NoZW1lO1xuLyoqXG4gKiBDcmVhdGUgYSBuYW1lIHJlc29sdmVyIGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCwgaWYgcG9zc2libGUuIFRocm93cyBhblxuICogZXJyb3IgaWYgbm8gc3VjaCBuYW1lIHJlc29sdmVyIGNhbiBiZSBjcmVhdGVkLlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIGxpc3RlbmVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKHRhcmdldCwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykge1xuICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRSZXNvbHZlcnNbdGFyZ2V0LnNjaGVtZV0odGFyZ2V0LCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlc29sdmVyIGNvdWxkIGJlIGNyZWF0ZWQgZm9yIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGNyZWF0ZVJlc29sdmVyO1xuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgYXV0aG9yaXR5IGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCwgaWYgcG9zc2libGUuIFRocm93cyBhblxuICogZXJyb3IgaWYgbm8gcmVnaXN0ZXJlZCBuYW1lIHJlc29sdmVyIGNhbiBwYXJzZSB0aGF0IHRhcmdldCBzdHJpbmcuXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQuc2NoZW1lIGluIHJlZ2lzdGVyZWRSZXNvbHZlcnMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRSZXNvbHZlcnNbdGFyZ2V0LnNjaGVtZV0uZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREZWZhdWx0QXV0aG9yaXR5ID0gZ2V0RGVmYXVsdEF1dGhvcml0eTtcbmZ1bmN0aW9uIG1hcFVyaURlZmF1bHRTY2hlbWUodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgPT09IHVuZGVmaW5lZCB8fCAhKHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRTY2hlbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NoZW1lOiBkZWZhdWx0U2NoZW1lLFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBhdGg6ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmV4cG9ydHMubWFwVXJpRGVmYXVsdFNjaGVtZSA9IG1hcFVyaURlZmF1bHRTY2hlbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtYXBVcmlEZWZhdWx0U2NoZW1lIiwiZ2V0RGVmYXVsdEF1dGhvcml0eSIsImNyZWF0ZVJlc29sdmVyIiwicmVnaXN0ZXJEZWZhdWx0U2NoZW1lIiwicmVnaXN0ZXJSZXNvbHZlciIsInVyaV9wYXJzZXJfMSIsInJlcXVpcmUiLCJyZWdpc3RlcmVkUmVzb2x2ZXJzIiwiZGVmYXVsdFNjaGVtZSIsInNjaGVtZSIsInJlc29sdmVyQ2xhc3MiLCJ0YXJnZXQiLCJsaXN0ZW5lciIsIm9wdGlvbnMiLCJ1bmRlZmluZWQiLCJFcnJvciIsInVyaVRvU3RyaW5nIiwiYXV0aG9yaXR5IiwicGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-call.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ResolvingCall = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst TRACER_NAME = \"resolving_call\";\nclass ResolvingCall {\n    constructor(channel, method, options, filterStackFactory, credentials, callNumber){\n        this.channel = channel;\n        this.method = method;\n        this.filterStackFactory = filterStackFactory;\n        this.credentials = credentials;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.readFilterPending = false;\n        this.writeFilterPending = false;\n        this.pendingChildStatus = null;\n        this.metadata = null;\n        this.listener = null;\n        this.statusWatchers = [];\n        this.deadlineTimer = setTimeout(()=>{}, 0);\n        this.filterStack = null;\n        this.deadline = options.deadline;\n        this.host = options.host;\n        if (options.parentCall) {\n            if (options.flags & constants_1.Propagate.CANCELLATION) {\n                options.parentCall.on(\"cancelled\", ()=>{\n                    this.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled by parent call\");\n                });\n            }\n            if (options.flags & constants_1.Propagate.DEADLINE) {\n                this.trace(\"Propagating deadline from parent: \" + options.parentCall.getDeadline());\n                this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());\n            }\n        }\n        this.trace(\"Created\");\n        this.runDeadlineTimer();\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callNumber + \"] \" + text);\n    }\n    runDeadlineTimer() {\n        clearTimeout(this.deadlineTimer);\n        this.trace(\"Deadline: \" + (0, deadline_1.deadlineToString)(this.deadline));\n        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);\n        if (timeout !== Infinity) {\n            this.trace(\"Deadline will be reached in \" + timeout + \"ms\");\n            const handleDeadline = ()=>{\n                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, \"Deadline exceeded\");\n            };\n            if (timeout <= 0) {\n                process.nextTick(handleDeadline);\n            } else {\n                this.deadlineTimer = setTimeout(handleDeadline, timeout);\n            }\n        }\n    }\n    outputStatus(status) {\n        if (!this.ended) {\n            this.ended = true;\n            if (!this.filterStack) {\n                this.filterStack = this.filterStackFactory.createFilter();\n            }\n            clearTimeout(this.deadlineTimer);\n            const filteredStatus = this.filterStack.receiveTrailers(status);\n            this.trace(\"ended with status: code=\" + filteredStatus.code + ' details=\"' + filteredStatus.details + '\"');\n            this.statusWatchers.forEach((watcher)=>watcher(filteredStatus));\n            process.nextTick(()=>{\n                var _a;\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n            });\n        }\n    }\n    sendMessageOnChild(context, message) {\n        if (!this.child) {\n            throw new Error(\"sendMessageonChild called with child not populated\");\n        }\n        const child = this.child;\n        this.writeFilterPending = true;\n        this.filterStack.sendMessage(Promise.resolve({\n            message: message,\n            flags: context.flags\n        })).then((filteredMessage)=>{\n            this.writeFilterPending = false;\n            child.sendMessageWithContext(context, filteredMessage.message);\n            if (this.pendingHalfClose) {\n                child.halfClose();\n            }\n        }, (status)=>{\n            this.cancelWithStatus(status.code, status.details);\n        });\n    }\n    getConfig() {\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata || !this.listener) {\n            throw new Error(\"getConfig called before start\");\n        }\n        const configResult = this.channel.getConfig(this.method, this.metadata);\n        if (configResult.type === \"NONE\") {\n            this.channel.queueCallForConfig(this);\n            return;\n        } else if (configResult.type === \"ERROR\") {\n            if (this.metadata.getOptions().waitForReady) {\n                this.channel.queueCallForConfig(this);\n            } else {\n                this.outputStatus(configResult.error);\n            }\n            return;\n        }\n        // configResult.type === 'SUCCESS'\n        const config = configResult.config;\n        if (config.status !== constants_1.Status.OK) {\n            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, \"Failed to route call to method \" + this.method);\n            this.outputStatus({\n                code: code,\n                details: details,\n                metadata: new metadata_1.Metadata()\n            });\n            return;\n        }\n        if (config.methodConfig.timeout) {\n            const configDeadline = new Date();\n            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);\n            configDeadline.setMilliseconds(configDeadline.getMilliseconds() + config.methodConfig.timeout.nanos / 1000000);\n            this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);\n            this.runDeadlineTimer();\n        }\n        this.filterStackFactory.push(config.dynamicFilterFactories);\n        this.filterStack = this.filterStackFactory.createFilter();\n        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then((filteredMetadata)=>{\n            this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);\n            this.trace(\"Created child [\" + this.child.getCallNumber() + \"]\");\n            this.child.start(filteredMetadata, {\n                onReceiveMetadata: (metadata)=>{\n                    this.trace(\"Received metadata\");\n                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));\n                },\n                onReceiveMessage: (message)=>{\n                    this.trace(\"Received message\");\n                    this.readFilterPending = true;\n                    this.filterStack.receiveMessage(message).then((filteredMesssage)=>{\n                        this.trace(\"Finished filtering received message\");\n                        this.readFilterPending = false;\n                        this.listener.onReceiveMessage(filteredMesssage);\n                        if (this.pendingChildStatus) {\n                            this.outputStatus(this.pendingChildStatus);\n                        }\n                    }, (status)=>{\n                        this.cancelWithStatus(status.code, status.details);\n                    });\n                },\n                onReceiveStatus: (status)=>{\n                    this.trace(\"Received status\");\n                    if (this.readFilterPending) {\n                        this.pendingChildStatus = status;\n                    } else {\n                        this.outputStatus(status);\n                    }\n                }\n            });\n            if (this.readPending) {\n                this.child.startRead();\n            }\n            if (this.pendingMessage) {\n                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);\n            } else if (this.pendingHalfClose) {\n                this.child.halfClose();\n            }\n        }, (status)=>{\n            this.outputStatus(status);\n        });\n    }\n    reportResolverError(status) {\n        var _a;\n        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\n            this.channel.queueCallForConfig(this);\n        } else {\n            this.outputStatus(status);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({\n            code: status,\n            details: details,\n            metadata: new metadata_1.Metadata()\n        });\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace(\"start called\");\n        this.metadata = metadata.clone();\n        this.listener = listener;\n        this.getConfig();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace(\"write() called with message of length \" + message.length);\n        if (this.child) {\n            this.sendMessageOnChild(context, message);\n        } else {\n            this.pendingMessage = {\n                context,\n                message\n            };\n        }\n    }\n    startRead() {\n        this.trace(\"startRead called\");\n        if (this.child) {\n            this.child.startRead();\n        } else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace(\"halfClose called\");\n        if (this.child && !this.writeFilterPending) {\n            this.child.halfClose();\n        } else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        this.credentials = this.credentials.compose(credentials);\n    }\n    addStatusWatcher(watcher) {\n        this.statusWatchers.push(watcher);\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n}\nexports.ResolvingCall = ResolvingCall; //# sourceMappingURL=resolving-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWNhbGwuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBRyxLQUFLO0FBQzdCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1JLHlCQUF5QkosbUJBQU9BLENBQUMsb0dBQXdCO0FBQy9ELE1BQU1LLGNBQWM7QUFDcEIsTUFBTVA7SUFDRlEsWUFBWUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsa0JBQWtCLEVBQUVDLFdBQVcsRUFBRUMsVUFBVSxDQUFFO1FBQy9FLElBQUksQ0FBQ0wsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0Usa0JBQWtCLEdBQUdBO1FBQzFCLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFD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QUFJLENBQUM5RixXQUFXLEdBQUc7UUFDdkI7SUFDSjtJQUNBNkQsWUFBWTtRQUNSLElBQUksQ0FBQ3JDLEtBQUssQ0FBQztRQUNYLElBQUksSUFBSSxDQUFDekIsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDTSxrQkFBa0IsRUFBRTtZQUN4QyxJQUFJLENBQUNOLEtBQUssQ0FBQzhELFNBQVM7UUFDeEIsT0FDSztZQUNELElBQUksQ0FBQzNELGdCQUFnQixHQUFHO1FBQzVCO0lBQ0o7SUFDQW1HLGVBQWV4RyxXQUFXLEVBQUU7UUFDeEIsSUFBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLENBQUN5RyxPQUFPLENBQUN6RztJQUNoRDtJQUNBMEcsaUJBQWlCdkQsT0FBTyxFQUFFO1FBQ3RCLElBQUksQ0FBQ3ZDLGNBQWMsQ0FBQ3lFLElBQUksQ0FBQ2xDO0lBQzdCO0lBQ0F1QyxnQkFBZ0I7UUFDWixPQUFPLElBQUksQ0FBQ3pGLFVBQVU7SUFDMUI7QUFDSjtBQUNBaEIscUJBQXFCLEdBQUdFLGVBQ3hCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmluZy1jYWxsLmpzPzYxYWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb2x2aW5nQ2FsbCA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZGVhZGxpbmVfMSA9IHJlcXVpcmUoXCIuL2RlYWRsaW5lXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb250cm9sX3BsYW5lX3N0YXR1c18xID0gcmVxdWlyZShcIi4vY29udHJvbC1wbGFuZS1zdGF0dXNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyZXNvbHZpbmdfY2FsbCc7XG5jbGFzcyBSZXNvbHZpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBtZXRob2QsIG9wdGlvbnMsIGZpbHRlclN0YWNrRmFjdG9yeSwgY3JlZGVudGlhbHMsIGNhbGxOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5ID0gZmlsdGVyU3RhY2tGYWN0b3J5O1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuY2FsbE51bWJlciA9IGNhbGxOdW1iZXI7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkU3RhdHVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzID0gW107XG4gICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBvcHRpb25zLmRlYWRsaW5lO1xuICAgICAgICB0aGlzLmhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gICAgICAgIGlmIChvcHRpb25zLnBhcmVudENhbGwpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZsYWdzICYgY29uc3RhbnRzXzEuUHJvcGFnYXRlLkNBTkNFTExBVElPTikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyZW50Q2FsbC5vbignY2FuY2VsbGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBieSBwYXJlbnQgY2FsbCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmxhZ3MgJiBjb25zdGFudHNfMS5Qcm9wYWdhdGUuREVBRExJTkUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdQcm9wYWdhdGluZyBkZWFkbGluZSBmcm9tIHBhcmVudDogJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyZW50Q2FsbC5nZXREZWFkbGluZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gKDAsIGRlYWRsaW5lXzEubWluRGVhZGxpbmUpKHRoaXMuZGVhZGxpbmUsIG9wdGlvbnMucGFyZW50Q2FsbC5nZXREZWFkbGluZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkJyk7XG4gICAgICAgIHRoaXMucnVuRGVhZGxpbmVUaW1lcigpO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJ1snICsgdGhpcy5jYWxsTnVtYmVyICsgJ10gJyArIHRleHQpO1xuICAgIH1cbiAgICBydW5EZWFkbGluZVRpbWVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWFkbGluZVRpbWVyKTtcbiAgICAgICAgdGhpcy50cmFjZSgnRGVhZGxpbmU6ICcgKyAoMCwgZGVhZGxpbmVfMS5kZWFkbGluZVRvU3RyaW5nKSh0aGlzLmRlYWRsaW5lKSk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoMCwgZGVhZGxpbmVfMS5nZXRSZWxhdGl2ZVRpbWVvdXQpKHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICBpZiAodGltZW91dCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ0RlYWRsaW5lIHdpbGwgYmUgcmVhY2hlZCBpbiAnICsgdGltZW91dCArICdtcycpO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRGVhZGxpbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRCwgJ0RlYWRsaW5lIGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soaGFuZGxlRGVhZGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gc2V0VGltZW91dChoYW5kbGVEZWFkbGluZSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0U3RhdHVzKHN0YXR1cykge1xuICAgICAgICBpZiAoIXRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbHRlclN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5LmNyZWF0ZUZpbHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFN0YXR1cyA9IHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZVRyYWlsZXJzKHN0YXR1cyk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFN0YXR1cy5jb2RlICtcbiAgICAgICAgICAgICAgICAnIGRldGFpbHM9XCInICtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFN0YXR1cy5kZXRhaWxzICtcbiAgICAgICAgICAgICAgICAnXCInKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzV2F0Y2hlcnMuZm9yRWFjaCh3YXRjaGVyID0+IHdhdGNoZXIoZmlsdGVyZWRTdGF0dXMpKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlU3RhdHVzKGZpbHRlcmVkU3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlT25DaGlsZChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZW5kTWVzc2FnZW9uQ2hpbGQgY2FsbGVkIHdpdGggY2hpbGQgbm90IHBvcHVsYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZDtcbiAgICAgICAgdGhpcy53cml0ZUZpbHRlclBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnNlbmRNZXNzYWdlKFByb21pc2UucmVzb2x2ZSh7IG1lc3NhZ2U6IG1lc3NhZ2UsIGZsYWdzOiBjb250ZXh0LmZsYWdzIH0pKS50aGVuKGZpbHRlcmVkTWVzc2FnZSA9PiB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY2hpbGQuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBmaWx0ZXJlZE1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tZXRhZGF0YSB8fCAhdGhpcy5saXN0ZW5lcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRDb25maWcgY2FsbGVkIGJlZm9yZSBzdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IHRoaXMuY2hhbm5lbC5nZXRDb25maWcodGhpcy5tZXRob2QsIHRoaXMubWV0YWRhdGEpO1xuICAgICAgICBpZiAoY29uZmlnUmVzdWx0LnR5cGUgPT09ICdOT05FJykge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvckNvbmZpZyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWdSZXN1bHQudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5xdWV1ZUNhbGxGb3JDb25maWcodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyhjb25maWdSZXN1bHQuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbmZpZ1Jlc3VsdC50eXBlID09PSAnU1VDQ0VTUydcbiAgICAgICAgY29uc3QgY29uZmlnID0gY29uZmlnUmVzdWx0LmNvbmZpZztcbiAgICAgICAgaWYgKGNvbmZpZy5zdGF0dXMgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKGNvbmZpZy5zdGF0dXMsICdGYWlsZWQgdG8gcm91dGUgY2FsbCB0byBtZXRob2QgJyArIHRoaXMubWV0aG9kKTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0KSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWdEZWFkbGluZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBjb25maWdEZWFkbGluZS5zZXRTZWNvbmRzKGNvbmZpZ0RlYWRsaW5lLmdldFNlY29uZHMoKSArIGNvbmZpZy5tZXRob2RDb25maWcudGltZW91dC5zZWNvbmRzKTtcbiAgICAgICAgICAgIGNvbmZpZ0RlYWRsaW5lLnNldE1pbGxpc2Vjb25kcyhjb25maWdEZWFkbGluZS5nZXRNaWxsaXNlY29uZHMoKSArXG4gICAgICAgICAgICAgICAgY29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0Lm5hbm9zIC8gMTAwMDAwMCk7XG4gICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gKDAsIGRlYWRsaW5lXzEubWluRGVhZGxpbmUpKHRoaXMuZGVhZGxpbmUsIGNvbmZpZ0RlYWRsaW5lKTtcbiAgICAgICAgICAgIHRoaXMucnVuRGVhZGxpbmVUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5LnB1c2goY29uZmlnLmR5bmFtaWNGaWx0ZXJGYWN0b3JpZXMpO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrID0gdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkuY3JlYXRlRmlsdGVyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2suc2VuZE1ldGFkYXRhKFByb21pc2UucmVzb2x2ZSh0aGlzLm1ldGFkYXRhKSkudGhlbihmaWx0ZXJlZE1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQgPSB0aGlzLmNoYW5uZWwuY3JlYXRlSW5uZXJDYWxsKGNvbmZpZywgdGhpcy5tZXRob2QsIHRoaXMuaG9zdCwgdGhpcy5jcmVkZW50aWFscywgdGhpcy5kZWFkbGluZSk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkIGNoaWxkIFsnICsgdGhpcy5jaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydChmaWx0ZXJlZE1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWV0YWRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSh0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkRmlsdGVyUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkudGhlbihmaWx0ZXJlZE1lc3NzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZpbmlzaGVkIGZpbHRlcmluZyByZWNlaXZlZCBtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UoZmlsdGVyZWRNZXNzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh0aGlzLnBlbmRpbmdDaGlsZFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc3RhdHVzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZFN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkUGVuZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VPbkNoaWxkKHRoaXMucGVuZGluZ01lc3NhZ2UuY29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXBvcnRSZXNvbHZlckVycm9yKHN0YXR1cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvckNvbmZpZyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY2hhbm5lbC5nZXRUYXJnZXQoKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmdldENvbmZpZygpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZU9uQ2hpbGQoY29udGV4dCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0geyBjb250ZXh0LCBtZXNzYWdlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdzdGFydFJlYWQgY2FsbGVkJyk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0UmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdoYWxmQ2xvc2UgY2FsbGVkJyk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkICYmICF0aGlzLndyaXRlRmlsdGVyUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHRoaXMuY3JlZGVudGlhbHMuY29tcG9zZShjcmVkZW50aWFscyk7XG4gICAgfVxuICAgIGFkZFN0YXR1c1dhdGNoZXIod2F0Y2hlcikge1xuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgfVxuICAgIGdldENhbGxOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxOdW1iZXI7XG4gICAgfVxufVxuZXhwb3J0cy5SZXNvbHZpbmdDYWxsID0gUmVzb2x2aW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmluZy1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJlc29sdmluZ0NhbGwiLCJjb25zdGFudHNfMSIsInJlcXVpcmUiLCJkZWFkbGluZV8xIiwibWV0YWRhdGFfMSIsImxvZ2dpbmciLCJjb250cm9sX3BsYW5lX3N0YXR1c18xIiwiVFJBQ0VSX05BTUUiLCJjb25zdHJ1Y3RvciIsImNoYW5uZWwiLCJtZXRob2QiLCJvcHRpb25zIiwiZmlsdGVyU3RhY2tGYWN0b3J5IiwiY3JlZGVudGlhbHMiLCJjYWxsTnVtYmVyIiwiY2hpbGQiLCJyZWFkUGVuZGluZyIsInBlbmRpbmdNZXNzYWdlIiwicGVuZGluZ0hhbGZDbG9zZSIsImVuZGVkIiwicmVhZEZpbHRlclBlbmRpbmciLCJ3cml0ZUZpbHRlclBlbmRpbmciLCJwZW5kaW5nQ2hpbGRTdGF0dXMiLCJtZXRhZGF0YSIsImxpc3RlbmVyIiwic3RhdHVzV2F0Y2hlcnMiLCJkZWFkbGluZVRpbWVyIiwic2V0VGltZW91dCIsImZpbHRlclN0YWNrIiwiZGVhZGxpbmUiLCJob3N0IiwicGFyZW50Q2FsbCIsImZsYWdzIiwiUHJvcGFnYXRlIiwiQ0FOQ0VMTEFUSU9OIiwib24iLCJjYW5jZWxXaXRoU3RhdHVzIiwiU3RhdHVzIiwiQ0FOQ0VMTEVEIiwiREVBRExJTkUiLCJ0cmFjZSIsImdldERlYWRsaW5lIiwibWluRGVhZGxpbmUiLCJydW5EZWFkbGluZVRpbWVyIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiY2xlYXJUaW1lb3V0IiwiZGVhZGxpbmVUb1N0cmluZyIsInRpbWVvdXQiLCJnZXRSZWxhdGl2ZVRpbWVvdXQiLCJJbmZpbml0eSIsImhhbmRsZURlYWRsaW5lIiwiREVBRExJTkVfRVhDRUVERUQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJvdXRwdXRTdGF0dXMiLCJzdGF0dXMiLCJjcmVhdGVGaWx0ZXIiLCJmaWx0ZXJlZFN0YXR1cyIsInJlY2VpdmVUcmFpbGVycyIsImNvZGUiLCJkZXRhaWxzIiwiZm9yRWFjaCIsIndhdGNoZXIiLCJfYSIsIm9uUmVjZWl2ZVN0YXR1cyIsInNlbmRNZXNzYWdlT25DaGlsZCIsImNvbnRleHQiLCJtZXNzYWdlIiwiRXJyb3IiLCJzZW5kTWVzc2FnZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImZpbHRlcmVkTWVzc2FnZSIsInNlbmRNZXNzYWdlV2l0aENvbnRleHQiLCJoYWxmQ2xvc2UiLCJnZXRDb25maWciLCJjb25maWdSZXN1bHQiLCJ0eXBlIiwicXVldWVDYWxsRm9yQ29uZmlnIiwiZ2V0T3B0aW9ucyIsIndhaXRGb3JSZWFkeSIsImVycm9yIiwiY29uZmlnIiwiT0siLCJyZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUiLCJNZXRhZGF0YSIsIm1ldGhvZENvbmZpZyIsImNvbmZpZ0RlYWRsaW5lIiwiRGF0ZSIsInNldFNlY29uZHMiLCJnZXRTZWNvbmRzIiwic2Vjb25kcyIsInNldE1pbGxpc2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsIm5hbm9zIiwicHVzaCIsImR5bmFtaWNGaWx0ZXJGYWN0b3JpZXMiLCJzZW5kTWV0YWRhdGEiLCJmaWx0ZXJlZE1ldGFkYXRhIiwiY3JlYXRlSW5uZXJDYWxsIiwiZ2V0Q2FsbE51bWJlciIsInN0YXJ0Iiwib25SZWNlaXZlTWV0YWRhdGEiLCJyZWNlaXZlTWV0YWRhdGEiLCJvblJlY2VpdmVNZXNzYWdlIiwicmVjZWl2ZU1lc3NhZ2UiLCJmaWx0ZXJlZE1lc3NzYWdlIiwic3RhcnRSZWFkIiwicmVwb3J0UmVzb2x2ZXJFcnJvciIsImdldFBlZXIiLCJfYiIsImdldFRhcmdldCIsImNsb25lIiwibGVuZ3RoIiwic2V0Q3JlZGVudGlhbHMiLCJjb21wb3NlIiwiYWRkU3RhdHVzV2F0Y2hlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst TRACER_NAME = \"resolving_load_balancer\";\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * Name match levels in order from most to least specific. This is the order in\n * which searches will be performed.\n */ const NAME_MATCH_LEVEL_ORDER = [\n    \"SERVICE_AND_METHOD\",\n    \"SERVICE\",\n    \"EMPTY\"\n];\nfunction hasMatchingName(service, method, methodConfig, matchLevel) {\n    for (const name of methodConfig.name){\n        switch(matchLevel){\n            case \"EMPTY\":\n                if (!name.service && !name.method) {\n                    return true;\n                }\n                break;\n            case \"SERVICE\":\n                if (name.service === service && !name.method) {\n                    return true;\n                }\n                break;\n            case \"SERVICE_AND_METHOD\":\n                if (name.service === service && name.method === method) {\n                    return true;\n                }\n        }\n    }\n    return false;\n}\nfunction findMatchingConfig(service, method, methodConfigs, matchLevel) {\n    for (const config of methodConfigs){\n        if (hasMatchingName(service, method, config, matchLevel)) {\n            return config;\n        }\n    }\n    return null;\n}\nfunction getDefaultConfigSelector(serviceConfig) {\n    return function defaultConfigSelector(methodName, metadata) {\n        var _a, _b;\n        const splitName = methodName.split(\"/\").filter((x)=>x.length > 0);\n        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : \"\";\n        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : \"\";\n        if (serviceConfig && serviceConfig.methodConfig) {\n            /* Check for the following in order, and return the first method\n             * config that matches:\n             * 1. A name that exactly matches the service and method\n             * 2. A name with no method set that matches the service\n             * 3. An empty name\n             */ for (const matchLevel of NAME_MATCH_LEVEL_ORDER){\n                const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);\n                if (matchingConfig) {\n                    return {\n                        methodConfig: matchingConfig,\n                        pickInformation: {},\n                        status: constants_1.Status.OK,\n                        dynamicFilterFactories: []\n                    };\n                }\n            }\n        }\n        return {\n            methodConfig: {\n                name: []\n            },\n            pickInformation: {},\n            status: constants_1.Status.OK,\n            dynamicFilterFactories: []\n        };\n    };\n}\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */ constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution){\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.onSuccessfulResolution = onSuccessfulResolution;\n        this.onFailedResolution = onFailedResolution;\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        /**\n         * This resolving load balancer's current connectivity state.\n         */ this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of null indicates that we have not yet received a valid\n         * service config from the resolver.\n         */ this.previousServiceConfig = null;\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */ this.continueResolving = false;\n        if (channelOptions[\"grpc.service_config\"]) {\n            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions[\"grpc.service_config\"]));\n        } else {\n            this.defaultServiceConfig = {\n                loadBalancingConfig: [],\n                methodConfig: []\n            };\n        }\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n            requestReresolution: ()=>{\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */ if (this.backoffTimeout.isRunning()) {\n                    trace(\"requestReresolution delayed by backoff timer until \" + this.backoffTimeout.getEndTime().toISOString());\n                    this.continueResolving = true;\n                } else {\n                    this.updateResolution();\n                }\n            },\n            updateState: (newState, picker)=>{\n                this.latestChildState = newState;\n                this.latestChildPicker = picker;\n                this.updateState(newState, picker);\n            },\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)\n        });\n        this.innerResolver = (0, resolver_1.createResolver)(target, {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes)=>{\n                var _a;\n                this.backoffTimeout.stop();\n                this.backoffTimeout.reset();\n                let workingServiceConfig = null;\n                /* This first group of conditionals implements the algorithm described\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\n                 */ if (serviceConfig === null) {\n                    // Step 4 and 5\n                    if (serviceConfigError === null) {\n                        // Step 5\n                        this.previousServiceConfig = null;\n                        workingServiceConfig = this.defaultServiceConfig;\n                    } else {\n                        // Step 4\n                        if (this.previousServiceConfig === null) {\n                            // Step 4.ii\n                            this.handleResolutionFailure(serviceConfigError);\n                        } else {\n                            // Step 4.i\n                            workingServiceConfig = this.previousServiceConfig;\n                        }\n                    }\n                } else {\n                    // Step 3\n                    workingServiceConfig = serviceConfig;\n                    this.previousServiceConfig = serviceConfig;\n                }\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n                const loadBalancingConfig = (0, load_balancer_1.getFirstUsableConfig)(workingConfigList, true);\n                if (loadBalancingConfig === null) {\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\n                    this.handleResolutionFailure({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: \"All load balancer options in service config are not compatible\",\n                        metadata: new metadata_1.Metadata()\n                    });\n                    return;\n                }\n                this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n                this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n            },\n            onError: (error)=>{\n                this.handleResolutionFailure(error);\n            }\n        }, channelOptions);\n        const backoffOptions = {\n            initialDelay: channelOptions[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: channelOptions[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(()=>{\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            } else {\n                this.updateState(this.latestChildState, this.latestChildPicker);\n            }\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        this.backoffTimeout.runOnce();\n    }\n    updateState(connectivityState, picker) {\n        trace((0, uri_parser_1.uriToString)(this.target) + \" \" + connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[connectivityState]);\n        // Ensure that this.exitIdle() is called by the picker\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n            picker = new picker_1.QueuePicker(this);\n        }\n        this.currentState = connectivityState;\n        this.channelControlHelper.updateState(connectivityState, picker);\n    }\n    handleResolutionFailure(error) {\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n            this.onFailedResolution(error);\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            } else {\n                this.updateResolution();\n            }\n        }\n        this.childLoadBalancer.exitIdle();\n    }\n    updateAddressList(addressList, lbConfig) {\n        throw new Error(\"updateAddressList not supported on ResolvingLoadBalancer\");\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.childLoadBalancer.resetBackoff();\n    }\n    destroy() {\n        this.childLoadBalancer.destroy();\n        this.innerResolver.destroy();\n        this.backoffTimeout.reset();\n        this.backoffTimeout.stop();\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.previousServiceConfig = null;\n        this.continueResolving = false;\n    }\n    getTypeName() {\n        return \"resolving_load_balancer\";\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer; //# sourceMappingURL=resolving-load-balancer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUcsa0JBQWtCQyxtQkFBT0EsQ0FBQyxzRkFBaUI7QUFDakQsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDbkQsTUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUksV0FBV0osbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUssb0JBQW9CTCxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTU0sY0FBY04sbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTVEsVUFBVVIsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTVMsY0FBY1QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTVUsZUFBZVYsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVcsZ0NBQWdDWCxtQkFBT0EsQ0FBQyxrSEFBK0I7QUFDN0UsTUFBTVksY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZOLFFBQVFLLEtBQUssQ0FBQ0osWUFBWU0sWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUcseUJBQXlCO0lBQzNCO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsU0FBU0MsZ0JBQWdCQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsWUFBWSxFQUFFQyxVQUFVO0lBQzlELEtBQUssTUFBTUMsUUFBUUYsYUFBYUUsSUFBSSxDQUFFO1FBQ2xD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QUFFOEIsUUFBUSxFQUFFO1FBQ3JDLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBQyxlQUFlO1FBQ1gsSUFBSSxDQUFDM0MsY0FBYyxDQUFDZ0IsS0FBSztRQUN6QixJQUFJLENBQUNyQixpQkFBaUIsQ0FBQ2dELFlBQVk7SUFDdkM7SUFDQUMsVUFBVTtRQUNOLElBQUksQ0FBQ2pELGlCQUFpQixDQUFDaUQsT0FBTztRQUM5QixJQUFJLENBQUNuQyxhQUFhLENBQUNtQyxPQUFPO1FBQzFCLElBQUksQ0FBQzVDLGNBQWMsQ0FBQ2dCLEtBQUs7UUFDekIsSUFBSSxDQUFDaEIsY0FBYyxDQUFDZSxJQUFJO1FBQ3hCLElBQUksQ0FBQ2xDLGdCQUFnQixHQUFHakQscUJBQXFCa0QsaUJBQWlCLENBQUNDLElBQUk7UUFDbkUsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxJQUFJbEQsU0FBU21ELFdBQVcsQ0FBQyxJQUFJO1FBQ3RELElBQUksQ0FBQ0MsWUFBWSxHQUFHdEQscUJBQXFCa0QsaUJBQWlCLENBQUNDLElBQUk7UUFDL0QsSUFBSSxDQUFDSSxxQkFBcUIsR0FBRztRQUM3QixJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0F5RCxjQUFjO1FBQ1YsT0FBTztJQUNYO0FBQ0o7QUFDQXZILDZCQUE2QixHQUFHRSx1QkFDaEMsbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanM/NDk3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXNvbHZpbmdMb2FkQmFsYW5jZXIgPSB2b2lkIDA7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3Qgc2VydmljZV9jb25maWdfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2UtY29uZmlnXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncmVzb2x2aW5nX2xvYWRfYmFsYW5jZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG4vKipcbiAqIE5hbWUgbWF0Y2ggbGV2ZWxzIGluIG9yZGVyIGZyb20gbW9zdCB0byBsZWFzdCBzcGVjaWZpYy4gVGhpcyBpcyB0aGUgb3JkZXIgaW5cbiAqIHdoaWNoIHNlYXJjaGVzIHdpbGwgYmUgcGVyZm9ybWVkLlxuICovXG5jb25zdCBOQU1FX01BVENIX0xFVkVMX09SREVSID0gW1xuICAgICdTRVJWSUNFX0FORF9NRVRIT0QnLFxuICAgICdTRVJWSUNFJyxcbiAgICAnRU1QVFknLFxuXTtcbmZ1bmN0aW9uIGhhc01hdGNoaW5nTmFtZShzZXJ2aWNlLCBtZXRob2QsIG1ldGhvZENvbmZpZywgbWF0Y2hMZXZlbCkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXRob2RDb25maWcubmFtZSkge1xuICAgICAgICBzd2l0Y2ggKG1hdGNoTGV2ZWwpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VNUFRZJzpcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUuc2VydmljZSAmJiAhbmFtZS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU0VSVklDRSc6XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc2VydmljZSA9PT0gc2VydmljZSAmJiAhbmFtZS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU0VSVklDRV9BTkRfTUVUSE9EJzpcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zZXJ2aWNlID09PSBzZXJ2aWNlICYmIG5hbWUubWV0aG9kID09PSBtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmRNYXRjaGluZ0NvbmZpZyhzZXJ2aWNlLCBtZXRob2QsIG1ldGhvZENvbmZpZ3MsIG1hdGNoTGV2ZWwpIHtcbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBtZXRob2RDb25maWdzKSB7XG4gICAgICAgIGlmIChoYXNNYXRjaGluZ05hbWUoc2VydmljZSwgbWV0aG9kLCBjb25maWcsIG1hdGNoTGV2ZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdENvbmZpZ1NlbGVjdG9yKHNlcnZpY2VDb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVmYXVsdENvbmZpZ1NlbGVjdG9yKG1ldGhvZE5hbWUsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHNwbGl0TmFtZSA9IG1ldGhvZE5hbWUuc3BsaXQoJy8nKS5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDApO1xuICAgICAgICBjb25zdCBzZXJ2aWNlID0gKF9hID0gc3BsaXROYW1lWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgY29uc3QgbWV0aG9kID0gKF9iID0gc3BsaXROYW1lWzFdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgICAgICAgaWYgKHNlcnZpY2VDb25maWcgJiYgc2VydmljZUNvbmZpZy5tZXRob2RDb25maWcpIHtcbiAgICAgICAgICAgIC8qIENoZWNrIGZvciB0aGUgZm9sbG93aW5nIGluIG9yZGVyLCBhbmQgcmV0dXJuIHRoZSBmaXJzdCBtZXRob2RcbiAgICAgICAgICAgICAqIGNvbmZpZyB0aGF0IG1hdGNoZXM6XG4gICAgICAgICAgICAgKiAxLiBBIG5hbWUgdGhhdCBleGFjdGx5IG1hdGNoZXMgdGhlIHNlcnZpY2UgYW5kIG1ldGhvZFxuICAgICAgICAgICAgICogMi4gQSBuYW1lIHdpdGggbm8gbWV0aG9kIHNldCB0aGF0IG1hdGNoZXMgdGhlIHNlcnZpY2VcbiAgICAgICAgICAgICAqIDMuIEFuIGVtcHR5IG5hbWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaExldmVsIG9mIE5BTUVfTUFUQ0hfTEVWRUxfT1JERVIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ0NvbmZpZyA9IGZpbmRNYXRjaGluZ0NvbmZpZyhzZXJ2aWNlLCBtZXRob2QsIHNlcnZpY2VDb25maWcubWV0aG9kQ29uZmlnLCBtYXRjaExldmVsKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogbWF0Y2hpbmdDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrSW5mb3JtYXRpb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljRmlsdGVyRmFjdG9yaWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGhvZENvbmZpZzogeyBuYW1lOiBbXSB9LFxuICAgICAgICAgICAgcGlja0luZm9ybWF0aW9uOiB7fSxcbiAgICAgICAgICAgIHN0YXR1czogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxuICAgICAgICAgICAgZHluYW1pY0ZpbHRlckZhY3RvcmllczogW10sXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmNsYXNzIFJlc29sdmluZ0xvYWRCYWxhbmNlciB7XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBjbGFzcyB0aGF0IGJlaGF2ZXMgbGlrZSBhIGBMb2FkQmFsYW5jZXJgIGFuZCBhbHNvIGhhbmRsZXMgbmFtZVxuICAgICAqIHJlc29sdXRpb24gaW50ZXJuYWxseS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSBhZGRyZXNzIG9mIHRoZSBiYWNrZW5kIHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHBhcmFtIGNoYW5uZWxDb250cm9sSGVscGVyIGBDaGFubmVsQ29udHJvbEhlbHBlcmAgaW5zdGFuY2UgcHJvdmlkZWQgYnlcbiAgICAgKiAgICAgdGhpcyBsb2FkIGJhbGFuY2VyJ3Mgb3duZXIuXG4gICAgICogQHBhcmFtIGRlZmF1bHRTZXJ2aWNlQ29uZmlnIFRoZSBkZWZhdWx0IHNlcnZpY2UgY29uZmlndXJhdGlvbiB0byBiZSB1c2VkXG4gICAgICogICAgIGlmIG5vbmUgaXMgcHJvdmlkZWQgYnkgdGhlIG5hbWUgcmVzb2x2ZXIuIEEgYG51bGxgIHZhbHVlIGluZGljYXRlc1xuICAgICAqICAgICB0aGF0IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHNob3VsZCBiZSB0aGUgZGVmYXVsdCB1bmNvbmZpZ3VyZWQgYmVoYXZpb3IuXG4gICAgICogICAgIEluIHByYWN0aWNlLCB0aGF0IG1lYW5zIHVzaW5nIHRoZSBcInBpY2sgZmlyc3RcIiBsb2FkIGJhbGFuY2VyXG4gICAgICogICAgIGltcGxtZW50YXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNoYW5uZWxDb250cm9sSGVscGVyLCBjaGFubmVsT3B0aW9ucywgb25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgb25GYWlsZWRSZXNvbHV0aW9uKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIHRoaXMub25TdWNjZXNzZnVsUmVzb2x1dGlvbiA9IG9uU3VjY2Vzc2Z1bFJlc29sdXRpb247XG4gICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uID0gb25GYWlsZWRSZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkUGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyByZXNvbHZpbmcgbG9hZCBiYWxhbmNlcidzIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlcnZpY2UgY29uZmlnIG9iamVjdCBmcm9tIHRoZSBsYXN0IHN1Y2Nlc3NmdWwgcmVzb2x1dGlvbiwgaWZcbiAgICAgICAgICogYXZhaWxhYmxlLiBBIHZhbHVlIG9mIG51bGwgaW5kaWNhdGVzIHRoYXQgd2UgaGF2ZSBub3QgeWV0IHJlY2VpdmVkIGEgdmFsaWRcbiAgICAgICAgICogc2VydmljZSBjb25maWcgZnJvbSB0aGUgcmVzb2x2ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB3ZSBzaG91bGQgYXR0ZW1wdCB0byByZXNvbHZlIGFnYWluIGFmdGVyIHRoZSBiYWNrb2ZmXG4gICAgICAgICAqIHRpbWVyIHJ1bnMgb3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoY2hhbm5lbE9wdGlvbnNbJ2dycGMuc2VydmljZV9jb25maWcnXSkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2VydmljZUNvbmZpZyA9ICgwLCBzZXJ2aWNlX2NvbmZpZ18xLnZhbGlkYXRlU2VydmljZUNvbmZpZykoSlNPTi5wYXJzZShjaGFubmVsT3B0aW9uc1snZ3JwYy5zZXJ2aWNlX2NvbmZpZyddKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGxvYWRCYWxhbmNpbmdDb25maWc6IFtdLFxuICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlciA9IG5ldyBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIoe1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbC5iaW5kKGNoYW5uZWxDb250cm9sSGVscGVyKSxcbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgYmFja29mZlRpbWVvdXQgaXMgcnVubmluZywgd2UncmUgc3RpbGwgYmFja2luZyBvZmYgZnJvbVxuICAgICAgICAgICAgICAgICAqIG1ha2luZyByZXNvbHZlIHJlcXVlc3RzLCBzbyB3ZSBzaG91bGRuJ3QgbWFrZSBhbm90aGVyIG9uZSBoZXJlLlxuICAgICAgICAgICAgICAgICAqIEluIHRoYXQgY2FzZSwgdGhlIGJhY2tvZmYgdGltZXIgY2FsbGJhY2sgd2lsbCBjYWxsXG4gICAgICAgICAgICAgICAgICogdXBkYXRlUmVzb2x1dGlvbiAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdyZXF1ZXN0UmVyZXNvbHV0aW9uIGRlbGF5ZWQgYnkgYmFja29mZiB0aW1lciB1bnRpbCAnICsgdGhpcy5iYWNrb2ZmVGltZW91dC5nZXRFbmRUaW1lKCkudG9JU09TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAobmV3U3RhdGUsIHBpY2tlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBwaWNrZXI7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiBjaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkLmJpbmQoY2hhbm5lbENvbnRyb2xIZWxwZXIpLFxuICAgICAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZC5iaW5kKGNoYW5uZWxDb250cm9sSGVscGVyKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlciA9ICgwLCByZXNvbHZlcl8xLmNyZWF0ZVJlc29sdmVyKSh0YXJnZXQsIHtcbiAgICAgICAgICAgIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb246IChhZGRyZXNzTGlzdCwgc2VydmljZUNvbmZpZywgc2VydmljZUNvbmZpZ0Vycm9yLCBjb25maWdTZWxlY3RvciwgYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvKiBUaGlzIGZpcnN0IGdyb3VwIG9mIGNvbmRpdGlvbmFscyBpbXBsZW1lbnRzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkXG4gICAgICAgICAgICAgICAgICogaW4gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvcHJvcG9zYWwvYmxvYi9tYXN0ZXIvQTIxLXNlcnZpY2UtY29uZmlnLWVycm9yLWhhbmRsaW5nLm1kXG4gICAgICAgICAgICAgICAgICogaW4gdGhlIHNlY3Rpb24gY2FsbGVkIFwiQmVoYXZpb3Igb24gcmVjZWl2aW5nIGEgbmV3IGdSUEMgQ29uZmlnXCIuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VDb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0IGFuZCA1XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnRXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQuaWlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKHNlcnZpY2VDb25maWdFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQuaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgM1xuICAgICAgICAgICAgICAgICAgICB3b3JraW5nU2VydmljZUNvbmZpZyA9IHNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID0gc2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd29ya2luZ0NvbmZpZ0xpc3QgPSAoX2EgPSB3b3JraW5nU2VydmljZUNvbmZpZyA9PT0gbnVsbCB8fCB3b3JraW5nU2VydmljZUNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd29ya2luZ1NlcnZpY2VDb25maWcubG9hZEJhbGFuY2luZ0NvbmZpZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZEJhbGFuY2luZ0NvbmZpZyA9ICgwLCBsb2FkX2JhbGFuY2VyXzEuZ2V0Rmlyc3RVc2FibGVDb25maWcpKHdvcmtpbmdDb25maWdMaXN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobG9hZEJhbGFuY2luZ0NvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSB3ZXJlIGxvYWQgYmFsYW5jaW5nIGNvbmZpZ3MgYnV0IG5vbmUgYXJlIHN1cHBvcnRlZC4gVGhpcyBjb3VudHMgYXMgYSByZXNvbHV0aW9uIGZhaWx1cmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHV0aW9uRmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnQWxsIGxvYWQgYmFsYW5jZXIgb3B0aW9ucyBpbiBzZXJ2aWNlIGNvbmZpZyBhcmUgbm90IGNvbXBhdGlibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxvYWRCYWxhbmNpbmdDb25maWcsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsU2VydmljZUNvbmZpZyA9IHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSBudWxsICYmIHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSB2b2lkIDAgPyB3b3JraW5nU2VydmljZUNvbmZpZyA6IHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKGZpbmFsU2VydmljZUNvbmZpZywgY29uZmlnU2VsZWN0b3IgIT09IG51bGwgJiYgY29uZmlnU2VsZWN0b3IgIT09IHZvaWQgMCA/IGNvbmZpZ1NlbGVjdG9yIDogZ2V0RGVmYXVsdENvbmZpZ1NlbGVjdG9yKGZpbmFsU2VydmljZUNvbmZpZykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzb2x1dGlvbkZhaWx1cmUoZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBiYWNrb2ZmT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGluaXRpYWxEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMuaW5pdGlhbF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICAgICAgbWF4RGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0ID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLmxhdGVzdENoaWxkU3RhdGUsIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQudW5yZWYoKTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5ydW5PbmNlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpIHtcbiAgICAgICAgdHJhY2UoKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW2Nvbm5lY3Rpdml0eVN0YXRlXSk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoaXMuZXhpdElkbGUoKSBpcyBjYWxsZWQgYnkgdGhlIHBpY2tlclxuICAgICAgICBpZiAoY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIHBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eVN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpO1xuICAgIH1cbiAgICBoYW5kbGVSZXNvbHV0aW9uRmFpbHVyZShlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5sYXRlc3RDaGlsZFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoZXJyb3IpKTtcbiAgICAgICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VwZGF0ZUFkZHJlc3NMaXN0IG5vdCBzdXBwb3J0ZWQgb24gUmVzb2x2aW5nTG9hZEJhbGFuY2VyJyk7XG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLnJlc2V0QmFja29mZigpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAncmVzb2x2aW5nX2xvYWRfYmFsYW5jZXInO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gUmVzb2x2aW5nTG9hZEJhbGFuY2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmVzb2x2aW5nTG9hZEJhbGFuY2VyIiwibG9hZF9iYWxhbmNlcl8xIiwicmVxdWlyZSIsInNlcnZpY2VfY29uZmlnXzEiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsInJlc29sdmVyXzEiLCJwaWNrZXJfMSIsImJhY2tvZmZfdGltZW91dF8xIiwiY29uc3RhbnRzXzEiLCJtZXRhZGF0YV8xIiwibG9nZ2luZyIsImNvbnN0YW50c18yIiwidXJpX3BhcnNlcl8xIiwibG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEiLCJUUkFDRVJfTkFNRSIsInRyYWNlIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiTkFNRV9NQVRDSF9MRVZFTF9PUkRFUiIsImhhc01hdGNoaW5nTmFtZSIsInNlcnZpY2UiLCJtZXRob2QiLCJtZXRob2RDb25maWciLCJtYXRjaExldmVsIiwibmFtZSIsImZpbmRNYXRjaGluZ0NvbmZpZyIsIm1ldGhvZENvbmZpZ3MiLCJjb25maWciLCJnZXREZWZhdWx0Q29uZmlnU2VsZWN0b3IiLCJzZXJ2aWNlQ29uZmlnIiwiZGVmYXVsdENvbmZpZ1NlbGVjdG9yIiwibWV0aG9kTmFtZSIsIm1ldGFkYXRhIiwiX2EiLCJfYiIsInNwbGl0TmFtZSIsInNwbGl0IiwiZmlsdGVyIiwieCIsImxlbmd0aCIsIm1hdGNoaW5nQ29uZmlnIiwicGlja0luZm9ybWF0aW9uIiwic3RhdHVzIiwiU3RhdHVzIiwiT0siLCJkeW5hbWljRmlsdGVyRmFjdG9yaWVzIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImNoYW5uZWxPcHRpb25zIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsIm9uRmFpbGVkUmVzb2x1dGlvbiIsImxhdGVzdENoaWxkU3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJsYXRlc3RDaGlsZFBpY2tlciIsIlF1ZXVlUGlja2VyIiwiY3VycmVudFN0YXRlIiwicHJldmlvdXNTZXJ2aWNlQ29uZmlnIiwiY29udGludWVSZXNvbHZpbmciLCJkZWZhdWx0U2VydmljZUNvbmZpZyIsInZhbGlkYXRlU2VydmljZUNvbmZpZyIsIkpTT04iLCJwYXJzZSIsImxvYWRCYWxhbmNpbmdDb25maWciLCJ1cGRhdGVTdGF0ZSIsImNoaWxkTG9hZEJhbGFuY2VyIiwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIiwiY3JlYXRlU3ViY2hhbm5lbCIsImJpbmQiLCJyZXF1ZXN0UmVyZXNvbHV0aW9uIiwiYmFja29mZlRpbWVvdXQiLCJpc1J1bm5pbmciLCJnZXRFbmRUaW1lIiwidG9JU09TdHJpbmciLCJ1cGRhdGVSZXNvbHV0aW9uIiwibmV3U3RhdGUiLCJwaWNrZXIiLCJhZGRDaGFubmVsekNoaWxkIiwicmVtb3ZlQ2hhbm5lbHpDaGlsZCIsImlubmVyUmVzb2x2ZXIiLCJjcmVhdGVSZXNvbHZlciIsImFkZHJlc3NMaXN0Iiwic2VydmljZUNvbmZpZ0Vycm9yIiwiY29uZmlnU2VsZWN0b3IiLCJhdHRyaWJ1dGVzIiwic3RvcCIsInJlc2V0Iiwid29ya2luZ1NlcnZpY2VDb25maWciLCJoYW5kbGVSZXNvbHV0aW9uRmFpbHVyZSIsIndvcmtpbmdDb25maWdMaXN0IiwiZ2V0Rmlyc3RVc2FibGVDb25maWciLCJjb2RlIiwiVU5BVkFJTEFCTEUiLCJkZXRhaWxzIiwiTWV0YWRhdGEiLCJ1cGRhdGVBZGRyZXNzTGlzdCIsImZpbmFsU2VydmljZUNvbmZpZyIsIm9uRXJyb3IiLCJlcnJvciIsImJhY2tvZmZPcHRpb25zIiwiaW5pdGlhbERlbGF5IiwibWF4RGVsYXkiLCJCYWNrb2ZmVGltZW91dCIsInVucmVmIiwiQ09OTkVDVElORyIsInJ1bk9uY2UiLCJjb25uZWN0aXZpdHlTdGF0ZSIsInVyaVRvU3RyaW5nIiwiVFJBTlNJRU5UX0ZBSUxVUkUiLCJVbmF2YWlsYWJsZVBpY2tlciIsImV4aXRJZGxlIiwibGJDb25maWciLCJFcnJvciIsInJlc2V0QmFja29mZiIsImRlc3Ryb3kiLCJnZXRUeXBlTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/retrying-call.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"retrying_call\";\nclass RetryThrottler {\n    constructor(maxTokens, tokenRatio, previousRetryThrottler){\n        this.maxTokens = maxTokens;\n        this.tokenRatio = tokenRatio;\n        if (previousRetryThrottler) {\n            /* When carrying over tokens from a previous config, rescale them to the\n             * new max value */ this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);\n        } else {\n            this.tokens = maxTokens;\n        }\n    }\n    addCallSucceeded() {\n        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n    }\n    addCallFailed() {\n        this.tokens = Math.min(this.tokens - 1, 0);\n    }\n    canRetryCall() {\n        return this.tokens > this.maxTokens / 2;\n    }\n}\nexports.RetryThrottler = RetryThrottler;\nclass MessageBufferTracker {\n    constructor(totalLimit, limitPerCall){\n        this.totalLimit = totalLimit;\n        this.limitPerCall = limitPerCall;\n        this.totalAllocated = 0;\n        this.allocatedPerCall = new Map();\n    }\n    allocate(size, callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {\n            return false;\n        }\n        this.allocatedPerCall.set(callId, currentPerCall + size);\n        this.totalAllocated += size;\n        return true;\n    }\n    free(size, callId) {\n        var _a;\n        if (this.totalAllocated < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= size;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (currentPerCall < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n        }\n        this.allocatedPerCall.set(callId, currentPerCall - size);\n    }\n    freeAll(callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.totalAllocated < currentPerCall) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= currentPerCall;\n        this.allocatedPerCall.delete(callId);\n    }\n}\nexports.MessageBufferTracker = MessageBufferTracker;\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = \"grpc-previous-rpc-attempts\";\nclass RetryingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler){\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.bufferTracker = bufferTracker;\n        this.retryThrottler = retryThrottler;\n        this.listener = null;\n        this.initialMetadata = null;\n        this.underlyingCalls = [];\n        this.writeBuffer = [];\n        /**\n         * The offset of message indices in the writeBuffer. For example, if\n         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n         * is in writeBuffer[5].\n         */ this.writeBufferOffset = 0;\n        /**\n         * Tracks whether a read has been started, so that we know whether to start\n         * reads on new child calls. This only matters for the first read, because\n         * once a message comes in the child call becomes committed and there will\n         * be no new child calls.\n         */ this.readStarted = false;\n        this.transparentRetryUsed = false;\n        /**\n         * Number of attempts so far\n         */ this.attempts = 0;\n        this.hedgingTimer = null;\n        this.committedCallIndex = null;\n        this.initialRetryBackoffSec = 0;\n        this.nextRetryBackoffSec = 0;\n        if (callConfig.methodConfig.retryPolicy) {\n            this.state = \"RETRY\";\n            const retryPolicy = callConfig.methodConfig.retryPolicy;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n        } else if (callConfig.methodConfig.hedgingPolicy) {\n            this.state = \"HEDGING\";\n        } else {\n            this.state = \"TRANSPARENT_ONLY\";\n        }\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callNumber + \"] \" + text);\n    }\n    reportStatus(statusObject) {\n        this.trace(\"ended with status: code=\" + statusObject.code + ' details=\"' + statusObject.details + '\"');\n        this.bufferTracker.freeAll(this.callNumber);\n        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n        this.writeBuffer = [];\n        process.nextTick(()=>{\n            var _a;\n            // Explicitly construct status object to remove progress field\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({\n                code: statusObject.code,\n                details: statusObject.details,\n                metadata: statusObject.metadata\n            });\n        });\n    }\n    cancelWithStatus(status, details) {\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        this.reportStatus({\n            code: status,\n            details,\n            metadata: new metadata_1.Metadata()\n        });\n        for (const { call } of this.underlyingCalls){\n            call.cancelWithStatus(status, details);\n        }\n    }\n    getPeer() {\n        if (this.committedCallIndex !== null) {\n            return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n        } else {\n            return \"unknown\";\n        }\n    }\n    getBufferEntry(messageIndex) {\n        var _a;\n        return (_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {\n            entryType: \"FREED\",\n            allocated: false\n        };\n    }\n    getNextBufferIndex() {\n        return this.writeBufferOffset + this.writeBuffer.length;\n    }\n    clearSentMessages() {\n        if (this.state !== \"COMMITTED\") {\n            return;\n        }\n        const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;\n        for(let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++){\n            const bufferEntry = this.getBufferEntry(messageIndex);\n            if (bufferEntry.allocated) {\n                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\n            }\n        }\n        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\n        this.writeBufferOffset = earliestNeededMessageIndex;\n    }\n    commitCall(index) {\n        if (this.state === \"COMMITTED\") {\n            return;\n        }\n        if (this.underlyingCalls[index].state === \"COMPLETED\") {\n            return;\n        }\n        this.trace(\"Committing call [\" + this.underlyingCalls[index].call.getCallNumber() + \"] at index \" + index);\n        this.state = \"COMMITTED\";\n        this.committedCallIndex = index;\n        for(let i = 0; i < this.underlyingCalls.length; i++){\n            if (i === index) {\n                continue;\n            }\n            if (this.underlyingCalls[i].state === \"COMPLETED\") {\n                continue;\n            }\n            this.underlyingCalls[i].state = \"COMPLETED\";\n            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, \"Discarded in favor of other hedged attempt\");\n        }\n        this.clearSentMessages();\n    }\n    commitCallWithMostMessages() {\n        if (this.state === \"COMMITTED\") {\n            return;\n        }\n        let mostMessages = -1;\n        let callWithMostMessages = -1;\n        for (const [index, childCall] of this.underlyingCalls.entries()){\n            if (childCall.state === \"ACTIVE\" && childCall.nextMessageToSend > mostMessages) {\n                mostMessages = childCall.nextMessageToSend;\n                callWithMostMessages = index;\n            }\n        }\n        if (callWithMostMessages === -1) {\n            /* There are no active calls, disable retries to force the next call that\n             * is started to be committed. */ this.state = \"TRANSPARENT_ONLY\";\n        } else {\n            this.commitCall(callWithMostMessages);\n        }\n    }\n    isStatusCodeInList(list, code) {\n        return list.some((value)=>value === code || value.toString().toLowerCase() === constants_1.Status[code].toLowerCase());\n    }\n    getNextRetryBackoffMs() {\n        var _a;\n        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\n        if (!retryPolicy) {\n            return 0;\n        }\n        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n        return nextBackoffMs;\n    }\n    maybeRetryCall(pushback, callback) {\n        if (this.state !== \"RETRY\") {\n            callback(false);\n            return;\n        }\n        const retryPolicy = this.callConfig.methodConfig.retryPolicy;\n        if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\n            callback(false);\n            return;\n        }\n        let retryDelayMs;\n        if (pushback === null) {\n            retryDelayMs = this.getNextRetryBackoffMs();\n        } else if (pushback < 0) {\n            this.state = \"TRANSPARENT_ONLY\";\n            callback(false);\n            return;\n        } else {\n            retryDelayMs = pushback;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n        }\n        setTimeout(()=>{\n            var _a, _b;\n            if (this.state !== \"RETRY\") {\n                callback(false);\n                return;\n            }\n            if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\n                callback(true);\n                this.attempts += 1;\n                this.startNewAttempt();\n            }\n        }, retryDelayMs);\n    }\n    countActiveCalls() {\n        let count = 0;\n        for (const call of this.underlyingCalls){\n            if ((call === null || call === void 0 ? void 0 : call.state) === \"ACTIVE\") {\n                count += 1;\n            }\n        }\n        return count;\n    }\n    handleProcessedStatus(status, callIndex, pushback) {\n        var _a, _b, _c;\n        switch(this.state){\n            case \"COMMITTED\":\n            case \"TRANSPARENT_ONLY\":\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case \"HEDGING\":\n                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\n                    (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\n                    let delayMs;\n                    if (pushback === null) {\n                        delayMs = 0;\n                    } else if (pushback < 0) {\n                        this.state = \"TRANSPARENT_ONLY\";\n                        this.commitCall(callIndex);\n                        this.reportStatus(status);\n                        return;\n                    } else {\n                        delayMs = pushback;\n                    }\n                    setTimeout(()=>{\n                        this.maybeStartHedgingAttempt();\n                        // If after trying to start a call there are no active calls, this was the last one\n                        if (this.countActiveCalls() === 0) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    }, delayMs);\n                } else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n            case \"RETRY\":\n                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\n                    (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\n                    this.maybeRetryCall(pushback, (retried)=>{\n                        if (!retried) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    });\n                } else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n        }\n    }\n    getPushback(metadata) {\n        const mdValue = metadata.get(\"grpc-retry-pushback-ms\");\n        if (mdValue.length === 0) {\n            return null;\n        }\n        try {\n            return parseInt(mdValue[0]);\n        } catch (e) {\n            return -1;\n        }\n    }\n    handleChildStatus(status, callIndex) {\n        var _a;\n        if (this.underlyingCalls[callIndex].state === \"COMPLETED\") {\n            return;\n        }\n        this.trace(\"state=\" + this.state + \" handling status with progress \" + status.progress + \" from child [\" + this.underlyingCalls[callIndex].call.getCallNumber() + \"] in state \" + this.underlyingCalls[callIndex].state);\n        this.underlyingCalls[callIndex].state = \"COMPLETED\";\n        if (status.code === constants_1.Status.OK) {\n            (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n        }\n        if (this.state === \"COMMITTED\") {\n            this.reportStatus(status);\n            return;\n        }\n        const pushback = this.getPushback(status.metadata);\n        switch(status.progress){\n            case \"NOT_STARTED\":\n                // RPC never leaves the client, always safe to retry\n                this.startNewAttempt();\n                break;\n            case \"REFUSED\":\n                // RPC reaches the server library, but not the server application logic\n                if (this.transparentRetryUsed) {\n                    this.handleProcessedStatus(status, callIndex, pushback);\n                } else {\n                    this.transparentRetryUsed = true;\n                    this.startNewAttempt();\n                }\n                break;\n            case \"DROP\":\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case \"PROCESSED\":\n                this.handleProcessedStatus(status, callIndex, pushback);\n                break;\n        }\n    }\n    maybeStartHedgingAttempt() {\n        if (this.state !== \"HEDGING\") {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n            return;\n        }\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    maybeStartHedgingTimer() {\n        var _a, _b, _c;\n        if (this.hedgingTimer) {\n            clearTimeout(this.hedgingTimer);\n        }\n        if (this.state !== \"HEDGING\") {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n            return;\n        }\n        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : \"0s\";\n        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n        this.hedgingTimer = setTimeout(()=>{\n            this.maybeStartHedgingAttempt();\n        }, hedgingDelaySec * 1000);\n        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n    }\n    startNewAttempt() {\n        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n        this.trace(\"Created child call [\" + child.getCallNumber() + \"] for attempt \" + this.attempts);\n        const index = this.underlyingCalls.length;\n        this.underlyingCalls.push({\n            state: \"ACTIVE\",\n            call: child,\n            nextMessageToSend: 0\n        });\n        const previousAttempts = this.attempts - 1;\n        const initialMetadata = this.initialMetadata.clone();\n        if (previousAttempts > 0) {\n            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        let receivedMetadata = false;\n        child.start(initialMetadata, {\n            onReceiveMetadata: (metadata)=>{\n                this.trace(\"Received metadata from child [\" + child.getCallNumber() + \"]\");\n                this.commitCall(index);\n                receivedMetadata = true;\n                if (previousAttempts > 0) {\n                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                if (this.underlyingCalls[index].state === \"ACTIVE\") {\n                    this.listener.onReceiveMetadata(metadata);\n                }\n            },\n            onReceiveMessage: (message)=>{\n                this.trace(\"Received message from child [\" + child.getCallNumber() + \"]\");\n                this.commitCall(index);\n                if (this.underlyingCalls[index].state === \"ACTIVE\") {\n                    this.listener.onReceiveMessage(message);\n                }\n            },\n            onReceiveStatus: (status)=>{\n                this.trace(\"Received status from child [\" + child.getCallNumber() + \"]\");\n                if (!receivedMetadata && previousAttempts > 0) {\n                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                this.handleChildStatus(status, index);\n            }\n        });\n        this.sendNextChildMessage(index);\n        if (this.readStarted) {\n            child.startRead();\n        }\n    }\n    start(metadata, listener) {\n        this.trace(\"start called\");\n        this.listener = listener;\n        this.initialMetadata = metadata;\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    handleChildWriteCompleted(childIndex) {\n        var _a, _b;\n        const childCall = this.underlyingCalls[childIndex];\n        const messageIndex = childCall.nextMessageToSend;\n        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.clearSentMessages();\n        childCall.nextMessageToSend += 1;\n        this.sendNextChildMessage(childIndex);\n    }\n    sendNextChildMessage(childIndex) {\n        const childCall = this.underlyingCalls[childIndex];\n        if (childCall.state === \"COMPLETED\") {\n            return;\n        }\n        if (this.getBufferEntry(childCall.nextMessageToSend)) {\n            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n            switch(bufferEntry.entryType){\n                case \"MESSAGE\":\n                    childCall.call.sendMessageWithContext({\n                        callback: (error)=>{\n                            // Ignore error\n                            this.handleChildWriteCompleted(childIndex);\n                        }\n                    }, bufferEntry.message.message);\n                    break;\n                case \"HALF_CLOSE\":\n                    childCall.nextMessageToSend += 1;\n                    childCall.call.halfClose();\n                    break;\n                case \"FREED\":\n                    break;\n            }\n        }\n    }\n    sendMessageWithContext(context, message) {\n        var _a;\n        this.trace(\"write() called with message of length \" + message.length);\n        const writeObj = {\n            message,\n            flags: context.flags\n        };\n        const messageIndex = this.getNextBufferIndex();\n        const bufferEntry = {\n            entryType: \"MESSAGE\",\n            message: writeObj,\n            allocated: this.bufferTracker.allocate(message.length, this.callNumber)\n        };\n        this.writeBuffer.push(bufferEntry);\n        if (bufferEntry.allocated) {\n            (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            for (const [callIndex, call] of this.underlyingCalls.entries()){\n                if (call.state === \"ACTIVE\" && call.nextMessageToSend === messageIndex) {\n                    call.call.sendMessageWithContext({\n                        callback: (error)=>{\n                            // Ignore error\n                            this.handleChildWriteCompleted(callIndex);\n                        }\n                    }, message);\n                }\n            }\n        } else {\n            this.commitCallWithMostMessages();\n            // commitCallWithMostMessages can fail if we are between ping attempts\n            if (this.committedCallIndex === null) {\n                return;\n            }\n            const call = this.underlyingCalls[this.committedCallIndex];\n            bufferEntry.callback = context.callback;\n            if (call.state === \"ACTIVE\" && call.nextMessageToSend === messageIndex) {\n                call.call.sendMessageWithContext({\n                    callback: (error)=>{\n                        // Ignore error\n                        this.handleChildWriteCompleted(this.committedCallIndex);\n                    }\n                }, message);\n            }\n        }\n    }\n    startRead() {\n        this.trace(\"startRead called\");\n        this.readStarted = true;\n        for (const underlyingCall of this.underlyingCalls){\n            if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === \"ACTIVE\") {\n                underlyingCall.call.startRead();\n            }\n        }\n    }\n    halfClose() {\n        this.trace(\"halfClose called\");\n        const halfCloseIndex = this.getNextBufferIndex();\n        this.writeBuffer.push({\n            entryType: \"HALF_CLOSE\",\n            allocated: false\n        });\n        for (const call of this.underlyingCalls){\n            if ((call === null || call === void 0 ? void 0 : call.state) === \"ACTIVE\" && call.nextMessageToSend === halfCloseIndex) {\n                call.nextMessageToSend += 1;\n                call.call.halfClose();\n            }\n        }\n    }\n    setCredentials(newCredentials) {\n        throw new Error(\"Method not implemented.\");\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.host;\n    }\n}\nexports.RetryingCall = RetryingCall; //# sourceMappingURL=retrying-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmV0cnlpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSw0QkFBNEIsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUNwRixNQUFNSyxjQUFjQyxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNRyxjQUFjO0FBQ3BCLE1BQU1MO0lBQ0ZNLFlBQVlDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxzQkFBc0IsQ0FBRTtRQUN2RCxJQUFJLENBQUNGLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO1FBQ2xCLElBQUlDLHdCQUF3QjtZQUN4Qjs2QkFDaUIsR0FDakIsSUFBSSxDQUFDQyxNQUFNLEdBQ1BELHVCQUF1QkMsTUFBTSxHQUN4QkgsQ0FBQUEsWUFBWUUsdUJBQXVCRixTQUFTO1FBQ3pELE9BQ0s7WUFDRCxJQUFJLENBQUNHLE1BQU0sR0FBR0g7UUFDbEI7SUFDSjtJQUNBSSxtQkFBbUI7UUFDZixJQUFJLENBQUNELE1BQU0sR0FBR0UsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ0gsTUFBTSxHQUFHLElBQUksQ0FBQ0YsVUFBVSxFQUFFLElBQUksQ0FBQ0QsU0FBUztJQUN4RTtJQUNBTyxnQkFBZ0I7UUFDWixJQUFJLENBQUNKLE1BQU0sR0FBR0UsS0FBS0csR0FBRyxDQUFDLElBQUksQ0FBQ0wsTUFBTSxHQUFHLEdBQUc7SUFDNUM7SUFDQU0sZUFBZTtRQUNYLE9BQU8sSUFBSSxDQUFDTixNQUFNLEdBQUcsSUFBSSxDQUFDSCxTQUFTLEdBQUc7SUFDMUM7QUFDSjtBQUNBWCxzQkFB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L25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXRyeWluZy1jYWxsLmpzPzdjNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmV0cnlpbmdDYWxsID0gZXhwb3J0cy5NZXNzYWdlQnVmZmVyVHJhY2tlciA9IGV4cG9ydHMuUmV0cnlUaHJvdHRsZXIgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncmV0cnlpbmdfY2FsbCc7XG5jbGFzcyBSZXRyeVRocm90dGxlciB7XG4gICAgY29uc3RydWN0b3IobWF4VG9rZW5zLCB0b2tlblJhdGlvLCBwcmV2aW91c1JldHJ5VGhyb3R0bGVyKSB7XG4gICAgICAgIHRoaXMubWF4VG9rZW5zID0gbWF4VG9rZW5zO1xuICAgICAgICB0aGlzLnRva2VuUmF0aW8gPSB0b2tlblJhdGlvO1xuICAgICAgICBpZiAocHJldmlvdXNSZXRyeVRocm90dGxlcikge1xuICAgICAgICAgICAgLyogV2hlbiBjYXJyeWluZyBvdmVyIHRva2VucyBmcm9tIGEgcHJldmlvdXMgY29uZmlnLCByZXNjYWxlIHRoZW0gdG8gdGhlXG4gICAgICAgICAgICAgKiBuZXcgbWF4IHZhbHVlICovXG4gICAgICAgICAgICB0aGlzLnRva2VucyA9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZXRyeVRocm90dGxlci50b2tlbnMgKlxuICAgICAgICAgICAgICAgICAgICAobWF4VG9rZW5zIC8gcHJldmlvdXNSZXRyeVRocm90dGxlci5tYXhUb2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2tlbnMgPSBtYXhUb2tlbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQ2FsbFN1Y2NlZWRlZCgpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBNYXRoLm1heCh0aGlzLnRva2VucyArIHRoaXMudG9rZW5SYXRpbywgdGhpcy5tYXhUb2tlbnMpO1xuICAgIH1cbiAgICBhZGRDYWxsRmFpbGVkKCkge1xuICAgICAgICB0aGlzLnRva2VucyA9IE1hdGgubWluKHRoaXMudG9rZW5zIC0gMSwgMCk7XG4gICAgfVxuICAgIGNhblJldHJ5Q2FsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zID4gdGhpcy5tYXhUb2tlbnMgLyAyO1xuICAgIH1cbn1cbmV4cG9ydHMuUmV0cnlUaHJvdHRsZXIgPSBSZXRyeVRocm90dGxlcjtcbmNsYXNzIE1lc3NhZ2VCdWZmZXJUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3RhbExpbWl0LCBsaW1pdFBlckNhbGwpIHtcbiAgICAgICAgdGhpcy50b3RhbExpbWl0ID0gdG90YWxMaW1pdDtcbiAgICAgICAgdGhpcy5saW1pdFBlckNhbGwgPSBsaW1pdFBlckNhbGw7XG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgPSAwO1xuICAgICAgICB0aGlzLmFsbG9jYXRlZFBlckNhbGwgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFsbG9jYXRlKHNpemUsIGNhbGxJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJDYWxsID0gKF9hID0gdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmdldChjYWxsSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBpZiAodGhpcy5saW1pdFBlckNhbGwgLSBjdXJyZW50UGVyQ2FsbCA8IHNpemUgfHxcbiAgICAgICAgICAgIHRoaXMudG90YWxMaW1pdCAtIHRoaXMudG90YWxBbGxvY2F0ZWQgPCBzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLnNldChjYWxsSWQsIGN1cnJlbnRQZXJDYWxsICsgc2l6ZSk7XG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZyZWUoc2l6ZSwgY2FsbElkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMudG90YWxBbGxvY2F0ZWQgPCBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVmZmVyIGFsbG9jYXRpb24gc3RhdGU6IGNhbGwgJHtjYWxsSWR9IGZyZWVkICR7c2l6ZX0gPiB0b3RhbCBhbGxvY2F0ZWQgJHt0aGlzLnRvdGFsQWxsb2NhdGVkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgLT0gc2l6ZTtcbiAgICAgICAgY29uc3QgY3VycmVudFBlckNhbGwgPSAoX2EgPSB0aGlzLmFsbG9jYXRlZFBlckNhbGwuZ2V0KGNhbGxJZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIGlmIChjdXJyZW50UGVyQ2FsbCA8IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidWZmZXIgYWxsb2NhdGlvbiBzdGF0ZTogY2FsbCAke2NhbGxJZH0gZnJlZWQgJHtzaXplfSA+IGFsbG9jYXRlZCBmb3IgY2FsbCAke2N1cnJlbnRQZXJDYWxsfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5zZXQoY2FsbElkLCBjdXJyZW50UGVyQ2FsbCAtIHNpemUpO1xuICAgIH1cbiAgICBmcmVlQWxsKGNhbGxJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJDYWxsID0gKF9hID0gdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmdldChjYWxsSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBpZiAodGhpcy50b3RhbEFsbG9jYXRlZCA8IGN1cnJlbnRQZXJDYWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVmZmVyIGFsbG9jYXRpb24gc3RhdGU6IGNhbGwgJHtjYWxsSWR9IGFsbG9jYXRlZCAke2N1cnJlbnRQZXJDYWxsfSA+IHRvdGFsIGFsbG9jYXRlZCAke3RoaXMudG90YWxBbGxvY2F0ZWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRlZCAtPSBjdXJyZW50UGVyQ2FsbDtcbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmRlbGV0ZShjYWxsSWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzc2FnZUJ1ZmZlclRyYWNrZXIgPSBNZXNzYWdlQnVmZmVyVHJhY2tlcjtcbmNvbnN0IFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVkgPSAnZ3JwYy1wcmV2aW91cy1ycGMtYXR0ZW1wdHMnO1xuY2xhc3MgUmV0cnlpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBjYWxsQ29uZmlnLCBtZXRob2ROYW1lLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIsIGJ1ZmZlclRyYWNrZXIsIHJldHJ5VGhyb3R0bGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuY2FsbENvbmZpZyA9IGNhbGxDb25maWc7XG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWU7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IGRlYWRsaW5lO1xuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlclRyYWNrZXIgPSBidWZmZXJUcmFja2VyO1xuICAgICAgICB0aGlzLnJldHJ5VGhyb3R0bGVyID0gcmV0cnlUaHJvdHRsZXI7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRpYWxNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzID0gW107XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvZmZzZXQgb2YgbWVzc2FnZSBpbmRpY2VzIGluIHRoZSB3cml0ZUJ1ZmZlci4gRm9yIGV4YW1wbGUsIGlmXG4gICAgICAgICAqIHdyaXRlQnVmZmVyT2Zmc2V0IGlzIDEwLCBtZXNzYWdlIDEwIGlzIGluIHdyaXRlQnVmZmVyWzBdIGFuZCBtZXNzYWdlIDE1XG4gICAgICAgICAqIGlzIGluIHdyaXRlQnVmZmVyWzVdLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3Mgd2hldGhlciBhIHJlYWQgaGFzIGJlZW4gc3RhcnRlZCwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgdG8gc3RhcnRcbiAgICAgICAgICogcmVhZHMgb24gbmV3IGNoaWxkIGNhbGxzLiBUaGlzIG9ubHkgbWF0dGVycyBmb3IgdGhlIGZpcnN0IHJlYWQsIGJlY2F1c2VcbiAgICAgICAgICogb25jZSBhIG1lc3NhZ2UgY29tZXMgaW4gdGhlIGNoaWxkIGNhbGwgYmVjb21lcyBjb21taXR0ZWQgYW5kIHRoZXJlIHdpbGxcbiAgICAgICAgICogYmUgbm8gbmV3IGNoaWxkIGNhbGxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW50UmV0cnlVc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgYXR0ZW1wdHMgc28gZmFyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5oZWRnaW5nVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbW1pdHRlZENhbGxJbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdGlhbFJldHJ5QmFja29mZlNlYyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IDA7XG4gICAgICAgIGlmIChjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdSRVRSWSc7XG4gICAgICAgICAgICBjb25zdCByZXRyeVBvbGljeSA9IGNhbGxDb25maWcubWV0aG9kQ29uZmlnLnJldHJ5UG9saWN5O1xuICAgICAgICAgICAgdGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjID0gdGhpcy5pbml0aWFsUmV0cnlCYWNrb2ZmU2VjID0gTnVtYmVyKHJldHJ5UG9saWN5LmluaXRpYWxCYWNrb2ZmLnN1YnN0cmluZygwLCByZXRyeVBvbGljeS5pbml0aWFsQmFja29mZi5sZW5ndGggLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdIRURHSU5HJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnVFJBTlNQQVJFTlRfT05MWSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbE51bWJlciArICddICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgcmVwb3J0U3RhdHVzKHN0YXR1c09iamVjdCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgIHN0YXR1c09iamVjdC5jb2RlICtcbiAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xuICAgICAgICAgICAgc3RhdHVzT2JqZWN0LmRldGFpbHMgK1xuICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgIHRoaXMuYnVmZmVyVHJhY2tlci5mcmVlQWxsKHRoaXMuY2FsbE51bWJlcik7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgPSB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ICsgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGNvbnN0cnVjdCBzdGF0dXMgb2JqZWN0IHRvIHJlbW92ZSBwcm9ncmVzcyBmaWVsZFxuICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogc3RhdHVzT2JqZWN0LmNvZGUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogc3RhdHVzT2JqZWN0LmRldGFpbHMsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHN0YXR1c09iamVjdC5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnY2FuY2VsV2l0aFN0YXR1cyBjb2RlOiAnICsgc3RhdHVzICsgJyBkZXRhaWxzOiBcIicgKyBkZXRhaWxzICsgJ1wiJyk7XG4gICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHsgY29kZTogc3RhdHVzLCBkZXRhaWxzLCBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSB9KTtcbiAgICAgICAgZm9yIChjb25zdCB7IGNhbGwgfSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tbWl0dGVkQ2FsbEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmRlcmx5aW5nQ2FsbHNbdGhpcy5jb21taXR0ZWRDYWxsSW5kZXhdLmNhbGwuZ2V0UGVlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMud3JpdGVCdWZmZXJbbWVzc2FnZUluZGV4IC0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHtcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ0ZSRUVEJyxcbiAgICAgICAgICAgIGFsbG9jYXRlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROZXh0QnVmZmVySW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ICsgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIGNsZWFyU2VudE1lc3NhZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0NPTU1JVFRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW3RoaXMuY29tbWl0dGVkQ2FsbEluZGV4XS5uZXh0TWVzc2FnZVRvU2VuZDtcbiAgICAgICAgZm9yIChsZXQgbWVzc2FnZUluZGV4ID0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldDsgbWVzc2FnZUluZGV4IDwgZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXg7IG1lc3NhZ2VJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJFbnRyeSA9IHRoaXMuZ2V0QnVmZmVyRW50cnkobWVzc2FnZUluZGV4KTtcbiAgICAgICAgICAgIGlmIChidWZmZXJFbnRyeS5hbGxvY2F0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclRyYWNrZXIuZnJlZShidWZmZXJFbnRyeS5tZXNzYWdlLm1lc3NhZ2UubGVuZ3RoLCB0aGlzLmNhbGxOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSB0aGlzLndyaXRlQnVmZmVyLnNsaWNlKGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4IC0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgPSBlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleDtcbiAgICB9XG4gICAgY29tbWl0Q2FsbChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0NPTU1JVFRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbaW5kZXhdLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ0NvbW1pdHRpbmcgY2FsbCBbJyArXG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tpbmRleF0uY2FsbC5nZXRDYWxsTnVtYmVyKCkgK1xuICAgICAgICAgICAgJ10gYXQgaW5kZXggJyArXG4gICAgICAgICAgICBpbmRleCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnQ09NTUlUVEVEJztcbiAgICAgICAgdGhpcy5jb21taXR0ZWRDYWxsSW5kZXggPSBpbmRleDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnVuZGVybHlpbmdDYWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbaV0uc3RhdGUgPT09ICdDT01QTEVURUQnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tpXS5zdGF0ZSA9ICdDT01QTEVURUQnO1xuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbaV0uY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdEaXNjYXJkZWQgaW4gZmF2b3Igb2Ygb3RoZXIgaGVkZ2VkIGF0dGVtcHQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyU2VudE1lc3NhZ2VzKCk7XG4gICAgfVxuICAgIGNvbW1pdENhbGxXaXRoTW9zdE1lc3NhZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0NPTU1JVFRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9zdE1lc3NhZ2VzID0gLTE7XG4gICAgICAgIGxldCBjYWxsV2l0aE1vc3RNZXNzYWdlcyA9IC0xO1xuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgY2hpbGRDYWxsXSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZENhbGwuc3RhdGUgPT09ICdBQ1RJVkUnICYmXG4gICAgICAgICAgICAgICAgY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kID4gbW9zdE1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgbW9zdE1lc3NhZ2VzID0gY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kO1xuICAgICAgICAgICAgICAgIGNhbGxXaXRoTW9zdE1lc3NhZ2VzID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxXaXRoTW9zdE1lc3NhZ2VzID09PSAtMSkge1xuICAgICAgICAgICAgLyogVGhlcmUgYXJlIG5vIGFjdGl2ZSBjYWxscywgZGlzYWJsZSByZXRyaWVzIHRvIGZvcmNlIHRoZSBuZXh0IGNhbGwgdGhhdFxuICAgICAgICAgICAgICogaXMgc3RhcnRlZCB0byBiZSBjb21taXR0ZWQuICovXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxXaXRoTW9zdE1lc3NhZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1N0YXR1c0NvZGVJbkxpc3QobGlzdCwgY29kZSkge1xuICAgICAgICByZXR1cm4gbGlzdC5zb21lKHZhbHVlID0+IHZhbHVlID09PSBjb2RlIHx8XG4gICAgICAgICAgICB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IGNvbnN0YW50c18xLlN0YXR1c1tjb2RlXS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgZ2V0TmV4dFJldHJ5QmFja29mZk1zKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJldHJ5UG9saWN5ID0gKF9hID0gdGhpcy5jYWxsQ29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWV0aG9kQ29uZmlnLnJldHJ5UG9saWN5O1xuICAgICAgICBpZiAoIXJldHJ5UG9saWN5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0QmFja29mZk1zID0gTWF0aC5yYW5kb20oKSAqIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyAqIDEwMDA7XG4gICAgICAgIGNvbnN0IG1heEJhY2tvZmZTZWMgPSBOdW1iZXIocmV0cnlQb2xpY3kubWF4QmFja29mZi5zdWJzdHJpbmcoMCwgcmV0cnlQb2xpY3kubWF4QmFja29mZi5sZW5ndGggLSAxKSk7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IE1hdGgubWluKHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyAqIHJldHJ5UG9saWN5LmJhY2tvZmZNdWx0aXBsaWVyLCBtYXhCYWNrb2ZmU2VjKTtcbiAgICAgICAgcmV0dXJuIG5leHRCYWNrb2ZmTXM7XG4gICAgfVxuICAgIG1heWJlUmV0cnlDYWxsKHB1c2hiYWNrLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ1JFVFJZJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHJ5UG9saWN5ID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeTtcbiAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdHMgPj0gTWF0aC5taW4ocmV0cnlQb2xpY3kubWF4QXR0ZW1wdHMsIDUpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldHJ5RGVsYXlNcztcbiAgICAgICAgaWYgKHB1c2hiYWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXRyeURlbGF5TXMgPSB0aGlzLmdldE5leHRSZXRyeUJhY2tvZmZNcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1c2hiYWNrIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcbiAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHJ5RGVsYXlNcyA9IHB1c2hiYWNrO1xuICAgICAgICAgICAgdGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjID0gdGhpcy5pbml0aWFsUmV0cnlCYWNrb2ZmU2VjO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnUkVUUlknKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoX2IgPSAoX2EgPSB0aGlzLnJldHJ5VGhyb3R0bGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuUmV0cnlDYWxsKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRzICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE5ld0F0dGVtcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmV0cnlEZWxheU1zKTtcbiAgICB9XG4gICAgY291bnRBY3RpdmVDYWxscygpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzKSB7XG4gICAgICAgICAgICBpZiAoKGNhbGwgPT09IG51bGwgfHwgY2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbC5zdGF0ZSkgPT09ICdBQ1RJVkUnKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIGhhbmRsZVByb2Nlc3NlZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCwgcHVzaGJhY2spIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnQ09NTUlUVEVEJzpcbiAgICAgICAgICAgIGNhc2UgJ1RSQU5TUEFSRU5UX09OTFknOlxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdIRURHSU5HJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXR1c0NvZGVJbkxpc3QoKF9hID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5Lm5vbkZhdGFsU3RhdHVzQ29kZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCBzdGF0dXMuY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gdGhpcy5yZXRyeVRocm90dGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGF5TXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwdXNoYmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlNcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHVzaGJhY2sgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlNcyA9IHB1c2hiYWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGFmdGVyIHRyeWluZyB0byBzdGFydCBhIGNhbGwgdGhlcmUgYXJlIG5vIGFjdGl2ZSBjYWxscywgdGhpcyB3YXMgdGhlIGxhc3Qgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudEFjdGl2ZUNhbGxzKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBkZWxheU1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JFVFJZJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXR1c0NvZGVJbkxpc3QodGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeS5yZXRyeWFibGVTdGF0dXNDb2Rlcywgc3RhdHVzLmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVSZXRyeUNhbGwocHVzaGJhY2ssIHJldHJpZWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXRyaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UHVzaGJhY2sobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgbWRWYWx1ZSA9IG1ldGFkYXRhLmdldCgnZ3JwYy1yZXRyeS1wdXNoYmFjay1tcycpO1xuICAgICAgICBpZiAobWRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobWRWYWx1ZVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGlsZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1tjYWxsSW5kZXhdLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXRlPScgK1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSArXG4gICAgICAgICAgICAnIGhhbmRsaW5nIHN0YXR1cyB3aXRoIHByb2dyZXNzICcgK1xuICAgICAgICAgICAgc3RhdHVzLnByb2dyZXNzICtcbiAgICAgICAgICAgICcgZnJvbSBjaGlsZCBbJyArXG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tjYWxsSW5kZXhdLmNhbGwuZ2V0Q2FsbE51bWJlcigpICtcbiAgICAgICAgICAgICddIGluIHN0YXRlICcgK1xuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2FsbEluZGV4XS5zdGF0ZSk7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2NhbGxJbmRleF0uc3RhdGUgPSAnQ09NUExFVEVEJztcbiAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdDT01NSVRURUQnKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1c2hiYWNrID0gdGhpcy5nZXRQdXNoYmFjayhzdGF0dXMubWV0YWRhdGEpO1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cy5wcm9ncmVzcykge1xuICAgICAgICAgICAgY2FzZSAnTk9UX1NUQVJURUQnOlxuICAgICAgICAgICAgICAgIC8vIFJQQyBuZXZlciBsZWF2ZXMgdGhlIGNsaWVudCwgYWx3YXlzIHNhZmUgdG8gcmV0cnlcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUkVGVVNFRCc6XG4gICAgICAgICAgICAgICAgLy8gUlBDIHJlYWNoZXMgdGhlIHNlcnZlciBsaWJyYXJ5LCBidXQgbm90IHRoZSBzZXJ2ZXIgYXBwbGljYXRpb24gbG9naWNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVByb2Nlc3NlZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCwgcHVzaGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRFJPUCc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BST0NFU1NFRCc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQcm9jZXNzZWRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgsIHB1c2hiYWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnSEVER0lORycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlZGdpbmdQb2xpY3kgPSB0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3k7XG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzID49IE1hdGgubWluKGhlZGdpbmdQb2xpY3kubWF4QXR0ZW1wdHMsIDUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRlbXB0cyArPSAxO1xuICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xuICAgICAgICB0aGlzLm1heWJlU3RhcnRIZWRnaW5nVGltZXIoKTtcbiAgICB9XG4gICAgbWF5YmVTdGFydEhlZGdpbmdUaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICh0aGlzLmhlZGdpbmdUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVkZ2luZ1RpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0hFREdJTkcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3kpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWRnaW5nUG9saWN5ID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5O1xuICAgICAgICBpZiAodGhpcy5hdHRlbXB0cyA+PSBNYXRoLm1pbihoZWRnaW5nUG9saWN5Lm1heEF0dGVtcHRzLCA1KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlZGdpbmdEZWxheVN0cmluZyA9IChfYSA9IGhlZGdpbmdQb2xpY3kuaGVkZ2luZ0RlbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnMHMnO1xuICAgICAgICBjb25zdCBoZWRnaW5nRGVsYXlTZWMgPSBOdW1iZXIoaGVkZ2luZ0RlbGF5U3RyaW5nLnN1YnN0cmluZygwLCBoZWRnaW5nRGVsYXlTdHJpbmcubGVuZ3RoIC0gMSkpO1xuICAgICAgICB0aGlzLmhlZGdpbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKTtcbiAgICAgICAgfSwgaGVkZ2luZ0RlbGF5U2VjICogMTAwMCk7XG4gICAgICAgIChfYyA9IChfYiA9IHRoaXMuaGVkZ2luZ1RpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xuICAgIH1cbiAgICBzdGFydE5ld0F0dGVtcHQoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGFubmVsLmNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsKHRoaXMuY2FsbENvbmZpZywgdGhpcy5tZXRob2ROYW1lLCB0aGlzLmhvc3QsIHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkIGNoaWxkIGNhbGwgWycgK1xuICAgICAgICAgICAgY2hpbGQuZ2V0Q2FsbE51bWJlcigpICtcbiAgICAgICAgICAgICddIGZvciBhdHRlbXB0ICcgK1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0cyk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy51bmRlcmx5aW5nQ2FsbHMubGVuZ3RoO1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxscy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXRlOiAnQUNUSVZFJyxcbiAgICAgICAgICAgIGNhbGw6IGNoaWxkLFxuICAgICAgICAgICAgbmV4dE1lc3NhZ2VUb1NlbmQ6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcmV2aW91c0F0dGVtcHRzID0gdGhpcy5hdHRlbXB0cyAtIDE7XG4gICAgICAgIGNvbnN0IGluaXRpYWxNZXRhZGF0YSA9IHRoaXMuaW5pdGlhbE1ldGFkYXRhLmNsb25lKCk7XG4gICAgICAgIGlmIChwcmV2aW91c0F0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgaW5pdGlhbE1ldGFkYXRhLnNldChQUkVWSU9OU19SUENfQVRURU1QVFNfTUVUQURBVEFfS0VZLCBgJHtwcmV2aW91c0F0dGVtcHRzfWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWNlaXZlZE1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIGNoaWxkLnN0YXJ0KGluaXRpYWxNZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBtZXRhZGF0YSBmcm9tIGNoaWxkIFsnICsgY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0F0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5zZXQoUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSwgYCR7cHJldmlvdXNBdHRlbXB0c31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2luZGV4XS5zdGF0ZSA9PT0gJ0FDVElWRScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSBjaGlsZCBbJyArIGNoaWxkLmdldENhbGxOdW1iZXIoKSArICddJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbaW5kZXhdLnN0YXRlID09PSAnQUNUSVZFJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzdGF0dXMgZnJvbSBjaGlsZCBbJyArIGNoaWxkLmdldENhbGxOdW1iZXIoKSArICddJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWNlaXZlZE1ldGFkYXRhICYmIHByZXZpb3VzQXR0ZW1wdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5tZXRhZGF0YS5zZXQoUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSwgYCR7cHJldmlvdXNBdHRlbXB0c31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlsZFN0YXR1cyhzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbmROZXh0Q2hpbGRNZXNzYWdlKGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMucmVhZFN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0UmVhZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnRyYWNlKCdzdGFydCBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmluaXRpYWxNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLmF0dGVtcHRzICs9IDE7XG4gICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XG4gICAgICAgIHRoaXMubWF5YmVTdGFydEhlZGdpbmdUaW1lcigpO1xuICAgIH1cbiAgICBoYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkKGNoaWxkSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2hpbGRDYWxsID0gdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2hpbGRJbmRleF07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJbmRleCA9IGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZDtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5nZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpKS5jYWxsYmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB0aGlzLmNsZWFyU2VudE1lc3NhZ2VzKCk7XG4gICAgICAgIGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCArPSAxO1xuICAgICAgICB0aGlzLnNlbmROZXh0Q2hpbGRNZXNzYWdlKGNoaWxkSW5kZXgpO1xuICAgIH1cbiAgICBzZW5kTmV4dENoaWxkTWVzc2FnZShjaGlsZEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkQ2FsbCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW2NoaWxkSW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGRDYWxsLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldEJ1ZmZlckVudHJ5KGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckVudHJ5ID0gdGhpcy5nZXRCdWZmZXJFbnRyeShjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQpO1xuICAgICAgICAgICAgc3dpdGNoIChidWZmZXJFbnRyeS5lbnRyeVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdNRVNTQUdFJzpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDYWxsLmNhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRXcml0ZUNvbXBsZXRlZChjaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sIGJ1ZmZlckVudHJ5Lm1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0hBTEZfQ0xPU0UnOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDYWxsLmNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0ZSRUVEJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBiZSBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRyYWNlKCd3cml0ZSgpIGNhbGxlZCB3aXRoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHdyaXRlT2JqID0ge1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGZsYWdzOiBjb250ZXh0LmZsYWdzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtZXNzYWdlSW5kZXggPSB0aGlzLmdldE5leHRCdWZmZXJJbmRleCgpO1xuICAgICAgICBjb25zdCBidWZmZXJFbnRyeSA9IHtcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ01FU1NBR0UnLFxuICAgICAgICAgICAgbWVzc2FnZTogd3JpdGVPYmosXG4gICAgICAgICAgICBhbGxvY2F0ZWQ6IHRoaXMuYnVmZmVyVHJhY2tlci5hbGxvY2F0ZShtZXNzYWdlLmxlbmd0aCwgdGhpcy5jYWxsTnVtYmVyKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKGJ1ZmZlckVudHJ5KTtcbiAgICAgICAgaWYgKGJ1ZmZlckVudHJ5LmFsbG9jYXRlZCkge1xuICAgICAgICAgICAgKF9hID0gY29udGV4dC5jYWxsYmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY29udGV4dCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjYWxsSW5kZXgsIGNhbGxdIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsLnN0YXRlID09PSAnQUNUSVZFJyAmJlxuICAgICAgICAgICAgICAgICAgICBjYWxsLm5leHRNZXNzYWdlVG9TZW5kID09PSBtZXNzYWdlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbFdpdGhNb3N0TWVzc2FnZXMoKTtcbiAgICAgICAgICAgIC8vIGNvbW1pdENhbGxXaXRoTW9zdE1lc3NhZ2VzIGNhbiBmYWlsIGlmIHdlIGFyZSBiZXR3ZWVuIHBpbmcgYXR0ZW1wdHNcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbW1pdHRlZENhbGxJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSB0aGlzLnVuZGVybHlpbmdDYWxsc1t0aGlzLmNvbW1pdHRlZENhbGxJbmRleF07XG4gICAgICAgICAgICBidWZmZXJFbnRyeS5jYWxsYmFjayA9IGNvbnRleHQuY2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAoY2FsbC5zdGF0ZSA9PT0gJ0FDVElWRScgJiYgY2FsbC5uZXh0TWVzc2FnZVRvU2VuZCA9PT0gbWVzc2FnZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FsbC5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQodGhpcy5jb21taXR0ZWRDYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnRSZWFkIGNhbGxlZCcpO1xuICAgICAgICB0aGlzLnJlYWRTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCB1bmRlcmx5aW5nQ2FsbCBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgaWYgKCh1bmRlcmx5aW5nQ2FsbCA9PT0gbnVsbCB8fCB1bmRlcmx5aW5nQ2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5kZXJseWluZ0NhbGwuc3RhdGUpID09PSAnQUNUSVZFJykge1xuICAgICAgICAgICAgICAgIHVuZGVybHlpbmdDYWxsLmNhbGwuc3RhcnRSZWFkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdoYWxmQ2xvc2UgY2FsbGVkJyk7XG4gICAgICAgIGNvbnN0IGhhbGZDbG9zZUluZGV4ID0gdGhpcy5nZXROZXh0QnVmZmVySW5kZXgoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHtcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ0hBTEZfQ0xPU0UnLFxuICAgICAgICAgICAgYWxsb2NhdGVkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgaWYgKChjYWxsID09PSBudWxsIHx8IGNhbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGwuc3RhdGUpID09PSAnQUNUSVZFJyAmJlxuICAgICAgICAgICAgICAgIGNhbGwubmV4dE1lc3NhZ2VUb1NlbmQgPT09IGhhbGZDbG9zZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FsbC5uZXh0TWVzc2FnZVRvU2VuZCArPSAxO1xuICAgICAgICAgICAgICAgIGNhbGwuY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDcmVkZW50aWFscyhuZXdDcmVkZW50aWFscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIGdldE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kTmFtZTtcbiAgICB9XG4gICAgZ2V0SG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdDtcbiAgICB9XG59XG5leHBvcnRzLlJldHJ5aW5nQ2FsbCA9IFJldHJ5aW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5aW5nLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmV0cnlpbmdDYWxsIiwiTWVzc2FnZUJ1ZmZlclRyYWNrZXIiLCJSZXRyeVRocm90dGxlciIsImNvbnN0YW50c18xIiwicmVxdWlyZSIsIm1ldGFkYXRhXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJjb25zdHJ1Y3RvciIsIm1heFRva2VucyIsInRva2VuUmF0aW8iLCJwcmV2aW91c1JldHJ5VGhyb3R0bGVyIiwidG9rZW5zIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsIk1hdGgiLCJtYXgiLCJhZGRDYWxsRmFpbGVkIiwibWluIiwiY2FuUmV0cnlDYWxsIiwidG90YWxMaW1pdCIsImxpbWl0UGVyQ2FsbCIsInRvdGFsQWxsb2NhdGVkIiwiYWxsb2NhdGVkUGVyQ2FsbCIsIk1hcCIsImFsbG9jYXRlIiwic2l6ZSIsImNhbGxJZCIsIl9hIiwiY3VycmVudFBlckNhbGwiLCJnZXQiLCJzZXQiLCJmcmVlIiwiRXJyb3IiLCJmcmVlQWxsIiwiZGVsZXRlIiwiUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSIsImNoYW5uZWwiLCJjYWxsQ29uZmlnIiwibWV0aG9kTmFtZSIsImhvc3QiLCJjcmVkZW50aWFscyIsImRlYWRsaW5lIiwiY2FsbE51bWJlciIsImJ1ZmZlclRyYWNrZXIiLCJyZXRyeVRocm90dGxlciIsImxpc3RlbmVyIiwiaW5pdGlhbE1ldGFkYXRhIiwidW5kZXJseWluZ0NhbGxzIiwid3JpdGVCdWZmZXIiLCJ3cml0ZUJ1ZmZlck9mZnNldCIsInJlYWRTdGFydGVkIiwidHJhbnNwYXJlbnRSZXRyeVVzZWQiLCJhdHRlbXB0cyIsImhlZGdpbmdUaW1lciIsImNvbW1pdHRlZENhbGxJbmRleCIsImluaXRpYWxSZXRyeUJhY2tvZmZTZWMiLCJuZXh0UmV0cnlCYWNrb2ZmU2VjIiwibWV0aG9kQ29uZmlnIiwicmV0cnlQb2xpY3kiLCJzdGF0ZSIsIk51bWJlciIsImluaXRpYWxCYWNrb2ZmIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiaGVkZ2luZ1BvbGljeSIsImdldENhbGxOdW1iZXIiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsInJlcG9ydFN0YXR1cyIsInN0YXR1c09iamVjdCIsImNvZGUiLCJkZXRhaWxzIiwicHJvY2VzcyIsIm5leHRUaWNrIiwib25SZWNlaXZlU3RhdHVzIiwibWV0YWRhdGEiLCJjYW5jZWxXaXRoU3RhdHVzIiwic3RhdHVzIiwiTWV0YWRhdGEiLCJjYWxsIiwiZ2V0UGVlciIsImdldEJ1ZmZlckVudHJ5IiwibWVzc2FnZUluZGV4IiwiZW50cnlUeXBlIiwiYWxsb2NhdGVkIiwiZ2V0TmV4dEJ1ZmZlckluZGV4IiwiY2xlYXJTZW50TWVzc2FnZXMiLCJlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleCIsIm5leHRNZXNzYWdlVG9TZW5kIiwiYnVmZmVyRW50cnkiLCJtZXNzYWdlIiwic2xpY2UiLCJjb21taXRDYWxsIiwiaW5kZXgiLCJpIiwiU3RhdHVzIiwiQ0FOQ0VMTEVEIiwiY29tbWl0Q2FsbFdpdGhNb3N0TWVzc2FnZXMiLCJtb3N0TWVzc2FnZXMiLCJjYWxsV2l0aE1vc3RNZXNzYWdlcyIsImNoaWxkQ2FsbCIsImVudHJpZXMiLCJpc1N0YXR1c0NvZGVJbkxpc3QiLCJsaXN0Iiwic29tZSIsInRvU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJnZXROZXh0UmV0cnlCYWNrb2ZmTXMiLCJuZXh0QmFja29mZk1zIiwicmFuZG9tIiwibWF4QmFja29mZlNlYyIsIm1heEJhY2tvZmYiLCJiYWNrb2ZmTXVsdGlwbGllciIsIm1heWJlUmV0cnlDYWxsIiwicHVzaGJhY2siLCJjYWxsYmFjayIsIm1heEF0dGVtcHRzIiwicmV0cnlEZWxheU1zIiwic2V0VGltZW91dCIsIl9iIiwic3RhcnROZXdBdHRlbXB0IiwiY291bnRBY3RpdmVDYWxscyIsImNvdW50IiwiaGFuZGxlUHJvY2Vzc2VkU3RhdHVzIiwiY2FsbEluZGV4IiwiX2MiLCJub25GYXRhbFN0YXR1c0NvZGVzIiwiZGVsYXlNcyIsIm1heWJlU3RhcnRIZWRnaW5nQXR0ZW1wdCIsInJldHJ5YWJsZVN0YXR1c0NvZGVzIiwicmV0cmllZCIsImdldFB1c2hiYWNrIiwibWRWYWx1ZSIsInBhcnNlSW50IiwiZSIsImhhbmRsZUNoaWxkU3RhdHVzIiwicHJvZ3Jlc3MiLCJPSyIsIm1heWJlU3RhcnRIZWRnaW5nVGltZXIiLCJjbGVhclRpbWVvdXQiLCJoZWRnaW5nRGVsYXlTdHJpbmciLCJoZWRnaW5nRGVsYXkiLCJoZWRnaW5nRGVsYXlTZWMiLCJ1bnJlZiIsImNoaWxkIiwiY3JlYXRlTG9hZEJhbGFuY2luZ0NhbGwiLCJwdXNoIiwicHJldmlvdXNBdHRlbXB0cyIsImNsb25lIiwicmVjZWl2ZWRNZXRhZGF0YSIsInN0YXJ0Iiwib25SZWNlaXZlTWV0YWRhdGEiLCJvblJlY2VpdmVNZXNzYWdlIiwic2VuZE5leHRDaGlsZE1lc3NhZ2UiLCJzdGFydFJlYWQiLCJoYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkIiwiY2hpbGRJbmRleCIsInNlbmRNZXNzYWdlV2l0aENvbnRleHQiLCJlcnJvciIsImhhbGZDbG9zZSIsImNvbnRleHQiLCJ3cml0ZU9iaiIsImZsYWdzIiwidW5kZXJseWluZ0NhbGwiLCJoYWxmQ2xvc2VJbmRleCIsInNldENyZWRlbnRpYWxzIiwibmV3Q3JlZGVudGlhbHMiLCJnZXRNZXRob2QiLCJnZXRIb3N0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-call.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst TRACER_NAME = \"server_call\";\nconst unzip = (0, util_1.promisify)(zlib.unzip);\nconst inflate = (0, util_1.promisify)(zlib.inflate);\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = \"grpc-accept-encoding\";\nconst GRPC_ENCODING_HEADER = \"grpc-encoding\";\nconst GRPC_MESSAGE_HEADER = \"grpc-message\";\nconst GRPC_STATUS_HEADER = \"grpc-status\";\nconst GRPC_TIMEOUT_HEADER = \"grpc-timeout\";\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001\n};\nconst defaultCompressionHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: \"identity,deflate,gzip\",\n    [GRPC_ENCODING_HEADER]: \"identity\"\n};\nconst defaultResponseHeaders = {\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: \"application/grpc+proto\"\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(call, metadata, request){\n        super();\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(call, metadata, deserialize, encoding){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n    }\n    _read(size) {\n        if (!this.call.consumeUnpushedMessages(this)) {\n            return;\n        }\n        this.call.resume();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(call, metadata, serialize, request){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.request = request;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.on(\"error\", (err)=>{\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    _write(chunk, encoding, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            const response = this.call.serializeMessage(chunk);\n            if (!this.call.write(response)) {\n                this.call.once(\"drain\", callback);\n                return;\n            }\n        } catch (err) {\n            this.emit(\"error\", {\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL\n            });\n        }\n        callback();\n    }\n    _final(callback) {\n        this.call.sendStatus({\n            code: constants_1.Status.OK,\n            details: \"OK\",\n            metadata: this.trailingMetadata\n        });\n        callback(null);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(call, metadata, serialize, deserialize, encoding){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n        this.on(\"error\", (err)=>{\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n    constructor(stream, handler, options){\n        super();\n        this.stream = stream;\n        this.handler = handler;\n        this.cancelled = false;\n        this.deadlineTimer = null;\n        this.statusSent = false;\n        this.deadline = Infinity;\n        this.wantTrailers = false;\n        this.metadataSent = false;\n        this.canPush = false;\n        this.isPushPending = false;\n        this.bufferedMessages = [];\n        this.messagesToPush = [];\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.stream.once(\"error\", (err)=>{\n        /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */ });\n        this.stream.once(\"close\", ()=>{\n            var _a;\n            trace(\"Request to method \" + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + \" stream closed with rstCode \" + this.stream.rstCode);\n            if (!this.statusSent) {\n                this.cancelled = true;\n                this.emit(\"cancelled\", \"cancelled\");\n                this.emit(\"streamEnd\", false);\n                this.sendStatus({\n                    code: constants_1.Status.CANCELLED,\n                    details: \"Cancelled by client\",\n                    metadata: null\n                });\n                if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n            }\n        });\n        this.stream.on(\"drain\", ()=>{\n            this.emit(\"drain\");\n        });\n        if (\"grpc.max_send_message_length\" in options) {\n            this.maxSendMessageSize = options[\"grpc.max_send_message_length\"];\n        }\n        if (\"grpc.max_receive_message_length\" in options) {\n            this.maxReceiveMessageSize = options[\"grpc.max_receive_message_length\"];\n        }\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */ if (this.stream.destroyed || this.stream.closed) {\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    getDecompressedMessage(message, encoding) {\n        if (encoding === \"deflate\") {\n            return inflate(message.subarray(5));\n        } else if (encoding === \"gzip\") {\n            return unzip(message.subarray(5));\n        } else if (encoding === \"identity\") {\n            return message.subarray(5);\n        }\n        return Promise.reject({\n            code: constants_1.Status.UNIMPLEMENTED,\n            details: `Received message compressed with unsupported encoding \"${encoding}\"`\n        });\n    }\n    sendMetadata(customMetadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n        // TODO(cjihrig): Include compression headers.\n        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    receiveMetadata(headers) {\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            trace(\"Request to \" + this.handler.path + \" received headers \" + JSON.stringify(metadata.toJSON()));\n        }\n        // TODO(cjihrig): Receive compression metadata.\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n            if (match === null) {\n                const err = new Error(\"Invalid deadline\");\n                err.code = constants_1.Status.OUT_OF_RANGE;\n                this.sendError(err);\n                return metadata;\n            }\n            const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n            const now = new Date();\n            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n            metadata.remove(GRPC_TIMEOUT_HEADER);\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        metadata.remove(\"grpc-accept-encoding\");\n        return metadata;\n    }\n    receiveUnaryMessage(encoding) {\n        return new Promise((resolve, reject)=>{\n            const { stream } = this;\n            let receivedLength = 0;\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const call = this;\n            const body = [];\n            const limit = this.maxReceiveMessageSize;\n            this.stream.on(\"data\", onData);\n            this.stream.on(\"end\", onEnd);\n            this.stream.on(\"error\", onEnd);\n            function onData(chunk) {\n                receivedLength += chunk.byteLength;\n                if (limit !== -1 && receivedLength > limit) {\n                    stream.removeListener(\"data\", onData);\n                    stream.removeListener(\"end\", onEnd);\n                    stream.removeListener(\"error\", onEnd);\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${receivedLength} vs. ${limit})`\n                    });\n                    return;\n                }\n                body.push(chunk);\n            }\n            function onEnd(err) {\n                stream.removeListener(\"data\", onData);\n                stream.removeListener(\"end\", onEnd);\n                stream.removeListener(\"error\", onEnd);\n                if (err !== undefined) {\n                    reject({\n                        code: constants_1.Status.INTERNAL,\n                        details: err.message\n                    });\n                    return;\n                }\n                if (receivedLength === 0) {\n                    reject({\n                        code: constants_1.Status.INTERNAL,\n                        details: \"received empty unary message\"\n                    });\n                    return;\n                }\n                call.emit(\"receiveMessage\");\n                const requestBytes = Buffer.concat(body, receivedLength);\n                const compressed = requestBytes.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : \"identity\";\n                const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n                if (Buffer.isBuffer(decompressedMessage)) {\n                    resolve(call.deserializeMessageWithInternalError(decompressedMessage));\n                    return;\n                }\n                decompressedMessage.then((decompressed)=>resolve(call.deserializeMessageWithInternalError(decompressed)), (err)=>reject(err.code ? err : {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`\n                    }));\n            }\n        });\n    }\n    async deserializeMessageWithInternalError(buffer) {\n        try {\n            return this.deserializeMessage(buffer);\n        } catch (err) {\n            throw {\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL\n            };\n        }\n    }\n    serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        // TODO(cjihrig): Call compression aware serializeMessage().\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    deserializeMessage(bytes) {\n        return this.handler.deserialize(bytes);\n    }\n    async sendUnaryMessage(err, value, metadata, flags) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (metadata === undefined) {\n            metadata = null;\n        }\n        if (err) {\n            if (!Object.prototype.hasOwnProperty.call(err, \"metadata\") && metadata) {\n                err.metadata = metadata;\n            }\n            this.sendError(err);\n            return;\n        }\n        try {\n            const response = this.serializeMessage(value);\n            this.write(response);\n            this.sendStatus({\n                code: constants_1.Status.OK,\n                details: \"OK\",\n                metadata\n            });\n        } catch (err) {\n            this.sendError({\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL\n            });\n        }\n    }\n    sendStatus(statusObj) {\n        var _a, _b;\n        this.emit(\"callEnd\", statusObj.code);\n        this.emit(\"streamEnd\", statusObj.code === constants_1.Status.OK);\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace(\"Request to method \" + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + \" ended with status code: \" + constants_1.Status[statusObj.code] + \" details: \" + statusObj.details);\n        if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n        if (this.stream.headersSent) {\n            if (!this.wantTrailers) {\n                this.wantTrailers = true;\n                this.stream.once(\"wantTrailers\", ()=>{\n                    var _a;\n                    const trailersToSend = Object.assign({\n                        [GRPC_STATUS_HEADER]: statusObj.code,\n                        [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n                    }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n                    this.stream.sendTrailers(trailersToSend);\n                    this.statusSent = true;\n                });\n                this.stream.end();\n            }\n        } else {\n            // Trailers-only response\n            const trailersToSend = Object.assign(Object.assign({\n                [GRPC_STATUS_HEADER]: statusObj.code,\n                [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n            }, defaultResponseHeaders), (_b = statusObj.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());\n            this.stream.respond(trailersToSend, {\n                endStream: true\n            });\n            this.statusSent = true;\n        }\n    }\n    sendError(error) {\n        const status = {\n            code: constants_1.Status.UNKNOWN,\n            details: \"message\" in error ? error.message : \"Unknown Error\",\n            metadata: \"metadata\" in error && error.metadata !== undefined ? error.metadata : null\n        };\n        if (\"code\" in error && typeof error.code === \"number\" && Number.isInteger(error.code)) {\n            status.code = error.code;\n            if (\"details\" in error && typeof error.details === \"string\") {\n                status.details = error.details;\n            }\n        }\n        this.sendStatus(status);\n    }\n    write(chunk) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n            this.sendError({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n            });\n            return;\n        }\n        this.sendMetadata();\n        this.emit(\"sendMessage\");\n        return this.stream.write(chunk);\n    }\n    resume() {\n        this.stream.resume();\n    }\n    setupSurfaceCall(call) {\n        this.once(\"cancelled\", (reason)=>{\n            call.cancelled = true;\n            call.emit(\"cancelled\", reason);\n        });\n        this.once(\"callEnd\", (status)=>call.emit(\"callEnd\", status));\n    }\n    setupReadable(readable, encoding) {\n        const decoder = new stream_decoder_1.StreamDecoder();\n        let readsDone = false;\n        let pendingMessageProcessing = false;\n        let pushedEnd = false;\n        const maybePushEnd = async ()=>{\n            if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n                pushedEnd = true;\n                await this.pushOrBufferMessage(readable, null);\n            }\n        };\n        this.stream.on(\"data\", async (data)=>{\n            const messages = decoder.write(data);\n            pendingMessageProcessing = true;\n            this.stream.pause();\n            for (const message of messages){\n                if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {\n                    this.sendError({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`\n                    });\n                    return;\n                }\n                this.emit(\"receiveMessage\");\n                const compressed = message.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : \"identity\";\n                const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n                // Encountered an error with decompression; it'll already have been propogated back\n                // Just return early\n                if (!decompressedMessage) return;\n                await this.pushOrBufferMessage(readable, decompressedMessage);\n            }\n            pendingMessageProcessing = false;\n            this.stream.resume();\n            await maybePushEnd();\n        });\n        this.stream.once(\"end\", async ()=>{\n            readsDone = true;\n            await maybePushEnd();\n        });\n    }\n    consumeUnpushedMessages(readable) {\n        this.canPush = true;\n        while(this.messagesToPush.length > 0){\n            const nextMessage = this.messagesToPush.shift();\n            const canPush = readable.push(nextMessage);\n            if (nextMessage === null || canPush === false) {\n                this.canPush = false;\n                break;\n            }\n        }\n        return this.canPush;\n    }\n    async pushOrBufferMessage(readable, messageBytes) {\n        if (this.isPushPending) {\n            this.bufferedMessages.push(messageBytes);\n        } else {\n            await this.pushMessage(readable, messageBytes);\n        }\n    }\n    async pushMessage(readable, messageBytes) {\n        if (messageBytes === null) {\n            trace(\"Received end of stream\");\n            if (this.canPush) {\n                readable.push(null);\n            } else {\n                this.messagesToPush.push(null);\n            }\n            return;\n        }\n        trace(\"Received message of length \" + messageBytes.length);\n        this.isPushPending = true;\n        try {\n            const deserialized = await this.deserializeMessage(messageBytes);\n            if (this.canPush) {\n                if (!readable.push(deserialized)) {\n                    this.canPush = false;\n                    this.stream.pause();\n                }\n            } else {\n                this.messagesToPush.push(deserialized);\n            }\n        } catch (error) {\n            // Ignore any remaining messages when errors occur.\n            this.bufferedMessages.length = 0;\n            let code = (0, error_1.getErrorCode)(error);\n            if (code === null || code < constants_1.Status.OK || code > constants_1.Status.UNAUTHENTICATED) {\n                code = constants_1.Status.INTERNAL;\n            }\n            readable.emit(\"error\", {\n                details: (0, error_1.getErrorMessage)(error),\n                code: code\n            });\n        }\n        this.isPushPending = false;\n        if (this.bufferedMessages.length > 0) {\n            await this.pushMessage(readable, this.bufferedMessages.shift());\n        }\n    }\n    getPeer() {\n        var _a;\n        const socket = (_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket;\n        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            } else {\n                return socket.remoteAddress;\n            }\n        } else {\n            return \"unknown\";\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n    getPath() {\n        return this.handler.path;\n    }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n    const err = new Error(\"Deadline exceeded\");\n    err.code = constants_1.Status.DEADLINE_EXCEEDED;\n    call.sendError(err);\n    call.cancelled = true;\n    call.emit(\"cancelled\", \"deadline\");\n} //# sourceMappingURL=server-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw2QkFBNkIsR0FBR0EsOEJBQThCLEdBQUdBLGdDQUFnQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsMkJBQTJCLEdBQUcsS0FBSztBQUMxSyxNQUFNTyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNSSxTQUFTSixtQkFBT0EsQ0FBQyxrQkFBTTtBQUM3QixNQUFNSyxjQUFjTCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNTSxhQUFhTixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNTyxtQkFBbUJQLG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNuRCxNQUFNUSxVQUFVUixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNUyxVQUFVVCxtQkFBT0EsQ0FBQyxzRUFBUztBQUNqQyxNQUFNVSxjQUFjO0FBQ3BCLE1BQU1DLFFBQVEsQ0FBQyxHQUFHUCxPQUFPUSxTQUFTLEVBQUVULEtBQUtRLEtBQUs7QUFDOUMsTUFBTUUsVUFBVSxDQUFDLEdBQUdULE9BQU9RLFNBQVMsRUFBRVQsS0FBS1UsT0FBTztBQUNsRCxTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZQLFFBQVFNLEtBQUssQ0FBQ1QsWUFBWVcsWUFBWSxDQUFDQyxLQUFLLEVBQUVQLGFBQWFLO0FBQy9EO0FBQ0EsTUFBTUcsOEJBQThCO0FBQ3BDLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMscUJBQXFCO0FBQzNCLE1B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QUFLLElBQUksS0FBSyxJQUFJQSxPQUFPRSxhQUFhLEVBQUU7WUFDdEUsSUFBSUYsT0FBT0csVUFBVSxFQUFFO2dCQUNuQixPQUFPLENBQUMsRUFBRUgsT0FBT0UsYUFBYSxDQUFDLENBQUMsRUFBRUYsT0FBT0csVUFBVSxDQUFDLENBQUM7WUFDekQsT0FDSztnQkFDRCxPQUFPSCxPQUFPRSxhQUFhO1lBQy9CO1FBQ0osT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0lBQ0FySyxjQUFjO1FBQ1YsT0FBTyxJQUFJLENBQUMwQyxRQUFRO0lBQ3hCO0lBQ0F6QyxVQUFVO1FBQ04sT0FBTyxJQUFJLENBQUNxQyxPQUFPLENBQUNpQixJQUFJO0lBQzVCO0FBQ0o7QUFDQWhILDZCQUE2QixHQUFHRTtBQUNoQyxTQUFTb0osc0JBQXNCckcsSUFBSTtJQUMvQixNQUFNd0IsTUFBTSxJQUFJcUUsTUFBTTtJQUN0QnJFLElBQUlhLElBQUksR0FBR3pFLFlBQVkwRSxNQUFNLENBQUN5SSxpQkFBaUI7SUFDL0MvSyxLQUFLeUIsU0FBUyxDQUFDRDtJQUNmeEIsS0FBS0csU0FBUyxHQUFHO0lBQ2pCSCxLQUFLa0MsSUFBSSxDQUFDLGFBQWE7QUFDM0IsRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY2FsbC5qcz83MjNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHAyU2VydmVyQ2FsbFN0cmVhbSA9IGV4cG9ydHMuU2VydmVyRHVwbGV4U3RyZWFtSW1wbCA9IGV4cG9ydHMuU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLlNlcnZlclVuYXJ5Q2FsbEltcGwgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBzdHJlYW1fZGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vc3RyZWFtLWRlY29kZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3NlcnZlcl9jYWxsJztcbmNvbnN0IHVuemlwID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHpsaWIudW56aXApO1xuY29uc3QgaW5mbGF0ZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh6bGliLmluZmxhdGUpO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVIgPSAnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnO1xuY29uc3QgR1JQQ19FTkNPRElOR19IRUFERVIgPSAnZ3JwYy1lbmNvZGluZyc7XG5jb25zdCBHUlBDX01FU1NBR0VfSEVBREVSID0gJ2dycGMtbWVzc2FnZSc7XG5jb25zdCBHUlBDX1NUQVRVU19IRUFERVIgPSAnZ3JwYy1zdGF0dXMnO1xuY29uc3QgR1JQQ19USU1FT1VUX0hFQURFUiA9ICdncnBjLXRpbWVvdXQnO1xuY29uc3QgREVBRExJTkVfUkVHRVggPSAvKFxcZHsxLDh9KVxccyooW0hNU211bl0pLztcbmNvbnN0IGRlYWRsaW5lVW5pdHNUb01zID0ge1xuICAgIEg6IDM2MDAwMDAsXG4gICAgTTogNjAwMDAsXG4gICAgUzogMTAwMCxcbiAgICBtOiAxLFxuICAgIHU6IDAuMDAxLFxuICAgIG46IDAuMDAwMDAxLFxufTtcbmNvbnN0IGRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMgPSB7XG4gICAgLy8gVE9ETyhjamlocmlnKTogUmVtb3ZlIHRoZXNlIGVuY29kaW5nIGhlYWRlcnMgZnJvbSB0aGUgZGVmYXVsdCByZXNwb25zZVxuICAgIC8vIG9uY2UgY29tcHJlc3Npb24gaXMgaW50ZWdyYXRlZC5cbiAgICBbR1JQQ19BQ0NFUFRfRU5DT0RJTkdfSEVBREVSXTogJ2lkZW50aXR5LGRlZmxhdGUsZ3ppcCcsXG4gICAgW0dSUENfRU5DT0RJTkdfSEVBREVSXTogJ2lkZW50aXR5Jyxcbn07XG5jb25zdCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzID0ge1xuICAgIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1NUQVRVU106IGh0dHAyLmNvbnN0YW50cy5IVFRQX1NUQVRVU19PSyxcbiAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdOiAnYXBwbGljYXRpb24vZ3JwYytwcm90bycsXG59O1xuY29uc3QgZGVmYXVsdFJlc3BvbnNlT3B0aW9ucyA9IHtcbiAgICB3YWl0Rm9yVHJhaWxlcnM6IHRydWUsXG59O1xuY2xhc3MgU2VydmVyVW5hcnlDYWxsSW1wbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyVW5hcnlDYWxsSW1wbCA9IFNlcnZlclVuYXJ5Q2FsbEltcGw7XG5jbGFzcyBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5SZWFkYWJsZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIGRlc2VyaWFsaXplLCBlbmNvZGluZykge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwUmVhZGFibGUodGhpcywgZW5jb2RpbmcpO1xuICAgIH1cbiAgICBfcmVhZChzaXplKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsLmNvbnN1bWVVbnB1c2hlZE1lc3NhZ2VzKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsLnJlc3VtZSgpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQYXRoKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgPSBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGw7XG5jbGFzcyBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHNlcmlhbGl6ZSwgcmVxdWVzdCkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIHRoaXMuY2FsbC5zZXR1cFN1cmZhY2VDYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGwuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuY2FsbC5zZXJpYWxpemVNZXNzYWdlKGNodW5rKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxsLndyaXRlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5vbmNlKCdkcmFpbicsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGVyciksXG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgX2ZpbmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgIGRldGFpbHM6ICdPSycsXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy50cmFpbGluZ01ldGFkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZW5kKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsID0gU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgU2VydmVyRHVwbGV4U3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGVuY29kaW5nKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwUmVhZGFibGUodGhpcywgZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGwuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVuZChtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlckR1cGxleFN0cmVhbUltcGwgPSBTZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsO1xuU2VydmVyRHVwbGV4U3RyZWFtSW1wbC5wcm90b3R5cGUuX3JlYWQgPVxuICAgIFNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbC5wcm90b3R5cGUuX3JlYWQ7XG5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsLnByb3RvdHlwZS5fd3JpdGUgPVxuICAgIFNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbC5wcm90b3R5cGUuX3dyaXRlO1xuU2VydmVyRHVwbGV4U3RyZWFtSW1wbC5wcm90b3R5cGUuX2ZpbmFsID1cbiAgICBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwucHJvdG90eXBlLl9maW5hbDtcbi8vIEludGVybmFsIGNsYXNzIHRoYXQgd3JhcHMgdGhlIEhUVFAyIHJlcXVlc3QuXG5jbGFzcyBIdHRwMlNlcnZlckNhbGxTdHJlYW0gZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNTZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy53YW50VHJhaWxlcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YVNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1RvUHVzaCA9IFtdO1xuICAgICAgICB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID0gY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAvKiBXZSBuZWVkIGFuIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgdW5jYXVnaHQgZXJyb3IgZXZlbnQgZXhjZXB0aW9ucywgYnV0XG4gICAgICAgICAgICAgKiB0aGVyZSBpcyBub3RoaW5nIHdlIGNhbiByZWFzb25hYmx5IGRvIGhlcmUuIEFueSBlcnJvciBldmVudCBzaG91bGRcbiAgICAgICAgICAgICAqIGhhdmUgYSBjb3JyZXNwb25kaW5nIGNsb3NlIGV2ZW50LCB3aGljaCBoYW5kbGVzIGVtaXR0aW5nIHRoZSBjYW5jZWxsZWRcbiAgICAgICAgICAgICAqIGV2ZW50LiBBbmQgdGhlIHN0cmVhbSBpcyBub3cgaW4gYSBiYWQgc3RhdGUsIHNvIHdlIGNhbid0IHJlYXNvbmFibHlcbiAgICAgICAgICAgICAqIGV4cGVjdCB0byBiZSBhYmxlIHRvIHNlbmQgYW4gZXJyb3Igb3ZlciBpdC4gKi9cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdHJhY2UoJ1JlcXVlc3QgdG8gbWV0aG9kICcgK1xuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLmhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSArXG4gICAgICAgICAgICAgICAgJyBzdHJlYW0gY2xvc2VkIHdpdGggcnN0Q29kZSAnICtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5yc3RDb2RlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0dXNTZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2FuY2VsbGVkJywgJ2NhbmNlbGxlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RyZWFtRW5kJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdDYW5jZWxsZWQgYnkgY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVhZGxpbmVUaW1lcilcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbignZHJhaW4nLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gb3B0aW9uc1snZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tDYW5jZWxsZWQoKSB7XG4gICAgICAgIC8qIEluIHNvbWUgY2FzZXMgdGhlIHN0cmVhbSBjYW4gYmVjb21lIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNsb3NlIGV2ZW50XG4gICAgICAgICAqIGZpcmVzLiBUaGF0IGNyZWF0ZXMgYSByYWNlIGNvbmRpdGlvbiB0aGF0IHRoaXMgY2hlY2sgd29ya3MgYXJvdW5kICovXG4gICAgICAgIGlmICh0aGlzLnN0cmVhbS5kZXN0cm95ZWQgfHwgdGhpcy5zdHJlYW0uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsbGVkO1xuICAgIH1cbiAgICBnZXREZWNvbXByZXNzZWRNZXNzYWdlKG1lc3NhZ2UsIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2RlZmxhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbGF0ZShtZXNzYWdlLnN1YmFycmF5KDUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZyA9PT0gJ2d6aXAnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW56aXAobWVzc2FnZS5zdWJhcnJheSg1KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5jb2RpbmcgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlLnN1YmFycmF5KDUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIGNvbXByZXNzZWQgd2l0aCB1bnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7ZW5jb2Rpbmd9XCJgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKGN1c3RvbU1ldGFkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YVNlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldGFkYXRhU2VudCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGN1c3RvbSA9IGN1c3RvbU1ldGFkYXRhID8gY3VzdG9tTWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKSA6IG51bGw7XG4gICAgICAgIC8vIFRPRE8oY2ppaHJpZyk6IEluY2x1ZGUgY29tcHJlc3Npb24gaGVhZGVycy5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzKSwgZGVmYXVsdENvbXByZXNzaW9uSGVhZGVycyksIGN1c3RvbSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLnJlc3BvbmQoaGVhZGVycywgZGVmYXVsdFJlc3BvbnNlT3B0aW9ucyk7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFfMS5NZXRhZGF0YS5mcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICBpZiAobG9nZ2luZy5pc1RyYWNlckVuYWJsZWQoVFJBQ0VSX05BTUUpKSB7XG4gICAgICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXIucGF0aCArXG4gICAgICAgICAgICAgICAgJyByZWNlaXZlZCBoZWFkZXJzICcgK1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhLnRvSlNPTigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhjamlocmlnKTogUmVjZWl2ZSBjb21wcmVzc2lvbiBtZXRhZGF0YS5cbiAgICAgICAgY29uc3QgdGltZW91dEhlYWRlciA9IG1ldGFkYXRhLmdldChHUlBDX1RJTUVPVVRfSEVBREVSKTtcbiAgICAgICAgaWYgKHRpbWVvdXRIZWFkZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0aW1lb3V0SGVhZGVyWzBdLnRvU3RyaW5nKCkubWF0Y2goREVBRExJTkVfUkVHRVgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJbnZhbGlkIGRlYWRsaW5lJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuT1VUX09GX1JBTkdFO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9ICgrbWF0Y2hbMV0gKiBkZWFkbGluZVVuaXRzVG9Nc1ttYXRjaFsyXV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gbm93LnNldE1pbGxpc2Vjb25kcyhub3cuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IHNldFRpbWVvdXQoaGFuZGxlRXhwaXJlZERlYWRsaW5lLCB0aW1lb3V0LCB0aGlzKTtcbiAgICAgICAgICAgIG1ldGFkYXRhLnJlbW92ZShHUlBDX1RJTUVPVVRfSEVBREVSKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgc2V2ZXJhbCBoZWFkZXJzIHRoYXQgc2hvdWxkIG5vdCBiZSBwcm9wYWdhdGVkIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9BQ0NFUFRfRU5DT0RJTkcpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9URSk7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSk7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICByZWNlaXZlVW5hcnlNZXNzYWdlKGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHN0cmVhbSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCByZWNlaXZlZExlbmd0aCA9IDA7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbGltaXQgPSB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uKCdkYXRhJywgb25EYXRhKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlbmQnLCBvbkVuZCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5vbignZXJyb3InLCBvbkVuZCk7XG4gICAgICAgICAgICBmdW5jdGlvbiBvbkRhdGEoY2h1bmspIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZExlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gLTEgJiYgcmVjZWl2ZWRMZW5ndGggPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7cmVjZWl2ZWRMZW5ndGh9IHZzLiAke2xpbWl0fSlgLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib2R5LnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gb25FbmQoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FbmQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoeyBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsIGRldGFpbHM6IGVyci5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ3JlY2VpdmVkIGVtcHR5IHVuYXJ5IG1lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsLmVtaXQoJ3JlY2VpdmVNZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdEJ5dGVzID0gQnVmZmVyLmNvbmNhdChib2R5LCByZWNlaXZlZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IHJlcXVlc3RCeXRlcy5yZWFkVUludDgoMCkgPT09IDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyA9IGNvbXByZXNzZWQgPyBlbmNvZGluZyA6ICdpZGVudGl0eSc7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb21wcmVzc2VkTWVzc2FnZSA9IGNhbGwuZ2V0RGVjb21wcmVzc2VkTWVzc2FnZShyZXF1ZXN0Qnl0ZXMsIGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGVjb21wcmVzc2VkTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjYWxsLmRlc2VyaWFsaXplTWVzc2FnZVdpdGhJbnRlcm5hbEVycm9yKGRlY29tcHJlc3NlZE1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZWRNZXNzYWdlLnRoZW4oZGVjb21wcmVzc2VkID0+IHJlc29sdmUoY2FsbC5kZXNlcmlhbGl6ZU1lc3NhZ2VXaXRoSW50ZXJuYWxFcnJvcihkZWNvbXByZXNzZWQpKSwgKGVycikgPT4gcmVqZWN0KGVyci5jb2RlXG4gICAgICAgICAgICAgICAgICAgID8gZXJyXG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIFwiZ3JwYy1lbmNvZGluZ1wiIGhlYWRlciBcIiR7ZW5jb2Rpbmd9XCIgYnV0ICR7ZW5jb2Rpbmd9IGRlY29tcHJlc3Npb24gZmFpbGVkYCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZGVzZXJpYWxpemVNZXNzYWdlV2l0aEludGVybmFsRXJyb3IoYnVmZmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZU1lc3NhZ2UoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgZGV0YWlsczogKDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnIpLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VyaWFsaXplTWVzc2FnZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlQnVmZmVyID0gdGhpcy5oYW5kbGVyLnNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgIC8vIFRPRE8oY2ppaHJpZyk6IENhbGwgY29tcHJlc3Npb24gYXdhcmUgc2VyaWFsaXplTWVzc2FnZSgpLlxuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gbWVzc2FnZUJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZUxlbmd0aCArIDUpO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50OCgwLCAwKTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDMyQkUoYnl0ZUxlbmd0aCwgMSk7XG4gICAgICAgIG1lc3NhZ2VCdWZmZXIuY29weShvdXRwdXQsIDUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBkZXNlcmlhbGl6ZU1lc3NhZ2UoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5kZXNlcmlhbGl6ZShieXRlcyk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRVbmFyeU1lc3NhZ2UoZXJyLCB2YWx1ZSwgbWV0YWRhdGEsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgJ21ldGFkYXRhJykgJiYgbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBlcnIubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5zZXJpYWxpemVNZXNzYWdlKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGUocmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk9LLCBkZXRhaWxzOiAnT0snLCBtZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRFcnJvcih7XG4gICAgICAgICAgICAgICAgZGV0YWlsczogKDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnIpLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRTdGF0dXMoc3RhdHVzT2JqKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuZW1pdCgnY2FsbEVuZCcsIHN0YXR1c09iai5jb2RlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdzdHJlYW1FbmQnLCBzdGF0dXNPYmouY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKTtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvIG1ldGhvZCAnICtcbiAgICAgICAgICAgICgoX2EgPSB0aGlzLmhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSArXG4gICAgICAgICAgICAnIGVuZGVkIHdpdGggc3RhdHVzIGNvZGU6ICcgK1xuICAgICAgICAgICAgY29uc3RhbnRzXzEuU3RhdHVzW3N0YXR1c09iai5jb2RlXSArXG4gICAgICAgICAgICAnIGRldGFpbHM6ICcgK1xuICAgICAgICAgICAgc3RhdHVzT2JqLmRldGFpbHMpO1xuICAgICAgICBpZiAodGhpcy5kZWFkbGluZVRpbWVyKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbS5oZWFkZXJzU2VudCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLndhbnRUcmFpbGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMud2FudFRyYWlsZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCd3YW50VHJhaWxlcnMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhaWxlcnNUb1NlbmQgPSBPYmplY3QuYXNzaWduKHsgW0dSUENfU1RBVFVTX0hFQURFUl06IHN0YXR1c09iai5jb2RlLCBbR1JQQ19NRVNTQUdFX0hFQURFUl06IGVuY29kZVVSSShzdGF0dXNPYmouZGV0YWlscykgfSwgKF9hID0gc3RhdHVzT2JqLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9IdHRwMkhlYWRlcnMoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnNlbmRUcmFpbGVycyh0cmFpbGVyc1RvU2VuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzU2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0uZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmFpbGVycy1vbmx5IHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCB0cmFpbGVyc1RvU2VuZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IFtHUlBDX1NUQVRVU19IRUFERVJdOiBzdGF0dXNPYmouY29kZSwgW0dSUENfTUVTU0FHRV9IRUFERVJdOiBlbmNvZGVVUkkoc3RhdHVzT2JqLmRldGFpbHMpIH0sIGRlZmF1bHRSZXNwb25zZUhlYWRlcnMpLCAoX2IgPSBzdGF0dXNPYmoubWV0YWRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0h0dHAySGVhZGVycygpKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlc3BvbmQodHJhaWxlcnNUb1NlbmQsIHsgZW5kU3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNTZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXG4gICAgICAgICAgICBkZXRhaWxzOiAnbWVzc2FnZScgaW4gZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gRXJyb3InLFxuICAgICAgICAgICAgbWV0YWRhdGE6ICdtZXRhZGF0YScgaW4gZXJyb3IgJiYgZXJyb3IubWV0YWRhdGEgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gZXJyb3IubWV0YWRhdGFcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGlmICgnY29kZScgaW4gZXJyb3IgJiZcbiAgICAgICAgICAgIHR5cGVvZiBlcnJvci5jb2RlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihlcnJvci5jb2RlKSkge1xuICAgICAgICAgICAgc3RhdHVzLmNvZGUgPSBlcnJvci5jb2RlO1xuICAgICAgICAgICAgaWYgKCdkZXRhaWxzJyBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IuZGV0YWlscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGV0YWlscyA9IGVycm9yLmRldGFpbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHN0YXR1cyk7XG4gICAgfVxuICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgIT09IC0xICYmXG4gICAgICAgICAgICBjaHVuay5sZW5ndGggPiB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFNlbnQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7Y2h1bmsubGVuZ3RofSB2cy4gJHt0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZX0pYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZE1ldGFkYXRhKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnc2VuZE1lc3NhZ2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKGNodW5rKTtcbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gICAgc2V0dXBTdXJmYWNlQ2FsbChjYWxsKSB7XG4gICAgICAgIHRoaXMub25jZSgnY2FuY2VsbGVkJywgcmVhc29uID0+IHtcbiAgICAgICAgICAgIGNhbGwuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGwuZW1pdCgnY2FuY2VsbGVkJywgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25jZSgnY2FsbEVuZCcsIHN0YXR1cyA9PiBjYWxsLmVtaXQoJ2NhbGxFbmQnLCBzdGF0dXMpKTtcbiAgICB9XG4gICAgc2V0dXBSZWFkYWJsZShyZWFkYWJsZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBzdHJlYW1fZGVjb2Rlcl8xLlN0cmVhbURlY29kZXIoKTtcbiAgICAgICAgbGV0IHJlYWRzRG9uZSA9IGZhbHNlO1xuICAgICAgICBsZXQgcGVuZGluZ01lc3NhZ2VQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBwdXNoZWRFbmQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbWF5YmVQdXNoRW5kID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwdXNoZWRFbmQgJiYgcmVhZHNEb25lICYmICFwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBwdXNoZWRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVzaE9yQnVmZmVyTWVzc2FnZShyZWFkYWJsZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdkYXRhJywgYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gZGVjb2Rlci53cml0ZShkYXRhKTtcbiAgICAgICAgICAgIHBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxlbmd0aCA+IHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7bWVzc2FnZS5sZW5ndGh9IHZzLiAke3RoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplfSlgLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlY2VpdmVNZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IG1lc3NhZ2UucmVhZFVJbnQ4KDApID09PSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcgPSBjb21wcmVzc2VkID8gZW5jb2RpbmcgOiAnaWRlbnRpdHknO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZE1lc3NhZ2UgPSBhd2FpdCB0aGlzLmdldERlY29tcHJlc3NlZE1lc3NhZ2UobWVzc2FnZSwgY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgLy8gRW5jb3VudGVyZWQgYW4gZXJyb3Igd2l0aCBkZWNvbXByZXNzaW9uOyBpdCdsbCBhbHJlYWR5IGhhdmUgYmVlbiBwcm9wb2dhdGVkIGJhY2tcbiAgICAgICAgICAgICAgICAvLyBKdXN0IHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgIGlmICghZGVjb21wcmVzc2VkTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVzaE9yQnVmZmVyTWVzc2FnZShyZWFkYWJsZSwgZGVjb21wcmVzc2VkTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICAgICAgYXdhaXQgbWF5YmVQdXNoRW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCdlbmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZWFkc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgYXdhaXQgbWF5YmVQdXNoRW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdW1lVW5wdXNoZWRNZXNzYWdlcyhyZWFkYWJsZSkge1xuICAgICAgICB0aGlzLmNhblB1c2ggPSB0cnVlO1xuICAgICAgICB3aGlsZSAodGhpcy5tZXNzYWdlc1RvUHVzaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0TWVzc2FnZSA9IHRoaXMubWVzc2FnZXNUb1B1c2guc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhblB1c2ggPSByZWFkYWJsZS5wdXNoKG5leHRNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChuZXh0TWVzc2FnZSA9PT0gbnVsbCB8fCBjYW5QdXNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhblB1c2g7XG4gICAgfVxuICAgIGFzeW5jIHB1c2hPckJ1ZmZlck1lc3NhZ2UocmVhZGFibGUsIG1lc3NhZ2VCeXRlcykge1xuICAgICAgICBpZiAodGhpcy5pc1B1c2hQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMucHVzaChtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdXNoTWVzc2FnZShyZWFkYWJsZSwgbWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwdXNoTWVzc2FnZShyZWFkYWJsZSwgbWVzc2FnZUJ5dGVzKSB7XG4gICAgICAgIGlmIChtZXNzYWdlQnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYWNlKCdSZWNlaXZlZCBlbmQgb2Ygc3RyZWFtJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5QdXNoKSB7XG4gICAgICAgICAgICAgICAgcmVhZGFibGUucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNUb1B1c2gucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUmVjZWl2ZWQgbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2VCeXRlcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkID0gYXdhaXQgdGhpcy5kZXNlcmlhbGl6ZU1lc3NhZ2UobWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhblB1c2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWRhYmxlLnB1c2goZGVzZXJpYWxpemVkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzVG9QdXNoLnB1c2goZGVzZXJpYWxpemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgcmVtYWluaW5nIG1lc3NhZ2VzIHdoZW4gZXJyb3JzIG9jY3VyLlxuICAgICAgICAgICAgdGhpcy5idWZmZXJlZE1lc3NhZ2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBsZXQgY29kZSA9ICgwLCBlcnJvcl8xLmdldEVycm9yQ29kZSkoZXJyb3IpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IG51bGwgfHwgY29kZSA8IGNvbnN0YW50c18xLlN0YXR1cy5PSyB8fCBjb2RlID4gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVVUSEVOVElDQVRFRCkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkYWJsZS5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGVycm9yKSxcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdXNoTWVzc2FnZShyZWFkYWJsZSwgdGhpcy5idWZmZXJlZE1lc3NhZ2VzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gKF9hID0gdGhpcy5zdHJlYW0uc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvY2tldDtcbiAgICAgICAgaWYgKHNvY2tldCA9PT0gbnVsbCB8fCBzb2NrZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvY2tldC5yZW1vdGVBZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoc29ja2V0LnJlbW90ZVBvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c29ja2V0LnJlbW90ZUFkZHJlc3N9OiR7c29ja2V0LnJlbW90ZVBvcnR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlYWRsaW5lO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLnBhdGg7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwMlNlcnZlckNhbGxTdHJlYW0gPSBIdHRwMlNlcnZlckNhbGxTdHJlYW07XG5mdW5jdGlvbiBoYW5kbGVFeHBpcmVkRGVhZGxpbmUoY2FsbCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignRGVhZGxpbmUgZXhjZWVkZWQnKTtcbiAgICBlcnIuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRDtcbiAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgIGNhbGwuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBjYWxsLmVtaXQoJ2NhbmNlbGxlZCcsICdkZWFkbGluZScpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtIiwiU2VydmVyRHVwbGV4U3RyZWFtSW1wbCIsIlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCIsIlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCIsIlNlcnZlclVuYXJ5Q2FsbEltcGwiLCJldmVudHNfMSIsInJlcXVpcmUiLCJodHRwMiIsInN0cmVhbV8xIiwiemxpYiIsInV0aWxfMSIsImNvbnN0YW50c18xIiwibWV0YWRhdGFfMSIsInN0cmVhbV9kZWNvZGVyXzEiLCJsb2dnaW5nIiwiZXJyb3JfMSIsIlRSQUNFUl9OQU1FIiwidW56aXAiLCJwcm9taXNpZnkiLCJpbmZsYXRlIiwidHJhY2UiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVIiLCJHUlBDX0VOQ09ESU5HX0hFQURFUiIsIkdSUENfTUVTU0FHRV9IRUFERVIiLCJHUlBDX1NUQVRVU19IRUFERVIiLCJHUlBDX1RJTUVPVVRfSEVBREVSIiwiREVBRExJTkVfUkVHRVgiLCJkZWFkbGluZVVuaXRzVG9NcyIsIkgiLCJNIiwiUyIsIm0iLCJ1IiwibiIsImRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMiLCJkZWZhdWx0UmVzcG9uc2VIZWFkZXJzIiwiY29uc3RhbnRzIiwiSFRUUDJfSEVBREVSX1NUQVRVUyIsIkhUVFBfU1RBVFVTX09LIiwiSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSIsImRlZmF1bHRSZXNwb25zZU9wdGlvbnMiLCJ3YWl0Rm9yVHJhaWxlcnMiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsImNhbGwiLCJtZXRhZGF0YSIsInJlcXVlc3QiLCJjYW5jZWxsZWQiLCJzZXR1cFN1cmZhY2VDYWxsIiwiZ2V0UGVlciIsInNlbmRNZXRhZGF0YSIsInJlc3BvbnNlTWV0YWRhdGEiLCJnZXREZWFkbGluZSIsImdldFBhdGgiLCJSZWFkYWJsZSIsImRlc2VyaWFsaXplIiwiZW5jb2RpbmciLCJvYmplY3RNb2RlIiwic2V0dXBSZWFkYWJsZSIsIl9yZWFkIiwic2l6ZSIsImNvbnN1bWVVbnB1c2hlZE1lc3NhZ2VzIiwicmVzdW1lIiwiV3JpdGFibGUiLCJzZXJpYWxpemUiLCJ0cmFpbGluZ01ldGFkYXRhIiwiTWV0YWRhdGEiLCJvbiIsImVyciIsInNlbmRFcnJvciIsImVuZCIsIl93cml0ZSIsImNodW5rIiwiY2FsbGJhY2siLCJyZXNwb25zZSIsInNlcmlhbGl6ZU1lc3NhZ2UiLCJ3cml0ZSIsIm9uY2UiLCJlbWl0IiwiZGV0YWlscyIsImdldEVycm9yTWVzc2FnZSIsImNvZGUiLCJTdGF0dXMiLCJJTlRFUk5BTCIsIl9maW5hbCIsInNlbmRTdGF0dXMiLCJPSyIsIkR1cGxleCIsInByb3RvdHlwZSIsInN0cmVhbSIsImhhbmRsZXIiLCJvcHRpb25zIiwiZGVhZGxpbmVUaW1lciIsInN0YXR1c1NlbnQiLCJkZWFkbGluZSIsIkluZmluaXR5Iiwid2FudFRyYWlsZXJzIiwibWV0YWRhdGFTZW50IiwiY2FuUHVzaCIsImlzUHVzaFBlbmRpbmciLCJidWZmZXJlZE1lc3NhZ2VzIiwibWVzc2FnZXNUb1B1c2giLCJtYXhTZW5kTWVzc2FnZVNpemUiLCJERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIIiwibWF4UmVjZWl2ZU1lc3NhZ2VTaXplIiwiREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCIsIl9hIiwicGF0aCIsInJzdENvZGUiLCJDQU5DRUxMRUQiLCJjbGVhclRpbWVvdXQiLCJjaGVja0NhbmNlbGxlZCIsImRlc3Ryb3llZCIsImNsb3NlZCIsImdldERlY29tcHJlc3NlZE1lc3NhZ2UiLCJtZXNzYWdlIiwic3ViYXJyYXkiLCJQcm9taXNlIiwicmVqZWN0IiwiVU5JTVBMRU1FTlRFRCIsImN1c3RvbU1ldGFkYXRhIiwiY3VzdG9tIiwidG9IdHRwMkhlYWRlcnMiLCJoZWFkZXJzIiwiYXNzaWduIiwicmVzcG9uZCIsInJlY2VpdmVNZXRhZGF0YSIsImZyb21IdHRwMkhlYWRlcnMiLCJpc1RyYWNlckVuYWJsZWQiLCJKU09OIiwic3RyaW5naWZ5IiwidG9KU09OIiwidGltZW91dEhlYWRlciIsImdldCIsImxlbmd0aCIsIm1hdGNoIiwidG9TdHJpbmciLCJFcnJvciIsIk9VVF9PRl9SQU5HRSIsInRpbWVvdXQiLCJub3ciLCJEYXRlIiwic2V0TWlsbGlzZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwic2V0VGltZW91dCIsImhhbmRsZUV4cGlyZWREZWFkbGluZSIsInJlbW92ZSIsIkhUVFAyX0hFQURFUl9BQ0NFUFRfRU5DT0RJTkciLCJIVFRQMl9IRUFERVJfVEUiLCJyZWNlaXZlVW5hcnlNZXNzYWdlIiwicmVzb2x2ZSIsInJlY2VpdmVkTGVuZ3RoIiwiYm9keSIsImxpbWl0Iiwib25EYXRhIiwib25FbmQiLCJieXRlTGVuZ3RoIiwicmVtb3ZlTGlzdGVuZXIiLCJSRVNPVVJDRV9FWEhBVVNURUQiLCJwdXNoIiwidW5kZWZpbmVkIiwicmVxdWVzdEJ5dGVzIiwiQnVmZmVyIiwiY29uY2F0IiwiY29tcHJlc3NlZCIsInJlYWRVSW50OCIsImNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmciLCJkZWNvbXByZXNzZWRNZXNzYWdlIiwiaXNCdWZmZXIiLCJkZXNlcmlhbGl6ZU1lc3NhZ2VXaXRoSW50ZXJuYWxFcnJvciIsInRoZW4iLCJkZWNvbXByZXNzZWQiLCJidWZmZXIiLCJkZXNlcmlhbGl6ZU1lc3NhZ2UiLCJtZXNzYWdlQnVmZmVyIiwib3V0cHV0IiwiYWxsb2NVbnNhZmUiLCJ3cml0ZVVJbnQ4Iiwid3JpdGVVSW50MzJCRSIsImNvcHkiLCJieXRlcyIsInNlbmRVbmFyeU1lc3NhZ2UiLCJmbGFncyIsImhhc093blByb3BlcnR5Iiwic3RhdHVzT2JqIiwiX2IiLCJoZWFkZXJzU2VudCIsInRyYWlsZXJzVG9TZW5kIiwiZW5jb2RlVVJJIiwic2VuZFRyYWlsZXJzIiwiZW5kU3RyZWFtIiwiZXJyb3IiLCJzdGF0dXMiLCJVTktOT1dOIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwicmVhc29uIiwicmVhZGFibGUiLCJkZWNvZGVyIiwiU3RyZWFtRGVjb2RlciIsInJlYWRzRG9uZSIsInBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyIsInB1c2hlZEVuZCIsIm1heWJlUHVzaEVuZCIsInB1c2hPckJ1ZmZlck1lc3NhZ2UiLCJkYXRhIiwibWVzc2FnZXMiLCJwYXVzZSIsIm5leHRNZXNzYWdlIiwic2hpZnQiLCJtZXNzYWdlQnl0ZXMiLCJwdXNoTWVzc2FnZSIsImRlc2VyaWFsaXplZCIsImdldEVycm9yQ29kZSIsIlVOQVVUSEVOVElDQVRFRCIsInNvY2tldCIsInNlc3Npb24iLCJyZW1vdGVBZGRyZXNzIiwicmVtb3RlUG9ydCIsIkRFQURMSU5FX0VYQ0VFREVEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ServerCredentials = void 0;\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\nclass ServerCredentials {\n    static createInsecure() {\n        return new InsecureServerCredentials();\n    }\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\n        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\n            throw new TypeError(\"rootCerts must be null or a Buffer\");\n        }\n        if (!Array.isArray(keyCertPairs)) {\n            throw new TypeError(\"keyCertPairs must be an array\");\n        }\n        if (typeof checkClientCertificate !== \"boolean\") {\n            throw new TypeError(\"checkClientCertificate must be a boolean\");\n        }\n        const cert = [];\n        const key = [];\n        for(let i = 0; i < keyCertPairs.length; i++){\n            const pair = keyCertPairs[i];\n            if (pair === null || typeof pair !== \"object\") {\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\n            }\n            if (!Buffer.isBuffer(pair.private_key)) {\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\n            }\n            if (!Buffer.isBuffer(pair.cert_chain)) {\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\n            }\n            cert.push(pair.cert_chain);\n            key.push(pair.private_key);\n        }\n        return new SecureServerCredentials({\n            ca: rootCerts || (0, tls_helpers_1.getDefaultRootsData)() || undefined,\n            cert,\n            key,\n            requestCert: checkClientCertificate,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        });\n    }\n}\nexports.ServerCredentials = ServerCredentials;\nclass InsecureServerCredentials extends ServerCredentials {\n    _isSecure() {\n        return false;\n    }\n    _getSettings() {\n        return null;\n    }\n}\nclass SecureServerCredentials extends ServerCredentials {\n    constructor(options){\n        super();\n        this.options = options;\n    }\n    _isSecure() {\n        return true;\n    }\n    _getSettings() {\n        return this.options;\n    }\n} //# sourceMappingURL=server-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUcsS0FBSztBQUNqQyxNQUFNRyxnQkFBZ0JDLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLE1BQU1GO0lBQ0YsT0FBT0csaUJBQWlCO1FBQ3BCLE9BQU8sSUFBSUM7SUFDZjtJQUNBLE9BQU9DLFVBQVVDLFNBQVMsRUFBRUMsWUFBWSxFQUFFQyx5QkFBeUIsS0FBSyxFQUFFO1FBQ3RFLElBQUlGLGNBQWMsUUFBUSxDQUFDRyxNQUFNQSxDQUFDQyxRQUFRLENBQUNKLFlBQVk7WUFDbkQsTUFBTSxJQUFJSyxVQUFVO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNOLGVBQWU7WUFDOUIsTUFBTSxJQUFJSSxVQUFVO1FBQ3hCO1FBQ0EsSUFBSSxPQUFPSCwyQkFBMkIsV0FBVztZQUM3QyxNQUFNLElBQUlHLFVBQVU7UUFDeEI7UUFDQSxNQUFNRyxPQUFPLEVBQUU7UUFDZixNQUFNQyxNQUFNLEVBQUU7UUFDZCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVQsYUFBYVUsTUFBTSxFQUFFRCxJQUFLO1lBQzFDLE1BQU1FLE9BQU9YLFlBQVksQ0FBQ1MsRUFBRTtZQUM1QixJQUFJRSxTQUFTLFFBQVEsT0FBT0EsU0FBUyxVQUFVO2dCQUMzQyxNQUFNLElBQUlQLFVBQVUsQ0FBQyxZQUFZLEVBQUVLLEVBQUUsbUJBQW1CLENBQUM7WUFDN0Q7WUFDQSxJQUFJLENBQUNQLE1BQU1BLENBQUNDLFFBQVEsQ0FBQ1EsS0FBS0MsV0FBVyxHQUFHO2dCQUNwQyxNQUFNLElBQUlSLFVBQVUsQ0FBQyxZQUFZLEVBQUVLLEVBQUUsOEJBQThCLENBQUM7WUFDeEU7WUFDQSxJQUFJLENBQUNQLE1BQU1BLENBQUNDLFFBQVEsQ0FBQ1EsS0FBS0UsVUFBVSxHQUFHO2dCQUNuQyxNQUFNLElBQUlULFVBQVUsQ0FBQyxZQUFZLEVBQUVLLEVBQUUsNkJBQTZCLENBQUM7WUFDdkU7WUFDQUYsS0FBS08sSUFBSSxDQUFDSCxLQUFLRSxVQUFVO1lBQ3pCTCxJQUFJTSxJQUFJLENBQUNILEtBQUtDLFdBQVc7UUFDN0I7UUFDQSxPQUFPLElBQUlHLHdCQUF3QjtZQUMvQkMsSUFBSWpCLGFBQWEsQ0FBQyxHQUFHTCxjQUFjdUIsbUJBQW1CLE9BQU9DO1lBQzdEWDtZQUNBQztZQUNBVyxhQUFhbEI7WUFDYm1CLFNBQVMxQixjQUFjMkIsYUFBYTtRQUN4QztJQUNKO0FBQ0o7QUFDQTlCLHlCQUF5QixHQUFHRTtBQUM1QixNQUFNSSxrQ0FBa0NKO0lBQ3BDNkIsWUFBWTtRQUNSLE9BQU87SUFDWDtJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0FBQ0o7QUFDQSxNQUFNUixnQ0FBZ0N0QjtJQUNsQytCLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLO1FBQ0wsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FILFlBQVk7UUFDUixPQUFPO0lBQ1g7SUFDQUMsZUFBZTtRQUNYLE9BQU8sSUFBSSxDQUFDRSxPQUFPO0lBQ3ZCO0FBQ0osRUFDQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY3JlZGVudGlhbHMuanM/ZGM3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXJDcmVkZW50aWFscyA9IHZvaWQgMDtcbmNvbnN0IHRsc19oZWxwZXJzXzEgPSByZXF1aXJlKFwiLi90bHMtaGVscGVyc1wiKTtcbmNsYXNzIFNlcnZlckNyZWRlbnRpYWxzIHtcbiAgICBzdGF0aWMgY3JlYXRlSW5zZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5zZWN1cmVTZXJ2ZXJDcmVkZW50aWFscygpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlU3NsKHJvb3RDZXJ0cywga2V5Q2VydFBhaXJzLCBjaGVja0NsaWVudENlcnRpZmljYXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiAhQnVmZmVyLmlzQnVmZmVyKHJvb3RDZXJ0cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jvb3RDZXJ0cyBtdXN0IGJlIG51bGwgb3IgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5Q2VydFBhaXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2V5Q2VydFBhaXJzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlcnQgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Q2VydFBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWlyID0ga2V5Q2VydFBhaXJzW2ldO1xuICAgICAgICAgICAgaWYgKHBhaXIgPT09IG51bGwgfHwgdHlwZW9mIHBhaXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0gbXVzdCBiZSBhbiBvYmplY3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhaXIucHJpdmF0ZV9rZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0ucHJpdmF0ZV9rZXkgbXVzdCBiZSBhIEJ1ZmZlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFpci5jZXJ0X2NoYWluKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dLmNlcnRfY2hhaW4gbXVzdCBiZSBhIEJ1ZmZlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VydC5wdXNoKHBhaXIuY2VydF9jaGFpbik7XG4gICAgICAgICAgICBrZXkucHVzaChwYWlyLnByaXZhdGVfa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZVNlcnZlckNyZWRlbnRpYWxzKHtcbiAgICAgICAgICAgIGNhOiByb290Q2VydHMgfHwgKDAsIHRsc19oZWxwZXJzXzEuZ2V0RGVmYXVsdFJvb3RzRGF0YSkoKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBjZXJ0LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcmVxdWVzdENlcnQ6IGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUsXG4gICAgICAgICAgICBjaXBoZXJzOiB0bHNfaGVscGVyc18xLkNJUEhFUl9TVUlURVMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSBTZXJ2ZXJDcmVkZW50aWFscztcbmNsYXNzIEluc2VjdXJlU2VydmVyQ3JlZGVudGlhbHMgZXh0ZW5kcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9nZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMgZXh0ZW5kcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNlcnZlckNyZWRlbnRpYWxzIiwidGxzX2hlbHBlcnNfMSIsInJlcXVpcmUiLCJjcmVhdGVJbnNlY3VyZSIsIkluc2VjdXJlU2VydmVyQ3JlZGVudGlhbHMiLCJjcmVhdGVTc2wiLCJyb290Q2VydHMiLCJrZXlDZXJ0UGFpcnMiLCJjaGVja0NsaWVudENlcnRpZmljYXRlIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJUeXBlRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJjZXJ0Iiwia2V5IiwiaSIsImxlbmd0aCIsInBhaXIiLCJwcml2YXRlX2tleSIsImNlcnRfY2hhaW4iLCJwdXNoIiwiU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMiLCJjYSIsImdldERlZmF1bHRSb290c0RhdGEiLCJ1bmRlZmluZWQiLCJyZXF1ZXN0Q2VydCIsImNpcGhlcnMiLCJDSVBIRVJfU1VJVEVTIiwiX2lzU2VjdXJlIiwiX2dldFNldHRpbmdzIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Server = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst server_call_1 = __webpack_require__(/*! ./server-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js\");\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst { HTTP2_HEADER_PATH } = http2.constants;\nconst TRACER_NAME = \"server\";\nfunction noop() {}\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch(handlerType){\n        case \"unary\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"clientStream\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"serverStream\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        case \"bidi\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nclass Server {\n    constructor(options){\n        var _a, _b, _c, _d;\n        this.http2ServerList = [];\n        this.handlers = new Map();\n        this.sessions = new Map();\n        this.started = false;\n        this.shutdown = false;\n        this.serverAddressString = \"null\";\n        // Channelz Info\n        this.channelzEnabled = true;\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.options = options !== null && options !== void 0 ? options : {};\n        if (this.options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzServer)(()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Server created\");\n        }\n        this.maxConnectionAgeMs = (_a = this.options[\"grpc.max_connection_age_ms\"]) !== null && _a !== void 0 ? _a : UNLIMITED_CONNECTION_AGE_MS;\n        this.maxConnectionAgeGraceMs = (_b = this.options[\"grpc.max_connection_age_grace_ms\"]) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\n        this.keepaliveTimeMs = (_c = this.options[\"grpc.keepalive_time_ms\"]) !== null && _c !== void 0 ? _c : KEEPALIVE_MAX_TIME_MS;\n        this.keepaliveTimeoutMs = (_d = this.options[\"grpc.keepalive_timeout_ms\"]) !== null && _d !== void 0 ? _d : KEEPALIVE_TIMEOUT_MS;\n        this.trace(\"Server constructed\");\n    }\n    getChannelzInfo() {\n        return {\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            listenerChildren: this.listenerChildrenTracker.getChildLists(),\n            sessionChildren: this.sessionChildrenTracker.getChildLists()\n        };\n    }\n    getChannelzSessionInfoGetter(session) {\n        return ()=>{\n            var _a, _b, _c;\n            const sessionInfo = this.sessions.get(session);\n            const sessionSocket = session.socket;\n            const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n            const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n            let tlsInfo;\n            if (session.encrypted) {\n                const tlsSocket = sessionSocket;\n                const cipherInfo = tlsSocket.getCipher();\n                const certificate = tlsSocket.getCertificate();\n                const peerCertificate = tlsSocket.getPeerCertificate();\n                tlsInfo = {\n                    cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                    cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                    localCertificate: certificate && \"raw\" in certificate ? certificate.raw : null,\n                    remoteCertificate: peerCertificate && \"raw\" in peerCertificate ? peerCertificate.raw : null\n                };\n            } else {\n                tlsInfo = null;\n            }\n            const socketInfo = {\n                remoteAddress: remoteAddress,\n                localAddress: localAddress,\n                security: tlsInfo,\n                remoteName: null,\n                streamsStarted: sessionInfo.streamTracker.callsStarted,\n                streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n                streamsFailed: sessionInfo.streamTracker.callsFailed,\n                messagesSent: sessionInfo.messagesSent,\n                messagesReceived: sessionInfo.messagesReceived,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n                lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n                lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n                localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n                remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n            };\n            return socketInfo;\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + text);\n    }\n    addProtoService() {\n        throw new Error(\"Not implemented. Use addService() instead\");\n    }\n    addService(service, implementation) {\n        if (service === null || typeof service !== \"object\" || implementation === null || typeof implementation !== \"object\") {\n            throw new Error(\"addService() requires two objects as arguments\");\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error(\"Cannot add an empty service to a server\");\n        }\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = \"bidi\";\n                } else {\n                    methodType = \"clientStream\";\n                }\n            } else {\n                if (attrs.responseStream) {\n                    methodType = \"serverStream\";\n                } else {\n                    methodType = \"unary\";\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === \"string\") {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            } else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    removeService(service) {\n        if (service === null || typeof service !== \"object\") {\n            throw new Error(\"removeService() requires object as argument\");\n        }\n        const serviceKeys = Object.keys(service);\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            this.unregister(attrs.path);\n        });\n    }\n    bind(port, creds) {\n        throw new Error(\"Not implemented. Use bindAsync() instead\");\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error(\"server is already started\");\n        }\n        if (this.shutdown) {\n            throw new Error(\"bindAsync called after shutdown\");\n        }\n        if (typeof port !== \"string\") {\n            throw new TypeError(\"port must be a string\");\n        }\n        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n            throw new TypeError(\"creds must be a ServerCredentials object\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new TypeError(\"callback must be a function\");\n        }\n        const initialPortUri = (0, uri_parser_1.parseUri)(port);\n        if (initialPortUri === null) {\n            throw new Error(`Could not parse port \"${port}\"`);\n        }\n        const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\n        if (portUri === null) {\n            throw new Error(`Could not get a default scheme for port \"${port}\"`);\n        }\n        const serverOptions = {\n            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n        };\n        if (\"grpc-node.max_session_memory\" in this.options) {\n            serverOptions.maxSessionMemory = this.options[\"grpc-node.max_session_memory\"];\n        } else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */ serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        if (\"grpc.max_concurrent_streams\" in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options[\"grpc.max_concurrent_streams\"]\n            };\n        }\n        const deferredCallback = (error, port)=>{\n            process.nextTick(()=>callback(error, port));\n        };\n        const setupServer = ()=>{\n            let http2Server;\n            if (creds._isSecure()) {\n                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n                secureServerOptions.enableTrace = this.options[\"grpc-node.tls_enable_trace\"] === 1;\n                http2Server = http2.createSecureServer(secureServerOptions);\n                http2Server.on(\"secureConnection\", (socket)=>{\n                    /* These errors need to be handled by the user of Http2SecureServer,\n                     * according to https://github.com/nodejs/node/issues/35824 */ socket.on(\"error\", (e)=>{\n                        this.trace(\"An incoming TLS connection closed with error: \" + e.message);\n                    });\n                });\n            } else {\n                http2Server = http2.createServer(serverOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server);\n            return http2Server;\n        };\n        const bindSpecificPort = (addressList, portNum, previousCount)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: portNum,\n                    count: previousCount\n                });\n            }\n            return Promise.all(addressList.map((address)=>{\n                this.trace(\"Attempting to bind \" + (0, subchannel_address_1.subchannelAddressToString)(address));\n                let addr;\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n                    addr = {\n                        host: address.host,\n                        port: portNum\n                    };\n                } else {\n                    addr = address;\n                }\n                const http2Server = setupServer();\n                return new Promise((resolve, reject)=>{\n                    const onError = (err)=>{\n                        this.trace(\"Failed to bind \" + (0, subchannel_address_1.subchannelAddressToString)(address) + \" with error \" + err.message);\n                        resolve(err);\n                    };\n                    http2Server.once(\"error\", onError);\n                    http2Server.listen(addr, ()=>{\n                        if (this.shutdown) {\n                            http2Server.close();\n                            resolve(new Error(\"bindAsync failed because server is shutdown\"));\n                            return;\n                        }\n                        const boundAddress = http2Server.address();\n                        let boundSubchannelAddress;\n                        if (typeof boundAddress === \"string\") {\n                            boundSubchannelAddress = {\n                                path: boundAddress\n                            };\n                        } else {\n                            boundSubchannelAddress = {\n                                host: boundAddress.address,\n                                port: boundAddress.port\n                            };\n                        }\n                        const channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), ()=>{\n                            return {\n                                localAddress: boundSubchannelAddress,\n                                remoteAddress: null,\n                                security: null,\n                                remoteName: null,\n                                streamsStarted: 0,\n                                streamsSucceeded: 0,\n                                streamsFailed: 0,\n                                messagesSent: 0,\n                                messagesReceived: 0,\n                                keepAlivesSent: 0,\n                                lastLocalStreamCreatedTimestamp: null,\n                                lastRemoteStreamCreatedTimestamp: null,\n                                lastMessageSentTimestamp: null,\n                                lastMessageReceivedTimestamp: null,\n                                localFlowControlWindow: null,\n                                remoteFlowControlWindow: null\n                            };\n                        }, this.channelzEnabled);\n                        if (this.channelzEnabled) {\n                            this.listenerChildrenTracker.refChild(channelzRef);\n                        }\n                        this.http2ServerList.push({\n                            server: http2Server,\n                            channelzRef: channelzRef\n                        });\n                        this.trace(\"Successfully bound \" + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                        resolve(\"port\" in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n                        http2Server.removeListener(\"error\", onError);\n                    });\n                });\n            })).then((results)=>{\n                let count = 0;\n                for (const result of results){\n                    if (typeof result === \"number\") {\n                        count += 1;\n                        if (result !== portNum) {\n                            throw new Error(\"Invalid state: multiple port numbers added from single address\");\n                        }\n                    }\n                }\n                return {\n                    port: portNum,\n                    count: count + previousCount\n                };\n            });\n        };\n        const bindWildcardPort = (addressList)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: 0,\n                    count: 0\n                });\n            }\n            const address = addressList[0];\n            const http2Server = setupServer();\n            return new Promise((resolve, reject)=>{\n                const onError = (err)=>{\n                    this.trace(\"Failed to bind \" + (0, subchannel_address_1.subchannelAddressToString)(address) + \" with error \" + err.message);\n                    resolve(bindWildcardPort(addressList.slice(1)));\n                };\n                http2Server.once(\"error\", onError);\n                http2Server.listen(address, ()=>{\n                    if (this.shutdown) {\n                        http2Server.close();\n                        resolve({\n                            port: 0,\n                            count: 0\n                        });\n                        return;\n                    }\n                    const boundAddress = http2Server.address();\n                    const boundSubchannelAddress = {\n                        host: boundAddress.address,\n                        port: boundAddress.port\n                    };\n                    const channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), ()=>{\n                        return {\n                            localAddress: boundSubchannelAddress,\n                            remoteAddress: null,\n                            security: null,\n                            remoteName: null,\n                            streamsStarted: 0,\n                            streamsSucceeded: 0,\n                            streamsFailed: 0,\n                            messagesSent: 0,\n                            messagesReceived: 0,\n                            keepAlivesSent: 0,\n                            lastLocalStreamCreatedTimestamp: null,\n                            lastRemoteStreamCreatedTimestamp: null,\n                            lastMessageSentTimestamp: null,\n                            lastMessageReceivedTimestamp: null,\n                            localFlowControlWindow: null,\n                            remoteFlowControlWindow: null\n                        };\n                    }, this.channelzEnabled);\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.refChild(channelzRef);\n                    }\n                    this.http2ServerList.push({\n                        server: http2Server,\n                        channelzRef: channelzRef\n                    });\n                    this.trace(\"Successfully bound \" + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                    resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n                    http2Server.removeListener(\"error\", onError);\n                });\n            });\n        };\n        const resolverListener = {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError)=>{\n                // We only want one resolution result. Discard all future results\n                resolverListener.onSuccessfulResolution = ()=>{};\n                if (this.shutdown) {\n                    deferredCallback(new Error(`bindAsync failed because server is shutdown`), 0);\n                }\n                if (addressList.length === 0) {\n                    deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n                    return;\n                }\n                let bindResultPromise;\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0])) {\n                    if (addressList[0].port === 0) {\n                        bindResultPromise = bindWildcardPort(addressList);\n                    } else {\n                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n                    }\n                } else {\n                    // Use an arbitrary non-zero port for non-TCP addresses\n                    bindResultPromise = bindSpecificPort(addressList, 1, 0);\n                }\n                bindResultPromise.then((bindResult)=>{\n                    if (bindResult.count === 0) {\n                        const errorString = `No address added out of total ${addressList.length} resolved`;\n                        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                        deferredCallback(new Error(errorString), 0);\n                    } else {\n                        if (bindResult.count < addressList.length) {\n                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                        }\n                        deferredCallback(null, bindResult.port);\n                    }\n                }, (error)=>{\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                    deferredCallback(new Error(errorString), 0);\n                });\n            },\n            onError: (error)=>{\n                deferredCallback(new Error(error.details), 0);\n            }\n        };\n        const resolver = (0, resolver_1.createResolver)(portUri, resolverListener, this.options);\n        resolver.updateResolution();\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        (0, channelz_1.unregisterChannelzRef)(ref);\n                    }\n                });\n            }\n        }\n        this.started = false;\n        this.shutdown = true;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach((channelzInfo, session)=>{\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n        if (this.channelzEnabled) {\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        }\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n            path: name\n        });\n        return true;\n    }\n    unregister(name) {\n        return this.handlers.delete(name);\n    }\n    start() {\n        if (this.http2ServerList.length === 0 || this.http2ServerList.every(({ server: http2Server })=>http2Server.listening !== true)) {\n            throw new Error(\"server must be bound in order to start\");\n        }\n        if (this.started === true) {\n            throw new Error(\"server is already started\");\n        }\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Starting\");\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        const wrappedCallback = (error)=>{\n            if (this.channelzEnabled) {\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            }\n            callback(error);\n        };\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                wrappedCallback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        this.shutdown = true;\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                pendingChecks++;\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        (0, channelz_1.unregisterChannelzRef)(ref);\n                    }\n                    maybeCallback();\n                });\n            }\n        }\n        this.sessions.forEach((channelzInfo, session)=>{\n            if (!session.closed) {\n                pendingChecks += 1;\n                session.close(maybeCallback);\n            }\n        });\n        if (pendingChecks === 0) {\n            wrappedCallback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error(\"Not yet implemented\");\n    }\n    /**\n     * Get the channelz reference object for this server. The returned value is\n     * garbage if channelz is disabled for this server.\n     * @returns\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    _verifyContentType(stream, headers) {\n        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n        if (typeof contentType !== \"string\" || !contentType.startsWith(\"application/grpc\")) {\n            stream.respond({\n                [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n            }, {\n                endStream: true\n            });\n            return false;\n        }\n        return true;\n    }\n    _retrieveHandler(path) {\n        this.trace(\"Received call to method \" + path + \" at address \" + this.serverAddressString);\n        const handler = this.handlers.get(path);\n        if (handler === undefined) {\n            this.trace(\"No handler registered for method \" + path + \". Sending UNIMPLEMENTED status.\");\n            return null;\n        }\n        return handler;\n    }\n    _respondWithError(err, stream, channelzSessionInfo = null) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n        if (err.code === undefined) {\n            err.code = constants_1.Status.INTERNAL;\n        }\n        if (this.channelzEnabled) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        }\n        call.sendError(err);\n    }\n    _channelzHandler(stream, headers) {\n        const channelzSessionInfo = this.sessions.get(stream.session);\n        this.callTracker.addCallStarted();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n        if (!this._verifyContentType(stream, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            return;\n        }\n        const path = headers[HTTP2_HEADER_PATH];\n        const handler = this._retrieveHandler(path);\n        if (!handler) {\n            this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        call.once(\"callEnd\", (code)=>{\n            if (code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            } else {\n                this.callTracker.addCallFailed();\n            }\n        });\n        if (channelzSessionInfo) {\n            call.once(\"streamEnd\", (success)=>{\n                if (success) {\n                    channelzSessionInfo.streamTracker.addCallSucceeded();\n                } else {\n                    channelzSessionInfo.streamTracker.addCallFailed();\n                }\n            });\n            call.on(\"sendMessage\", ()=>{\n                channelzSessionInfo.messagesSent += 1;\n                channelzSessionInfo.lastMessageSentTimestamp = new Date();\n            });\n            call.on(\"receiveMessage\", ()=>{\n                channelzSessionInfo.messagesReceived += 1;\n                channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n            });\n        }\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _streamHandler(stream, headers) {\n        if (this._verifyContentType(stream, headers) !== true) {\n            return;\n        }\n        const path = headers[HTTP2_HEADER_PATH];\n        const handler = this._retrieveHandler(path);\n        if (!handler) {\n            this._respondWithError(getUnimplementedStatusResponse(path), stream, null);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _runHandlerForCall(call, handler, headers) {\n        var _a;\n        const metadata = call.receiveMetadata(headers);\n        const encoding = (_a = metadata.get(\"grpc-encoding\")[0]) !== null && _a !== void 0 ? _a : \"identity\";\n        metadata.remove(\"grpc-encoding\");\n        const { type } = handler;\n        if (type === \"unary\") {\n            handleUnary(call, handler, metadata, encoding);\n        } else if (type === \"clientStream\") {\n            handleClientStreaming(call, handler, metadata, encoding);\n        } else if (type === \"serverStream\") {\n            handleServerStreaming(call, handler, metadata, encoding);\n        } else if (type === \"bidi\") {\n            handleBidiStreaming(call, handler, metadata, encoding);\n        } else {\n            return false;\n        }\n        return true;\n    }\n    _setupHandlers(http2Server) {\n        if (http2Server === null) {\n            return;\n        }\n        const serverAddress = http2Server.address();\n        let serverAddressString = \"null\";\n        if (serverAddress) {\n            if (typeof serverAddress === \"string\") {\n                serverAddressString = serverAddress;\n            } else {\n                serverAddressString = serverAddress.address + \":\" + serverAddress.port;\n            }\n        }\n        this.serverAddressString = serverAddressString;\n        const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n        http2Server.on(\"stream\", handler.bind(this));\n        http2Server.on(\"session\", (session)=>{\n            var _a, _b, _c, _d, _e;\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            const channelzRef = (0, channelz_1.registerChannelzSocket)((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : \"unknown\", this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n            const channelzSessionInfo = {\n                ref: channelzRef,\n                streamTracker: new channelz_1.ChannelzCallTracker(),\n                messagesSent: 0,\n                messagesReceived: 0,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null\n            };\n            this.sessions.set(session, channelzSessionInfo);\n            const clientAddress = session.socket.remoteAddress;\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Connection established by client \" + clientAddress);\n                this.sessionChildrenTracker.refChild(channelzRef);\n            }\n            let connectionAgeTimer = null;\n            let connectionAgeGraceTimer = null;\n            let sessionClosedByServer = false;\n            if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                // Apply a random jitter within a +/-10% range\n                const jitterMagnitude = this.maxConnectionAgeMs / 10;\n                const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n                connectionAgeTimer = (_c = (_b = setTimeout(()=>{\n                    var _a, _b;\n                    sessionClosedByServer = true;\n                    if (this.channelzEnabled) {\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by max connection age from \" + clientAddress);\n                    }\n                    try {\n                        session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), Buffer.from(\"max_age\"));\n                    } catch (e) {\n                        // The goaway can't be sent because the session is already closed\n                        session.destroy();\n                        return;\n                    }\n                    session.close();\n                    /* Allow a grace period after sending the GOAWAY before forcibly\n                     * closing the connection. */ if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                        connectionAgeGraceTimer = (_b = (_a = setTimeout(()=>{\n                            session.destroy();\n                        }, this.maxConnectionAgeGraceMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    }\n                }, this.maxConnectionAgeMs + jitter)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n            }\n            const keeapliveTimeTimer = (_e = (_d = setInterval(()=>{\n                var _a, _b;\n                const timeoutTImer = (_b = (_a = setTimeout(()=>{\n                    sessionClosedByServer = true;\n                    if (this.channelzEnabled) {\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by keepalive timeout from \" + clientAddress);\n                    }\n                    session.close();\n                }, this.keepaliveTimeoutMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n                try {\n                    session.ping((err, duration, payload)=>{\n                        clearTimeout(timeoutTImer);\n                    });\n                } catch (e) {\n                    // The ping can't be sent because the session is already closed\n                    session.destroy();\n                }\n            }, this.keepaliveTimeMs)).unref) === null || _e === void 0 ? void 0 : _e.call(_d);\n            session.on(\"close\", ()=>{\n                if (this.channelzEnabled) {\n                    if (!sessionClosedByServer) {\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by client \" + clientAddress);\n                    }\n                    this.sessionChildrenTracker.unrefChild(channelzRef);\n                    (0, channelz_1.unregisterChannelzRef)(channelzRef);\n                }\n                if (connectionAgeTimer) {\n                    clearTimeout(connectionAgeTimer);\n                }\n                if (connectionAgeGraceTimer) {\n                    clearTimeout(connectionAgeGraceTimer);\n                }\n                if (keeapliveTimeTimer) {\n                    clearTimeout(keeapliveTimeTimer);\n                }\n                this.sessions.delete(session);\n            });\n        });\n    }\n}\nexports.Server = Server;\nasync function handleUnary(call, handler, metadata, encoding) {\n    try {\n        const request = await call.receiveUnaryMessage(encoding);\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n        handler.func(emitter, (err, value, trailer, flags)=>{\n            call.sendUnaryMessage(err, value, trailer, flags);\n        });\n    } catch (err) {\n        call.sendError(err);\n    }\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on(\"error\", respond);\n    handler.func(stream, respond);\n}\nasync function handleServerStreaming(call, handler, metadata, encoding) {\n    try {\n        const request = await call.receiveUnaryMessage(encoding);\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n        handler.func(stream);\n    } catch (err) {\n        call.sendError(err);\n    }\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n} //# sourceMappingURL=server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLmpzIiwibWFwcGluZ3MiOiI7O0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLE1BQU1HLFFBQVFDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQzdCLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLGdCQUFnQkYsbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0MsTUFBTUcsdUJBQXVCSCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUksYUFBYUosbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTU0sdUJBQXVCTixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVEsYUFBYVIsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTVMsOEJBQThCLENBQUUsTUFBSyxFQUFDO0FBQzVDLE1BQU1DLHdCQUF3QixDQUFFLE1BQUssRUFBQztBQUN0QyxNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTSxFQUFFQyxpQkFBaUIsRUFBRSxHQUFHYixNQUFNYyxTQUFTO0FBQzdDLE1BQU1DLGNBQWM7QUFDcEIsU0FBU0MsUUFBUztBQUNsQixTQUFTQywrQkFBK0JDLFVBQVU7SUFDOUMsT0FBTztRQUNIQyxNQUFNakIsWUFBWWtCLE1BQU0sQ0FBQ0MsYUFBYTtRQUN0Q0MsU0FBUyxDQUFDLHlDQUF5QyxFQUFFSixXQUFXLENBQUM7SUFDckU7QUFDSjtBQUNBLFNBQVNLLGtCQUFrQkMsV0FBVyxFQUFFTixVQUFVO0lBQzlDLE1BQU1PLDhCQUE4QlIsK0JBQStCQztJQUNuRSxPQUFRTTtRQUNKLEtBQUs7WUFDRCxPQUFPLENB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O0lBQzFELE1BQU16QixTQUFTLElBQUlwUCxjQUFjbVQsc0JBQXNCLENBQUM1UixNQUFNb1AsVUFBVXpDLFFBQVFDLFNBQVMsRUFBRUQsUUFBUUUsV0FBVyxFQUFFeUM7SUFDaEgsSUFBSXRQLEtBQUtvUixTQUFTLEVBQUU7UUFDaEI7SUFDSjtJQUNBekUsUUFBUU0sSUFBSSxDQUFDWTtBQUNqQixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZlci5qcz9hODgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBzZXJ2ZXJfY2FsbF8xID0gcmVxdWlyZShcIi4vc2VydmVyLWNhbGxcIik7XG5jb25zdCBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TID0gfigxIDw8IDMxKTtcbmNvbnN0IEtFRVBBTElWRV9NQVhfVElNRV9NUyA9IH4oMSA8PCAzMSk7XG5jb25zdCBLRUVQQUxJVkVfVElNRU9VVF9NUyA9IDIwMDAwO1xuY29uc3QgeyBIVFRQMl9IRUFERVJfUEFUSCB9ID0gaHR0cDIuY29uc3RhbnRzO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc2VydmVyJztcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmZ1bmN0aW9uIGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsXG4gICAgICAgIGRldGFpbHM6IGBUaGUgc2VydmVyIGRvZXMgbm90IGltcGxlbWVudCB0aGUgbWV0aG9kICR7bWV0aG9kTmFtZX1gLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0SGFuZGxlcihoYW5kbGVyVHlwZSwgbWV0aG9kTmFtZSkge1xuICAgIGNvbnN0IHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSA9IGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShtZXRob2ROYW1lKTtcbiAgICBzd2l0Y2ggKGhhbmRsZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3VuYXJ5JzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UsIG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnY2xpZW50U3RyZWFtJzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UsIG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnc2VydmVyU3RyZWFtJzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGwuZW1pdCgnZXJyb3InLCB1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYmlkaSc6XG4gICAgICAgICAgICByZXR1cm4gKGNhbGwpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsLmVtaXQoJ2Vycm9yJywgdW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaGFuZGxlclR5cGUgJHtoYW5kbGVyVHlwZX1gKTtcbiAgICB9XG59XG5jbGFzcyBTZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLmh0dHAyU2VydmVyTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNlc3Npb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaHV0ZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlcnZlckFkZHJlc3NTdHJpbmcgPSAnbnVsbCc7XG4gICAgICAgIC8vIENoYW5uZWx6IEluZm9cbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlKCk7XG4gICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNlcnZlcikoKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTZXJ2ZXIgY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zID1cbiAgICAgICAgICAgIChfYSA9IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfbXMnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TO1xuICAgICAgICB0aGlzLm1heENvbm5lY3Rpb25BZ2VHcmFjZU1zID1cbiAgICAgICAgICAgIChfYiA9IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfZ3JhY2VfbXMnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA9XG4gICAgICAgICAgICAoX2MgPSB0aGlzLm9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogS0VFUEFMSVZFX01BWF9USU1FX01TO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9XG4gICAgICAgICAgICAoX2QgPSB0aGlzLm9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogS0VFUEFMSVZFX1RJTUVPVVRfTVM7XG4gICAgICAgIHRoaXMudHJhY2UoJ1NlcnZlciBjb25zdHJ1Y3RlZCcpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFjZTogdGhpcy5jaGFubmVselRyYWNlLFxuICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXG4gICAgICAgICAgICBsaXN0ZW5lckNoaWxkcmVuOiB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKSxcbiAgICAgICAgICAgIHNlc3Npb25DaGlsZHJlbjogdGhpcy5zZXNzaW9uQ2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpTZXNzaW9uSW5mb0dldHRlcihzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0gdGhpcy5zZXNzaW9ucy5nZXQoc2Vzc2lvbik7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uU29ja2V0ID0gc2Vzc2lvbi5zb2NrZXQ7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVBZGRyZXNzID0gc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzXG4gICAgICAgICAgICAgICAgPyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcykoc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzLCBzZXNzaW9uU29ja2V0LnJlbW90ZVBvcnQpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxBZGRyZXNzID0gc2Vzc2lvblNvY2tldC5sb2NhbEFkZHJlc3NcbiAgICAgICAgICAgICAgICA/ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKShzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzcywgc2Vzc2lvblNvY2tldC5sb2NhbFBvcnQpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgbGV0IHRsc0luZm87XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bHNTb2NrZXQgPSBzZXNzaW9uU29ja2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpcGhlckluZm8gPSB0bHNTb2NrZXQuZ2V0Q2lwaGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0Q2VydGlmaWNhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZWVyQ2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICAgICAgdGxzSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWU6IChfYSA9IGNpcGhlckluZm8uc3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZU90aGVyTmFtZTogY2lwaGVySW5mby5zdGFuZGFyZE5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjaXBoZXJJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQ2VydGlmaWNhdGU6IGNlcnRpZmljYXRlICYmICdyYXcnIGluIGNlcnRpZmljYXRlID8gY2VydGlmaWNhdGUucmF3IDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlQ2VydGlmaWNhdGU6IHBlZXJDZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBwZWVyQ2VydGlmaWNhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGVlckNlcnRpZmljYXRlLnJhd1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bHNJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvY2tldEluZm8gPSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogcmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzZWN1cml0eTogdGxzSW5mbyxcbiAgICAgICAgICAgICAgICByZW1vdGVOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IHNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNTZW50OiBzZXNzaW9uSW5mby5tZXNzYWdlc1NlbnQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogc2Vzc2lvbkluZm8ubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogMCxcbiAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IHNlc3Npb25JbmZvLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IChfYiA9IHNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiAoX2MgPSBzZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHNvY2tldEluZm87XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArIHRleHQpO1xuICAgIH1cbiAgICBhZGRQcm90b1NlcnZpY2UoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLiBVc2UgYWRkU2VydmljZSgpIGluc3RlYWQnKTtcbiAgICB9XG4gICAgYWRkU2VydmljZShzZXJ2aWNlLCBpbXBsZW1lbnRhdGlvbikge1xuICAgICAgICBpZiAoc2VydmljZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIHNlcnZpY2UgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIGltcGxlbWVudGF0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRTZXJ2aWNlKCkgcmVxdWlyZXMgdHdvIG9iamVjdHMgYXMgYXJndW1lbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VydmljZUtleXMgPSBPYmplY3Qua2V5cyhzZXJ2aWNlKTtcbiAgICAgICAgaWYgKHNlcnZpY2VLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGFuIGVtcHR5IHNlcnZpY2UgdG8gYSBzZXJ2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJ2aWNlS2V5cy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBzZXJ2aWNlW25hbWVdO1xuICAgICAgICAgICAgbGV0IG1ldGhvZFR5cGU7XG4gICAgICAgICAgICBpZiAoYXR0cnMucmVxdWVzdFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ2JpZGknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdjbGllbnRTdHJlYW0nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3NlcnZlclN0cmVhbSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3VuYXJ5JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW1wbEZuID0gaW1wbGVtZW50YXRpb25bbmFtZV07XG4gICAgICAgICAgICBsZXQgaW1wbDtcbiAgICAgICAgICAgIGlmIChpbXBsRm4gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYXR0cnMub3JpZ2luYWxOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGltcGxGbiA9IGltcGxlbWVudGF0aW9uW2F0dHJzLm9yaWdpbmFsTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1wbEZuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbXBsID0gaW1wbEZuLmJpbmQoaW1wbGVtZW50YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1wbCA9IGdldERlZmF1bHRIYW5kbGVyKG1ldGhvZFR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHRoaXMucmVnaXN0ZXIoYXR0cnMucGF0aCwgaW1wbCwgYXR0cnMucmVzcG9uc2VTZXJpYWxpemUsIGF0dHJzLnJlcXVlc3REZXNlcmlhbGl6ZSwgbWV0aG9kVHlwZSk7XG4gICAgICAgICAgICBpZiAoc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ldGhvZCBoYW5kbGVyIGZvciAke2F0dHJzLnBhdGh9IGFscmVhZHkgcHJvdmlkZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgICAgICAgaWYgKHNlcnZpY2UgPT09IG51bGwgfHwgdHlwZW9mIHNlcnZpY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZVNlcnZpY2UoKSByZXF1aXJlcyBvYmplY3QgYXMgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2aWNlS2V5cyA9IE9iamVjdC5rZXlzKHNlcnZpY2UpO1xuICAgICAgICBzZXJ2aWNlS2V5cy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBzZXJ2aWNlW25hbWVdO1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKGF0dHJzLnBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmluZChwb3J0LCBjcmVkcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4gVXNlIGJpbmRBc3luYygpIGluc3RlYWQnKTtcbiAgICB9XG4gICAgYmluZEFzeW5jKHBvcnQsIGNyZWRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcnZlciBpcyBhbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaHV0ZG93bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQXN5bmMgY2FsbGVkIGFmdGVyIHNodXRkb3duJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwb3J0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncG9ydCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNyZWRzID09PSBudWxsIHx8ICEoY3JlZHMgaW5zdGFuY2VvZiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5TZXJ2ZXJDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NyZWRzIG11c3QgYmUgYSBTZXJ2ZXJDcmVkZW50aWFscyBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0aWFsUG9ydFVyaSA9ICgwLCB1cmlfcGFyc2VyXzEucGFyc2VVcmkpKHBvcnQpO1xuICAgICAgICBpZiAoaW5pdGlhbFBvcnRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHBvcnQgXCIke3BvcnR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3J0VXJpID0gKDAsIHJlc29sdmVyXzEubWFwVXJpRGVmYXVsdFNjaGVtZSkoaW5pdGlhbFBvcnRVcmkpO1xuICAgICAgICBpZiAocG9ydFVyaSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0IGEgZGVmYXVsdCBzY2hlbWUgZm9yIHBvcnQgXCIke3BvcnR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgbWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHNlcnZlck9wdGlvbnMubWF4U2Vzc2lvbk1lbW9yeSA9XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zWydncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5J107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBCeSBkZWZhdWx0LCBzZXQgYSB2ZXJ5IGxhcmdlIG1heCBzZXNzaW9uIG1lbW9yeSBsaW1pdCwgdG8gZWZmZWN0aXZlbHlcbiAgICAgICAgICAgICAqIGRpc2FibGUgZW5mb3JjZW1lbnQgb2YgdGhlIGxpbWl0LiBTb21lIHRlc3RpbmcgaW5kaWNhdGVzIHRoYXQgTm9kZSdzXG4gICAgICAgICAgICAgKiBiZWhhdmlvciBkZWdyYWRlcyBiYWRseSB3aGVuIHRoaXMgbGltaXQgaXMgcmVhY2hlZCwgc28gd2Ugc29sdmUgdGhhdFxuICAgICAgICAgICAgICogYnkgZGlzYWJsaW5nIHRoZSBjaGVjayBlbnRpcmVseS4gKi9cbiAgICAgICAgICAgIHNlcnZlck9wdGlvbnMubWF4U2Vzc2lvbk1lbW9yeSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHNlcnZlck9wdGlvbnMuc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgbWF4Q29uY3VycmVudFN0cmVhbXM6IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmVycmVkQ2FsbGJhY2sgPSAoZXJyb3IsIHBvcnQpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gY2FsbGJhY2soZXJyb3IsIHBvcnQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0dXBTZXJ2ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgaHR0cDJTZXJ2ZXI7XG4gICAgICAgICAgICBpZiAoY3JlZHMuX2lzU2VjdXJlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN1cmVTZXJ2ZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbihzZXJ2ZXJPcHRpb25zLCBjcmVkcy5fZ2V0U2V0dGluZ3MoKSk7XG4gICAgICAgICAgICAgICAgc2VjdXJlU2VydmVyT3B0aW9ucy5lbmFibGVUcmFjZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1snZ3JwYy1ub2RlLnRsc19lbmFibGVfdHJhY2UnXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlciA9IGh0dHAyLmNyZWF0ZVNlY3VyZVNlcnZlcihzZWN1cmVTZXJ2ZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbignc2VjdXJlQ29ubmVjdGlvbicsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogVGhlc2UgZXJyb3JzIG5lZWQgdG8gYmUgaGFuZGxlZCBieSB0aGUgdXNlciBvZiBIdHRwMlNlY3VyZVNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgICogYWNjb3JkaW5nIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzU4MjQgKi9cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdBbiBpbmNvbWluZyBUTFMgY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBlcnJvcjogJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIgPSBodHRwMi5jcmVhdGVTZXJ2ZXIoc2VydmVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodHRwMlNlcnZlci5zZXRUaW1lb3V0KDAsIG5vb3ApO1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBIYW5kbGVycyhodHRwMlNlcnZlcik7XG4gICAgICAgICAgICByZXR1cm4gaHR0cDJTZXJ2ZXI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJpbmRTcGVjaWZpY1BvcnQgPSAoYWRkcmVzc0xpc3QsIHBvcnROdW0sIHByZXZpb3VzQ291bnQpID0+IHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgcG9ydDogcG9ydE51bSwgY291bnQ6IHByZXZpb3VzQ291bnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0F0dGVtcHRpbmcgdG8gYmluZCAnICsgKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkcjtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBhZGRyZXNzLmhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBwb3J0TnVtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkciA9IGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGh0dHAyU2VydmVyID0gc2V0dXBTZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIGJpbmQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5saXN0ZW4oYWRkciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2h1dGRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEVycm9yKCdiaW5kQXN5bmMgZmFpbGVkIGJlY2F1c2Ugc2VydmVyIGlzIHNodXRkb3duJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kQWRkcmVzcyA9IGh0dHAyU2VydmVyLmFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBib3VuZFN1YmNoYW5uZWxBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBib3VuZEFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRTdWJjaGFubmVsQWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYm91bmRBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZFN1YmNoYW5uZWxBZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBib3VuZEFkZHJlc3MuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogYm91bmRBZGRyZXNzLnBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCkoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBib3VuZFN1YmNoYW5uZWxBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVBZGRyZXNzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN1cml0eTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N0YXJ0ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdWNjZWVkZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlcjogaHR0cDJTZXJ2ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpSZWY6IGNoYW5uZWx6UmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdTdWNjZXNzZnVsbHkgYm91bmQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ3BvcnQnIGluIGJvdW5kU3ViY2hhbm5lbEFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MucG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcG9ydE51bSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gcG9ydE51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogbXVsdGlwbGUgcG9ydCBudW1iZXJzIGFkZGVkIGZyb20gc2luZ2xlIGFkZHJlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwb3J0OiBwb3J0TnVtLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnQgKyBwcmV2aW91c0NvdW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYmluZFdpbGRjYXJkUG9ydCA9IChhZGRyZXNzTGlzdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFkZHJlc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBwb3J0OiAwLCBjb3VudDogMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhZGRyZXNzTGlzdFswXTtcbiAgICAgICAgICAgIGNvbnN0IGh0dHAyU2VydmVyID0gc2V0dXBTZXJ2ZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIGJpbmQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYWRkcmVzcykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJpbmRXaWxkY2FyZFBvcnQoYWRkcmVzc0xpc3Quc2xpY2UoMSkpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLm9uY2UoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIubGlzdGVuKGFkZHJlc3MsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2h1dGRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgcG9ydDogMCwgY291bnQ6IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRBZGRyZXNzID0gaHR0cDJTZXJ2ZXIuYWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZFN1YmNoYW5uZWxBZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogYm91bmRBZGRyZXNzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBib3VuZEFkZHJlc3MucG9ydCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U29ja2V0KSgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYm91bmRTdWJjaGFubmVsQWRkcmVzcyksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBib3VuZFN1YmNoYW5uZWxBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdXJpdHk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3RhcnRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNTZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZsb3dDb250cm9sV2luZG93OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyOiBodHRwMlNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6UmVmOiBjaGFubmVselJlZixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1N1Y2Nlc3NmdWxseSBib3VuZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShib3VuZFN1YmNoYW5uZWxBZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYmluZFNwZWNpZmljUG9ydChhZGRyZXNzTGlzdC5zbGljZSgxKSwgYm91bmRBZGRyZXNzLnBvcnQsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXJMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb246IChhZGRyZXNzTGlzdCwgc2VydmljZUNvbmZpZywgc2VydmljZUNvbmZpZ0Vycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IG9uZSByZXNvbHV0aW9uIHJlc3VsdC4gRGlzY2FyZCBhbGwgZnV0dXJlIHJlc3VsdHNcbiAgICAgICAgICAgICAgICByZXNvbHZlckxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24gPSAoKSA9PiB7IH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2h1dGRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDYWxsYmFjayhuZXcgRXJyb3IoYGJpbmRBc3luYyBmYWlsZWQgYmVjYXVzZSBzZXJ2ZXIgaXMgc2h1dGRvd25gKSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDYWxsYmFjayhuZXcgRXJyb3IoYE5vIGFkZHJlc3NlcyByZXNvbHZlZCBmb3IgcG9ydCAke3BvcnR9YCksIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiaW5kUmVzdWx0UHJvbWlzZTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKGFkZHJlc3NMaXN0WzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzc0xpc3RbMF0ucG9ydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UgPSBiaW5kV2lsZGNhcmRQb3J0KGFkZHJlc3NMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRSZXN1bHRQcm9taXNlID0gYmluZFNwZWNpZmljUG9ydChhZGRyZXNzTGlzdCwgYWRkcmVzc0xpc3RbMF0ucG9ydCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhbiBhcmJpdHJhcnkgbm9uLXplcm8gcG9ydCBmb3Igbm9uLVRDUCBhZGRyZXNzZXNcbiAgICAgICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UgPSBiaW5kU3BlY2lmaWNQb3J0KGFkZHJlc3NMaXN0LCAxLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UudGhlbihiaW5kUmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmRSZXN1bHQuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yU3RyaW5nID0gYE5vIGFkZHJlc3MgYWRkZWQgb3V0IG9mIHRvdGFsICR7YWRkcmVzc0xpc3QubGVuZ3RofSByZXNvbHZlZGA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGVycm9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobmV3IEVycm9yKGVycm9yU3RyaW5nKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluZFJlc3VsdC5jb3VudCA8IGFkZHJlc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPLCBgV0FSTklORyBPbmx5ICR7YmluZFJlc3VsdC5jb3VudH0gYWRkcmVzc2VzIGFkZGVkIG91dCBvZiB0b3RhbCAke2FkZHJlc3NMaXN0Lmxlbmd0aH0gcmVzb2x2ZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobnVsbCwgYmluZFJlc3VsdC5wb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JTdHJpbmcgPSBgTm8gYWRkcmVzcyBhZGRlZCBvdXQgb2YgdG90YWwgJHthZGRyZXNzTGlzdC5sZW5ndGh9IHJlc29sdmVkYDtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBlcnJvclN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobmV3IEVycm9yKGVycm9yU3RyaW5nKSwgMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25FcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobmV3IEVycm9yKGVycm9yLmRldGFpbHMpLCAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gKDAsIHJlc29sdmVyXzEuY3JlYXRlUmVzb2x2ZXIpKHBvcnRVcmksIHJlc29sdmVyTGlzdGVuZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHJlc29sdmVyLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICB9XG4gICAgZm9yY2VTaHV0ZG93bigpIHtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIHNlcnZlciBpZiBpdCBpcyBzdGlsbCBydW5uaW5nLlxuICAgICAgICBmb3IgKGNvbnN0IHsgc2VydmVyOiBodHRwMlNlcnZlciwgY2hhbm5lbHpSZWY6IHJlZiB9IG9mIHRoaXNcbiAgICAgICAgICAgIC5odHRwMlNlcnZlckxpc3QpIHtcbiAgICAgICAgICAgIGlmIChodHRwMlNlcnZlci5saXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaHV0ZG93biA9IHRydWU7XG4gICAgICAgIC8vIEFsd2F5cyBkZXN0cm95IGFueSBhdmFpbGFibGUgc2Vzc2lvbnMuIEl0J3MgcG9zc2libGUgdGhhdCBvbmUgb3IgbW9yZVxuICAgICAgICAvLyB0cnlTaHV0ZG93bigpIGNhbGxzIGFyZSBpbiBwcm9ncmVzcy4gRG9uJ3Qgd2FpdCBvbiB0aGVtIHRvIGZpbmlzaC5cbiAgICAgICAgdGhpcy5zZXNzaW9ucy5mb3JFYWNoKChjaGFubmVsekluZm8sIHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgIC8vIENhc3QgTkdIVFRQMl9DQU5DRUwgdG8gYW55IGJlY2F1c2UgVHlwZVNjcmlwdCBkb2Vzbid0IHNlZW0gdG9cbiAgICAgICAgICAgIC8vIHJlY29nbml6ZSBkZXN0cm95KGNvZGUpIGFzIGEgdmFsaWQgc2lnbmF0dXJlLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveShodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXNzaW9ucy5jbGVhcigpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXIobmFtZSwgaGFuZGxlciwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgdHlwZSkge1xuICAgICAgICBpZiAodGhpcy5oYW5kbGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZXJzLnNldChuYW1lLCB7XG4gICAgICAgICAgICBmdW5jOiBoYW5kbGVyLFxuICAgICAgICAgICAgc2VyaWFsaXplLFxuICAgICAgICAgICAgZGVzZXJpYWxpemUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGF0aDogbmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaHR0cDJTZXJ2ZXJMaXN0Lmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgdGhpcy5odHRwMlNlcnZlckxpc3QuZXZlcnkoKHsgc2VydmVyOiBodHRwMlNlcnZlciB9KSA9PiBodHRwMlNlcnZlci5saXN0ZW5pbmcgIT09IHRydWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcnZlciBtdXN0IGJlIGJvdW5kIGluIG9yZGVyIHRvIHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXJ2ZXIgaXMgYWxyZWFkeSBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU3RhcnRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0cnlTaHV0ZG93bihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwZW5kaW5nQ2hlY2tzID0gMDtcbiAgICAgICAgZnVuY3Rpb24gbWF5YmVDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHBlbmRpbmdDaGVja3MtLTtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nQ2hlY2tzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvc2UgdGhlIHNlcnZlciBpZiBuZWNlc3NhcnkuXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNodXRkb3duID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCB7IHNlcnZlcjogaHR0cDJTZXJ2ZXIsIGNoYW5uZWx6UmVmOiByZWYgfSBvZiB0aGlzXG4gICAgICAgICAgICAuaHR0cDJTZXJ2ZXJMaXN0KSB7XG4gICAgICAgICAgICBpZiAoaHR0cDJTZXJ2ZXIubGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0NoZWNrcysrO1xuICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXliZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9ucy5mb3JFYWNoKChjaGFubmVsekluZm8sIHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nQ2hlY2tzICs9IDE7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZShtYXliZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwZW5kaW5nQ2hlY2tzID09PSAwKSB7XG4gICAgICAgICAgICB3cmFwcGVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIdHRwMlBvcnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5uZWx6IHJlZmVyZW5jZSBvYmplY3QgZm9yIHRoaXMgc2VydmVyLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXNcbiAgICAgKiBnYXJiYWdlIGlmIGNoYW5uZWx6IGlzIGRpc2FibGVkIGZvciB0aGlzIHNlcnZlci5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcbiAgICB9XG4gICAgX3ZlcmlmeUNvbnRlbnRUeXBlKHN0cmVhbSwgaGVhZGVycykge1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnNbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRUeXBlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgIWNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL2dycGMnKSkge1xuICAgICAgICAgICAgc3RyZWFtLnJlc3BvbmQoe1xuICAgICAgICAgICAgICAgIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1NUQVRVU106IGh0dHAyLmNvbnN0YW50cy5IVFRQX1NUQVRVU19VTlNVUFBPUlRFRF9NRURJQV9UWVBFLFxuICAgICAgICAgICAgfSwgeyBlbmRTdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9yZXRyaWV2ZUhhbmRsZXIocGF0aCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBjYWxsIHRvIG1ldGhvZCAnICtcbiAgICAgICAgICAgIHBhdGggK1xuICAgICAgICAgICAgJyBhdCBhZGRyZXNzICcgK1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnMuZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdObyBoYW5kbGVyIHJlZ2lzdGVyZWQgZm9yIG1ldGhvZCAnICtcbiAgICAgICAgICAgICAgICBwYXRoICtcbiAgICAgICAgICAgICAgICAnLiBTZW5kaW5nIFVOSU1QTEVNRU5URUQgc3RhdHVzLicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuICAgIF9yZXNwb25kV2l0aEVycm9yKGVyciwgc3RyZWFtLCBjaGFubmVselNlc3Npb25JbmZvID0gbnVsbCkge1xuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHNlcnZlcl9jYWxsXzEuSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtKHN0cmVhbSwgbnVsbCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVyci5jb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbC5zZW5kRXJyb3IoZXJyKTtcbiAgICB9XG4gICAgX2NoYW5uZWx6SGFuZGxlcihzdHJlYW0sIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbHpTZXNzaW9uSW5mbyA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHN0cmVhbS5zZXNzaW9uKTtcbiAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvbnRlbnRUeXBlKHN0cmVhbSwgaGVhZGVycykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gbnVsbCB8fCBjaGFubmVselNlc3Npb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX3JldHJpZXZlSGFuZGxlcihwYXRoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kV2l0aEVycm9yKGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShwYXRoKSwgc3RyZWFtLCBjaGFubmVselNlc3Npb25JbmZvKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHNlcnZlcl9jYWxsXzEuSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtKHN0cmVhbSwgaGFuZGxlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgY2FsbC5vbmNlKCdjYWxsRW5kJywgKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNoYW5uZWx6U2Vzc2lvbkluZm8pIHtcbiAgICAgICAgICAgIGNhbGwub25jZSgnc3RyZWFtRW5kJywgKHN1Y2Nlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGwub24oJ3NlbmRNZXNzYWdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubWVzc2FnZXNTZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWxsLm9uKCdyZWNlaXZlTWVzc2FnZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLm1lc3NhZ2VzUmVjZWl2ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9ydW5IYW5kbGVyRm9yQ2FsbChjYWxsLCBoYW5kbGVyLCBoZWFkZXJzKSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICBjYWxsLnNlbmRFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBVbmtub3duIGhhbmRsZXIgdHlwZTogJHtoYW5kbGVyLnR5cGV9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zdHJlYW1IYW5kbGVyKHN0cmVhbSwgaGVhZGVycykge1xuICAgICAgICBpZiAodGhpcy5fdmVyaWZ5Q29udGVudFR5cGUoc3RyZWFtLCBoZWFkZXJzKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX3JldHJpZXZlSGFuZGxlcihwYXRoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kV2l0aEVycm9yKGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShwYXRoKSwgc3RyZWFtLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHNlcnZlcl9jYWxsXzEuSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtKHN0cmVhbSwgaGFuZGxlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ydW5IYW5kbGVyRm9yQ2FsbChjYWxsLCBoYW5kbGVyLCBoZWFkZXJzKSkge1xuICAgICAgICAgICAgY2FsbC5zZW5kRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgVW5rbm93biBoYW5kbGVyIHR5cGU6ICR7aGFuZGxlci50eXBlfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcnVuSGFuZGxlckZvckNhbGwoY2FsbCwgaGFuZGxlciwgaGVhZGVycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY2FsbC5yZWNlaXZlTWV0YWRhdGEoaGVhZGVycyk7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gKF9hID0gbWV0YWRhdGEuZ2V0KCdncnBjLWVuY29kaW5nJylbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdpZGVudGl0eSc7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IGhhbmRsZXI7XG4gICAgICAgIGlmICh0eXBlID09PSAndW5hcnknKSB7XG4gICAgICAgICAgICBoYW5kbGVVbmFyeShjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdjbGllbnRTdHJlYW0nKSB7XG4gICAgICAgICAgICBoYW5kbGVDbGllbnRTdHJlYW1pbmcoY2FsbCwgaGFuZGxlciwgbWV0YWRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2VydmVyU3RyZWFtJykge1xuICAgICAgICAgICAgaGFuZGxlU2VydmVyU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2JpZGknKSB7XG4gICAgICAgICAgICBoYW5kbGVCaWRpU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9zZXR1cEhhbmRsZXJzKGh0dHAyU2VydmVyKSB7XG4gICAgICAgIGlmIChodHRwMlNlcnZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZlckFkZHJlc3MgPSBodHRwMlNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgIGxldCBzZXJ2ZXJBZGRyZXNzU3RyaW5nID0gJ251bGwnO1xuICAgICAgICBpZiAoc2VydmVyQWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJ2ZXJBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VydmVyQWRkcmVzc1N0cmluZyA9IHNlcnZlckFkZHJlc3MuYWRkcmVzcyArICc6JyArIHNlcnZlckFkZHJlc3MucG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzU3RyaW5nO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5jaGFubmVsekVuYWJsZWRcbiAgICAgICAgICAgID8gdGhpcy5fY2hhbm5lbHpIYW5kbGVyXG4gICAgICAgICAgICA6IHRoaXMuX3N0cmVhbUhhbmRsZXI7XG4gICAgICAgIGh0dHAyU2VydmVyLm9uKCdzdHJlYW0nLCBoYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICBodHRwMlNlcnZlci5vbignc2Vzc2lvbicsIHNlc3Npb24gPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U29ja2V0KSgoX2EgPSBzZXNzaW9uLnNvY2tldC5yZW1vdGVBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAndW5rbm93bicsIHRoaXMuZ2V0Q2hhbm5lbHpTZXNzaW9uSW5mb0dldHRlcihzZXNzaW9uKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbHpTZXNzaW9uSW5mbyA9IHtcbiAgICAgICAgICAgICAgICByZWY6IGNoYW5uZWx6UmVmLFxuICAgICAgICAgICAgICAgIHN0cmVhbVRyYWNrZXI6IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogMCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25zLnNldChzZXNzaW9uLCBjaGFubmVselNlc3Npb25JbmZvKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudEFkZHJlc3MgPSBzZXNzaW9uLnNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpb24gZXN0YWJsaXNoZWQgYnkgY2xpZW50ICcgKyBjbGllbnRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25BZ2VUaW1lciA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY29ubmVjdGlvbkFnZUdyYWNlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zICE9PSBVTkxJTUlURURfQ09OTkVDVElPTl9BR0VfTVMpIHtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBhIHJhbmRvbSBqaXR0ZXIgd2l0aGluIGEgKy8tMTAlIHJhbmdlXG4gICAgICAgICAgICAgICAgY29uc3Qgaml0dGVyTWFnbml0dWRlID0gdGhpcy5tYXhDb25uZWN0aW9uQWdlTXMgLyAxMDtcbiAgICAgICAgICAgICAgICBjb25zdCBqaXR0ZXIgPSBNYXRoLnJhbmRvbSgpICogaml0dGVyTWFnbml0dWRlICogMiAtIGppdHRlck1hZ25pdHVkZTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWdlVGltZXIgPSAoX2MgPSAoX2IgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNsb3NlZEJ5U2VydmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IG1heCBjb25uZWN0aW9uIGFnZSBmcm9tICcgKyBjbGllbnRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5nb2F3YXkoaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1IsIH4oMSA8PCAzMSksIEJ1ZmZlci5mcm9tKCdtYXhfYWdlJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZ29hd2F5IGNhbid0IGJlIHNlbnQgYmVjYXVzZSB0aGUgc2Vzc2lvbiBpcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAvKiBBbGxvdyBhIGdyYWNlIHBlcmlvZCBhZnRlciBzZW5kaW5nIHRoZSBHT0FXQVkgYmVmb3JlIGZvcmNpYmx5XG4gICAgICAgICAgICAgICAgICAgICAqIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24uICovXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heENvbm5lY3Rpb25BZ2VHcmFjZU1zICE9PSBVTkxJTUlURURfQ09OTkVDVElPTl9BR0VfTVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyID0gKF9iID0gKF9hID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1heENvbm5lY3Rpb25BZ2VHcmFjZU1zKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zICsgaml0dGVyKSkudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtlZWFwbGl2ZVRpbWVUaW1lciA9IChfZSA9IChfZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRUSW1lciA9IChfYiA9IChfYSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aW9uIGRyb3BwZWQgYnkga2VlcGFsaXZlIHRpbWVvdXQgZnJvbSAnICsgY2xpZW50QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZW91dE1zKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnBpbmcoKGVyciwgZHVyYXRpb24sIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VEltZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHBpbmcgY2FuJ3QgYmUgc2VudCBiZWNhdXNlIHRoZSBzZXNzaW9uIGlzIGFscmVhZHkgY2xvc2VkXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZU1zKSkudW5yZWYpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKTtcbiAgICAgICAgICAgIHNlc3Npb24ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25DbG9zZWRCeVNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpb24gZHJvcHBlZCBieSBjbGllbnQgJyArIGNsaWVudEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKShjaGFubmVselJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uQWdlVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BZ2VUaW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uQWdlR3JhY2VUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbkFnZUdyYWNlVGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2VlYXBsaXZlVGltZVRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChrZWVhcGxpdmVUaW1lVGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25zLmRlbGV0ZShzZXNzaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVVuYXJ5KGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBjYWxsLnJlY2VpdmVVbmFyeU1lc3NhZ2UoZW5jb2RpbmcpO1xuICAgICAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkIHx8IGNhbGwuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlclVuYXJ5Q2FsbEltcGwoY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpO1xuICAgICAgICBoYW5kbGVyLmZ1bmMoZW1pdHRlciwgKGVyciwgdmFsdWUsIHRyYWlsZXIsIGZsYWdzKSA9PiB7XG4gICAgICAgICAgICBjYWxsLnNlbmRVbmFyeU1lc3NhZ2UoZXJyLCB2YWx1ZSwgdHJhaWxlciwgZmxhZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUNsaWVudFN0cmVhbWluZyhjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgc2VydmVyX2NhbGxfMS5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwoY2FsbCwgbWV0YWRhdGEsIGhhbmRsZXIuZGVzZXJpYWxpemUsIGVuY29kaW5nKTtcbiAgICBmdW5jdGlvbiByZXNwb25kKGVyciwgdmFsdWUsIHRyYWlsZXIsIGZsYWdzKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIGNhbGwuc2VuZFVuYXJ5TWVzc2FnZShlcnIsIHZhbHVlLCB0cmFpbGVyLCBmbGFncyk7XG4gICAgfVxuICAgIGlmIChjYWxsLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0cmVhbS5vbignZXJyb3InLCByZXNwb25kKTtcbiAgICBoYW5kbGVyLmZ1bmMoc3RyZWFtLCByZXNwb25kKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVNlcnZlclN0cmVhbWluZyhjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgY2FsbC5yZWNlaXZlVW5hcnlNZXNzYWdlKGVuY29kaW5nKTtcbiAgICAgICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCB8fCBjYWxsLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbChjYWxsLCBtZXRhZGF0YSwgaGFuZGxlci5zZXJpYWxpemUsIHJlcXVlc3QpO1xuICAgICAgICBoYW5kbGVyLmZ1bmMoc3RyZWFtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUJpZGlTdHJlYW1pbmcoY2FsbCwgaGFuZGxlciwgbWV0YWRhdGEsIGVuY29kaW5nKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IHNlcnZlcl9jYWxsXzEuU2VydmVyRHVwbGV4U3RyZWFtSW1wbChjYWxsLCBtZXRhZGF0YSwgaGFuZGxlci5zZXJpYWxpemUsIGhhbmRsZXIuZGVzZXJpYWxpemUsIGVuY29kaW5nKTtcbiAgICBpZiAoY2FsbC5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVyLmZ1bmMoc3RyZWFtKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTZXJ2ZXIiLCJodHRwMiIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsInNlcnZlcl9jYWxsXzEiLCJzZXJ2ZXJfY3JlZGVudGlhbHNfMSIsInJlc29sdmVyXzEiLCJsb2dnaW5nIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJ1cmlfcGFyc2VyXzEiLCJjaGFubmVsel8xIiwiVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TIiwiS0VFUEFMSVZFX01BWF9USU1FX01TIiwiS0VFUEFMSVZFX1RJTUVPVVRfTVMiLCJIVFRQMl9IRUFERVJfUEFUSCIsImNvbnN0YW50cyIsIlRSQUNFUl9OQU1FIiwibm9vcCIsImdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSIsIm1ldGhvZE5hbWUiLCJjb2RlIiwiU3RhdHVzIiwiVU5JTVBMRU1FTlRFRCIsImRldGFpbHMiLCJnZXREZWZhdWx0SGFuZGxlciIsImhhbmRsZXJUeXBlIiwidW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlIiwiY2FsbCIsImNhbGxiYWNrIiwiZW1pdCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJodHRwMlNlcnZlckxpc3QiLCJoYW5kbGVycyIsIk1hcCIsInNlc3Npb25zIiwic3RhcnRlZCIsInNodXRkb3duIiwic2VydmVyQWRkcmVzc1N0cmluZyIsImNoYW5uZWx6RW5hYmxlZCIsImNoYW5uZWx6VHJhY2UiLCJDaGFubmVselRyYWNlIiwiY2FsbFRyYWNrZXIiLCJDaGFubmVsekNhbGxUcmFja2VyIiwibGlzdGVuZXJDaGlsZHJlblRyYWNrZXIiLCJDaGFubmVsekNoaWxkcmVuVHJhY2tlciIsInNlc3Npb25DaGlsZHJlblRyYWNrZXIiLCJjaGFubmVselJlZiIsInJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXIiLCJnZXRDaGFubmVsekluZm8iLCJhZGRUcmFjZSIsIm1heENvbm5lY3Rpb25BZ2VNcyIsIm1heENvbm5lY3Rpb25BZ2VHcmFjZU1zIiwia2VlcGFsaXZlVGltZU1zIiwia2VlcGFsaXZlVGltZW91dE1zIiwidHJhY2UiLCJsaXN0ZW5lckNoaWxkcmVuIiwiZ2V0Q2hpbGRMaXN0cyIsInNlc3Npb25DaGlsZHJlbiIsImdldENoYW5uZWx6U2Vzc2lvbkluZm9HZXR0ZXIiLCJzZXNzaW9uIiwic2Vzc2lvbkluZm8iLCJnZXQiLCJzZXNzaW9uU29ja2V0Iiwic29ja2V0IiwicmVtb3RlQWRkcmVzcyIsInN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MiLCJyZW1vdGVQb3J0IiwibG9jYWxBZGRyZXNzIiwibG9jYWxQb3J0IiwidGxzSW5mbyIsImVuY3J5cHRlZCIsInRsc1NvY2tldCIsImNpcGhlckluZm8iLCJnZXRDaXBoZXIiLCJjZXJ0aWZpY2F0ZSIsImdldENlcnRpZmljYXRlIiwicGVlckNlcnRpZmljYXRlIiwiZ2V0UGVlckNlcnRpZmljYXRlIiwiY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJjaXBoZXJTdWl0ZU90aGVyTmFtZSIsIm5hbWUiLCJsb2NhbENlcnRpZmljYXRlIiwicmF3IiwicmVtb3RlQ2VydGlmaWNhdGUiLCJzb2NrZXRJbmZvIiwic2VjdXJpdHkiLCJyZW1vdGVOYW1lIiwic3RyZWFtc1N0YXJ0ZWQiLCJzdHJlYW1UcmFja2VyIiwiY2FsbHNTdGFydGVkIiwic3RyZWFtc1N1Y2NlZWRlZCIsImNhbGxzU3VjY2VlZGVkIiwic3RyZWFtc0ZhaWxlZCIsImNhbGxzRmFpbGVkIiwibWVzc2FnZXNTZW50IiwibWVzc2FnZXNSZWNlaXZlZCIsImtlZXBBbGl2ZXNTZW50IiwibGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCIsImxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibGFzdENhbGxTdGFydGVkVGltZXN0YW1wIiwibGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wIiwibGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCIsImxvY2FsRmxvd0NvbnRyb2xXaW5kb3ciLCJzdGF0ZSIsImxvY2FsV2luZG93U2l6ZSIsInJlbW90ZUZsb3dDb250cm9sV2luZG93IiwicmVtb3RlV2luZG93U2l6ZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsImlkIiwiYWRkUHJvdG9TZXJ2aWNlIiwiYWRkU2VydmljZSIsInNlcnZpY2UiLCJpbXBsZW1lbnRhdGlvbiIsInNlcnZpY2VLZXlzIiwia2V5cyIsImxlbmd0aCIsImZvckVhY2giLCJhdHRycyIsIm1ldGhvZFR5cGUiLCJyZXF1ZXN0U3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJpbXBsRm4iLCJpbXBsIiwidW5kZWZpbmVkIiwib3JpZ2luYWxOYW1lIiwiYmluZCIsInN1Y2Nlc3MiLCJyZWdpc3RlciIsInBhdGgiLCJyZXNwb25zZVNlcmlhbGl6ZSIsInJlcXVlc3REZXNlcmlhbGl6ZSIsInJlbW92ZVNlcnZpY2UiLCJ1bnJlZ2lzdGVyIiwicG9ydCIsImNyZWRzIiwiYmluZEFzeW5jIiwiVHlwZUVycm9yIiwiU2VydmVyQ3JlZGVudGlhbHMiLCJpbml0aWFsUG9ydFVyaSIsInBhcnNlVXJpIiwicG9ydFVyaSIsIm1hcFVyaURlZmF1bHRTY2hlbWUiLCJzZXJ2ZXJPcHRpb25zIiwibWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIm1heFNlc3Npb25NZW1vcnkiLCJzZXR0aW5ncyIsIm1heENvbmN1cnJlbnRTdHJlYW1zIiwiZGVmZXJyZWRDYWxsYmFjayIsImVycm9yIiwicHJvY2VzcyIsIm5leHRUaWNrIiwic2V0dXBTZXJ2ZXIiLCJodHRwMlNlcnZlciIsIl9pc1NlY3VyZSIsInNlY3VyZVNlcnZlck9wdGlvbnMiLCJhc3NpZ24iLCJfZ2V0U2V0dGluZ3MiLCJlbmFibGVUcmFjZSIsImNyZWF0ZVNlY3VyZVNlcnZlciIsIm9uIiwiZSIsIm1lc3NhZ2UiLCJjcmVhdGVTZXJ2ZXIiLCJzZXRUaW1lb3V0IiwiX3NldHVwSGFuZGxlcnMiLCJiaW5kU3BlY2lmaWNQb3J0IiwiYWRkcmVzc0xpc3QiLCJwb3J0TnVtIiwicHJldmlvdXNDb3VudCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY291bnQiLCJhbGwiLCJtYXAiLCJhZGRyZXNzIiwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyIsImFkZHIiLCJpc1RjcFN1YmNoYW5uZWxBZGRyZXNzIiwiaG9zdCIsInJlamVjdCIsIm9uRXJyb3IiLCJlcnIiLCJvbmNlIiwibGlzdGVuIiwiY2xvc2UiLCJib3VuZEFkZHJlc3MiLCJib3VuZFN1YmNoYW5uZWxBZGRyZXNzIiwicmVnaXN0ZXJDaGFubmVselNvY2tldCIsInJlZkNoaWxkIiwicHVzaCIsInNlcnZlciIsInJlbW92ZUxpc3RlbmVyIiwidGhlbiIsInJlc3VsdHMiLCJyZXN1bHQiLCJiaW5kV2lsZGNhcmRQb3J0Iiwic2xpY2UiLCJyZXNvbHZlckxpc3RlbmVyIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsInNlcnZpY2VDb25maWciLCJzZXJ2aWNlQ29uZmlnRXJyb3IiLCJiaW5kUmVzdWx0UHJvbWlzZSIsImJpbmRSZXN1bHQiLCJlcnJvclN0cmluZyIsImxvZyIsIkVSUk9SIiwiSU5GTyIsInJlc29sdmVyIiwiY3JlYXRlUmVzb2x2ZXIiLCJ1cGRhdGVSZXNvbHV0aW9uIiwiZm9yY2VTaHV0ZG93biIsInJlZiIsImxpc3RlbmluZyIsInVucmVmQ2hpbGQiLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJjaGFubmVsekluZm8iLCJkZXN0cm95IiwiTkdIVFRQMl9DQU5DRUwiLCJjbGVhciIsImhhbmRsZXIiLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsInR5cGUiLCJoYXMiLCJzZXQiLCJmdW5jIiwiZGVsZXRlIiwic3RhcnQiLCJldmVyeSIsInRyeVNodXRkb3duIiwid3JhcHBlZENhbGxiYWNrIiwicGVuZGluZ0NoZWNrcyIsIm1heWJlQ2FsbGJhY2siLCJjbG9zZWQiLCJhZGRIdHRwMlBvcnQiLCJnZXRDaGFubmVselJlZiIsIl92ZXJpZnlDb250ZW50VHlwZSIsInN0cmVhbSIsImhlYWRlcnMiLCJjb250ZW50VHlwZSIsIkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUiLCJzdGFydHNXaXRoIiwicmVzcG9uZCIsIkhUVFAyX0hFQURFUl9TVEFUVVMiLCJIVFRQX1NUQVRVU19VTlNVUFBPUlRFRF9NRURJQV9UWVBFIiwiZW5kU3RyZWFtIiwiX3JldHJpZXZlSGFuZGxlciIsIl9yZXNwb25kV2l0aEVycm9yIiwiY2hhbm5lbHpTZXNzaW9uSW5mbyIsIkh0dHAyU2VydmVyQ2FsbFN0cmVhbSIsIklOVEVSTkFMIiwiYWRkQ2FsbEZhaWxlZCIsInNlbmRFcnJvciIsIl9jaGFubmVsekhhbmRsZXIiLCJhZGRDYWxsU3RhcnRlZCIsIk9LIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsIkRhdGUiLCJfcnVuSGFuZGxlckZvckNhbGwiLCJfc3RyZWFtSGFuZGxlciIsIm1ldGFkYXRhIiwicmVjZWl2ZU1ldGFkYXRhIiwiZW5jb2RpbmciLCJyZW1vdmUiLCJoYW5kbGVVbmFyeSIsImhhbmRsZUNsaWVudFN0cmVhbWluZyIsImhhbmRsZVNlcnZlclN0cmVhbWluZyIsImhhbmRsZUJpZGlTdHJlYW1pbmciLCJzZXJ2ZXJBZGRyZXNzIiwiX2UiLCJjbGllbnRBZGRyZXNzIiwiY29ubmVjdGlvbkFnZVRpbWVyIiwiY29ubmVjdGlvbkFnZUdyYWNlVGltZXIiLCJzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIiLCJqaXR0ZXJNYWduaXR1ZGUiLCJqaXR0ZXIiLCJNYXRoIiwicmFuZG9tIiwiZ29hd2F5IiwiTkdIVFRQMl9OT19FUlJPUiIsIkJ1ZmZlciIsImZyb20iLCJ1bnJlZiIsImtlZWFwbGl2ZVRpbWVUaW1lciIsInNldEludGVydmFsIiwidGltZW91dFRJbWVyIiwicGluZyIsImR1cmF0aW9uIiwicGF5bG9hZCIsImNsZWFyVGltZW91dCIsInJlcXVlc3QiLCJyZWNlaXZlVW5hcnlNZXNzYWdlIiwiY2FuY2VsbGVkIiwiZW1pdHRlciIsIlNlcnZlclVuYXJ5Q2FsbEltcGwiLCJ0cmFpbGVyIiwiZmxhZ3MiLCJzZW5kVW5hcnlNZXNzYWdlIiwiU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsIiwiU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsIiwiU2VydmVyRHVwbGV4U3RyZWFtSW1wbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/service-config.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.extractAndSelectServiceConfig = exports.validateServiceConfig = exports.validateRetryThrottling = void 0;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */ /* The any type is purposely used here. All functions validate their input at\n * runtime */ /* eslint-disable @typescript-eslint/no-explicit-any */ const os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */ const DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */ const CLIENT_LANGUAGE_STRING = \"node\";\nfunction validateName(obj) {\n    // In this context, and unset field and '' are considered the same\n    if (\"service\" in obj && obj.service !== \"\") {\n        if (typeof obj.service !== \"string\") {\n            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);\n        }\n        if (\"method\" in obj && obj.method !== \"\") {\n            if (typeof obj.method !== \"string\") {\n                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);\n            }\n            return {\n                service: obj.service,\n                method: obj.method\n            };\n        } else {\n            return {\n                service: obj.service\n            };\n        }\n    } else {\n        if (\"method\" in obj && obj.method !== undefined) {\n            throw new Error(`Invalid method config name: method set with empty or unset service`);\n        }\n        return {};\n    }\n}\nfunction validateRetryPolicy(obj) {\n    if (!(\"maxAttempts\" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n        throw new Error(\"Invalid method config retry policy: maxAttempts must be an integer at least 2\");\n    }\n    if (!(\"initialBackoff\" in obj) || typeof obj.initialBackoff !== \"string\" || !DURATION_REGEX.test(obj.initialBackoff)) {\n        throw new Error(\"Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer followed by s\");\n    }\n    if (!(\"maxBackoff\" in obj) || typeof obj.maxBackoff !== \"string\" || !DURATION_REGEX.test(obj.maxBackoff)) {\n        throw new Error(\"Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer followed by s\");\n    }\n    if (!(\"backoffMultiplier\" in obj) || typeof obj.backoffMultiplier !== \"number\" || obj.backoffMultiplier <= 0) {\n        throw new Error(\"Invalid method config retry policy: backoffMultiplier must be a number greater than 0\");\n    }\n    if (!(\"retryableStatusCodes\" in obj && Array.isArray(obj.retryableStatusCodes))) {\n        throw new Error(\"Invalid method config retry policy: retryableStatusCodes is required\");\n    }\n    if (obj.retryableStatusCodes.length === 0) {\n        throw new Error(\"Invalid method config retry policy: retryableStatusCodes must be non-empty\");\n    }\n    for (const value of obj.retryableStatusCodes){\n        if (typeof value === \"number\") {\n            if (!Object.values(constants_1.Status).includes(value)) {\n                throw new Error(\"Invalid method config retry policy: retryableStatusCodes value not in status code range\");\n            }\n        } else if (typeof value === \"string\") {\n            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                throw new Error(\"Invalid method config retry policy: retryableStatusCodes value not a status code name\");\n            }\n        } else {\n            throw new Error(\"Invalid method config retry policy: retryableStatusCodes value must be a string or number\");\n        }\n    }\n    return {\n        maxAttempts: obj.maxAttempts,\n        initialBackoff: obj.initialBackoff,\n        maxBackoff: obj.maxBackoff,\n        backoffMultiplier: obj.backoffMultiplier,\n        retryableStatusCodes: obj.retryableStatusCodes\n    };\n}\nfunction validateHedgingPolicy(obj) {\n    if (!(\"maxAttempts\" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n        throw new Error(\"Invalid method config hedging policy: maxAttempts must be an integer at least 2\");\n    }\n    if (\"hedgingDelay\" in obj && (typeof obj.hedgingDelay !== \"string\" || !DURATION_REGEX.test(obj.hedgingDelay))) {\n        throw new Error(\"Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s\");\n    }\n    if (\"nonFatalStatusCodes\" in obj && Array.isArray(obj.nonFatalStatusCodes)) {\n        for (const value of obj.nonFatalStatusCodes){\n            if (typeof value === \"number\") {\n                if (!Object.values(constants_1.Status).includes(value)) {\n                    throw new Error(\"Invlid method config hedging policy: nonFatalStatusCodes value not in status code range\");\n                }\n            } else if (typeof value === \"string\") {\n                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                    throw new Error(\"Invlid method config hedging policy: nonFatalStatusCodes value not a status code name\");\n                }\n            } else {\n                throw new Error(\"Invlid method config hedging policy: nonFatalStatusCodes value must be a string or number\");\n            }\n        }\n    }\n    const result = {\n        maxAttempts: obj.maxAttempts\n    };\n    if (obj.hedgingDelay) {\n        result.hedgingDelay = obj.hedgingDelay;\n    }\n    if (obj.nonFatalStatusCodes) {\n        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\n    }\n    return result;\n}\nfunction validateMethodConfig(obj) {\n    var _a;\n    const result = {\n        name: []\n    };\n    if (!(\"name\" in obj) || !Array.isArray(obj.name)) {\n        throw new Error(\"Invalid method config: invalid name array\");\n    }\n    for (const name of obj.name){\n        result.name.push(validateName(name));\n    }\n    if (\"waitForReady\" in obj) {\n        if (typeof obj.waitForReady !== \"boolean\") {\n            throw new Error(\"Invalid method config: invalid waitForReady\");\n        }\n        result.waitForReady = obj.waitForReady;\n    }\n    if (\"timeout\" in obj) {\n        if (typeof obj.timeout === \"object\") {\n            if (!(\"seconds\" in obj.timeout) || !(typeof obj.timeout.seconds === \"number\")) {\n                throw new Error(\"Invalid method config: invalid timeout.seconds\");\n            }\n            if (!(\"nanos\" in obj.timeout) || !(typeof obj.timeout.nanos === \"number\")) {\n                throw new Error(\"Invalid method config: invalid timeout.nanos\");\n            }\n            result.timeout = obj.timeout;\n        } else if (typeof obj.timeout === \"string\" && DURATION_REGEX.test(obj.timeout)) {\n            const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split(\".\");\n            result.timeout = {\n                seconds: timeoutParts[0] | 0,\n                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0\n            };\n        } else {\n            throw new Error(\"Invalid method config: invalid timeout\");\n        }\n    }\n    if (\"maxRequestBytes\" in obj) {\n        if (typeof obj.maxRequestBytes !== \"number\") {\n            throw new Error(\"Invalid method config: invalid maxRequestBytes\");\n        }\n        result.maxRequestBytes = obj.maxRequestBytes;\n    }\n    if (\"maxResponseBytes\" in obj) {\n        if (typeof obj.maxResponseBytes !== \"number\") {\n            throw new Error(\"Invalid method config: invalid maxRequestBytes\");\n        }\n        result.maxResponseBytes = obj.maxResponseBytes;\n    }\n    if (\"retryPolicy\" in obj) {\n        if (\"hedgingPolicy\" in obj) {\n            throw new Error(\"Invalid method config: retryPolicy and hedgingPolicy cannot both be specified\");\n        } else {\n            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\n        }\n    } else if (\"hedgingPolicy\" in obj) {\n        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\n    }\n    return result;\n}\nfunction validateRetryThrottling(obj) {\n    if (!(\"maxTokens\" in obj) || typeof obj.maxTokens !== \"number\" || obj.maxTokens <= 0 || obj.maxTokens > 1000) {\n        throw new Error(\"Invalid retryThrottling: maxTokens must be a number in (0, 1000]\");\n    }\n    if (!(\"tokenRatio\" in obj) || typeof obj.tokenRatio !== \"number\" || obj.tokenRatio <= 0) {\n        throw new Error(\"Invalid retryThrottling: tokenRatio must be a number greater than 0\");\n    }\n    return {\n        maxTokens: +obj.maxTokens.toFixed(3),\n        tokenRatio: +obj.tokenRatio.toFixed(3)\n    };\n}\nexports.validateRetryThrottling = validateRetryThrottling;\nfunction validateServiceConfig(obj) {\n    const result = {\n        loadBalancingConfig: [],\n        methodConfig: []\n    };\n    if (\"loadBalancingPolicy\" in obj) {\n        if (typeof obj.loadBalancingPolicy === \"string\") {\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\n        } else {\n            throw new Error(\"Invalid service config: invalid loadBalancingPolicy\");\n        }\n    }\n    if (\"loadBalancingConfig\" in obj) {\n        if (Array.isArray(obj.loadBalancingConfig)) {\n            for (const config of obj.loadBalancingConfig){\n                result.loadBalancingConfig.push((0, load_balancer_1.validateLoadBalancingConfig)(config));\n            }\n        } else {\n            throw new Error(\"Invalid service config: invalid loadBalancingConfig\");\n        }\n    }\n    if (\"methodConfig\" in obj) {\n        if (Array.isArray(obj.methodConfig)) {\n            for (const methodConfig of obj.methodConfig){\n                result.methodConfig.push(validateMethodConfig(methodConfig));\n            }\n        }\n    }\n    if (\"retryThrottling\" in obj) {\n        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\n    }\n    // Validate method name uniqueness\n    const seenMethodNames = [];\n    for (const methodConfig of result.methodConfig){\n        for (const name of methodConfig.name){\n            for (const seenName of seenMethodNames){\n                if (name.service === seenName.service && name.method === seenName.method) {\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n                }\n            }\n            seenMethodNames.push(name);\n        }\n    }\n    return result;\n}\nexports.validateServiceConfig = validateServiceConfig;\nfunction validateCanaryConfig(obj) {\n    if (!(\"serviceConfig\" in obj)) {\n        throw new Error(\"Invalid service config choice: missing service config\");\n    }\n    const result = {\n        serviceConfig: validateServiceConfig(obj.serviceConfig)\n    };\n    if (\"clientLanguage\" in obj) {\n        if (Array.isArray(obj.clientLanguage)) {\n            result.clientLanguage = [];\n            for (const lang of obj.clientLanguage){\n                if (typeof lang === \"string\") {\n                    result.clientLanguage.push(lang);\n                } else {\n                    throw new Error(\"Invalid service config choice: invalid clientLanguage\");\n                }\n            }\n        } else {\n            throw new Error(\"Invalid service config choice: invalid clientLanguage\");\n        }\n    }\n    if (\"clientHostname\" in obj) {\n        if (Array.isArray(obj.clientHostname)) {\n            result.clientHostname = [];\n            for (const lang of obj.clientHostname){\n                if (typeof lang === \"string\") {\n                    result.clientHostname.push(lang);\n                } else {\n                    throw new Error(\"Invalid service config choice: invalid clientHostname\");\n                }\n            }\n        } else {\n            throw new Error(\"Invalid service config choice: invalid clientHostname\");\n        }\n    }\n    if (\"percentage\" in obj) {\n        if (typeof obj.percentage === \"number\" && 0 <= obj.percentage && obj.percentage <= 100) {\n            result.percentage = obj.percentage;\n        } else {\n            throw new Error(\"Invalid service config choice: invalid percentage\");\n        }\n    }\n    // Validate that no unexpected fields are present\n    const allowedFields = [\n        \"clientLanguage\",\n        \"percentage\",\n        \"clientHostname\",\n        \"serviceConfig\"\n    ];\n    for(const field in obj){\n        if (!allowedFields.includes(field)) {\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\n        }\n    }\n    return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n    if (!Array.isArray(obj)) {\n        throw new Error(\"Invalid service config list\");\n    }\n    for (const config of obj){\n        const validatedConfig = validateCanaryConfig(config);\n        /* For each field, we check if it is present, then only discard the\n         * config if the field value does not match the current client */ if (typeof validatedConfig.percentage === \"number\" && percentage > validatedConfig.percentage) {\n            continue;\n        }\n        if (Array.isArray(validatedConfig.clientHostname)) {\n            let hostnameMatched = false;\n            for (const hostname of validatedConfig.clientHostname){\n                if (hostname === os.hostname()) {\n                    hostnameMatched = true;\n                }\n            }\n            if (!hostnameMatched) {\n                continue;\n            }\n        }\n        if (Array.isArray(validatedConfig.clientLanguage)) {\n            let languageMatched = false;\n            for (const language of validatedConfig.clientLanguage){\n                if (language === CLIENT_LANGUAGE_STRING) {\n                    languageMatched = true;\n                }\n            }\n            if (!languageMatched) {\n                continue;\n            }\n        }\n        return validatedConfig.serviceConfig;\n    }\n    throw new Error(\"No matching service config found\");\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */ function extractAndSelectServiceConfig(txtRecord, percentage) {\n    for (const record of txtRecord){\n        if (record.length > 0 && record[0].startsWith(\"grpc_config=\")) {\n            /* Treat the list of strings in this record as a single string and remove\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */ const recordString = record.join(\"\").substring(\"grpc_config=\".length);\n            const recordJson = JSON.parse(recordString);\n            return validateAndSelectCanaryConfig(recordJson, percentage);\n        }\n    }\n    return null;\n}\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig; //# sourceMappingURL=service-config.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFDQUFxQyxHQUFHQSw2QkFBNkIsR0FBR0EsK0JBQStCLEdBQUcsS0FBSztBQUMvRzs7Ozs7b0JBS29CLEdBQ3BCO1dBQ1csR0FDWCxxREFBcUQsR0FDckQsTUFBTUssS0FBS0MsbUJBQU9BLENBQUMsY0FBSTtBQUN2QixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxrQkFBa0JGLG1CQUFPQSxDQUFDLHNGQUFpQjtBQUNqRDs7O0NBR0MsR0FDRCxNQUFNRyxpQkFBaUI7QUFDdkI7OztDQUdDLEdBQ0QsTUFBTUMseUJBQXlCO0FBQy9CLFNBQVNDLGFBQWFDLEdBQUc7SUFDckIsa0VBQWtFO0lBQ2xFLElBQUksYUFBYUEsT0FBT0EsSUFBSUMsT0FBTyxLQUFLLElBQUk7UUFDeEMsSUFBSSxPQUFPRCxJQUFJQyxPQUFPLEtBQUssVUFBVTtZQUNqQyxNQUFNLElBQUlDLE1BQU0sQ0FBQyx1RUFBdUUsRUFBRSxPQUFPRixJQUFJQyxPQUFPLENBQUMsQ0FBQztRQUNsSDtRQUNBLElBQUksWUFBWUQsT0FBT0EsSUFBSUcsTUFBTSxLQUFLLElBQUk7WUFDdEMsSUFBSSxPQUFPSCxJQUFJRyxNQUFNLEtBQUssVUFBVTtnQkFDaEMsTUFBTSxJQUFJRCxNQUFNLENBQUMsc0VBQXNFLEVBQUUsT0FBT0YsSUFBSUMsT0FBTyxDQUFDLENBQUM7WUFDakg7WUFDQSxPQUFPO2dCQUNIQSxTQUFTRCxJQUFJQyxPQUFPO2dCQUNwQkUsUUFBUUgsSUFBSUcsTUFBTTtZQUN0QjtRQUNKLE9BQ0s7WUFDRCxPQUFPO2dCQUNIRixTQUFTRCxJQUFJQyxPQUFPO1lBQ3hCO1FBQ0o7SUFDSixPQUNL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Q0o7UUFDSjtRQUNBLE9BQU9ILGdCQUFnQlIsYUFBYTtJQUN4QztJQUNBLE1BQU0sSUFBSWxELE1BQU07QUFDcEI7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNaLDhCQUE4QjJFLFNBQVMsRUFBRVQsVUFBVTtJQUN4RCxLQUFLLE1BQU1VLFVBQVVELFVBQVc7UUFDNUIsSUFBSUMsT0FBT2xELE1BQU0sR0FBRyxLQUFLa0QsTUFBTSxDQUFDLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDLGlCQUFpQjtZQUMzRDttRkFDdUUsR0FDdkUsTUFBTUMsZUFBZUYsT0FBT0csSUFBSSxDQUFDLElBQUluQyxTQUFTLENBQUMsZUFBZWxCLE1BQU07WUFDcEUsTUFBTXNELGFBQWFDLEtBQUtDLEtBQUssQ0FBQ0o7WUFDOUIsT0FBT1QsOEJBQThCVyxZQUFZZDtRQUNyRDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0FwRSxxQ0FBcUMsR0FBR0UsK0JBQ3hDLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZpY2UtY29uZmlnLmpzPzZjNDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcgPSBleHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IGV4cG9ydHMudmFsaWRhdGVSZXRyeVRocm90dGxpbmcgPSB2b2lkIDA7XG4vKiBUaGlzIGZpbGUgaW1wbGVtZW50cyBnUkZDIEEyIGFuZCB0aGUgc2VydmljZSBjb25maWcgc3BlYzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0EyLXNlcnZpY2UtY29uZmlncy1pbi1kbnMubWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9tYXN0ZXIvZG9jL3NlcnZpY2VfY29uZmlnLm1kLiBFYWNoXG4gKiBmdW5jdGlvbiBoZXJlIHRha2VzIGFuIG9iamVjdCB3aXRoIHVua25vd24gc3RydWN0dXJlIGFuZCByZXR1cm5zIGl0c1xuICogc3BlY2lmaWMgb2JqZWN0IHR5cGUgaWYgdGhlIGlucHV0IGhhcyB0aGUgcmlnaHQgc3RydWN0dXJlLCBhbmQgdGhyb3dzIGFuXG4gKiBlcnJvciBvdGhlcndpc2UuICovXG4vKiBUaGUgYW55IHR5cGUgaXMgcHVycG9zZWx5IHVzZWQgaGVyZS4gQWxsIGZ1bmN0aW9ucyB2YWxpZGF0ZSB0aGVpciBpbnB1dCBhdFxuICogcnVudGltZSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG4vKipcbiAqIFJlY29nbml6ZXMgYSBudW1iZXIgd2l0aCB1cCB0byA5IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgZm9sbG93ZWQgYnlcbiAqIGFuIFwic1wiLCByZXByZXNlbnRpbmcgYSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAqL1xuY29uc3QgRFVSQVRJT05fUkVHRVggPSAvXlxcZCsoXFwuXFxkezEsOX0pP3MkLztcbi8qKlxuICogQ2xpZW50IGxhbmd1YWdlIG5hbWUgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGlzIGNsaWVudCBtYXRjaGVzIGFcbiAqIGBTZXJ2aWNlQ29uZmlnQ2FuYXJ5Q29uZmlnYCdzIGBjbGllbnRMYW5ndWFnZWAgbGlzdC5cbiAqL1xuY29uc3QgQ0xJRU5UX0xBTkdVQUdFX1NUUklORyA9ICdub2RlJztcbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZShvYmopIHtcbiAgICAvLyBJbiB0aGlzIGNvbnRleHQsIGFuZCB1bnNldCBmaWVsZCBhbmQgJycgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAgICBpZiAoJ3NlcnZpY2UnIGluIG9iaiAmJiBvYmouc2VydmljZSAhPT0gJycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmouc2VydmljZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IGludmFsaWQgc2VydmljZTogZXhwZWN0ZWQgdHlwZSBzdHJpbmcsIGdvdCAke3R5cGVvZiBvYmouc2VydmljZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ21ldGhvZCcgaW4gb2JqICYmIG9iai5tZXRob2QgIT09ICcnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iai5tZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1ldGhvZCBjb25maWcgbmFtZTogaW52YWxpZCBtZXRob2Q6IGV4cGVjdGVkIHR5cGUgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygb2JqLnNlcnZpY2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IG9iai5zZXJ2aWNlLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogb2JqLm1ldGhvZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IG9iai5zZXJ2aWNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCdtZXRob2QnIGluIG9iaiAmJiBvYmoubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IG1ldGhvZCBzZXQgd2l0aCBlbXB0eSBvciB1bnNldCBzZXJ2aWNlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmV0cnlQb2xpY3kob2JqKSB7XG4gICAgaWYgKCEoJ21heEF0dGVtcHRzJyBpbiBvYmopIHx8XG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9iai5tYXhBdHRlbXB0cykgfHxcbiAgICAgICAgb2JqLm1heEF0dGVtcHRzIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IG1heEF0dGVtcHRzIG11c3QgYmUgYW4gaW50ZWdlciBhdCBsZWFzdCAyJyk7XG4gICAgfVxuICAgIGlmICghKCdpbml0aWFsQmFja29mZicgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLmluaXRpYWxCYWNrb2ZmICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhRFVSQVRJT05fUkVHRVgudGVzdChvYmouaW5pdGlhbEJhY2tvZmYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogaW5pdGlhbEJhY2tvZmYgbXVzdCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIG9mIGEgcG9zaXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieSBzJyk7XG4gICAgfVxuICAgIGlmICghKCdtYXhCYWNrb2ZmJyBpbiBvYmopIHx8XG4gICAgICAgIHR5cGVvZiBvYmoubWF4QmFja29mZiAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIURVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLm1heEJhY2tvZmYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogbWF4QmFja29mZiBtdXN0IGJlIGEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5IHMnKTtcbiAgICB9XG4gICAgaWYgKCEoJ2JhY2tvZmZNdWx0aXBsaWVyJyBpbiBvYmopIHx8XG4gICAgICAgIHR5cGVvZiBvYmouYmFja29mZk11bHRpcGxpZXIgIT09ICdudW1iZXInIHx8XG4gICAgICAgIG9iai5iYWNrb2ZmTXVsdGlwbGllciA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogYmFja29mZk11bHRpcGxpZXIgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cbiAgICBpZiAoISgncmV0cnlhYmxlU3RhdHVzQ29kZXMnIGluIG9iaiAmJiBBcnJheS5pc0FycmF5KG9iai5yZXRyeWFibGVTdGF0dXNDb2RlcykpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKG9iai5yZXRyeWFibGVTdGF0dXNDb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyBtdXN0IGJlIG5vbi1lbXB0eScpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iai5yZXRyeWFibGVTdGF0dXNDb2Rlcykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyB2YWx1ZSBub3QgaW4gc3RhdHVzIGNvZGUgcmFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC52YWx1ZXMoY29uc3RhbnRzXzEuU3RhdHVzKS5pbmNsdWRlcyh2YWx1ZS50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgdmFsdWUgbm90IGEgc3RhdHVzIGNvZGUgbmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1heEF0dGVtcHRzOiBvYmoubWF4QXR0ZW1wdHMsXG4gICAgICAgIGluaXRpYWxCYWNrb2ZmOiBvYmouaW5pdGlhbEJhY2tvZmYsXG4gICAgICAgIG1heEJhY2tvZmY6IG9iai5tYXhCYWNrb2ZmLFxuICAgICAgICBiYWNrb2ZmTXVsdGlwbGllcjogb2JqLmJhY2tvZmZNdWx0aXBsaWVyLFxuICAgICAgICByZXRyeWFibGVTdGF0dXNDb2Rlczogb2JqLnJldHJ5YWJsZVN0YXR1c0NvZGVzLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUhlZGdpbmdQb2xpY3kob2JqKSB7XG4gICAgaWYgKCEoJ21heEF0dGVtcHRzJyBpbiBvYmopIHx8XG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9iai5tYXhBdHRlbXB0cykgfHxcbiAgICAgICAgb2JqLm1heEF0dGVtcHRzIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbWF4QXR0ZW1wdHMgbXVzdCBiZSBhbiBpbnRlZ2VyIGF0IGxlYXN0IDInKTtcbiAgICB9XG4gICAgaWYgKCdoZWRnaW5nRGVsYXknIGluIG9iaiAmJlxuICAgICAgICAodHlwZW9mIG9iai5oZWRnaW5nRGVsYXkgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAhRFVSQVRJT05fUkVHRVgudGVzdChvYmouaGVkZ2luZ0RlbGF5KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IGhlZGdpbmdEZWxheSBtdXN0IGJlIGEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5IHMnKTtcbiAgICB9XG4gICAgaWYgKCdub25GYXRhbFN0YXR1c0NvZGVzJyBpbiBvYmogJiYgQXJyYXkuaXNBcnJheShvYmoubm9uRmF0YWxTdGF0dXNDb2RlcykpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBvYmoubm9uRmF0YWxTdGF0dXNDb2Rlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC52YWx1ZXMoY29uc3RhbnRzXzEuU3RhdHVzKS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBub3QgaW4gc3RhdHVzIGNvZGUgcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBub3QgYSBzdGF0dXMgY29kZSBuYW1lJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbWF4QXR0ZW1wdHM6IG9iai5tYXhBdHRlbXB0cyxcbiAgICB9O1xuICAgIGlmIChvYmouaGVkZ2luZ0RlbGF5KSB7XG4gICAgICAgIHJlc3VsdC5oZWRnaW5nRGVsYXkgPSBvYmouaGVkZ2luZ0RlbGF5O1xuICAgIH1cbiAgICBpZiAob2JqLm5vbkZhdGFsU3RhdHVzQ29kZXMpIHtcbiAgICAgICAgcmVzdWx0Lm5vbkZhdGFsU3RhdHVzQ29kZXMgPSBvYmoubm9uRmF0YWxTdGF0dXNDb2RlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kQ29uZmlnKG9iaikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6IFtdLFxuICAgIH07XG4gICAgaWYgKCEoJ25hbWUnIGluIG9iaikgfHwgIUFycmF5LmlzQXJyYXkob2JqLm5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG5hbWUgYXJyYXknKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG9iai5uYW1lKSB7XG4gICAgICAgIHJlc3VsdC5uYW1lLnB1c2godmFsaWRhdGVOYW1lKG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKCd3YWl0Rm9yUmVhZHknIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai53YWl0Rm9yUmVhZHkgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgd2FpdEZvclJlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LndhaXRGb3JSZWFkeSA9IG9iai53YWl0Rm9yUmVhZHk7XG4gICAgfVxuICAgIGlmICgndGltZW91dCcgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnRpbWVvdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoISgnc2Vjb25kcycgaW4gb2JqLnRpbWVvdXQpIHx8XG4gICAgICAgICAgICAgICAgISh0eXBlb2Ygb2JqLnRpbWVvdXQuc2Vjb25kcyA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgdGltZW91dC5zZWNvbmRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISgnbmFub3MnIGluIG9iai50aW1lb3V0KSB8fFxuICAgICAgICAgICAgICAgICEodHlwZW9mIG9iai50aW1lb3V0Lm5hbm9zID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0Lm5hbm9zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQudGltZW91dCA9IG9iai50aW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmoudGltZW91dCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIERVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLnRpbWVvdXQpKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0UGFydHMgPSBvYmoudGltZW91dFxuICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMCwgb2JqLnRpbWVvdXQubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHJlc3VsdC50aW1lb3V0ID0ge1xuICAgICAgICAgICAgICAgIHNlY29uZHM6IHRpbWVvdXRQYXJ0c1swXSB8IDAsXG4gICAgICAgICAgICAgICAgbmFub3M6ICgoX2EgPSB0aW1lb3V0UGFydHNbMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIHwgMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdtYXhSZXF1ZXN0Qnl0ZXMnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5tYXhSZXF1ZXN0Qnl0ZXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCBtYXhSZXF1ZXN0Qnl0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQubWF4UmVxdWVzdEJ5dGVzID0gb2JqLm1heFJlcXVlc3RCeXRlcztcbiAgICB9XG4gICAgaWYgKCdtYXhSZXNwb25zZUJ5dGVzJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubWF4UmVzcG9uc2VCeXRlcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG1heFJlcXVlc3RCeXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5tYXhSZXNwb25zZUJ5dGVzID0gb2JqLm1heFJlc3BvbnNlQnl0ZXM7XG4gICAgfVxuICAgIGlmICgncmV0cnlQb2xpY3knIGluIG9iaikge1xuICAgICAgICBpZiAoJ2hlZGdpbmdQb2xpY3knIGluIG9iaikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IHJldHJ5UG9saWN5IGFuZCBoZWRnaW5nUG9saWN5IGNhbm5vdCBib3RoIGJlIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnJldHJ5UG9saWN5ID0gdmFsaWRhdGVSZXRyeVBvbGljeShvYmoucmV0cnlQb2xpY3kpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCdoZWRnaW5nUG9saWN5JyBpbiBvYmopIHtcbiAgICAgICAgcmVzdWx0LmhlZGdpbmdQb2xpY3kgPSB2YWxpZGF0ZUhlZGdpbmdQb2xpY3kob2JqLmhlZGdpbmdQb2xpY3kpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZXRyeVRocm90dGxpbmcob2JqKSB7XG4gICAgaWYgKCEoJ21heFRva2VucycgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLm1heFRva2VucyAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgb2JqLm1heFRva2VucyA8PSAwIHx8XG4gICAgICAgIG9iai5tYXhUb2tlbnMgPiAxMDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXRyeVRocm90dGxpbmc6IG1heFRva2VucyBtdXN0IGJlIGEgbnVtYmVyIGluICgwLCAxMDAwXScpO1xuICAgIH1cbiAgICBpZiAoISgndG9rZW5SYXRpbycgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLnRva2VuUmF0aW8gIT09ICdudW1iZXInIHx8XG4gICAgICAgIG9iai50b2tlblJhdGlvIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJldHJ5VGhyb3R0bGluZzogdG9rZW5SYXRpbyBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1heFRva2VuczogK29iai5tYXhUb2tlbnMudG9GaXhlZCgzKSxcbiAgICAgICAgdG9rZW5SYXRpbzogK29iai50b2tlblJhdGlvLnRvRml4ZWQoMyksXG4gICAgfTtcbn1cbmV4cG9ydHMudmFsaWRhdGVSZXRyeVRocm90dGxpbmcgPSB2YWxpZGF0ZVJldHJ5VGhyb3R0bGluZztcbmZ1bmN0aW9uIHZhbGlkYXRlU2VydmljZUNvbmZpZyhvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGxvYWRCYWxhbmNpbmdDb25maWc6IFtdLFxuICAgICAgICBtZXRob2RDb25maWc6IFtdLFxuICAgIH07XG4gICAgaWYgKCdsb2FkQmFsYW5jaW5nUG9saWN5JyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubG9hZEJhbGFuY2luZ1BvbGljeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5sb2FkQmFsYW5jaW5nUG9saWN5ID0gb2JqLmxvYWRCYWxhbmNpbmdQb2xpY3k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWc6IGludmFsaWQgbG9hZEJhbGFuY2luZ1BvbGljeScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbG9hZEJhbGFuY2luZ0NvbmZpZycgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5sb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2Ygb2JqLmxvYWRCYWxhbmNpbmdDb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubG9hZEJhbGFuY2luZ0NvbmZpZy5wdXNoKCgwLCBsb2FkX2JhbGFuY2VyXzEudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKShjb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogaW52YWxpZCBsb2FkQmFsYW5jaW5nQ29uZmlnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdtZXRob2RDb25maWcnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoubWV0aG9kQ29uZmlnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXRob2RDb25maWcgb2Ygb2JqLm1ldGhvZENvbmZpZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tZXRob2RDb25maWcucHVzaCh2YWxpZGF0ZU1ldGhvZENvbmZpZyhtZXRob2RDb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3JldHJ5VGhyb3R0bGluZycgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdC5yZXRyeVRocm90dGxpbmcgPSB2YWxpZGF0ZVJldHJ5VGhyb3R0bGluZyhvYmoucmV0cnlUaHJvdHRsaW5nKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgbWV0aG9kIG5hbWUgdW5pcXVlbmVzc1xuICAgIGNvbnN0IHNlZW5NZXRob2ROYW1lcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbWV0aG9kQ29uZmlnIG9mIHJlc3VsdC5tZXRob2RDb25maWcpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1ldGhvZENvbmZpZy5uYW1lKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZW5OYW1lIG9mIHNlZW5NZXRob2ROYW1lcykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlZW5OYW1lLnNlcnZpY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgbmFtZS5tZXRob2QgPT09IHNlZW5OYW1lLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VydmljZSBjb25maWc6IGR1cGxpY2F0ZSBuYW1lICR7bmFtZS5zZXJ2aWNlfS8ke25hbWUubWV0aG9kfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5NZXRob2ROYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IHZhbGlkYXRlU2VydmljZUNvbmZpZztcbmZ1bmN0aW9uIHZhbGlkYXRlQ2FuYXJ5Q29uZmlnKG9iaikge1xuICAgIGlmICghKCdzZXJ2aWNlQ29uZmlnJyBpbiBvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IG1pc3Npbmcgc2VydmljZSBjb25maWcnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzZXJ2aWNlQ29uZmlnOiB2YWxpZGF0ZVNlcnZpY2VDb25maWcob2JqLnNlcnZpY2VDb25maWcpLFxuICAgIH07XG4gICAgaWYgKCdjbGllbnRMYW5ndWFnZScgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5jbGllbnRMYW5ndWFnZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jbGllbnRMYW5ndWFnZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5nIG9mIG9iai5jbGllbnRMYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFuZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNsaWVudExhbmd1YWdlLnB1c2gobGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudExhbmd1YWdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRMYW5ndWFnZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnY2xpZW50SG9zdG5hbWUnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmouY2xpZW50SG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY2xpZW50SG9zdG5hbWUgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFuZyBvZiBvYmouY2xpZW50SG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jbGllbnRIb3N0bmFtZS5wdXNoKGxhbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRIb3N0bmFtZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgY2xpZW50SG9zdG5hbWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3BlcmNlbnRhZ2UnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5wZXJjZW50YWdlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgMCA8PSBvYmoucGVyY2VudGFnZSAmJlxuICAgICAgICAgICAgb2JqLnBlcmNlbnRhZ2UgPD0gMTAwKSB7XG4gICAgICAgICAgICByZXN1bHQucGVyY2VudGFnZSA9IG9iai5wZXJjZW50YWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBwZXJjZW50YWdlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgdGhhdCBubyB1bmV4cGVjdGVkIGZpZWxkcyBhcmUgcHJlc2VudFxuICAgIGNvbnN0IGFsbG93ZWRGaWVsZHMgPSBbXG4gICAgICAgICdjbGllbnRMYW5ndWFnZScsXG4gICAgICAgICdwZXJjZW50YWdlJyxcbiAgICAgICAgJ2NsaWVudEhvc3RuYW1lJyxcbiAgICAgICAgJ3NlcnZpY2VDb25maWcnLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBmaWVsZCBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFhbGxvd2VkRmllbGRzLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogdW5leHBlY3RlZCBmaWVsZCAke2ZpZWxkfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFNlbGVjdENhbmFyeUNvbmZpZyhvYmosIHBlcmNlbnRhZ2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgbGlzdCcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBvYmopIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkQ29uZmlnID0gdmFsaWRhdGVDYW5hcnlDb25maWcoY29uZmlnKTtcbiAgICAgICAgLyogRm9yIGVhY2ggZmllbGQsIHdlIGNoZWNrIGlmIGl0IGlzIHByZXNlbnQsIHRoZW4gb25seSBkaXNjYXJkIHRoZVxuICAgICAgICAgKiBjb25maWcgaWYgdGhlIGZpZWxkIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IGNsaWVudCAqL1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlZENvbmZpZy5wZXJjZW50YWdlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgcGVyY2VudGFnZSA+IHZhbGlkYXRlZENvbmZpZy5wZXJjZW50YWdlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0ZWRDb25maWcuY2xpZW50SG9zdG5hbWUpKSB7XG4gICAgICAgICAgICBsZXQgaG9zdG5hbWVNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhvc3RuYW1lIG9mIHZhbGlkYXRlZENvbmZpZy5jbGllbnRIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChob3N0bmFtZSA9PT0gb3MuaG9zdG5hbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaG9zdG5hbWVNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdGVkQ29uZmlnLmNsaWVudExhbmd1YWdlKSkge1xuICAgICAgICAgICAgbGV0IGxhbmd1YWdlTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5ndWFnZSBvZiB2YWxpZGF0ZWRDb25maWcuY2xpZW50TGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2UgPT09IENMSUVOVF9MQU5HVUFHRV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxhbmd1YWdlTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRDb25maWcuc2VydmljZUNvbmZpZztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBtYXRjaGluZyBzZXJ2aWNlIGNvbmZpZyBmb3VuZCcpO1xufVxuLyoqXG4gKiBGaW5kIHRoZSBcImdycGNfY29uZmlnXCIgcmVjb3JkIGFtb25nIHRoZSBUWFQgcmVjb3JkcywgcGFyc2UgaXRzIHZhbHVlIGFzIEpTT04sIHZhbGlkYXRlIGl0cyBjb250ZW50cyxcbiAqIGFuZCBzZWxlY3QgYSBzZXJ2aWNlIGNvbmZpZyB3aXRoIHNlbGVjdGlvbiBmaWVsZHMgdGhhdCBhbGwgbWF0Y2ggdGhpcyBjbGllbnQuIE1vc3Qgb2YgdGhlc2Ugc3RlcHNcbiAqIGNhbiBmYWlsIHdpdGggYW4gZXJyb3I7IHRoZSBjYWxsZXIgbXVzdCBoYW5kbGUgYW55IGVycm9ycyB0aHJvd24gdGhpcyB3YXkuXG4gKiBAcGFyYW0gdHh0UmVjb3JkIFRoZSBUWFQgcmVjb3JkIGFycmF5IHRoYXQgaXMgb3V0cHV0IGZyb20gYSBzdWNjZXNzZnVsIGNhbGwgdG8gZG5zLnJlc29sdmVUeHRcbiAqIEBwYXJhbSBwZXJjZW50YWdlIEEgbnVtYmVyIGNob3NlbiBmcm9tIHRoZSByYW5nZSBbMCwgMTAwKSB0aGF0IGlzIHVzZWQgdG8gc2VsZWN0IHdoaWNoIGNvbmZpZyB0byB1c2VcbiAqIEByZXR1cm4gVGhlIHNlcnZpY2UgY29uZmlndXJhdGlvbiB0byB1c2UsIGdpdmVuIHRoZSBwZXJjZW50YWdlIHZhbHVlLCBvciBudWxsIGlmIHRoZSBzZXJ2aWNlIGNvbmZpZ1xuICogICAgIGRhdGEgaGFzIGEgdmFsaWQgZm9ybWF0IGJ1dCBub25lIG9mIHRoZSBvcHRpb25zIG1hdGNoIHRoZSBjdXJyZW50IGNsaWVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcodHh0UmVjb3JkLCBwZXJjZW50YWdlKSB7XG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgdHh0UmVjb3JkKSB7XG4gICAgICAgIGlmIChyZWNvcmQubGVuZ3RoID4gMCAmJiByZWNvcmRbMF0uc3RhcnRzV2l0aCgnZ3JwY19jb25maWc9JykpIHtcbiAgICAgICAgICAgIC8qIFRyZWF0IHRoZSBsaXN0IG9mIHN0cmluZ3MgaW4gdGhpcyByZWNvcmQgYXMgYSBzaW5nbGUgc3RyaW5nIGFuZCByZW1vdmVcbiAgICAgICAgICAgICAqIFwiZ3JwY19jb25maWc9XCIgZnJvbSB0aGUgYmVnaW5uaW5nLiBUaGUgcmVzdCBzaG91bGQgYmUgYSBKU09OIHN0cmluZyAqL1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkU3RyaW5nID0gcmVjb3JkLmpvaW4oJycpLnN1YnN0cmluZygnZ3JwY19jb25maWc9Jy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkSnNvbiA9IEpTT04ucGFyc2UocmVjb3JkU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUFuZFNlbGVjdENhbmFyeUNvbmZpZyhyZWNvcmRKc29uLCBwZXJjZW50YWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcgPSBleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZpY2UtY29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnIiwidmFsaWRhdGVTZXJ2aWNlQ29uZmlnIiwidmFsaWRhdGVSZXRyeVRocm90dGxpbmciLCJvcyIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsImxvYWRfYmFsYW5jZXJfMSIsIkRVUkFUSU9OX1JFR0VYIiwiQ0xJRU5UX0xBTkdVQUdFX1NUUklORyIsInZhbGlkYXRlTmFtZSIsIm9iaiIsInNlcnZpY2UiLCJFcnJvciIsIm1ldGhvZCIsInVuZGVmaW5lZCIsInZhbGlkYXRlUmV0cnlQb2xpY3kiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJtYXhBdHRlbXB0cyIsImluaXRpYWxCYWNrb2ZmIiwidGVzdCIsIm1heEJhY2tvZmYiLCJiYWNrb2ZmTXVsdGlwbGllciIsIkFycmF5IiwiaXNBcnJheSIsInJldHJ5YWJsZVN0YXR1c0NvZGVzIiwibGVuZ3RoIiwidmFsdWVzIiwiU3RhdHVzIiwiaW5jbHVkZXMiLCJ0b1VwcGVyQ2FzZSIsInZhbGlkYXRlSGVkZ2luZ1BvbGljeSIsImhlZGdpbmdEZWxheSIsIm5vbkZhdGFsU3RhdHVzQ29kZXMiLCJyZXN1bHQiLCJ2YWxpZGF0ZU1ldGhvZENvbmZpZyIsIl9hIiwibmFtZSIsInB1c2giLCJ3YWl0Rm9yUmVhZHkiLCJ0aW1lb3V0Iiwic2Vjb25kcyIsIm5hbm9zIiwidGltZW91dFBhcnRzIiwic3Vic3RyaW5nIiwic3BsaXQiLCJtYXhSZXF1ZXN0Qnl0ZXMiLCJtYXhSZXNwb25zZUJ5dGVzIiwicmV0cnlQb2xpY3kiLCJoZWRnaW5nUG9saWN5IiwibWF4VG9rZW5zIiwidG9rZW5SYXRpbyIsInRvRml4ZWQiLCJsb2FkQmFsYW5jaW5nQ29uZmlnIiwibWV0aG9kQ29uZmlnIiwibG9hZEJhbGFuY2luZ1BvbGljeSIsImNvbmZpZyIsInZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyIsInJldHJ5VGhyb3R0bGluZyIsInNlZW5NZXRob2ROYW1lcyIsInNlZW5OYW1lIiwidmFsaWRhdGVDYW5hcnlDb25maWciLCJzZXJ2aWNlQ29uZmlnIiwiY2xpZW50TGFuZ3VhZ2UiLCJsYW5nIiwiY2xpZW50SG9zdG5hbWUiLCJwZXJjZW50YWdlIiwiYWxsb3dlZEZpZWxkcyIsImZpZWxkIiwidmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWciLCJ2YWxpZGF0ZWRDb25maWciLCJob3N0bmFtZU1hdGNoZWQiLCJob3N0bmFtZSIsImxhbmd1YWdlTWF0Y2hlZCIsImxhbmd1YWdlIiwidHh0UmVjb3JkIiwicmVjb3JkIiwic3RhcnRzV2l0aCIsInJlY29yZFN0cmluZyIsImpvaW4iLCJyZWNvcmRKc29uIiwiSlNPTiIsInBhcnNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/status-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StatusBuilder = void 0;\n/**\n * A builder for gRPC status objects.\n */ class StatusBuilder {\n    constructor(){\n        this.code = null;\n        this.details = null;\n        this.metadata = null;\n    }\n    /**\n     * Adds a status code to the builder.\n     */ withCode(code) {\n        this.code = code;\n        return this;\n    }\n    /**\n     * Adds details to the builder.\n     */ withDetails(details) {\n        this.details = details;\n        return this;\n    }\n    /**\n     * Adds metadata to the builder.\n     */ withMetadata(metadata) {\n        this.metadata = metadata;\n        return this;\n    }\n    /**\n     * Builds the status object.\n     */ build() {\n        const status = {};\n        if (this.code !== null) {\n            status.code = this.code;\n        }\n        if (this.details !== null) {\n            status.details = this.details;\n        }\n        if (this.metadata !== null) {\n            status.metadata = this.metadata;\n        }\n        return status;\n    }\n}\nexports.StatusBuilder = StatusBuilder; //# sourceMappingURL=status-builder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0I7O0NBRUMsR0FDRCxNQUFNRTtJQUNGQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ3BCO0lBQ0E7O0tBRUMsR0FDREMsU0FBU0gsSUFBSSxFQUFFO1FBQ1gsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNESSxZQUFZSCxPQUFPLEVBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNESSxhQUFhSCxRQUFRLEVBQUU7UUFDbkIsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO1FBQ2hCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7O0tBRUMsR0FDREksUUFBUTtRQUNKLE1BQU1DLFNBQVMsQ0FBQztRQUNoQixJQUFJLElBQUksQ0FBQ1AsSUFBSSxLQUFLLE1BQU07WUFDcEJPLE9BQU9QLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7UUFDM0I7UUFDQSxJQUFJLElBQUksQ0FBQ0MsT0FBTyxLQUFLLE1BQU07WUFDdkJNLE9BQU9OLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU87UUFDakM7UUFDQSxJQUFJLElBQUksQ0FBQ0MsUUFBUSxLQUFLLE1BQU07WUFDeEJLLE9BQU9MLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7UUFDbkM7UUFDQSxPQUFPSztJQUNYO0FBQ0o7QUFDQVgscUJBQXFCLEdBQUdFLGVBQ3hCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N0YXR1cy1idWlsZGVyLmpzP2QyOTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IHZvaWQgMDtcbi8qKlxuICogQSBidWlsZGVyIGZvciBnUlBDIHN0YXR1cyBvYmplY3RzLlxuICovXG5jbGFzcyBTdGF0dXNCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdGF0dXMgY29kZSB0byB0aGUgYnVpbGRlci5cbiAgICAgKi9cbiAgICB3aXRoQ29kZShjb2RlKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGRldGFpbHMgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgd2l0aERldGFpbHMoZGV0YWlscykge1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBtZXRhZGF0YSB0byB0aGUgYnVpbGRlci5cbiAgICAgKi9cbiAgICB3aXRoTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBzdGF0dXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGJ1aWxkKCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuY29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdHVzLmNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGV0YWlscyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgPSB0aGlzLmRldGFpbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXR1cy5tZXRhZGF0YSA9IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLlN0YXR1c0J1aWxkZXIgPSBTdGF0dXNCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdHVzLWJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3RhdHVzQnVpbGRlciIsImNvbnN0cnVjdG9yIiwiY29kZSIsImRldGFpbHMiLCJtZXRhZGF0YSIsIndpdGhDb2RlIiwid2l0aERldGFpbHMiLCJ3aXRoTWV0YWRhdGEiLCJidWlsZCIsInN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/stream-decoder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function(ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n    constructor(){\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n    }\n    write(data) {\n        let readHead = 0;\n        let toRead;\n        const result = [];\n        while(readHead < data.length){\n            switch(this.readState){\n                case ReadState.NO_DATA:\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\n                    readHead += 1;\n                    this.readState = ReadState.READING_SIZE;\n                    this.readPartialSize.fill(0);\n                    this.readSizeRemaining = 4;\n                    this.readMessageSize = 0;\n                    this.readMessageRemaining = 0;\n                    this.readPartialMessage = [];\n                    break;\n                case ReadState.READING_SIZE:\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                    this.readSizeRemaining -= toRead;\n                    readHead += toRead;\n                    // readSizeRemaining >=0 here\n                    if (this.readSizeRemaining === 0) {\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                        this.readMessageRemaining = this.readMessageSize;\n                        if (this.readMessageRemaining > 0) {\n                            this.readState = ReadState.READING_MESSAGE;\n                        } else {\n                            const message = Buffer.concat([\n                                this.readCompressFlag,\n                                this.readPartialSize\n                            ], 5);\n                            this.readState = ReadState.NO_DATA;\n                            result.push(message);\n                        }\n                    }\n                    break;\n                case ReadState.READING_MESSAGE:\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                    this.readMessageRemaining -= toRead;\n                    readHead += toRead;\n                    // readMessageRemaining >=0 here\n                    if (this.readMessageRemaining === 0) {\n                        // At this point, we have read a full message\n                        const framedMessageBuffers = [\n                            this.readCompressFlag,\n                            this.readPartialSize\n                        ].concat(this.readPartialMessage);\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                        this.readState = ReadState.NO_DATA;\n                        result.push(framedMessage);\n                    }\n                    break;\n                default:\n                    throw new Error(\"Unexpected read state\");\n            }\n        }\n        return result;\n    }\n}\nexports.StreamDecoder = StreamDecoder; //# sourceMappingURL=stream-decoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RyZWFtLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBRyxLQUFLO0FBQzdCLElBQUlHO0FBQ0gsVUFBVUEsU0FBUztJQUNoQkEsU0FBUyxDQUFDQSxTQUFTLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUN0Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUMzQ0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsa0JBQWtCLEdBQUcsRUFBRSxHQUFHO0FBQ2xELEdBQUdBLGFBQWNBLENBQUFBLFlBQVksQ0FBQztBQUM5QixNQUFNRDtJQUNGRSxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxTQUFTLEdBQUdGLFVBQVVHLE9BQU87UUFDbEMsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0MsTUFBTUEsQ0FBQ0MsS0FBSyxDQUFDO1FBQ3JDLElBQUksQ0FBQ0MsZUFBZSxHQUFHRixNQUFNQSxDQUFDQyxLQUFLLENBQUM7UUFDcEMsSUFBSSxDQUFDRSxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNDLGtCQUFrQixHQUFHLEVBQUU7UUFDNUIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztJQUNoQztJQUNBQyxNQUFNQyxJQUFJLEVBQUU7UUFDUixJQUFJQyxXQUFXO1FBQ2YsSUFBSUM7UUFDSixNQUFNQyxTQUFTLEVBQUU7UUFDakIsTUFBT0YsV0FBV0QsS0FBS0ksTUFBTSxDQUFFO1lBQzNCLE9BQVEsSUFBSSxDQUFDZixTQUFTO2dCQUNsQixLQUFLRixVQUFVRyxPQUFPO29CQUNsQixJQUFJLENBQUNDLGdCQUFnQixHQUFHUyxLQUFLSyxLQUFLLENBQUNKLFVBQVVBLFdBQVc7b0JBQ3hEQSxZQUFZO29CQUNaLElBQUksQ0FBQ1osU0FBUyxHQUFHRixVQUFVbUIsWUFBWTtvQkFDdkMsSUFBSSxDQUFDWixlQUFlLENBQUNhLElBQUksQ0FBQztvQkFDMUIsSUFBSSxDQUFDWixpQkFBaUIsR0FBRztvQkFDekIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7b0JBQ3ZCLElBQUksQ0FBQ0Usb0JBQW9CLEdBQUc7b0JBQzVCLElBQUksQ0FBQ0Qsa0JBQWtCLEdBQUcsRUFBRTtvQkFDNUI7Z0JBQ0osS0FBS1YsVUFBVW1CLFlBQVk7b0JBQ3ZCSixTQUFTTSxLQUFLQyxHQUFHLENBQUNULEtBQUtJLE1BQU0sR0FBR0gsVUFBVSxJQUFJLENBQUNOLGlCQUFpQjtvQkFDaEVLLEtBQUtVLElBQUksQ0FBQyxJQUFJLENBQUNoQixlQUFlLEVBQUUsSUFBSSxJQUFJLENBQUNDLGlCQUFpQixFQUFFTSxVQUFVQSxXQUFXQztvQkFDakYsSUFBSSxDQUFDUCxpQkFBaUIsSUFBSU87b0JBQzFCRCxZQUFZQztvQkFDWiw2QkFBNkI7b0JBQzdCLElBQUksSUFBSSxDQUFDUCxpQkFBaUIsS0FBSyxHQUFHO3dCQUM5QixJQUFJLENBQUNDLGVBQWUsR0FBRyxJQUFJLENBQUNGLGVBQWUsQ0FBQ2lCLFlBQVksQ0FBQzt3QkFDekQsSUFBSSxDQUFDYixvQkFBb0IsR0FBRyxJQUFJLENBQUNGLGVBQWU7d0JBQ2hELElBQUksSUFBSSxDQUFDRSxvQkFBb0IsR0FBRyxHQUFHOzRCQUMvQixJQUFJLENBQUNULFNBQVMsR0FBR0YsVUFBVXlCLGVBQWU7d0JBQzlDLE9BQ0s7NEJBQ0QsTUFBTUMsVUFBVXJCLE1BQU1BLENBQUNzQixNQUFNLENBQUM7Z0NBQUMsSUFBSSxDQUFDdkIsZ0JBQWdCO2dDQUFFLElBQUksQ0FBQ0csZUFBZTs2QkFBQyxFQUFFOzRCQUM3RSxJQUFJLENBQUNMLFNBQVMsR0FBR0YsVUFBVUcsT0FBTzs0QkFDbENhLE9BQU9ZLElBQUksQ0FBQ0Y7d0JBQ2hCO29CQUNKO29CQUNBO2dCQUNKLEtBQUsxQixVQUFVeUIsZUFBZTtvQkFDMUJWLFNBQVNNLEtBQUtDLEdBQUcsQ0FBQ1QsS0FBS0ksTUFBTSxHQUFHSCxVQUFVLElBQUksQ0FBQ0gsb0JBQW9CO29CQUNuRSxJQUFJLENBQUNELGtCQUFrQixDQUFDa0IsSUFBSSxDQUFDZixLQUFLSyxLQUFLLENBQUNKLFVBQVVBLFdBQVdDO29CQUM3RCxJQUFJLENBQUNKLG9CQUFvQixJQUFJSTtvQkFDN0JELFlBQVlDO29CQUNaLGdDQUFnQztvQkFDaEMsSUFBSSxJQUFJLENBQUNKLG9CQUFvQixLQUFLLEdBQUc7d0JBQ2pDLDZDQUE2Qzt3QkFDN0MsTUFBTWtCLHVCQUF1Qjs0QkFDekIsSUFBSSxDQUFDekIsZ0JBQWdCOzRCQUNyQixJQUFJLENBQUNHLGVBQWU7eUJBQ3ZCLENBQUNvQixNQUFNLENBQUMsSUFBSSxDQUFDakIsa0JBQWtCO3dCQUNoQyxNQUFNb0IsZ0JBQWdCekIsTUFBTUEsQ0FBQ3NCLE1BQU0sQ0FBQ0Usc0JBQXNCLElBQUksQ0FBQ3BCLGVBQWUsR0FBRzt3QkFDakYsSUFBSSxDQUFDUCxTQUFTLEdBQUdGLFVBQVVHLE9BQU87d0JBQ2xDYSxPQUFPWSxJQUFJLENBQUNFO29CQUNoQjtvQkFDQTtnQkFDSjtvQkFDSSxNQUFNLElBQUlDLE1BQU07WUFDeEI7UUFDSjtRQUNBLE9BQU9mO0lBQ1g7QUFDSjtBQUNBbkIscUJBQXFCLEdBQUdFLGVBQ3hCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N0cmVhbS1kZWNvZGVyLmpzPzZjYjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RyZWFtRGVjb2RlciA9IHZvaWQgMDtcbnZhciBSZWFkU3RhdGU7XG4oZnVuY3Rpb24gKFJlYWRTdGF0ZSkge1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJOT19EQVRBXCJdID0gMF0gPSBcIk5PX0RBVEFcIjtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiUkVBRElOR19TSVpFXCJdID0gMV0gPSBcIlJFQURJTkdfU0laRVwiO1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJSRUFESU5HX01FU1NBR0VcIl0gPSAyXSA9IFwiUkVBRElOR19NRVNTQUdFXCI7XG59KShSZWFkU3RhdGUgfHwgKFJlYWRTdGF0ZSA9IHt9KSk7XG5jbGFzcyBTdHJlYW1EZWNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZSA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyA9IDQ7XG4gICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gMDtcbiAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UgPSBbXTtcbiAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IDA7XG4gICAgfVxuICAgIHdyaXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlYWRIZWFkID0gMDtcbiAgICAgICAgbGV0IHRvUmVhZDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChyZWFkSGVhZCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucmVhZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuTk9fREFUQTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gZGF0YS5zbGljZShyZWFkSGVhZCwgcmVhZEhlYWQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEhlYWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuUkVBRElOR19TSVpFO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZS5maWxsKDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTaXplUmVtYWluaW5nID0gNDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuUkVBRElOR19TSVpFOlxuICAgICAgICAgICAgICAgICAgICB0b1JlYWQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIHJlYWRIZWFkLCB0aGlzLnJlYWRTaXplUmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jb3B5KHRoaXMucmVhZFBhcnRpYWxTaXplLCA0IC0gdGhpcy5yZWFkU2l6ZVJlbWFpbmluZywgcmVhZEhlYWQsIHJlYWRIZWFkICsgdG9SZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyAtPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZFNpemVSZW1haW5pbmcgPj0wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZFNpemVSZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gdGhpcy5yZWFkUGFydGlhbFNpemUucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IHRoaXMucmVhZE1lc3NhZ2VTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuUkVBRElOR19NRVNTQUdFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMucmVhZENvbXByZXNzRmxhZywgdGhpcy5yZWFkUGFydGlhbFNpemVdLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5OT19EQVRBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVhZFN0YXRlLlJFQURJTkdfTUVTU0FHRTpcbiAgICAgICAgICAgICAgICAgICAgdG9SZWFkID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSByZWFkSGVhZCwgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlLnB1c2goZGF0YS5zbGljZShyZWFkSGVhZCwgcmVhZEhlYWQgKyB0b1JlYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyAtPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZE1lc3NhZ2VSZW1haW5pbmcgPj0wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgcmVhZCBhIGZ1bGwgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJhbWVkTWVzc2FnZUJ1ZmZlcnMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQodGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJhbWVkTWVzc2FnZSA9IEJ1ZmZlci5jb25jYXQoZnJhbWVkTWVzc2FnZUJ1ZmZlcnMsIHRoaXMucmVhZE1lc3NhZ2VTaXplICsgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5OT19EQVRBO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHJlYWQgc3RhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyZWFtRGVjb2RlciA9IFN0cmVhbURlY29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJlYW0tZGVjb2Rlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdHJlYW1EZWNvZGVyIiwiUmVhZFN0YXRlIiwiY29uc3RydWN0b3IiLCJyZWFkU3RhdGUiLCJOT19EQVRBIiwicmVhZENvbXByZXNzRmxhZyIsIkJ1ZmZlciIsImFsbG9jIiwicmVhZFBhcnRpYWxTaXplIiwicmVhZFNpemVSZW1haW5pbmciLCJyZWFkTWVzc2FnZVNpemUiLCJyZWFkUGFydGlhbE1lc3NhZ2UiLCJyZWFkTWVzc2FnZVJlbWFpbmluZyIsIndyaXRlIiwiZGF0YSIsInJlYWRIZWFkIiwidG9SZWFkIiwicmVzdWx0IiwibGVuZ3RoIiwic2xpY2UiLCJSRUFESU5HX1NJWkUiLCJmaWxsIiwiTWF0aCIsIm1pbiIsImNvcHkiLCJyZWFkVUludDMyQkUiLCJSRUFESU5HX01FU1NBR0UiLCJtZXNzYWdlIiwiY29uY2F0IiwicHVzaCIsImZyYW1lZE1lc3NhZ2VCdWZmZXJzIiwiZnJhbWVkTWVzc2FnZSIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.stringToSubchannelAddress = exports.subchannelAddressToString = exports.subchannelAddressEqual = exports.isTcpSubchannelAddress = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction isTcpSubchannelAddress(address) {\n    return \"port\" in address;\n}\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nfunction subchannelAddressEqual(address1, address2) {\n    if (!address1 && !address2) {\n        return true;\n    }\n    if (!address1 || !address2) {\n        return false;\n    }\n    if (isTcpSubchannelAddress(address1)) {\n        return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;\n    } else {\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n    }\n}\nexports.subchannelAddressEqual = subchannelAddressEqual;\nfunction subchannelAddressToString(address) {\n    if (isTcpSubchannelAddress(address)) {\n        return address.host + \":\" + address.port;\n    } else {\n        return address.path;\n    }\n}\nexports.subchannelAddressToString = subchannelAddressToString;\nconst DEFAULT_PORT = 443;\nfunction stringToSubchannelAddress(addressString, port) {\n    if ((0, net_1.isIP)(addressString)) {\n        return {\n            host: addressString,\n            port: port !== null && port !== void 0 ? port : DEFAULT_PORT\n        };\n    } else {\n        return {\n            path: addressString\n        };\n    }\n}\nexports.stringToSubchannelAddress = stringToSubchannelAddress; //# sourceMappingURL=subchannel-address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQ0FBaUMsR0FBR0EsaUNBQWlDLEdBQUdBLDhCQUE4QixHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQy9JLE1BQU1NLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLFNBQVNGLHVCQUF1QkcsT0FBTztJQUNuQyxPQUFPLFVBQVVBO0FBQ3JCO0FBQ0FSLDhCQUE4QixHQUFHSztBQUNqQyxTQUFTRCx1QkFBdUJLLFFBQVEsRUFBRUMsUUFBUTtJQUM5QyxJQUFJLENBQUNELFlBQVksQ0FBQ0MsVUFBVTtRQUN4QixPQUFPO0lBQ1g7SUFDQSxJQUFJLENBQUNELFlBQVksQ0FBQ0MsVUFBVTtRQUN4QixPQUFPO0lBQ1g7SUFDQSxJQUFJTCx1QkFBdUJJLFdBQVc7UUFDbEMsT0FBUUosdUJBQXVCSyxhQUMzQkQsU0FBU0UsSUFBSSxLQUFLRCxTQUFTQyxJQUFJLElBQy9CRixTQUFTRyxJQUFJLEtBQUtGLFNBQVNFLElBQUk7SUFDdkMsT0FDSztRQUNELE9BQU8sQ0FBQ1AsdUJBQXVCSyxhQUFhRCxTQUFTSSxJQUFJLEtBQUtILFNBQVNHLElBQUk7SUFDL0U7QUFDSjtBQUNBYiw4QkFBOEIsR0FBR0k7QUFDakMsU0FBU0QsMEJBQTBCSyxPQUFPO0lBQ3RDLElBQUlILHVCQUF1QkcsVUFBVTtRQUNqQyxPQUFPQSxRQUFRRyxJQUFJLEdBQUcsTUFBTUgsUUFBUUksSUFBSTtJQUM1QyxPQUNLO1FBQ0QsT0FBT0osUUFBUUssSUFBSTtJQUN2QjtBQUNKO0FBQ0FiLGlDQUFpQyxHQUFHRztBQUNwQyxNQUFNVyxlQUFlO0FBQ3JCLFNBQVNaLDBCQUEwQmEsYUFBYSxFQUFFSCxJQUFJO0lBQ2xELElBQUksQ0FBQyxHQUFHTixNQUFNVSxJQUFJLEVBQUVELGdCQUFnQjtRQUNoQyxPQUFPO1lBQ0hKLE1BQU1JO1lBQ05ILE1BQU1BLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUlBLE9BQU9FO1FBQ3BEO0lBQ0osT0FDSztRQUNELE9BQU87WUFDSEQsTUFBTUU7UUFDVjtJQUNKO0FBQ0o7QUFDQWYsaUNBQWlDLEdBQUdFLDJCQUNwQyw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWFkZHJlc3MuanM/YmEzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc0VxdWFsID0gZXhwb3J0cy5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuZnVuY3Rpb24gaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgcmV0dXJuICdwb3J0JyBpbiBhZGRyZXNzO1xufVxuZXhwb3J0cy5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzID0gaXNUY3BTdWJjaGFubmVsQWRkcmVzcztcbmZ1bmN0aW9uIHN1YmNoYW5uZWxBZGRyZXNzRXF1YWwoYWRkcmVzczEsIGFkZHJlc3MyKSB7XG4gICAgaWYgKCFhZGRyZXNzMSAmJiAhYWRkcmVzczIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYWRkcmVzczEgfHwgIWFkZHJlc3MyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzczEpKSB7XG4gICAgICAgIHJldHVybiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMikgJiZcbiAgICAgICAgICAgIGFkZHJlc3MxLmhvc3QgPT09IGFkZHJlc3MyLmhvc3QgJiZcbiAgICAgICAgICAgIGFkZHJlc3MxLnBvcnQgPT09IGFkZHJlc3MyLnBvcnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICFpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MyKSAmJiBhZGRyZXNzMS5wYXRoID09PSBhZGRyZXNzMi5wYXRoO1xuICAgIH1cbn1cbmV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NFcXVhbCA9IHN1YmNoYW5uZWxBZGRyZXNzRXF1YWw7XG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpIHtcbiAgICBpZiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5ob3N0ICsgJzonICsgYWRkcmVzcy5wb3J0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3MucGF0aDtcbiAgICB9XG59XG5leHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcgPSBzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nO1xuY29uc3QgREVGQVVMVF9QT1JUID0gNDQzO1xuZnVuY3Rpb24gc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzU3RyaW5nLCBwb3J0KSB7XG4gICAgaWYgKCgwLCBuZXRfMS5pc0lQKShhZGRyZXNzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9zdDogYWRkcmVzc1N0cmluZyxcbiAgICAgICAgICAgIHBvcnQ6IHBvcnQgIT09IG51bGwgJiYgcG9ydCAhPT0gdm9pZCAwID8gcG9ydCA6IERFRkFVTFRfUE9SVCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoOiBhZGRyZXNzU3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyA9IHN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJzdWJjaGFubmVsQWRkcmVzc0VxdWFsIiwiaXNUY3BTdWJjaGFubmVsQWRkcmVzcyIsIm5ldF8xIiwicmVxdWlyZSIsImFkZHJlc3MiLCJhZGRyZXNzMSIsImFkZHJlc3MyIiwiaG9zdCIsInBvcnQiLCJwYXRoIiwiREVGQVVMVF9QT1JUIiwiYWRkcmVzc1N0cmluZyIsImlzSVAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-call.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2SubchannelCall = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"subchannel_call\";\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */ function getSystemErrorName(errno) {\n    for (const [name, num] of Object.entries(os.constants.errno)){\n        if (num === errno) {\n            return name;\n        }\n    }\n    return \"Unknown system error \" + errno;\n}\nclass Http2SubchannelCall {\n    constructor(http2Stream, callEventTracker, listener, transport, callId){\n        this.http2Stream = http2Stream;\n        this.callEventTracker = callEventTracker;\n        this.listener = listener;\n        this.transport = transport;\n        this.callId = callId;\n        this.decoder = new stream_decoder_1.StreamDecoder();\n        this.isReadFilterPending = false;\n        this.isPushPending = false;\n        this.canPush = false;\n        /**\n         * Indicates that an 'end' event has come from the http2 stream, so there\n         * will be no more data events.\n         */ this.readsClosed = false;\n        this.statusOutput = false;\n        this.unpushedReadMessages = [];\n        // Status code mapped from :status. To be used if grpc-status is not received\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.internalError = null;\n        http2Stream.on(\"response\", (headers, flags)=>{\n            let headersString = \"\";\n            for (const header of Object.keys(headers)){\n                headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n            }\n            this.trace(\"Received server headers:\\n\" + headersString);\n            switch(headers[\":status\"]){\n                // TODO(murgatroid99): handle 100 and 101\n                case 400:\n                    this.mappedStatusCode = constants_1.Status.INTERNAL;\n                    break;\n                case 401:\n                    this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n                    break;\n                case 403:\n                    this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n                    break;\n                case 404:\n                    this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n                    break;\n                case 429:\n                case 502:\n                case 503:\n                case 504:\n                    this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n                    break;\n                default:\n                    this.mappedStatusCode = constants_1.Status.UNKNOWN;\n            }\n            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                this.handleTrailers(headers);\n            } else {\n                let metadata;\n                try {\n                    metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                } catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNKNOWN,\n                        details: error.message,\n                        metadata: new metadata_1.Metadata()\n                    });\n                    return;\n                }\n                this.listener.onReceiveMetadata(metadata);\n            }\n        });\n        http2Stream.on(\"trailers\", (headers)=>{\n            this.handleTrailers(headers);\n        });\n        http2Stream.on(\"data\", (data)=>{\n            /* If the status has already been output, allow the http2 stream to\n             * drain without processing the data. */ if (this.statusOutput) {\n                return;\n            }\n            this.trace(\"receive HTTP/2 data frame of length \" + data.length);\n            const messages = this.decoder.write(data);\n            for (const message of messages){\n                this.trace(\"parsed message of length \" + message.length);\n                this.callEventTracker.addMessageReceived();\n                this.tryPush(message);\n            }\n        });\n        http2Stream.on(\"end\", ()=>{\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n        });\n        http2Stream.on(\"close\", ()=>{\n            /* Use process.next tick to ensure that this code happens after any\n             * \"error\" event that may be emitted at about the same time, so that\n             * we can bubble up the error message from that event. */ process.nextTick(()=>{\n                var _a;\n                this.trace(\"HTTP/2 stream closed with code \" + http2Stream.rstCode);\n                /* If we have a final status with an OK status code, that means that\n                 * we have received all of the messages and we have processed the\n                 * trailers and the call completed successfully, so it doesn't matter\n                 * how the stream ends after that */ if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                    return;\n                }\n                let code;\n                let details = \"\";\n                switch(http2Stream.rstCode){\n                    case http2.constants.NGHTTP2_NO_ERROR:\n                        /* If we get a NO_ERROR code and we already have a status, the\n                         * stream completed properly and we just haven't fully processed\n                         * it yet */ if (this.finalStatus !== null) {\n                            return;\n                        }\n                        code = constants_1.Status.INTERNAL;\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n                        break;\n                    case http2.constants.NGHTTP2_REFUSED_STREAM:\n                        code = constants_1.Status.UNAVAILABLE;\n                        details = \"Stream refused by server\";\n                        break;\n                    case http2.constants.NGHTTP2_CANCEL:\n                        code = constants_1.Status.CANCELLED;\n                        details = \"Call cancelled\";\n                        break;\n                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                        code = constants_1.Status.RESOURCE_EXHAUSTED;\n                        details = \"Bandwidth exhausted or memory limit exceeded\";\n                        break;\n                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                        code = constants_1.Status.PERMISSION_DENIED;\n                        details = \"Protocol not secure enough\";\n                        break;\n                    case http2.constants.NGHTTP2_INTERNAL_ERROR:\n                        code = constants_1.Status.INTERNAL;\n                        if (this.internalError === null) {\n                            /* This error code was previously handled in the default case, and\n                             * there are several instances of it online, so I wanted to\n                             * preserve the original error message so that people find existing\n                             * information in searches, but also include the more recognizable\n                             * \"Internal server error\" message. */ details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n                        } else {\n                            if (this.internalError.code === \"ECONNRESET\" || this.internalError.code === \"ETIMEDOUT\") {\n                                code = constants_1.Status.UNAVAILABLE;\n                                details = this.internalError.message;\n                            } else {\n                                /* The \"Received RST_STREAM with code ...\" error is preserved\n                                 * here for continuity with errors reported online, but the\n                                 * error message at the end will probably be more relevant in\n                                 * most cases. */ details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                            }\n                        }\n                        break;\n                    default:\n                        code = constants_1.Status.INTERNAL;\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n                }\n                // This is a no-op if trailers were received at all.\n                // This is OK, because status codes emitted here correspond to more\n                // catastrophic issues that prevent us from receiving trailers in the\n                // first place.\n                this.endCall({\n                    code,\n                    details,\n                    metadata: new metadata_1.Metadata(),\n                    rstCode: http2Stream.rstCode\n                });\n            });\n        });\n        http2Stream.on(\"error\", (err)=>{\n            /* We need an error handler here to stop \"Uncaught Error\" exceptions\n             * from bubbling up. However, errors here should all correspond to\n             * \"close\" events, where we will handle the error more granularly */ /* Specifically looking for stream errors that were *not* constructed\n             * from a RST_STREAM response here:\n             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n             */ if (err.code !== \"ERR_HTTP2_STREAM_ERROR\") {\n                this.trace(\"Node error event: message=\" + err.message + \" code=\" + err.code + \" errno=\" + getSystemErrorName(err.errno) + \" syscall=\" + err.syscall);\n                this.internalError = err;\n            }\n            this.callEventTracker.onStreamEnd(false);\n        });\n    }\n    onDisconnect() {\n        this.endCall({\n            code: constants_1.Status.UNAVAILABLE,\n            details: \"Connection dropped\",\n            metadata: new metadata_1.Metadata()\n        });\n    }\n    outputStatus() {\n        /* Precondition: this.finalStatus !== null */ if (!this.statusOutput) {\n            this.statusOutput = true;\n            this.trace(\"ended with status: code=\" + this.finalStatus.code + ' details=\"' + this.finalStatus.details + '\"');\n            this.callEventTracker.onCallEnd(this.finalStatus);\n            /* We delay the actual action of bubbling up the status to insulate the\n             * cleanup code in this class from any errors that may be thrown in the\n             * upper layers as a result of bubbling up the status. In particular,\n             * if the status is not OK, the \"error\" event may be emitted\n             * synchronously at the top level, which will result in a thrown error if\n             * the user does not handle that event. */ process.nextTick(()=>{\n                this.listener.onReceiveStatus(this.finalStatus);\n            });\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\n             * ensure that the stream closure completes. The call stream already does\n             * not push more messages after the status is output, so the messages go\n             * nowhere either way. */ this.http2Stream.resume();\n        }\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callId + \"] \" + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */ endCall(status) {\n        /* If the status is OK and a new status comes in (e.g. from a\n         * deserialization failure), that new status takes priority */ if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n            this.finalStatus = status;\n            this.maybeOutputStatus();\n        }\n        this.destroyHttp2Stream();\n    }\n    maybeOutputStatus() {\n        if (this.finalStatus !== null) {\n            /* The combination check of readsClosed and that the two message buffer\n             * arrays are empty checks that there all incoming data has been fully\n             * processed */ if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending && !this.isPushPending) {\n                this.outputStatus();\n            }\n        }\n    }\n    push(message) {\n        this.trace(\"pushing to reader message of length \" + (message instanceof Buffer ? message.length : null));\n        this.canPush = false;\n        this.isPushPending = true;\n        process.nextTick(()=>{\n            this.isPushPending = false;\n            /* If we have already output the status any later messages should be\n             * ignored, and can cause out-of-order operation errors higher up in the\n             * stack. Checking as late as possible here to avoid any race conditions.\n             */ if (this.statusOutput) {\n                return;\n            }\n            this.listener.onReceiveMessage(message);\n            this.maybeOutputStatus();\n        });\n    }\n    tryPush(messageBytes) {\n        if (this.canPush) {\n            this.http2Stream.pause();\n            this.push(messageBytes);\n        } else {\n            this.trace(\"unpushedReadMessages.push message of length \" + messageBytes.length);\n            this.unpushedReadMessages.push(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        this.callEventTracker.onStreamEnd(true);\n        let headersString = \"\";\n        for (const header of Object.keys(headers)){\n            headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n        }\n        this.trace(\"Received server trailers:\\n\" + headersString);\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        } catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const metadataMap = metadata.getMap();\n        let code = this.mappedStatusCode;\n        if (code === constants_1.Status.UNKNOWN && typeof metadataMap[\"grpc-status\"] === \"string\") {\n            const receivedStatus = Number(metadataMap[\"grpc-status\"]);\n            if (receivedStatus in constants_1.Status) {\n                code = receivedStatus;\n                this.trace(\"received status code \" + receivedStatus + \" from server\");\n            }\n            metadata.remove(\"grpc-status\");\n        }\n        let details = \"\";\n        if (typeof metadataMap[\"grpc-message\"] === \"string\") {\n            try {\n                details = decodeURI(metadataMap[\"grpc-message\"]);\n            } catch (e) {\n                details = metadataMap[\"grpc-message\"];\n            }\n            metadata.remove(\"grpc-message\");\n            this.trace('received status details string \"' + details + '\" from server');\n        }\n        const status = {\n            code,\n            details,\n            metadata\n        };\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall(status);\n    }\n    destroyHttp2Stream() {\n        var _a;\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (!this.http2Stream.destroyed) {\n            /* If the call has ended with an OK status, communicate that when closing\n             * the stream, partly to avoid a situation in which we detect an error\n             * RST_STREAM as a result after we have the status */ let code;\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                code = http2.constants.NGHTTP2_NO_ERROR;\n            } else {\n                code = http2.constants.NGHTTP2_CANCEL;\n            }\n            this.trace(\"close http2 stream with code \" + code);\n            this.http2Stream.close(code);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        this.endCall({\n            code: status,\n            details,\n            metadata: new metadata_1.Metadata()\n        });\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        return this.transport.getPeerName();\n    }\n    getCallNumber() {\n        return this.callId;\n    }\n    startRead() {\n        /* If the stream has ended with an error, we should not emit any more\n         * messages and we should communicate that the stream has ended */ if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n            return;\n        }\n        this.canPush = true;\n        if (this.unpushedReadMessages.length > 0) {\n            const nextMessage = this.unpushedReadMessages.shift();\n            this.push(nextMessage);\n            return;\n        }\n        /* Only resume reading from the http2Stream if we don't have any pending\n         * messages to emit */ this.http2Stream.resume();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace(\"write() called with message of length \" + message.length);\n        const cb = (error)=>{\n            /* nextTick here ensures that no stream action can be taken in the call\n             * stack of the write callback, in order to hopefully work around\n             * https://github.com/nodejs/node/issues/49147 */ process.nextTick(()=>{\n                var _a;\n                let code = constants_1.Status.UNAVAILABLE;\n                if ((error === null || error === void 0 ? void 0 : error.code) === \"ERR_STREAM_WRITE_AFTER_END\") {\n                    code = constants_1.Status.INTERNAL;\n                }\n                if (error) {\n                    this.cancelWithStatus(code, `Write error: ${error.message}`);\n                }\n                (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            });\n        };\n        this.trace(\"sending data chunk of length \" + message.length);\n        this.callEventTracker.addMessageSent();\n        try {\n            this.http2Stream.write(message, cb);\n        } catch (error) {\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Write failed with error ${error.message}`,\n                metadata: new metadata_1.Metadata()\n            });\n        }\n    }\n    halfClose() {\n        this.trace(\"end() called\");\n        this.trace(\"calling end() on HTTP/2 stream\");\n        this.http2Stream.end();\n    }\n}\nexports.Http2SubchannelCall = Http2SubchannelCall; //# sourceMappingURL=subchannel-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1jYWxsLmpzIiwibWFwcGluZ3MiOiI7O0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHLEtBQUs7QUFDbkMsTUFBTUcsUUFBUUMsbUJBQU9BLENBQUMsb0JBQU87QUFDN0IsTUFBTUMsS0FBS0QsbUJBQU9BLENBQUMsY0FBSTtBQUN2QixNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSSxtQkFBbUJKLG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNuRCxNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTSxjQUFjTixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNTyxjQUFjO0FBQ3BCOzs7OztDQUtDLEdBQ0QsU0FBU0MsbUJBQW1CQyxLQUFLO0lBQzdCLEtBQUssTUFBTSxDQUFDQyxNQUFNQyxJQUFJLElBQUlqQixPQUFPa0IsT0FBTyxDQUFDWCxHQUFHWSxTQUFTLENBQUNKLEtBQUssRUFBRztRQUMxRCxJQUFJRSxRQUFRRixPQUFPO1lBQ2YsT0FBT0M7UUFDWDtJQUNKO0lBQ0EsT0FBTywwQkFBMEJEO0FBQ3JDO0FBQ0EsTUFBTVg7SUFDRmdCLFlBQVlDLFdBQVcsRUFBRUMsZ0JBQWdCLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxNQUFNLENBQUU7UUFDcEUsSUFBSSxDQUFDSixXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdBO1FBQ3hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxPQUFPLEdB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LWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWNhbGwuanM/MDA1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDYWxsID0gdm9pZCAwO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3Qgc3RyZWFtX2RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS1kZWNvZGVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3N1YmNoYW5uZWxfY2FsbCc7XG4vKipcbiAqIFNob3VsZCBkbyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHRoaW5nIGFzIHV0aWwuZ2V0U3lzdGVtRXJyb3JOYW1lIGJ1dCB0aGVcbiAqIFR5cGVTY3JpcHQgdHlwZXMgZG9uJ3QgaGF2ZSB0aGF0IGZ1bmN0aW9uIGZvciBzb21lIHJlYXNvbiBzbyBJIGp1c3QgbWFkZSBteVxuICogb3duLlxuICogQHBhcmFtIGVycm5vXG4gKi9cbmZ1bmN0aW9uIGdldFN5c3RlbUVycm9yTmFtZShlcnJubykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIG51bV0gb2YgT2JqZWN0LmVudHJpZXMob3MuY29uc3RhbnRzLmVycm5vKSkge1xuICAgICAgICBpZiAobnVtID09PSBlcnJubykge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duIHN5c3RlbSBlcnJvciAnICsgZXJybm87XG59XG5jbGFzcyBIdHRwMlN1YmNoYW5uZWxDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihodHRwMlN0cmVhbSwgY2FsbEV2ZW50VHJhY2tlciwgbGlzdGVuZXIsIHRyYW5zcG9ydCwgY2FsbElkKSB7XG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0gPSBodHRwMlN0cmVhbTtcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyID0gY2FsbEV2ZW50VHJhY2tlcjtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5jYWxsSWQgPSBjYWxsSWQ7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBzdHJlYW1fZGVjb2Rlcl8xLlN0cmVhbURlY29kZXIoKTtcbiAgICAgICAgdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IGFuICdlbmQnIGV2ZW50IGhhcyBjb21lIGZyb20gdGhlIGh0dHAyIHN0cmVhbSwgc28gdGhlcmVcbiAgICAgICAgICogd2lsbCBiZSBubyBtb3JlIGRhdGEgZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXR1c091dHB1dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzID0gW107XG4gICAgICAgIC8vIFN0YXR1cyBjb2RlIG1hcHBlZCBmcm9tIDpzdGF0dXMuIFRvIGJlIHVzZWQgaWYgZ3JwYy1zdGF0dXMgaXMgbm90IHJlY2VpdmVkXG4gICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOO1xuICAgICAgICAvLyBUaGlzIGlzIHBvcHVsYXRlZCAobm9uLW51bGwpIGlmIGFuZCBvbmx5IGlmIHRoZSBjYWxsIGhhcyBlbmRlZFxuICAgICAgICB0aGlzLmZpbmFsU3RhdHVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gbnVsbDtcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ3Jlc3BvbnNlJywgKGhlYWRlcnMsIGZsYWdzKSA9PiB7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xuICAgICAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzU3RyaW5nICs9ICdcXHRcXHQnICsgaGVhZGVyICsgJzogJyArIGhlYWRlcnNbaGVhZGVyXSArICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc2VydmVyIGhlYWRlcnM6XFxuJyArIGhlYWRlcnNTdHJpbmcpO1xuICAgICAgICAgICAgc3dpdGNoIChoZWFkZXJzWyc6c3RhdHVzJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IGhhbmRsZSAxMDAgYW5kIDEwMVxuICAgICAgICAgICAgICAgIGNhc2UgNDAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVVRIRU5USUNBVEVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlBFUk1JU1NJT05fREVOSUVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDI5OlxuICAgICAgICAgICAgICAgIGNhc2UgNTAyOlxuICAgICAgICAgICAgICAgIGNhc2UgNTAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzICYgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRkxBR19FTkRfU1RSRUFNKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbigndHJhaWxlcnMnLCAoaGVhZGVycykgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGVycyhoZWFkZXJzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIC8qIElmIHRoZSBzdGF0dXMgaGFzIGFscmVhZHkgYmVlbiBvdXRwdXQsIGFsbG93IHRoZSBodHRwMiBzdHJlYW0gdG9cbiAgICAgICAgICAgICAqIGRyYWluIHdpdGhvdXQgcHJvY2Vzc2luZyB0aGUgZGF0YS4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c091dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmUgSFRUUC8yIGRhdGEgZnJhbWUgb2YgbGVuZ3RoICcgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMuZGVjb2Rlci53cml0ZShkYXRhKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3BhcnNlZCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5hZGRNZXNzYWdlUmVjZWl2ZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAvKiBVc2UgcHJvY2Vzcy5uZXh0IHRpY2sgdG8gZW5zdXJlIHRoYXQgdGhpcyBjb2RlIGhhcHBlbnMgYWZ0ZXIgYW55XG4gICAgICAgICAgICAgKiBcImVycm9yXCIgZXZlbnQgdGhhdCBtYXkgYmUgZW1pdHRlZCBhdCBhYm91dCB0aGUgc2FtZSB0aW1lLCBzbyB0aGF0XG4gICAgICAgICAgICAgKiB3ZSBjYW4gYnViYmxlIHVwIHRoZSBlcnJvciBtZXNzYWdlIGZyb20gdGhhdCBldmVudC4gKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdIVFRQLzIgc3RyZWFtIGNsb3NlZCB3aXRoIGNvZGUgJyArIGh0dHAyU3RyZWFtLnJzdENvZGUpO1xuICAgICAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgYSBmaW5hbCBzdGF0dXMgd2l0aCBhbiBPSyBzdGF0dXMgY29kZSwgdGhhdCBtZWFucyB0aGF0XG4gICAgICAgICAgICAgICAgICogd2UgaGF2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIG1lc3NhZ2VzIGFuZCB3ZSBoYXZlIHByb2Nlc3NlZCB0aGVcbiAgICAgICAgICAgICAgICAgKiB0cmFpbGVycyBhbmQgdGhlIGNhbGwgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgc28gaXQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAgICAgICAgKiBob3cgdGhlIHN0cmVhbSBlbmRzIGFmdGVyIHRoYXQgKi9cbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuZmluYWxTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICAgICAgICAgbGV0IGRldGFpbHMgPSAnJztcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGh0dHAyU3RyZWFtLnJzdENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9OT19FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHdlIGdldCBhIE5PX0VSUk9SIGNvZGUgYW5kIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXR1cywgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzdHJlYW0gY29tcGxldGVkIHByb3Blcmx5IGFuZCB3ZSBqdXN0IGhhdmVuJ3QgZnVsbHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCB5ZXQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtodHRwMlN0cmVhbS5yc3RDb2RlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9SRUZVU0VEX1NUUkVBTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1N0cmVhbSByZWZ1c2VkIGJ5IHNlcnZlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUw6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQ2FsbCBjYW5jZWxsZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE06XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQmFuZHdpZHRoIGV4aGF1c3RlZCBvciBtZW1vcnkgbGltaXQgZXhjZWVkZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfSU5BREVRVUFURV9TRUNVUklUWTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUEVSTUlTU0lPTl9ERU5JRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1Byb3RvY29sIG5vdCBzZWN1cmUgZW5vdWdoJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0lOVEVSTkFMX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsRXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGVycm9yIGNvZGUgd2FzIHByZXZpb3VzbHkgaGFuZGxlZCBpbiB0aGUgZGVmYXVsdCBjYXNlLCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGVyZSBhcmUgc2V2ZXJhbCBpbnN0YW5jZXMgb2YgaXQgb25saW5lLCBzbyBJIHdhbnRlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIHNvIHRoYXQgcGVvcGxlIGZpbmQgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBpbmZvcm1hdGlvbiBpbiBzZWFyY2hlcywgYnV0IGFsc28gaW5jbHVkZSB0aGUgbW9yZSByZWNvZ25pemFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiIG1lc3NhZ2UuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke2h0dHAyU3RyZWFtLnJzdENvZGV9IChJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsRXJyb3IuY29kZSA9PT0gJ0VDT05OUkVTRVQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxFcnJvci5jb2RlID09PSAnRVRJTUVET1VUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gdGhpcy5pbnRlcm5hbEVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGUgXCJSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAuLi5cIiBlcnJvciBpcyBwcmVzZXJ2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaGVyZSBmb3IgY29udGludWl0eSB3aXRoIGVycm9ycyByZXBvcnRlZCBvbmxpbmUsIGJ1dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZXJyb3IgbWVzc2FnZSBhdCB0aGUgZW5kIHdpbGwgcHJvYmFibHkgYmUgbW9yZSByZWxldmFudCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBtb3N0IGNhc2VzLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX0gdHJpZ2dlcmVkIGJ5IGludGVybmFsIGNsaWVudCBlcnJvcjogJHt0aGlzLmludGVybmFsRXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtodHRwMlN0cmVhbS5yc3RDb2RlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiB0cmFpbGVycyB3ZXJlIHJlY2VpdmVkIGF0IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIE9LLCBiZWNhdXNlIHN0YXR1cyBjb2RlcyBlbWl0dGVkIGhlcmUgY29ycmVzcG9uZCB0byBtb3JlXG4gICAgICAgICAgICAgICAgLy8gY2F0YXN0cm9waGljIGlzc3VlcyB0aGF0IHByZXZlbnQgdXMgZnJvbSByZWNlaXZpbmcgdHJhaWxlcnMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgcGxhY2UuXG4gICAgICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIHJzdENvZGU6IGh0dHAyU3RyZWFtLnJzdENvZGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgIC8qIFdlIG5lZWQgYW4gZXJyb3IgaGFuZGxlciBoZXJlIHRvIHN0b3AgXCJVbmNhdWdodCBFcnJvclwiIGV4Y2VwdGlvbnNcbiAgICAgICAgICAgICAqIGZyb20gYnViYmxpbmcgdXAuIEhvd2V2ZXIsIGVycm9ycyBoZXJlIHNob3VsZCBhbGwgY29ycmVzcG9uZCB0b1xuICAgICAgICAgICAgICogXCJjbG9zZVwiIGV2ZW50cywgd2hlcmUgd2Ugd2lsbCBoYW5kbGUgdGhlIGVycm9yIG1vcmUgZ3JhbnVsYXJseSAqL1xuICAgICAgICAgICAgLyogU3BlY2lmaWNhbGx5IGxvb2tpbmcgZm9yIHN0cmVhbSBlcnJvcnMgdGhhdCB3ZXJlICpub3QqIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgKiBmcm9tIGEgUlNUX1NUUkVBTSByZXNwb25zZSBoZXJlOlxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvOGI4NjIwZDU4MDMxNDA1MDE3NTk4MzQwMmRmZGRmMjY3NGU4ZTIyYS9saWIvaW50ZXJuYWwvaHR0cDIvY29yZS5qcyNMMjI2N1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFUlJfSFRUUDJfU1RSRUFNX0VSUk9SJykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ05vZGUgZXJyb3IgZXZlbnQ6IG1lc3NhZ2U9JyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlICtcbiAgICAgICAgICAgICAgICAgICAgJyBjb2RlPScgK1xuICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSArXG4gICAgICAgICAgICAgICAgICAgICcgZXJybm89JyArXG4gICAgICAgICAgICAgICAgICAgIGdldFN5c3RlbUVycm9yTmFtZShlcnIuZXJybm8pICtcbiAgICAgICAgICAgICAgICAgICAgJyBzeXNjYWxsPScgK1xuICAgICAgICAgICAgICAgICAgICBlcnIuc3lzY2FsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uRGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgIGRldGFpbHM6ICdDb25uZWN0aW9uIGRyb3BwZWQnLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvdXRwdXRTdGF0dXMoKSB7XG4gICAgICAgIC8qIFByZWNvbmRpdGlvbjogdGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAqL1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c091dHB1dCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgK1xuICAgICAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMuZGV0YWlscyArXG4gICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25DYWxsRW5kKHRoaXMuZmluYWxTdGF0dXMpO1xuICAgICAgICAgICAgLyogV2UgZGVsYXkgdGhlIGFjdHVhbCBhY3Rpb24gb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cyB0byBpbnN1bGF0ZSB0aGVcbiAgICAgICAgICAgICAqIGNsZWFudXAgY29kZSBpbiB0aGlzIGNsYXNzIGZyb20gYW55IGVycm9ycyB0aGF0IG1heSBiZSB0aHJvd24gaW4gdGhlXG4gICAgICAgICAgICAgKiB1cHBlciBsYXllcnMgYXMgYSByZXN1bHQgb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cy4gSW4gcGFydGljdWxhcixcbiAgICAgICAgICAgICAqIGlmIHRoZSBzdGF0dXMgaXMgbm90IE9LLCB0aGUgXCJlcnJvclwiIGV2ZW50IG1heSBiZSBlbWl0dGVkXG4gICAgICAgICAgICAgKiBzeW5jaHJvbm91c2x5IGF0IHRoZSB0b3AgbGV2ZWwsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgdGhyb3duIGVycm9yIGlmXG4gICAgICAgICAgICAgKiB0aGUgdXNlciBkb2VzIG5vdCBoYW5kbGUgdGhhdCBldmVudC4gKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHRoaXMuZmluYWxTdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKiBMZWF2ZSB0aGUgaHR0cDIgc3RyZWFtIGluIGZsb3dpbmcgc3RhdGUgdG8gZHJhaW4gaW5jb21pbmcgbWVzc2FnZXMsIHRvXG4gICAgICAgICAgICAgKiBlbnN1cmUgdGhhdCB0aGUgc3RyZWFtIGNsb3N1cmUgY29tcGxldGVzLiBUaGUgY2FsbCBzdHJlYW0gYWxyZWFkeSBkb2VzXG4gICAgICAgICAgICAgKiBub3QgcHVzaCBtb3JlIG1lc3NhZ2VzIGFmdGVyIHRoZSBzdGF0dXMgaXMgb3V0cHV0LCBzbyB0aGUgbWVzc2FnZXMgZ29cbiAgICAgICAgICAgICAqIG5vd2hlcmUgZWl0aGVyIHdheS4gKi9cbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbElkICsgJ10gJyArIHRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiBmaXJzdCBjYWxsLCBlbWl0cyBhICdzdGF0dXMnIGV2ZW50IHdpdGggdGhlIGdpdmVuIFN0YXR1c09iamVjdC5cbiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIGFyZSBuby1vcHMuXG4gICAgICogQHBhcmFtIHN0YXR1cyBUaGUgc3RhdHVzIG9mIHRoZSBjYWxsLlxuICAgICAqL1xuICAgIGVuZENhbGwoc3RhdHVzKSB7XG4gICAgICAgIC8qIElmIHRoZSBzdGF0dXMgaXMgT0sgYW5kIGEgbmV3IHN0YXR1cyBjb21lcyBpbiAoZS5nLiBmcm9tIGFcbiAgICAgICAgICogZGVzZXJpYWxpemF0aW9uIGZhaWx1cmUpLCB0aGF0IG5ldyBzdGF0dXMgdGFrZXMgcHJpb3JpdHkgKi9cbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgPT09IG51bGwgfHwgdGhpcy5maW5hbFN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95SHR0cDJTdHJlYW0oKTtcbiAgICB9XG4gICAgbWF5YmVPdXRwdXRTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvKiBUaGUgY29tYmluYXRpb24gY2hlY2sgb2YgcmVhZHNDbG9zZWQgYW5kIHRoYXQgdGhlIHR3byBtZXNzYWdlIGJ1ZmZlclxuICAgICAgICAgICAgICogYXJyYXlzIGFyZSBlbXB0eSBjaGVja3MgdGhhdCB0aGVyZSBhbGwgaW5jb21pbmcgZGF0YSBoYXMgYmVlbiBmdWxseVxuICAgICAgICAgICAgICogcHJvY2Vzc2VkICovXG4gICAgICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0sgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5yZWFkc0Nsb3NlZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzUHVzaFBlbmRpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgncHVzaGluZyB0byByZWFkZXIgbWVzc2FnZSBvZiBsZW5ndGggJyArXG4gICAgICAgICAgICAobWVzc2FnZSBpbnN0YW5jZW9mIEJ1ZmZlciA/IG1lc3NhZ2UubGVuZ3RoIDogbnVsbCkpO1xuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgYWxyZWFkeSBvdXRwdXQgdGhlIHN0YXR1cyBhbnkgbGF0ZXIgbWVzc2FnZXMgc2hvdWxkIGJlXG4gICAgICAgICAgICAgKiBpZ25vcmVkLCBhbmQgY2FuIGNhdXNlIG91dC1vZi1vcmRlciBvcGVyYXRpb24gZXJyb3JzIGhpZ2hlciB1cCBpbiB0aGVcbiAgICAgICAgICAgICAqIHN0YWNrLiBDaGVja2luZyBhcyBsYXRlIGFzIHBvc3NpYmxlIGhlcmUgdG8gYXZvaWQgYW55IHJhY2UgY29uZGl0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJ5UHVzaChtZXNzYWdlQnl0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuUHVzaCkge1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoKG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCd1bnB1c2hlZFJlYWRNZXNzYWdlcy5wdXNoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlQnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMucHVzaChtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKHRydWUpO1xuICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgaGVhZGVyc1N0cmluZyArPSAnXFx0XFx0JyArIGhlYWRlciArICc6ICcgKyBoZWFkZXJzW2hlYWRlcl0gKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzZXJ2ZXIgdHJhaWxlcnM6XFxuJyArIGhlYWRlcnNTdHJpbmcpO1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTWFwID0gbWV0YWRhdGEuZ2V0TWFwKCk7XG4gICAgICAgIGxldCBjb2RlID0gdGhpcy5tYXBwZWRTdGF0dXNDb2RlO1xuICAgICAgICBpZiAoY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04gJiZcbiAgICAgICAgICAgIHR5cGVvZiBtZXRhZGF0YU1hcFsnZ3JwYy1zdGF0dXMnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkU3RhdHVzID0gTnVtYmVyKG1ldGFkYXRhTWFwWydncnBjLXN0YXR1cyddKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cyBpbiBjb25zdGFudHNfMS5TdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gcmVjZWl2ZWRTdGF0dXM7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGNvZGUgJyArIHJlY2VpdmVkU3RhdHVzICsgJyBmcm9tIHNlcnZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLXN0YXR1cycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXRhaWxzID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gZGVjb2RlVVJJKG1ldGFkYXRhTWFwWydncnBjLW1lc3NhZ2UnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMgPSBtZXRhZGF0YU1hcFsnZ3JwYy1tZXNzYWdlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtbWVzc2FnZScpO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGRldGFpbHMgc3RyaW5nIFwiJyArIGRldGFpbHMgKyAnXCIgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSB7IGNvZGUsIGRldGFpbHMsIG1ldGFkYXRhIH07XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiB0aGUgY2FsbCB3YXMgYWxyZWFkeSBlbmRlZCB3aGVuIGhhbmRsaW5nIGhlYWRlcnMuXG4gICAgICAgIHRoaXMuZW5kQ2FsbChzdGF0dXMpO1xuICAgIH1cbiAgICBkZXN0cm95SHR0cDJTdHJlYW0oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gVGhlIGh0dHAyIHN0cmVhbSBjb3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBkZXN0cm95ZWQgaWYgY2FuY2VsV2l0aFN0YXR1c1xuICAgICAgICAvLyBpcyBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJuYWwgaHR0cDIgZXJyb3IuXG4gICAgICAgIGlmICghdGhpcy5odHRwMlN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIC8qIElmIHRoZSBjYWxsIGhhcyBlbmRlZCB3aXRoIGFuIE9LIHN0YXR1cywgY29tbXVuaWNhdGUgdGhhdCB3aGVuIGNsb3NpbmdcbiAgICAgICAgICAgICAqIHRoZSBzdHJlYW0sIHBhcnRseSB0byBhdm9pZCBhIHNpdHVhdGlvbiBpbiB3aGljaCB3ZSBkZXRlY3QgYW4gZXJyb3JcbiAgICAgICAgICAgICAqIFJTVF9TVFJFQU0gYXMgYSByZXN1bHQgYWZ0ZXIgd2UgaGF2ZSB0aGUgc3RhdHVzICovXG4gICAgICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5maW5hbFN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfQ0FOQ0VMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2xvc2UgaHR0cDIgc3RyZWFtIHdpdGggY29kZSAnICsgY29kZSk7XG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLmNsb3NlKGNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xuICAgICAgICB0aGlzLmVuZENhbGwoeyBjb2RlOiBzdGF0dXMsIGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0pO1xuICAgIH1cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmFsU3RhdHVzO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuZ2V0UGVlck5hbWUoKTtcbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkO1xuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIC8qIElmIHRoZSBzdHJlYW0gaGFzIGVuZGVkIHdpdGggYW4gZXJyb3IsIHdlIHNob3VsZCBub3QgZW1pdCBhbnkgbW9yZVxuICAgICAgICAgKiBtZXNzYWdlcyBhbmQgd2Ugc2hvdWxkIGNvbW11bmljYXRlIHRoYXQgdGhlIHN0cmVhbSBoYXMgZW5kZWQgKi9cbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwgJiYgdGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMucmVhZHNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRNZXNzYWdlID0gdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoKG5leHRNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBPbmx5IHJlc3VtZSByZWFkaW5nIGZyb20gdGhlIGh0dHAyU3RyZWFtIGlmIHdlIGRvbid0IGhhdmUgYW55IHBlbmRpbmdcbiAgICAgICAgICogbWVzc2FnZXMgdG8gZW1pdCAqL1xuICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjYiA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLyogbmV4dFRpY2sgaGVyZSBlbnN1cmVzIHRoYXQgbm8gc3RyZWFtIGFjdGlvbiBjYW4gYmUgdGFrZW4gaW4gdGhlIGNhbGxcbiAgICAgICAgICAgICAqIHN0YWNrIG9mIHRoZSB3cml0ZSBjYWxsYmFjaywgaW4gb3JkZXIgdG8gaG9wZWZ1bGx5IHdvcmsgYXJvdW5kXG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MTQ3ICovXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgaWYgKChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuY29kZSkgPT09XG4gICAgICAgICAgICAgICAgICAgICdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb2RlLCBgV3JpdGUgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9hID0gY29udGV4dC5jYWxsYmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY29udGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFjZSgnc2VuZGluZyBkYXRhIGNodW5rIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIuYWRkTWVzc2FnZVNlbnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ud3JpdGUobWVzc2FnZSwgY2IpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFdyaXRlIGZhaWxlZCB3aXRoIGVycm9yICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdlbmQoKSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy50cmFjZSgnY2FsbGluZyBlbmQoKSBvbiBIVFRQLzIgc3RyZWFtJyk7XG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0uZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDYWxsID0gSHR0cDJTdWJjaGFubmVsQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtY2FsbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJIdHRwMlN1YmNoYW5uZWxDYWxsIiwiaHR0cDIiLCJyZXF1aXJlIiwib3MiLCJjb25zdGFudHNfMSIsIm1ldGFkYXRhXzEiLCJzdHJlYW1fZGVjb2Rlcl8xIiwibG9nZ2luZyIsImNvbnN0YW50c18yIiwiVFJBQ0VSX05BTUUiLCJnZXRTeXN0ZW1FcnJvck5hbWUiLCJlcnJubyIsIm5hbWUiLCJudW0iLCJlbnRyaWVzIiwiY29uc3RhbnRzIiwiY29uc3RydWN0b3IiLCJodHRwMlN0cmVhbSIsImNhbGxFdmVudFRyYWNrZXIiLCJsaXN0ZW5lciIsInRyYW5zcG9ydCIsImNhbGxJZCIsImRlY29kZXIiLCJTdHJlYW1EZWNvZGVyIiwiaXNSZWFkRmlsdGVyUGVuZGluZyIsImlzUHVzaFBlbmRpbmciLCJjYW5QdXNoIiwicmVhZHNDbG9zZWQiLCJzdGF0dXNPdXRwdXQiLCJ1bnB1c2hlZFJlYWRNZXNzYWdlcyIsIm1hcHBlZFN0YXR1c0NvZGUiLCJTdGF0dXMiLCJVTktOT1dOIiwiZmluYWxTdGF0dXMiLCJpbnRlcm5hbEVycm9yIiwib24iLCJoZWFkZXJzIiwiZmxhZ3MiLCJoZWFkZXJzU3RyaW5nIiwiaGVhZGVyIiwia2V5cyIsInRyYWNlIiwiSU5URVJOQUwiLCJVTkFVVEhFTlRJQ0FURUQiLCJQRVJNSVNTSU9OX0RFTklFRCIsIlVOSU1QTEVNRU5URUQiLCJVTkFWQUlMQUJMRSIsIk5HSFRUUDJfRkxBR19FTkRfU1RSRUFNIiwiaGFuZGxlVHJhaWxlcnMiLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwiZnJvbUh0dHAySGVhZGVycyIsImVycm9yIiwiZW5kQ2FsbCIsImNvZGUiLCJkZXRhaWxzIiwibWVzc2FnZSIsIm9uUmVjZWl2ZU1ldGFkYXRhIiwiZGF0YSIsImxlbmd0aCIsIm1lc3NhZ2VzIiwid3JpdGUiLCJhZGRNZXNzYWdlUmVjZWl2ZWQiLCJ0cnlQdXNoIiwibWF5YmVPdXRwdXRTdGF0dXMiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJfYSIsInJzdENvZGUiLCJPSyIsIk5HSFRUUDJfTk9fRVJST1IiLCJOR0hUVFAyX1JFRlVTRURfU1RSRUFNIiwiTkdIVFRQMl9DQU5DRUwiLCJDQU5DRUxMRUQiLCJOR0hUVFAyX0VOSEFOQ0VfWU9VUl9DQUxNIiwiUkVTT1VSQ0VfRVhIQVVTVEVEIiwiTkdIVFRQMl9JTkFERVFVQVRFX1NFQ1VSSVRZIiwiTkdIVFRQMl9JTlRFUk5BTF9FUlJPUiIsImVyciIsInN5c2NhbGwiLCJvblN0cmVhbUVuZCIsIm9uRGlzY29ubmVjdCIsIm91dHB1dFN0YXR1cyIsIm9uQ2FsbEVuZCIsIm9uUmVjZWl2ZVN0YXR1cyIsInJlc3VtZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsInN0YXR1cyIsImRlc3Ryb3lIdHRwMlN0cmVhbSIsInB1c2giLCJCdWZmZXIiLCJvblJlY2VpdmVNZXNzYWdlIiwibWVzc2FnZUJ5dGVzIiwicGF1c2UiLCJlIiwibWV0YWRhdGFNYXAiLCJnZXRNYXAiLCJyZWNlaXZlZFN0YXR1cyIsIk51bWJlciIsInJlbW92ZSIsImRlY29kZVVSSSIsImRlc3Ryb3llZCIsImNsb3NlIiwiY2FuY2VsV2l0aFN0YXR1cyIsImdldFN0YXR1cyIsImdldFBlZXIiLCJnZXRQZWVyTmFtZSIsImdldENhbGxOdW1iZXIiLCJzdGFydFJlYWQiLCJuZXh0TWVzc2FnZSIsInNoaWZ0Iiwic2VuZE1lc3NhZ2VXaXRoQ29udGV4dCIsImNvbnRleHQiLCJjYiIsImNhbGxiYWNrIiwiY2FsbCIsImFkZE1lc3NhZ2VTZW50IiwiaGFsZkNsb3NlIiwiZW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseSubchannelWrapper = void 0;\nclass BaseSubchannelWrapper {\n    constructor(child){\n        this.child = child;\n    }\n    getConnectivityState() {\n        return this.child.getConnectivityState();\n    }\n    addConnectivityStateListener(listener) {\n        this.child.addConnectivityStateListener(listener);\n    }\n    removeConnectivityStateListener(listener) {\n        this.child.removeConnectivityStateListener(listener);\n    }\n    startConnecting() {\n        this.child.startConnecting();\n    }\n    getAddress() {\n        return this.child.getAddress();\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        this.child.throttleKeepalive(newKeepaliveTime);\n    }\n    ref() {\n        this.child.ref();\n    }\n    unref() {\n        this.child.unref();\n    }\n    getChannelzRef() {\n        return this.child.getChannelzRef();\n    }\n    getRealSubchannel() {\n        return this.child.getRealSubchannel();\n    }\n    realSubchannelEquals(other) {\n        return this.getRealSubchannel() === other.getRealSubchannel();\n    }\n}\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper; //# sourceMappingURL=subchannel-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUU7SUFDRkMsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0FDLHVCQUF1QjtRQUNuQixPQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxvQkFBb0I7SUFDMUM7SUFDQUMsNkJBQTZCQyxRQUFRLEVBQUU7UUFDbkMsSUFBSSxDQUFDSCxLQUFLLENBQUNFLDRCQUE0QixDQUFDQztJQUM1QztJQUNBQyxnQ0FBZ0NELFFBQVEsRUFBRTtRQUN0QyxJQUFJLENBQUNILEtBQUssQ0FBQ0ksK0JBQStCLENBQUNEO0lBQy9DO0lBQ0FFLGtCQUFrQjtRQUNkLElBQUksQ0FBQ0wsS0FBSyxDQUFDSyxlQUFlO0lBQzlCO0lBQ0FDLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ04sS0FBSyxDQUFDTSxVQUFVO0lBQ2hDO0lBQ0FDLGtCQUFrQkMsZ0JBQWdCLEVBQUU7UUFDaEMsSUFBSSxDQUFDUixLQUFLLENBQUNPLGlCQUFpQixDQUFDQztJQUNqQztJQUNBQyxNQUFNO1FBQ0YsSUFBSSxDQUFDVCxLQUFLLENBQUNTLEdBQUc7SUFDbEI7SUFDQUMsUUFBUTtRQUNKLElBQUksQ0FBQ1YsS0FBSyxDQUFDVSxLQUFLO0lBQ3BCO0lBQ0FDLGlCQUFpQjtRQUNiLE9BQU8sSUFBSSxDQUFDWCxLQUFLLENBQUNXLGNBQWM7SUFDcEM7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU8sSUFBSSxDQUFDWixLQUFLLENBQUNZLGlCQUFpQjtJQUN2QztJQUNBQyxxQkFBcUJDLEtBQUssRUFBRTtRQUN4QixPQUFPLElBQUksQ0FBQ0YsaUJBQWlCLE9BQU9FLE1BQU1GLGlCQUFpQjtJQUMvRDtBQUNKO0FBQ0FoQiw2QkFBNkIsR0FBR0UsdUJBQ2hDLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtaW50ZXJmYWNlLmpzPzI4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVN1YmNoYW5uZWxXcmFwcGVyID0gdm9pZCAwO1xuY2xhc3MgQmFzZVN1YmNoYW5uZWxXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZCkge1xuICAgICAgICB0aGlzLmNoaWxkID0gY2hpbGQ7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgIH1cbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuY2hpbGQuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgc3RhcnRDb25uZWN0aW5nKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpIHtcbiAgICAgICAgdGhpcy5jaGlsZC50aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKTtcbiAgICB9XG4gICAgcmVmKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnJlZigpO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC51bnJlZigpO1xuICAgIH1cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0Q2hhbm5lbHpSZWYoKTtcbiAgICB9XG4gICAgZ2V0UmVhbFN1YmNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldFJlYWxTdWJjaGFubmVsKCk7XG4gICAgfVxuICAgIHJlYWxTdWJjaGFubmVsRXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlYWxTdWJjaGFubmVsKCkgPT09IG90aGVyLmdldFJlYWxTdWJjaGFubmVsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlU3ViY2hhbm5lbFdyYXBwZXIgPSBCYXNlU3ViY2hhbm5lbFdyYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYXNlU3ViY2hhbm5lbFdyYXBwZXIiLCJjb25zdHJ1Y3RvciIsImNoaWxkIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwibGlzdGVuZXIiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwic3RhcnRDb25uZWN0aW5nIiwiZ2V0QWRkcmVzcyIsInRocm90dGxlS2VlcGFsaXZlIiwibmV3S2VlcGFsaXZlVGltZSIsInJlZiIsInVucmVmIiwiZ2V0Q2hhbm5lbHpSZWYiLCJnZXRSZWFsU3ViY2hhbm5lbCIsInJlYWxTdWJjaGFubmVsRXF1YWxzIiwib3RoZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\nconst channel_options_1 = __webpack_require__(/*! ./channel-options */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\");\nconst subchannel_1 = __webpack_require__(/*! ./subchannel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst transport_1 = __webpack_require__(/*! ./transport */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/transport.js\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */ const REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n    /**\n     * A pool of subchannels use for making connections. Subchannels with the\n     * exact same parameters will be reused.\n     */ constructor(){\n        this.pool = Object.create(null);\n        /**\n         * A timer of a task performing a periodic subchannel cleanup.\n         */ this.cleanupTimer = null;\n    }\n    /**\n     * Unrefs all unused subchannels and cancels the cleanup task if all\n     * subchannels have been unrefed.\n     */ unrefUnusedSubchannels() {\n        let allSubchannelsUnrefed = true;\n        /* These objects are created with Object.create(null), so they do not\n         * have a prototype, which means that for (... in ...) loops over them\n         * do not need to be filtered */ // eslint-disable-disable-next-line:forin\n        for(const channelTarget in this.pool){\n            const subchannelObjArray = this.pool[channelTarget];\n            const refedSubchannels = subchannelObjArray.filter((value)=>!value.subchannel.unrefIfOneRef());\n            if (refedSubchannels.length > 0) {\n                allSubchannelsUnrefed = false;\n            }\n            /* For each subchannel in the pool, try to unref it if it has\n             * exactly one ref (which is the ref from the pool itself). If that\n             * does happen, remove the subchannel from the pool */ this.pool[channelTarget] = refedSubchannels;\n        }\n        /* Currently we do not delete keys with empty values. If that results\n         * in significant memory usage we should change it. */ // Cancel the cleanup task if all subchannels have been unrefed.\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */ ensureCleanupTask() {\n        var _a, _b;\n        if (this.cleanupTimer === null) {\n            this.cleanupTimer = setInterval(()=>{\n                this.unrefUnusedSubchannels();\n            }, REF_CHECK_INTERVAL);\n            // Unref because this timer should not keep the event loop running.\n            // Call unref only if it exists to address electron/electron#21162\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */ getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n        this.ensureCleanupTask();\n        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);\n        if (channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            for (const subchannelObj of subchannelObjArray){\n                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) && (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n                    return subchannelObj.subchannel;\n                }\n            }\n        }\n        // If we get here, no matching subchannel was found\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));\n        if (!(channelTarget in this.pool)) {\n            this.pool[channelTarget] = [];\n        }\n        this.pool[channelTarget].push({\n            subchannelAddress: subchannelTarget,\n            channelArguments,\n            channelCredentials,\n            subchannel\n        });\n        subchannel.ref();\n        return subchannel;\n    }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */ function getSubchannelPool(global) {\n    if (global) {\n        return globalSubchannelPool;\n    } else {\n        return new SubchannelPool();\n    }\n}\nexports.getSubchannelPool = getSubchannelPool; //# sourceMappingURL=subchannel-pool.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUMxRCxNQUFNSSxvQkFBb0JDLG1CQUFPQSxDQUFDLDBGQUFtQjtBQUNyRCxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNSSxjQUFjSixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6Qyx1REFBdUQ7QUFDdkQ7OztDQUdDLEdBQ0QsTUFBTUsscUJBQXFCO0FBQzNCLE1BQU1QO0lBQ0Y7OztLQUdDLEdBQ0RRLGFBQWM7UUFDVixJQUFJLENBQUNDLElBQUksR0FBR2QsT0FBT2UsTUFBTSxDQUFDO1FBQzFCOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxZQUFZLEdBQUc7SUFDeEI7SUFDQTs7O0tBR0MsR0FDREMseUJBQXlCO1FBQ3JCLElBQUlDLHdCQUF3QjtRQUM1Qjs7c0NBRThCLEdBQzlCLHlDQUF5QztRQUN6QyxJQUFLLE1BQU1DLGlCQUFpQixJQUFJLENBQUNMLElBQUksQ0FBRTtZQUNuQyxNQUFNTSxxQkFBcUIsSUFBSSxDQUFDTixJQUFJLENBQUNLLGNBQWM7WUFDbkQsTUFBTUUsbUJBQW1CRCxtQkFBbUJFLE1BQU0sQ0FBQ25CLENBQUFBLFFBQVMsQ0FBQ0EsTUFBTW9CLFVBQVUsQ0FBQ0MsYUFBYTtZQUMzRixJQUFJSCxpQkFBaUJJLE1BQU0sR0FBRyxHQUFHO2dCQUM3QlAsd0JBQXdCO1lBQzVCO1lBQ0E7O2dFQUVvRCxHQUNwRCxJQUFJLENBQUNKLElBQUksQ0FBQ0ssY0FBYyxHQUFHRTtRQUMvQjtRQUNBOzREQUNvRCxHQUNwRCxnRUFBZ0U7UUFDaEUsSUFBSUgseUJBQXlCLElBQUksQ0FBQ0YsWUFBWSxLQUFLLE1BQU07WUFDckRVLGNBQWMsSUFBSSxDQUFDVixZQUFZO1lBQy9CLElBQUksQ0FBQ0EsWUFBWSxHQUFHO1FBQ3hCO0lBQ0o7SUFDQTs7S0FFQyxHQUNEVyxvQkFBb0I7UUFDaEIsSUFBSUMsSUFBSUM7UUFDUixJQUFJLElBQUksQ0FBQ2IsWUFBWSxLQUFLLE1BQU07WUFDNUIsSUFBSSxDQUFDQSxZQUFZLEdBQUdjLFlBQVk7Z0JBQzVCLElBQUksQ0FBQ2Isc0JBQXNCO1lBQy9CLEdBQUdMO1lBQ0gsbUVBQW1FO1lBQ25FLGtFQUFrRTtZQUNqRWlCLENBQUFBLEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNaLFlBQVksRUFBRWUsS0FBSyxNQUFNLFFBQVFGLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0csSUFBSSxDQUFDSjtRQUN2RjtJQUNKO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNESyxzQkFBc0JDLGdCQUFnQixFQUFFQyxnQkFBZ0IsRUFBRUMsZ0JBQWdCLEVBQUVDLGtCQUFrQixFQUFFO1FBQzVGLElBQUksQ0FBQ1YsaUJBQWlCO1FBQ3RCLE1BQU1SLGdCQUFnQixDQUFDLEdBQUdULGFBQWE0QixXQUFXLEVBQUVKO1FBQ3BELElBQUlmLGlCQUFpQixJQUFJLENBQUNMLElBQUksRUFBRTtZQUM1QixNQUFNTSxxQkFBcUIsSUFBSSxDQUFDTixJQUFJLENBQUNLLGNBQWM7WUFDbkQsS0FBSyxNQUFNb0IsaUJBQWlCbkIsbUJBQW9CO2dCQUM1QyxJQUFJLENBQUMsR0FBR1gscUJBQXFCK0Isc0JBQXNCLEVBQUVMLGtCQUFrQkksY0FBY0UsaUJBQWlCLEtBQ2xHLENBQUMsR0FBR25DLGtCQUFrQm9DLG1CQUFtQixFQUFFTixrQkFBa0JHLGNBQWNILGdCQUFnQixLQUMzRkMsbUJBQW1CTSxPQUFPLENBQUNKLGNBQWNGLGtCQUFrQixHQUFHO29CQUM5RCxPQUFPRSxjQUFjaEIsVUFBVTtnQkFDbkM7WUFDSjtRQUNKO1FBQ0EsbURBQW1EO1FBQ25ELE1BQU1BLGFBQWEsSUFBSWYsYUFBYW9DLFVBQVUsQ0FBQ1Ysa0JBQWtCQyxrQkFBa0JDLGtCQUFrQkMsb0JBQW9CLElBQUkxQixZQUFZa0Msd0JBQXdCLENBQUNYO1FBQ2xLLElBQUksQ0FBRWYsQ0FBQUEsaUJBQWlCLElBQUksQ0FBQ0wsSUFBSSxHQUFHO1lBQy9CLElBQUksQ0FBQ0EsSUFBSSxDQUFDSyxjQUFjLEdBQUcsRUFBRTtRQUNqQztRQUNBLElBQUksQ0FBQ0wsSUFBSSxDQUFDSyxjQUFjLENBQUMyQixJQUFJLENBQUM7WUFDMUJMLG1CQUFtQk47WUFDbkJDO1lBQ0FDO1lBQ0FkO1FBQ0o7UUFDQUEsV0FBV3dCLEdBQUc7UUFDZCxPQUFPeEI7SUFDWDtBQUNKO0FBQ0FyQixzQkFBc0IsR0FBR0c7QUFDekIsTUFBTTJDLHVCQUF1QixJQUFJM0M7QUFDakM7OztDQUdDLEdBQ0QsU0FBU0Qsa0JBQWtCNkMsTUFBTTtJQUM3QixJQUFJQSxRQUFRO1FBQ1IsT0FBT0Q7SUFDWCxPQUNLO1FBQ0QsT0FBTyxJQUFJM0M7SUFDZjtBQUNKO0FBQ0FILHlCQUF5QixHQUFHRSxtQkFDNUIsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzP2M1NjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U3ViY2hhbm5lbFBvb2wgPSBleHBvcnRzLlN1YmNoYW5uZWxQb29sID0gdm9pZCAwO1xuY29uc3QgY2hhbm5lbF9vcHRpb25zXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLW9wdGlvbnNcIik7XG5jb25zdCBzdWJjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRcIik7XG4vLyAxMCBzZWNvbmRzIGluIG1pbGxpc2Vjb25kcy4gVGhpcyB2YWx1ZSBpcyBhcmJpdHJhcnkuXG4vKipcbiAqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBiZXR3ZWVuIGNoZWNrcyBmb3IgZHJvcHBpbmcgc3ViY2hhbm5lbHMgdGhhdCBoYXZlIG5vXG4gKiBvdGhlciByZWZlcmVuY2VzXG4gKi9cbmNvbnN0IFJFRl9DSEVDS19JTlRFUlZBTCA9IDEwMDAwO1xuY2xhc3MgU3ViY2hhbm5lbFBvb2wge1xuICAgIC8qKlxuICAgICAqIEEgcG9vbCBvZiBzdWJjaGFubmVscyB1c2UgZm9yIG1ha2luZyBjb25uZWN0aW9ucy4gU3ViY2hhbm5lbHMgd2l0aCB0aGVcbiAgICAgKiBleGFjdCBzYW1lIHBhcmFtZXRlcnMgd2lsbCBiZSByZXVzZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucG9vbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHRpbWVyIG9mIGEgdGFzayBwZXJmb3JtaW5nIGEgcGVyaW9kaWMgc3ViY2hhbm5lbCBjbGVhbnVwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlZnMgYWxsIHVudXNlZCBzdWJjaGFubmVscyBhbmQgY2FuY2VscyB0aGUgY2xlYW51cCB0YXNrIGlmIGFsbFxuICAgICAqIHN1YmNoYW5uZWxzIGhhdmUgYmVlbiB1bnJlZmVkLlxuICAgICAqL1xuICAgIHVucmVmVW51c2VkU3ViY2hhbm5lbHMoKSB7XG4gICAgICAgIGxldCBhbGxTdWJjaGFubmVsc1VucmVmZWQgPSB0cnVlO1xuICAgICAgICAvKiBUaGVzZSBvYmplY3RzIGFyZSBjcmVhdGVkIHdpdGggT2JqZWN0LmNyZWF0ZShudWxsKSwgc28gdGhleSBkbyBub3RcbiAgICAgICAgICogaGF2ZSBhIHByb3RvdHlwZSwgd2hpY2ggbWVhbnMgdGhhdCBmb3IgKC4uLiBpbiAuLi4pIGxvb3BzIG92ZXIgdGhlbVxuICAgICAgICAgKiBkbyBub3QgbmVlZCB0byBiZSBmaWx0ZXJlZCAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1kaXNhYmxlLW5leHQtbGluZTpmb3JpblxuICAgICAgICBmb3IgKGNvbnN0IGNoYW5uZWxUYXJnZXQgaW4gdGhpcy5wb29sKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsT2JqQXJyYXkgPSB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF07XG4gICAgICAgICAgICBjb25zdCByZWZlZFN1YmNoYW5uZWxzID0gc3ViY2hhbm5lbE9iakFycmF5LmZpbHRlcih2YWx1ZSA9PiAhdmFsdWUuc3ViY2hhbm5lbC51bnJlZklmT25lUmVmKCkpO1xuICAgICAgICAgICAgaWYgKHJlZmVkU3ViY2hhbm5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFsbFN1YmNoYW5uZWxzVW5yZWZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogRm9yIGVhY2ggc3ViY2hhbm5lbCBpbiB0aGUgcG9vbCwgdHJ5IHRvIHVucmVmIGl0IGlmIGl0IGhhc1xuICAgICAgICAgICAgICogZXhhY3RseSBvbmUgcmVmICh3aGljaCBpcyB0aGUgcmVmIGZyb20gdGhlIHBvb2wgaXRzZWxmKS4gSWYgdGhhdFxuICAgICAgICAgICAgICogZG9lcyBoYXBwZW4sIHJlbW92ZSB0aGUgc3ViY2hhbm5lbCBmcm9tIHRoZSBwb29sICovXG4gICAgICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0gPSByZWZlZFN1YmNoYW5uZWxzO1xuICAgICAgICB9XG4gICAgICAgIC8qIEN1cnJlbnRseSB3ZSBkbyBub3QgZGVsZXRlIGtleXMgd2l0aCBlbXB0eSB2YWx1ZXMuIElmIHRoYXQgcmVzdWx0c1xuICAgICAgICAgKiBpbiBzaWduaWZpY2FudCBtZW1vcnkgdXNhZ2Ugd2Ugc2hvdWxkIGNoYW5nZSBpdC4gKi9cbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBjbGVhbnVwIHRhc2sgaWYgYWxsIHN1YmNoYW5uZWxzIGhhdmUgYmVlbiB1bnJlZmVkLlxuICAgICAgICBpZiAoYWxsU3ViY2hhbm5lbHNVbnJlZmVkICYmIHRoaXMuY2xlYW51cFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGNsZWFudXAgdGFzayBpcyBzcGF3bmVkLlxuICAgICAqL1xuICAgIGVuc3VyZUNsZWFudXBUYXNrKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudW5yZWZVbnVzZWRTdWJjaGFubmVscygpO1xuICAgICAgICAgICAgfSwgUkVGX0NIRUNLX0lOVEVSVkFMKTtcbiAgICAgICAgICAgIC8vIFVucmVmIGJlY2F1c2UgdGhpcyB0aW1lciBzaG91bGQgbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgcnVubmluZy5cbiAgICAgICAgICAgIC8vIENhbGwgdW5yZWYgb25seSBpZiBpdCBleGlzdHMgdG8gYWRkcmVzcyBlbGVjdHJvbi9lbGVjdHJvbiMyMTE2MlxuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jbGVhbnVwVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc3ViY2hhbm5lbCBpZiBvbmUgYWxyZWFkeSBleGlzdHMgd2l0aCBleGFjdGx5IG1hdGNoaW5nIHBhcmFtZXRlcnMuXG4gICAgICogT3RoZXJ3aXNlLCBjcmVhdGUgYW5kIHNhdmUgYSBzdWJjaGFubmVsIHdpdGggdGhvc2UgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbFRhcmdldFxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsVGFyZ2V0XG4gICAgICogQHBhcmFtIGNoYW5uZWxBcmd1bWVudHNcbiAgICAgKiBAcGFyYW0gY2hhbm5lbENyZWRlbnRpYWxzXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVTdWJjaGFubmVsKGNoYW5uZWxUYXJnZXRVcmksIHN1YmNoYW5uZWxUYXJnZXQsIGNoYW5uZWxBcmd1bWVudHMsIGNoYW5uZWxDcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmVuc3VyZUNsZWFudXBUYXNrKCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxUYXJnZXQgPSAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKShjaGFubmVsVGFyZ2V0VXJpKTtcbiAgICAgICAgaWYgKGNoYW5uZWxUYXJnZXQgaW4gdGhpcy5wb29sKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsT2JqQXJyYXkgPSB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxPYmogb2Ygc3ViY2hhbm5lbE9iakFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc0VxdWFsKShzdWJjaGFubmVsVGFyZ2V0LCBzdWJjaGFubmVsT2JqLnN1YmNoYW5uZWxBZGRyZXNzKSAmJlxuICAgICAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbF9vcHRpb25zXzEuY2hhbm5lbE9wdGlvbnNFcXVhbCkoY2hhbm5lbEFyZ3VtZW50cywgc3ViY2hhbm5lbE9iai5jaGFubmVsQXJndW1lbnRzKSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ3JlZGVudGlhbHMuX2VxdWFscyhzdWJjaGFubmVsT2JqLmNoYW5uZWxDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWxPYmouc3ViY2hhbm5lbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIG5vIG1hdGNoaW5nIHN1YmNoYW5uZWwgd2FzIGZvdW5kXG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWwgPSBuZXcgc3ViY2hhbm5lbF8xLlN1YmNoYW5uZWwoY2hhbm5lbFRhcmdldFVyaSwgc3ViY2hhbm5lbFRhcmdldCwgY2hhbm5lbEFyZ3VtZW50cywgY2hhbm5lbENyZWRlbnRpYWxzLCBuZXcgdHJhbnNwb3J0XzEuSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXRVcmkpKTtcbiAgICAgICAgaWYgKCEoY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpKSB7XG4gICAgICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0ucHVzaCh7XG4gICAgICAgICAgICBzdWJjaGFubmVsQWRkcmVzczogc3ViY2hhbm5lbFRhcmdldCxcbiAgICAgICAgICAgIGNoYW5uZWxBcmd1bWVudHMsXG4gICAgICAgICAgICBjaGFubmVsQ3JlZGVudGlhbHMsXG4gICAgICAgICAgICBzdWJjaGFubmVsLFxuICAgICAgICB9KTtcbiAgICAgICAgc3ViY2hhbm5lbC5yZWYoKTtcbiAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWw7XG4gICAgfVxufVxuZXhwb3J0cy5TdWJjaGFubmVsUG9vbCA9IFN1YmNoYW5uZWxQb29sO1xuY29uc3QgZ2xvYmFsU3ViY2hhbm5lbFBvb2wgPSBuZXcgU3ViY2hhbm5lbFBvb2woKTtcbi8qKlxuICogR2V0IGVpdGhlciB0aGUgZ2xvYmFsIHN1YmNoYW5uZWwgcG9vbCwgb3IgYSBuZXcgc3ViY2hhbm5lbCBwb29sLlxuICogQHBhcmFtIGdsb2JhbFxuICovXG5mdW5jdGlvbiBnZXRTdWJjaGFubmVsUG9vbChnbG9iYWwpIHtcbiAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxTdWJjaGFubmVsUG9vbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ViY2hhbm5lbFBvb2woKTtcbiAgICB9XG59XG5leHBvcnRzLmdldFN1YmNoYW5uZWxQb29sID0gZ2V0U3ViY2hhbm5lbFBvb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLXBvb2wuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0U3ViY2hhbm5lbFBvb2wiLCJTdWJjaGFubmVsUG9vbCIsImNoYW5uZWxfb3B0aW9uc18xIiwicmVxdWlyZSIsInN1YmNoYW5uZWxfMSIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwidXJpX3BhcnNlcl8xIiwidHJhbnNwb3J0XzEiLCJSRUZfQ0hFQ0tfSU5URVJWQUwiLCJjb25zdHJ1Y3RvciIsInBvb2wiLCJjcmVhdGUiLCJjbGVhbnVwVGltZXIiLCJ1bnJlZlVudXNlZFN1YmNoYW5uZWxzIiwiYWxsU3ViY2hhbm5lbHNVbnJlZmVkIiwiY2hhbm5lbFRhcmdldCIsInN1YmNoYW5uZWxPYmpBcnJheSIsInJlZmVkU3ViY2hhbm5lbHMiLCJmaWx0ZXIiLCJzdWJjaGFubmVsIiwidW5yZWZJZk9uZVJlZiIsImxlbmd0aCIsImNsZWFySW50ZXJ2YWwiLCJlbnN1cmVDbGVhbnVwVGFzayIsIl9hIiwiX2IiLCJzZXRJbnRlcnZhbCIsInVucmVmIiwiY2FsbCIsImdldE9yQ3JlYXRlU3ViY2hhbm5lbCIsImNoYW5uZWxUYXJnZXRVcmkiLCJzdWJjaGFubmVsVGFyZ2V0IiwiY2hhbm5lbEFyZ3VtZW50cyIsImNoYW5uZWxDcmVkZW50aWFscyIsInVyaVRvU3RyaW5nIiwic3ViY2hhbm5lbE9iaiIsInN1YmNoYW5uZWxBZGRyZXNzRXF1YWwiLCJzdWJjaGFubmVsQWRkcmVzcyIsImNoYW5uZWxPcHRpb25zRXF1YWwiLCJfZXF1YWxzIiwiU3ViY2hhbm5lbCIsIkh0dHAyU3ViY2hhbm5lbENvbm5lY3RvciIsInB1c2giLCJyZWYiLCJnbG9iYWxTdWJjaGFubmVsUG9vbCIsImdsb2JhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Subchannel = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst TRACER_NAME = \"subchannel\";\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */ const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nclass Subchannel {\n    /**\n     * A class representing a connection to a single backend.\n     * @param channelTarget The target string for the channel as a whole\n     * @param subchannelAddress The address for the backend that this subchannel\n     *     will connect to\n     * @param options The channel options, plus any specific subchannel options\n     *     for this subchannel\n     * @param credentials The channel credentials used to establish this\n     *     connection\n     */ constructor(channelTarget, subchannelAddress, options, credentials, connector){\n        var _a;\n        this.channelTarget = channelTarget;\n        this.subchannelAddress = subchannelAddress;\n        this.options = options;\n        this.credentials = credentials;\n        this.connector = connector;\n        /**\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n         */ this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The underlying http2 session used to make requests.\n         */ this.transport = null;\n        /**\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n         * CONNECTING instead of IDLE when the backoff timeout ends.\n         */ this.continueConnecting = false;\n        /**\n         * A list of listener functions that will be called whenever the connectivity\n         * state changes. Will be modified by `addConnectivityStateListener` and\n         * `removeConnectivityStateListener`\n         */ this.stateListeners = new Set();\n        /**\n         * Tracks channels and subchannel pools with references to this subchannel\n         */ this.refcount = 0;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        // Channelz socket info\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        const backoffOptions = {\n            initialDelay: options[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: options[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(()=>{\n            this.handleBackoffTimer();\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        this.keepaliveTime = (_a = options[\"grpc.keepalive_time_ms\"]) !== null && _a !== void 0 ? _a : -1;\n        if (options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Subchannel created\");\n        }\n        this.trace(\"Subchannel constructed with options \" + JSON.stringify(options, undefined, 2));\n    }\n    getChannelzInfo() {\n        return {\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n            target: this.subchannelAddressString\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    refTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"subchannel_refcount\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    handleBackoffTimer() {\n        if (this.continueConnecting) {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.CONNECTING);\n        } else {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.IDLE);\n        }\n    }\n    /**\n     * Start a backoff timer with the current nextBackoff timeout\n     */ startBackoff() {\n        this.backoffTimeout.runOnce();\n    }\n    stopBackoff() {\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n    }\n    startConnectingInternal() {\n        let options = this.options;\n        if (options[\"grpc.keepalive_time_ms\"]) {\n            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n            options = Object.assign(Object.assign({}, options), {\n                \"grpc.keepalive_time_ms\": adjustedKeepaliveTime\n            });\n        }\n        this.connector.connect(this.subchannelAddress, this.credentials, options).then((transport)=>{\n            if (this.transitionToState([\n                connectivity_state_1.ConnectivityState.CONNECTING\n            ], connectivity_state_1.ConnectivityState.READY)) {\n                this.transport = transport;\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(transport.getChannelzRef());\n                }\n                transport.addDisconnectListener((tooManyPings)=>{\n                    this.transitionToState([\n                        connectivity_state_1.ConnectivityState.READY\n                    ], connectivity_state_1.ConnectivityState.IDLE);\n                    if (tooManyPings && this.keepaliveTime > 0) {\n                        this.keepaliveTime *= 2;\n                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\n                    }\n                });\n            }\n        }, (error)=>{\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.CONNECTING\n            ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);\n        });\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */ transitionToState(oldStates, newState, errorMessage) {\n        var _a, _b;\n        if (oldStates.indexOf(this.connectivityState) === -1) {\n            return false;\n        }\n        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Connectivity state change to \" + connectivity_state_1.ConnectivityState[newState]);\n        }\n        const previousState = this.connectivityState;\n        this.connectivityState = newState;\n        switch(newState){\n            case connectivity_state_1.ConnectivityState.READY:\n                this.stopBackoff();\n                break;\n            case connectivity_state_1.ConnectivityState.CONNECTING:\n                this.startBackoff();\n                this.startConnectingInternal();\n                this.continueConnecting = false;\n                break;\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\n                this.transport = null;\n                /* If the backoff timer has already ended by the time we get to the\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */ if (!this.backoffTimeout.isRunning()) {\n                    process.nextTick(()=>{\n                        this.handleBackoffTimer();\n                    });\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.IDLE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\n                this.transport = null;\n                break;\n            default:\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n        }\n        for (const listener of this.stateListeners){\n            listener(this, previousState, newState, this.keepaliveTime, errorMessage);\n        }\n        return true;\n    }\n    ref() {\n        this.refTrace(\"refcount \" + this.refcount + \" -> \" + (this.refcount + 1));\n        this.refcount += 1;\n    }\n    unref() {\n        this.refTrace(\"refcount \" + this.refcount + \" -> \" + (this.refcount - 1));\n        this.refcount -= 1;\n        if (this.refcount === 0) {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Shutting down\");\n            }\n            if (this.channelzEnabled) {\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            }\n            process.nextTick(()=>{\n                this.transitionToState([\n                    connectivity_state_1.ConnectivityState.CONNECTING,\n                    connectivity_state_1.ConnectivityState.READY\n                ], connectivity_state_1.ConnectivityState.IDLE);\n            });\n        }\n    }\n    unrefIfOneRef() {\n        if (this.refcount === 1) {\n            this.unref();\n            return true;\n        }\n        return false;\n    }\n    createCall(metadata, host, method, listener) {\n        if (!this.transport) {\n            throw new Error(\"Cannot create call, subchannel not READY\");\n        }\n        let statsTracker;\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            this.streamTracker.addCallStarted();\n            statsTracker = {\n                onCallEnd: (status)=>{\n                    if (status.code === constants_1.Status.OK) {\n                        this.callTracker.addCallSucceeded();\n                    } else {\n                        this.callTracker.addCallFailed();\n                    }\n                }\n            };\n        } else {\n            statsTracker = {};\n        }\n        return this.transport.createCall(metadata, host, method, listener, statsTracker);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */ startConnecting() {\n        process.nextTick(()=>{\n            /* First, try to transition from IDLE to connecting. If that doesn't happen\n             * because the state is not currently IDLE, check if it is\n             * TRANSIENT_FAILURE, and if so indicate that it should go back to\n             * connecting after the backoff timer ends. Otherwise do nothing */ if (!this.transitionToState([\n                connectivity_state_1.ConnectivityState.IDLE\n            ], connectivity_state_1.ConnectivityState.CONNECTING)) {\n                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    this.continueConnecting = true;\n                }\n            }\n        });\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */ getConnectivityState() {\n        return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */ addConnectivityStateListener(listener) {\n        this.stateListeners.add(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */ removeConnectivityStateListener(listener) {\n        this.stateListeners.delete(listener);\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */ resetBackoff() {\n        process.nextTick(()=>{\n            this.backoffTimeout.reset();\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.CONNECTING);\n        });\n    }\n    getAddress() {\n        return this.subchannelAddressString;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getRealSubchannel() {\n        return this;\n    }\n    realSubchannelEquals(other) {\n        return other.getRealSubchannel() === this;\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n        }\n    }\n}\nexports.Subchannel = Subchannel; //# sourceMappingURL=subchannel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHLEtBQUs7QUFDMUIsTUFBTUcsdUJBQXVCQyxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUMsb0JBQW9CRCxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTUcsY0FBY0gsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUksZUFBZUosbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTUssdUJBQXVCTCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTU0sYUFBYU4sbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTU8sY0FBYztBQUNwQjs7bUJBRW1CLEdBQ25CLE1BQU1DLHdCQUF3QixDQUFFLE1BQUssRUFBQztBQUN0QyxNQUFNVjtJQUNGOzs7Ozs7Ozs7S0FTQyxHQUNEVyxZQUFZQyxhQUFhLEVBQUVDLGlCQUFpQixFQUFFQyxPQUFPLEVBQUVDLFdBQVcsRUFBRUMsU0FBUyxDQUFFO1FBQzNFLElBQUlDO1FBQ0osSUFBSSxDQUFDTCxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdBO1FBQ3pCLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakI7OztTQUdDLEdBQ0QsSUFBSSxDQUFDRSxpQkFBaUIsR0FBR2pCLHFCQUFxQmtCLGlCQUFpQixDQUFDQyxJQUFJO1FBQ3BFOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakI7OztTQUdDLEdBQ0QsSUFBSSxDQUFDQyxr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Q3JGLElBQUksQ0FBQ3hDLGtCQUFrQixHQUFHO2dCQUM5QjtZQUNKO1FBQ0o7SUFDSjtJQUNBOztLQUVDLEdBQ0Q2Rix1QkFBdUI7UUFDbkIsT0FBTyxJQUFJLENBQUNqRyxpQkFBaUI7SUFDakM7SUFDQTs7OztLQUlDLEdBQ0RrRyw2QkFBNkJuQixRQUFRLEVBQUU7UUFDbkMsSUFBSSxDQUFDMUUsY0FBYyxDQUFDOEYsR0FBRyxDQUFDcEI7SUFDNUI7SUFDQTs7OztLQUlDLEdBQ0RxQixnQ0FBZ0NyQixRQUFRLEVBQUU7UUFDdEMsSUFBSSxDQUFDMUUsY0FBYyxDQUFDZ0csTUFBTSxDQUFDdEI7SUFDL0I7SUFDQTs7S0FFQyxHQUNEdUIsZUFBZTtRQUNYMUIsT0FBT0EsQ0FBQ0MsUUFBUSxDQUFDO1lBQ2IsSUFBSSxDQUFDNUQsY0FBYyxDQUFDaUMsS0FBSztZQUN6QixJQUFJLENBQUNQLGlCQUFpQixDQUFDO2dCQUFDNUQscUJBQXFCa0IsaUJBQWlCLENBQUMyQyxpQkFBaUI7YUFBQyxFQUFFN0QscUJBQXFCa0IsaUJBQWlCLENBQUM0QyxVQUFVO1FBQ3hJO0lBQ0o7SUFDQTBELGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ2xGLHVCQUF1QjtJQUN2QztJQUNBdUMsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUNsQyxXQUFXO0lBQzNCO0lBQ0E4RSxvQkFBb0I7UUFDaEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMscUJBQXFCQyxLQUFLLEVBQUU7UUFDeEIsT0FBT0EsTUFBTUYsaUJBQWlCLE9BQU8sSUFBSTtJQUM3QztJQUNBRyxrQkFBa0JDLGdCQUFnQixFQUFFO1FBQ2hDLElBQUlBLG1CQUFtQixJQUFJLENBQUNyRixhQUFhLEVBQUU7WUFDdkMsSUFBSSxDQUFDQSxhQUFhLEdBQUdxRjtRQUN6QjtJQUNKO0FBQ0o7QUFDQWhJLGtCQUFrQixHQUFHRSxZQUNyQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLmpzPzg4NzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3ViY2hhbm5lbCA9IHZvaWQgMDtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc3ViY2hhbm5lbCc7XG4vKiBzZXRJbnRlcnZhbCBhbmQgc2V0VGltZW91dCBvbmx5IGFjY2VwdCBzaWduZWQgMzIgYml0IGludGVnZXJzLiBKUyBkb2Vzbid0XG4gKiBoYXZlIGEgY29uc3RhbnQgZm9yIHRoZSBtYXggc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLCBzbyB0aGlzIGlzIGEgc2ltcGxlIHdheVxuICogdG8gY2FsY3VsYXRlIGl0ICovXG5jb25zdCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMgPSB+KDEgPDwgMzEpO1xuY2xhc3MgU3ViY2hhbm5lbCB7XG4gICAgLyoqXG4gICAgICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBjb25uZWN0aW9uIHRvIGEgc2luZ2xlIGJhY2tlbmQuXG4gICAgICogQHBhcmFtIGNoYW5uZWxUYXJnZXQgVGhlIHRhcmdldCBzdHJpbmcgZm9yIHRoZSBjaGFubmVsIGFzIGEgd2hvbGVcbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbEFkZHJlc3MgVGhlIGFkZHJlc3MgZm9yIHRoZSBiYWNrZW5kIHRoYXQgdGhpcyBzdWJjaGFubmVsXG4gICAgICogICAgIHdpbGwgY29ubmVjdCB0b1xuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjaGFubmVsIG9wdGlvbnMsIHBsdXMgYW55IHNwZWNpZmljIHN1YmNoYW5uZWwgb3B0aW9uc1xuICAgICAqICAgICBmb3IgdGhpcyBzdWJjaGFubmVsXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxzIFRoZSBjaGFubmVsIGNyZWRlbnRpYWxzIHVzZWQgdG8gZXN0YWJsaXNoIHRoaXNcbiAgICAgKiAgICAgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxUYXJnZXQsIHN1YmNoYW5uZWxBZGRyZXNzLCBvcHRpb25zLCBjcmVkZW50aWFscywgY29ubmVjdG9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5jaGFubmVsVGFyZ2V0ID0gY2hhbm5lbFRhcmdldDtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzcyA9IHN1YmNoYW5uZWxBZGRyZXNzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN1YmNoYW5uZWwncyBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZS4gSW52YXJpYW50OiBgc2Vzc2lvbmAgPT09IGBudWxsYFxuICAgICAgICAgKiBpZiBhbmQgb25seSBpZiBgY29ubmVjdGl2aXR5U3RhdGVgIGlzIElETEUgb3IgVFJBTlNJRU5UX0ZBSUxVUkUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmRlcmx5aW5nIGh0dHAyIHNlc3Npb24gdXNlZCB0byBtYWtlIHJlcXVlc3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHN1YmNoYW5uZWwgc2hvdWxkIHRyYW5zaXRpb24gZnJvbSBUUkFOU0lFTlRfRkFJTFVSRSB0b1xuICAgICAgICAgKiBDT05ORUNUSU5HIGluc3RlYWQgb2YgSURMRSB3aGVuIHRoZSBiYWNrb2ZmIHRpbWVvdXQgZW5kcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGludWVDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIGNvbm5lY3Rpdml0eVxuICAgICAgICAgKiBzdGF0ZSBjaGFuZ2VzLiBXaWxsIGJlIG1vZGlmaWVkIGJ5IGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYCBhbmRcbiAgICAgICAgICogYHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tzIGNoYW5uZWxzIGFuZCBzdWJjaGFubmVsIHBvb2xzIHdpdGggcmVmZXJlbmNlcyB0byB0aGlzIHN1YmNoYW5uZWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVmY291bnQgPSAwO1xuICAgICAgICAvLyBDaGFubmVseiBpbmZvXG4gICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxsVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICAvLyBDaGFubmVseiBzb2NrZXQgaW5mb1xuICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBvcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBvcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0ID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmFja29mZlRpbWVyKCk7XG4gICAgICAgIH0sIGJhY2tvZmZPcHRpb25zKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC51bnJlZigpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKHN1YmNoYW5uZWxBZGRyZXNzKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gKF9hID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTtcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwpKHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcsICgpID0+IHRoaXMuZ2V0Q2hhbm5lbHpJbmZvKCksIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU3ViY2hhbm5lbCBjcmVhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnU3ViY2hhbm5lbCBjb25zdHJ1Y3RlZCB3aXRoIG9wdGlvbnMgJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShvcHRpb25zLCB1bmRlZmluZWQsIDIpKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY29ubmVjdGl2aXR5U3RhdGUsXG4gICAgICAgICAgICB0cmFjZTogdGhpcy5jaGFubmVselRyYWNlLFxuICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpLFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAgcmVmVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ3N1YmNoYW5uZWxfcmVmY291bnQnLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICBoYW5kbGVCYWNrb2ZmVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRpbnVlQ29ubmVjdGluZykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBiYWNrb2ZmIHRpbWVyIHdpdGggdGhlIGN1cnJlbnQgbmV4dEJhY2tvZmYgdGltZW91dFxuICAgICAqL1xuICAgIHN0YXJ0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5ydW5PbmNlKCk7XG4gICAgfVxuICAgIHN0b3BCYWNrb2ZmKCkge1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmdJbnRlcm5hbCgpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ10pIHtcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkS2VlcGFsaXZlVGltZSA9IE1hdGgubWluKHRoaXMua2VlcGFsaXZlVGltZSwgS0VFUEFMSVZFX01BWF9USU1FX01TKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7ICdncnBjLmtlZXBhbGl2ZV90aW1lX21zJzogYWRqdXN0ZWRLZWVwYWxpdmVUaW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdG9yXG4gICAgICAgICAgICAuY29ubmVjdCh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzLCB0aGlzLmNyZWRlbnRpYWxzLCBvcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4odHJhbnNwb3J0ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKHRyYW5zcG9ydC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmFkZERpc2Nvbm5lY3RMaXN0ZW5lcih0b29NYW55UGluZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vTWFueVBpbmdzICYmIHRoaXMua2VlcGFsaXZlVGltZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSAqPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgQ29ubmVjdGlvbiB0byAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMuY2hhbm5lbFRhcmdldCl9IGF0ICR7dGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZ30gcmVqZWN0ZWQgYnkgc2VydmVyIGJlY2F1c2Ugb2YgZXhjZXNzIHBpbmdzLiBJbmNyZWFzaW5nIHBpbmcgaW50ZXJ2YWwgdG8gJHt0aGlzLmtlZXBhbGl2ZVRpbWV9IG1zYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR10sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBgJHtlcnJvcn1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgc3RhdGUgdHJhbnNpdGlvbiBmcm9tIGFueSBlbGVtZW50IG9mIG9sZFN0YXRlcyB0byB0aGUgbmV3XG4gICAgICogc3RhdGUuIElmIHRoZSBjdXJyZW50IGNvbm5lY3Rpdml0eVN0YXRlIGlzIG5vdCBpbiBvbGRTdGF0ZXMsIGRvIG5vdGhpbmcuXG4gICAgICogQHBhcmFtIG9sZFN0YXRlcyBUaGUgc2V0IG9mIHN0YXRlcyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICAgKiBAcGFyYW0gbmV3U3RhdGUgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdGF0ZSBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uVG9TdGF0ZShvbGRTdGF0ZXMsIG5ld1N0YXRlLCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKG9sZFN0YXRlcy5pbmRleE9mKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UgdG8gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgc3dpdGNoIChuZXdTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWTpcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BCYWNrb2ZmKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZ0ludGVybmFsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkICYmIHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQodGhpcy50cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIGJhY2tvZmYgdGltZXIgaGFzIGFscmVhZHkgZW5kZWQgYnkgdGhlIHRpbWUgd2UgZ2V0IHRvIHRoZVxuICAgICAgICAgICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFIHN0YXRlLCB3ZSB3YW50IHRvIGltbWVkaWF0ZWx5IHRyYW5zaXRpb24gb3V0IG9mXG4gICAgICAgICAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUgYXMgdGhvdWdoIHRoZSBiYWNrb2ZmIHRpbWVyIGlzIGVuZGluZyByaWdodCBub3cgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmFja29mZlRpbWVvdXQuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJhY2tvZmZUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkICYmIHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQodGhpcy50cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZTogdW5rbm93biBDb25uZWN0aXZpdHlTdGF0ZSAke25ld1N0YXRlfWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIHRoaXMua2VlcGFsaXZlVGltZSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVmKCkge1xuICAgICAgICB0aGlzLnJlZlRyYWNlKCdyZWZjb3VudCAnICsgdGhpcy5yZWZjb3VudCArICcgLT4gJyArICh0aGlzLnJlZmNvdW50ICsgMSkpO1xuICAgICAgICB0aGlzLnJlZmNvdW50ICs9IDE7XG4gICAgfVxuICAgIHVucmVmKCkge1xuICAgICAgICB0aGlzLnJlZlRyYWNlKCdyZWZjb3VudCAnICsgdGhpcy5yZWZjb3VudCArICcgLT4gJyArICh0aGlzLnJlZmNvdW50IC0gMSkpO1xuICAgICAgICB0aGlzLnJlZmNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLnJlZmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU2h1dHRpbmcgZG93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKSh0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnJlZklmT25lUmVmKCkge1xuICAgICAgICBpZiAodGhpcy5yZWZjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy51bnJlZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsKG1ldGFkYXRhLCBob3N0LCBtZXRob2QsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBjYWxsLCBzdWJjaGFubmVsIG5vdCBSRUFEWScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0c1RyYWNrZXI7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgICAgICBzdGF0c1RyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgb25DYWxsRW5kOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdHNUcmFja2VyID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmNyZWF0ZUNhbGwobWV0YWRhdGEsIGhvc3QsIG1ldGhvZCwgbGlzdGVuZXIsIHN0YXRzVHJhY2tlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzdWJjaGFubmVsIGlzIGN1cnJlbnRseSBJRExFLCBzdGFydCBjb25uZWN0aW5nIGFuZCBzd2l0Y2ggdG8gdGhlXG4gICAgICogQ09OTkVDVElORyBzdGF0ZS4gSWYgdGhlIHN1YmNoYW5uZWwgaXMgY3VycmVudCBpbiBUUkFOU0lFTlRfRkFJTFVSRSxcbiAgICAgKiB0aGUgbmV4dCB0aW1lIGl0IHdvdWxkIHRyYW5zaXRpb24gdG8gSURMRSwgc3RhcnQgY29ubmVjdGluZyBhZ2FpbiBpbnN0ZWFkLlxuICAgICAqIE90aGVyd2lzZSwgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgLyogRmlyc3QsIHRyeSB0byB0cmFuc2l0aW9uIGZyb20gSURMRSB0byBjb25uZWN0aW5nLiBJZiB0aGF0IGRvZXNuJ3QgaGFwcGVuXG4gICAgICAgICAgICAgKiBiZWNhdXNlIHRoZSBzdGF0ZSBpcyBub3QgY3VycmVudGx5IElETEUsIGNoZWNrIGlmIGl0IGlzXG4gICAgICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRSwgYW5kIGlmIHNvIGluZGljYXRlIHRoYXQgaXQgc2hvdWxkIGdvIGJhY2sgdG9cbiAgICAgICAgICAgICAqIGNvbm5lY3RpbmcgYWZ0ZXIgdGhlIGJhY2tvZmYgdGltZXIgZW5kcy4gT3RoZXJ3aXNlIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVDb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN1YmNoYW5uZWwncyBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZS5cbiAgICAgKi9cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc3ViY2hhbm5lbCdzXG4gICAgICogY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIHByZXZpb3VzbHkgYWRkZWQgd2l0aCBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQSByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHBhc3NlZCB0b1xuICAgICAqICAgICBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKi9cbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGJhY2tvZmYgdGltZW91dCwgYW5kIGltbWVkaWF0ZWx5IHN0YXJ0IGNvbm5lY3RpbmcgaWYgaW4gYmFja29mZi5cbiAgICAgKi9cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nO1xuICAgIH1cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XG4gICAgfVxuICAgIGdldFJlYWxTdWJjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVhbFN1YmNoYW5uZWxFcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLmdldFJlYWxTdWJjaGFubmVsKCkgPT09IHRoaXM7XG4gICAgfVxuICAgIHRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpIHtcbiAgICAgICAgaWYgKG5ld0tlZXBhbGl2ZVRpbWUgPiB0aGlzLmtlZXBhbGl2ZVRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IG5ld0tlZXBhbGl2ZVRpbWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlN1YmNoYW5uZWwgPSBTdWJjaGFubmVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdWJjaGFubmVsIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJyZXF1aXJlIiwiYmFja29mZl90aW1lb3V0XzEiLCJsb2dnaW5nIiwiY29uc3RhbnRzXzEiLCJ1cmlfcGFyc2VyXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsImNoYW5uZWx6XzEiLCJUUkFDRVJfTkFNRSIsIktFRVBBTElWRV9NQVhfVElNRV9NUyIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbFRhcmdldCIsInN1YmNoYW5uZWxBZGRyZXNzIiwib3B0aW9ucyIsImNyZWRlbnRpYWxzIiwiY29ubmVjdG9yIiwiX2EiLCJjb25uZWN0aXZpdHlTdGF0ZSIsIkNvbm5lY3Rpdml0eVN0YXRlIiwiSURMRSIsInRyYW5zcG9ydCIsImNvbnRpbnVlQ29ubmVjdGluZyIsInN0YXRlTGlzdGVuZXJzIiwiU2V0IiwicmVmY291bnQiLCJjaGFubmVsekVuYWJsZWQiLCJjYWxsVHJhY2tlciIsIkNoYW5uZWx6Q2FsbFRyYWNrZXIiLCJjaGlsZHJlblRyYWNrZXIiLCJDaGFubmVsekNoaWxkcmVuVHJhY2tlciIsInN0cmVhbVRyYWNrZXIiLCJiYWNrb2ZmT3B0aW9ucyIsImluaXRpYWxEZWxheSIsIm1heERlbGF5IiwiYmFja29mZlRpbWVvdXQiLCJCYWNrb2ZmVGltZW91dCIsImhhbmRsZUJhY2tvZmZUaW1lciIsInVucmVmIiwic3ViY2hhbm5lbEFkZHJlc3NTdHJpbmciLCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nIiwia2VlcGFsaXZlVGltZSIsImNoYW5uZWx6VHJhY2UiLCJDaGFubmVselRyYWNlIiwiY2hhbm5lbHpSZWYiLCJyZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCIsImdldENoYW5uZWx6SW5mbyIsImFkZFRyYWNlIiwidHJhY2UiLCJKU09OIiwic3RyaW5naWZ5IiwidW5kZWZpbmVkIiwic3RhdGUiLCJjaGlsZHJlbiIsImdldENoaWxkTGlzdHMiLCJ0YXJnZXQiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJpZCIsInJlZlRyYWNlIiwidHJhbnNpdGlvblRvU3RhdGUiLCJUUkFOU0lFTlRfRkFJTFVSRSIsIkNPTk5FQ1RJTkciLCJzdGFydEJhY2tvZmYiLCJydW5PbmNlIiwic3RvcEJhY2tvZmYiLCJzdG9wIiwicmVzZXQiLCJzdGFydENvbm5lY3RpbmdJbnRlcm5hbCIsImFkanVzdGVkS2VlcGFsaXZlVGltZSIsIk1hdGgiLCJtaW4iLCJhc3NpZ24iLCJjb25uZWN0IiwidGhlbiIsIlJFQURZIiwicmVmQ2hpbGQiLCJnZXRDaGFubmVselJlZiIsImFkZERpc2Nvbm5lY3RMaXN0ZW5lciIsInRvb01hbnlQaW5ncyIsImxvZyIsIkVSUk9SIiwidXJpVG9TdHJpbmciLCJlcnJvciIsIm9sZFN0YXRlcyIsIm5ld1N0YXRlIiwiZXJyb3JNZXNzYWdlIiwiX2IiLCJpbmRleE9mIiwicHJldmlvdXNTdGF0ZSIsInVucmVmQ2hpbGQiLCJzaHV0ZG93biIsImlzUnVubmluZyIsInByb2Nlc3MiLCJuZXh0VGljayIsIkVycm9yIiwibGlzdGVuZXIiLCJyZWYiLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJ1bnJlZklmT25lUmVmIiwiY3JlYXRlQ2FsbCIsIm1ldGFkYXRhIiwiaG9zdCIsIm1ldGhvZCIsInN0YXRzVHJhY2tlciIsImFkZENhbGxTdGFydGVkIiwib25DYWxsRW5kIiwic3RhdHVzIiwiY29kZSIsIlN0YXR1cyIsIk9LIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsImFkZENhbGxGYWlsZWQiLCJzdGFydENvbm5lY3RpbmciLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsImFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJhZGQiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwiZGVsZXRlIiwicmVzZXRCYWNrb2ZmIiwiZ2V0QWRkcmVzcyIsImdldFJlYWxTdWJjaGFubmVsIiwicmVhbFN1YmNoYW5uZWxFcXVhbHMiLCJvdGhlciIsInRocm90dGxlS2VlcGFsaXZlIiwibmV3S2VlcGFsaXZlVGltZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/tls-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDefaultRootsData = exports.CIPHER_SUITES = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\nlet defaultRootsData = null;\nfunction getDefaultRootsData() {\n    if (DEFAULT_ROOTS_FILE_PATH) {\n        if (defaultRootsData === null) {\n            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\n        }\n        return defaultRootsData;\n    }\n    return null;\n}\nexports.getDefaultRootsData = getDefaultRootsData; //# sourceMappingURL=tls-helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUMzRCxNQUFNSSxLQUFLQyxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCTCxxQkFBcUIsR0FBR00sT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxzQkFBc0I7QUFDMUQsTUFBTUMsMEJBQTBCSCxPQUFPQSxDQUFDQyxHQUFHLENBQUNHLGdDQUFnQztBQUM1RSxJQUFJQyxtQkFBbUI7QUFDdkIsU0FBU1Q7SUFDTCxJQUFJTyx5QkFBeUI7UUFDekIsSUFBSUUscUJBQXFCLE1BQU07WUFDM0JBLG1CQUFtQlAsR0FBR1EsWUFBWSxDQUFDSDtRQUN2QztRQUNBLE9BQU9FO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQVgsMkJBQTJCLEdBQUdFLHFCQUM5Qix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy90bHMtaGVscGVycy5qcz8wZWQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERlZmF1bHRSb290c0RhdGEgPSBleHBvcnRzLkNJUEhFUl9TVUlURVMgPSB2b2lkIDA7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmV4cG9ydHMuQ0lQSEVSX1NVSVRFUyA9IHByb2Nlc3MuZW52LkdSUENfU1NMX0NJUEhFUl9TVUlURVM7XG5jb25zdCBERUZBVUxUX1JPT1RTX0ZJTEVfUEFUSCA9IHByb2Nlc3MuZW52LkdSUENfREVGQVVMVF9TU0xfUk9PVFNfRklMRV9QQVRIO1xubGV0IGRlZmF1bHRSb290c0RhdGEgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFJvb3RzRGF0YSgpIHtcbiAgICBpZiAoREVGQVVMVF9ST09UU19GSUxFX1BBVEgpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRSb290c0RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRSb290c0RhdGEgPSBmcy5yZWFkRmlsZVN5bmMoREVGQVVMVF9ST09UU19GSUxFX1BBVEgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Um9vdHNEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZ2V0RGVmYXVsdFJvb3RzRGF0YSA9IGdldERlZmF1bHRSb290c0RhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10bHMtaGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXREZWZhdWx0Um9vdHNEYXRhIiwiQ0lQSEVSX1NVSVRFUyIsImZzIiwicmVxdWlyZSIsInByb2Nlc3MiLCJlbnYiLCJHUlBDX1NTTF9DSVBIRVJfU1VJVEVTIiwiREVGQVVMVF9ST09UU19GSUxFX1BBVEgiLCJHUlBDX0RFRkFVTFRfU1NMX1JPT1RTX0ZJTEVfUEFUSCIsImRlZmF1bHRSb290c0RhdGEiLCJyZWFkRmlsZVN5bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/transport.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/transport.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2SubchannelConnector = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst subchannel_call_1 = __webpack_require__(/*! ./subchannel-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst TRACER_NAME = \"transport\";\nconst FLOW_CONTROL_TRACER_NAME = \"transport_flowctrl\";\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst tooManyPingsData = Buffer.from(\"too_many_pings\", \"ascii\");\nclass Http2Transport {\n    constructor(session, subchannelAddress, options, /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */ remoteName){\n        this.session = session;\n        this.remoteName = remoteName;\n        /**\n         * The amount of time in between sending pings\n         */ this.keepaliveTimeMs = -1;\n        /**\n         * The amount of time to wait for an acknowledgement after sending a ping\n         */ this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n        /**\n         * Timer reference for timeout that indicates when to send the next ping\n         */ this.keepaliveTimerId = null;\n        /**\n         * Indicates that the keepalive timer ran out while there were no active\n         * calls, and a ping should be sent the next time a call starts.\n         */ this.pendingSendKeepalivePing = false;\n        /**\n         * Timer reference tracking when the most recent ping will be considered lost\n         */ this.keepaliveTimeoutId = null;\n        /**\n         * Indicates whether keepalive pings should be sent without any active calls\n         */ this.keepaliveWithoutCalls = false;\n        this.activeCalls = new Set();\n        this.disconnectListeners = [];\n        this.disconnectHandled = false;\n        this.channelzEnabled = true;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n        /* Populate subchannelAddressString and channelzRef before doing anything\n         * else, because they are used in the trace methods. */ this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        if (options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        // Build user-agent string.\n        this.userAgent = [\n            options[\"grpc.primary_user_agent\"],\n            `grpc-node-js/${clientVersion}`,\n            options[\"grpc.secondary_user_agent\"]\n        ].filter((e)=>e).join(\" \"); // remove falsey values first\n        if (\"grpc.keepalive_time_ms\" in options) {\n            this.keepaliveTimeMs = options[\"grpc.keepalive_time_ms\"];\n        }\n        if (\"grpc.keepalive_timeout_ms\" in options) {\n            this.keepaliveTimeoutMs = options[\"grpc.keepalive_timeout_ms\"];\n        }\n        if (\"grpc.keepalive_permit_without_calls\" in options) {\n            this.keepaliveWithoutCalls = options[\"grpc.keepalive_permit_without_calls\"] === 1;\n        } else {\n            this.keepaliveWithoutCalls = false;\n        }\n        session.once(\"close\", ()=>{\n            this.trace(\"session closed\");\n            this.stopKeepalivePings();\n            this.handleDisconnect();\n        });\n        session.once(\"goaway\", (errorCode, lastStreamID, opaqueData)=>{\n            let tooManyPings = false;\n            /* See the last paragraph of\n             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */ if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData && opaqueData.equals(tooManyPingsData)) {\n                tooManyPings = true;\n            }\n            this.trace(\"connection closed by GOAWAY with code \" + errorCode + \" and data \" + (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));\n            this.reportDisconnectToOwner(tooManyPings);\n        });\n        session.once(\"error\", (error)=>{\n            /* Do nothing here. Any error should also trigger a close event, which is\n             * where we want to handle that.  */ this.trace(\"connection closed with error \" + error.message);\n        });\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            session.on(\"remoteSettings\", (settings)=>{\n                this.trace(\"new settings received\" + (this.session !== session ? \" on the old connection\" : \"\") + \": \" + JSON.stringify(settings));\n            });\n            session.on(\"localSettings\", (settings)=>{\n                this.trace(\"local settings acknowledged by remote\" + (this.session !== session ? \" on the old connection\" : \"\") + \": \" + JSON.stringify(settings));\n            });\n        }\n        /* Start the keepalive timer last, because this can trigger trace logs,\n         * which should only happen after everything else is set up. */ if (this.keepaliveWithoutCalls) {\n            this.maybeStartKeepalivePingTimer();\n        }\n    }\n    getChannelzInfo() {\n        var _a, _b, _c;\n        const sessionSocket = this.session.socket;\n        const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n        const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n        let tlsInfo;\n        if (this.session.encrypted) {\n            const tlsSocket = sessionSocket;\n            const cipherInfo = tlsSocket.getCipher();\n            const certificate = tlsSocket.getCertificate();\n            const peerCertificate = tlsSocket.getPeerCertificate();\n            tlsInfo = {\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                localCertificate: certificate && \"raw\" in certificate ? certificate.raw : null,\n                remoteCertificate: peerCertificate && \"raw\" in peerCertificate ? peerCertificate.raw : null\n            };\n        } else {\n            tlsInfo = null;\n        }\n        const socketInfo = {\n            remoteAddress: remoteAddress,\n            localAddress: localAddress,\n            security: tlsInfo,\n            remoteName: this.remoteName,\n            streamsStarted: this.streamTracker.callsStarted,\n            streamsSucceeded: this.streamTracker.callsSucceeded,\n            streamsFailed: this.streamTracker.callsFailed,\n            messagesSent: this.messagesSent,\n            messagesReceived: this.messagesReceived,\n            keepAlivesSent: this.keepalivesSent,\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n            lastRemoteStreamCreatedTimestamp: null,\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n        };\n        return socketInfo;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    keepaliveTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"keepalive\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    flowControlTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    internalsTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"transport_internals\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    /**\n     * Indicate to the owner of this object that this transport should no longer\n     * be used. That happens if the connection drops, or if the server sends a\n     * GOAWAY.\n     * @param tooManyPings If true, this was triggered by a GOAWAY with data\n     * indicating that the session was closed becaues the client sent too many\n     * pings.\n     * @returns\n     */ reportDisconnectToOwner(tooManyPings) {\n        if (this.disconnectHandled) {\n            return;\n        }\n        this.disconnectHandled = true;\n        this.disconnectListeners.forEach((listener)=>listener(tooManyPings));\n    }\n    /**\n     * Handle connection drops, but not GOAWAYs.\n     */ handleDisconnect() {\n        this.reportDisconnectToOwner(false);\n        /* Give calls an event loop cycle to finish naturally before reporting the\n         * disconnnection to them. */ setImmediate(()=>{\n            for (const call of this.activeCalls){\n                call.onDisconnect();\n            }\n        });\n    }\n    addDisconnectListener(listener) {\n        this.disconnectListeners.push(listener);\n    }\n    clearKeepaliveTimer() {\n        if (!this.keepaliveTimerId) {\n            return;\n        }\n        clearTimeout(this.keepaliveTimerId);\n        this.keepaliveTimerId = null;\n    }\n    clearKeepaliveTimeout() {\n        if (!this.keepaliveTimeoutId) {\n            return;\n        }\n        clearTimeout(this.keepaliveTimeoutId);\n        this.keepaliveTimeoutId = null;\n    }\n    canSendPing() {\n        return this.keepaliveTimeMs > 0 && (this.keepaliveWithoutCalls || this.activeCalls.size > 0);\n    }\n    maybeSendPing() {\n        var _a, _b;\n        this.clearKeepaliveTimer();\n        if (!this.canSendPing()) {\n            this.pendingSendKeepalivePing = true;\n            return;\n        }\n        if (this.channelzEnabled) {\n            this.keepalivesSent += 1;\n        }\n        this.keepaliveTrace(\"Sending ping with timeout \" + this.keepaliveTimeoutMs + \"ms\");\n        if (!this.keepaliveTimeoutId) {\n            this.keepaliveTimeoutId = setTimeout(()=>{\n                this.keepaliveTrace(\"Ping timeout passed without response\");\n                this.handleDisconnect();\n            }, this.keepaliveTimeoutMs);\n            (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n        try {\n            this.session.ping((err, duration, payload)=>{\n                if (err) {\n                    this.keepaliveTrace(\"Ping failed with error \" + err.message);\n                    this.handleDisconnect();\n                }\n                this.keepaliveTrace(\"Received ping response\");\n                this.clearKeepaliveTimeout();\n                this.maybeStartKeepalivePingTimer();\n            });\n        } catch (e) {\n            /* If we fail to send a ping, the connection is no longer functional, so\n             * we should discard it. */ this.handleDisconnect();\n        }\n    }\n    /**\n     * Starts the keepalive ping timer if appropriate. If the timer already ran\n     * out while there were no active requests, instead send a ping immediately.\n     * If the ping timer is already running or a ping is currently in flight,\n     * instead do nothing and wait for them to resolve.\n     */ maybeStartKeepalivePingTimer() {\n        var _a, _b;\n        if (!this.canSendPing()) {\n            return;\n        }\n        if (this.pendingSendKeepalivePing) {\n            this.pendingSendKeepalivePing = false;\n            this.maybeSendPing();\n        } else if (!this.keepaliveTimerId && !this.keepaliveTimeoutId) {\n            this.keepaliveTrace(\"Starting keepalive timer for \" + this.keepaliveTimeMs + \"ms\");\n            this.keepaliveTimerId = (_b = (_a = setTimeout(()=>{\n                this.maybeSendPing();\n            }, this.keepaliveTimeMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    /* Otherwise, there is already either a keepalive timer or a ping pending,\n         * wait for those to resolve. */ }\n    stopKeepalivePings() {\n        if (this.keepaliveTimerId) {\n            clearTimeout(this.keepaliveTimerId);\n            this.keepaliveTimerId = null;\n        }\n        this.clearKeepaliveTimeout();\n    }\n    removeActiveCall(call) {\n        this.activeCalls.delete(call);\n        if (this.activeCalls.size === 0) {\n            this.session.unref();\n        }\n    }\n    addActiveCall(call) {\n        this.activeCalls.add(call);\n        if (this.activeCalls.size === 1) {\n            this.session.ref();\n            if (!this.keepaliveWithoutCalls) {\n                this.maybeStartKeepalivePingTimer();\n            }\n        }\n    }\n    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\n        const headers = metadata.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = host;\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = \"application/grpc\";\n        headers[HTTP2_HEADER_METHOD] = \"POST\";\n        headers[HTTP2_HEADER_PATH] = method;\n        headers[HTTP2_HEADER_TE] = \"trailers\";\n        let http2Stream;\n        /* In theory, if an error is thrown by session.request because session has\n         * become unusable (e.g. because it has received a goaway), this subchannel\n         * should soon see the corresponding close or goaway event anyway and leave\n         * READY. But we have seen reports that this does not happen\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n         * so for defense in depth, we just discard the session when we see an\n         * error here.\n         */ try {\n            http2Stream = this.session.request(headers);\n        } catch (e) {\n            this.handleDisconnect();\n            throw e;\n        }\n        this.flowControlTrace(\"local window size: \" + this.session.state.localWindowSize + \" remote window size: \" + this.session.state.remoteWindowSize);\n        this.internalsTrace(\"session.closed=\" + this.session.closed + \" session.destroyed=\" + this.session.destroyed + \" session.socket.destroyed=\" + this.session.socket.destroyed);\n        let eventTracker;\n        // eslint-disable-next-line prefer-const\n        let call;\n        if (this.channelzEnabled) {\n            this.streamTracker.addCallStarted();\n            eventTracker = {\n                addMessageSent: ()=>{\n                    var _a;\n                    this.messagesSent += 1;\n                    this.lastMessageSentTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: ()=>{\n                    var _a;\n                    this.messagesReceived += 1;\n                    this.lastMessageReceivedTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: (status)=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: (success)=>{\n                    var _a;\n                    if (success) {\n                        this.streamTracker.addCallSucceeded();\n                    } else {\n                        this.streamTracker.addCallFailed();\n                    }\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                }\n            };\n        } else {\n            eventTracker = {\n                addMessageSent: ()=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: ()=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: (status)=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: (success)=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                }\n            };\n        }\n        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n        this.addActiveCall(call);\n        return call;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getPeerName() {\n        return this.subchannelAddressString;\n    }\n    shutdown() {\n        this.session.close();\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n    }\n}\nclass Http2SubchannelConnector {\n    constructor(channelTarget){\n        this.channelTarget = channelTarget;\n        this.session = null;\n        this.isShutdown = false;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + \" \" + text);\n    }\n    createSession(address, credentials, options, proxyConnectionResult) {\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        return new Promise((resolve, reject)=>{\n            var _a, _b, _c;\n            let remoteName;\n            if (proxyConnectionResult.realTarget) {\n                remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);\n                this.trace(\"creating HTTP/2 session through proxy to \" + (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));\n            } else {\n                remoteName = null;\n                this.trace(\"creating HTTP/2 session to \" + (0, subchannel_address_1.subchannelAddressToString)(address));\n            }\n            const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n            let connectionOptions = credentials._getConnectionOptions() || {};\n            connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n            if (\"grpc-node.max_session_memory\" in options) {\n                connectionOptions.maxSessionMemory = options[\"grpc-node.max_session_memory\"];\n            } else {\n                /* By default, set a very large max session memory limit, to effectively\n                 * disable enforcement of the limit. Some testing indicates that Node's\n                 * behavior degrades badly when this limit is reached, so we solve that\n                 * by disabling the check entirely. */ connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n            }\n            let addressScheme = \"http://\";\n            if (\"secureContext\" in connectionOptions) {\n                addressScheme = \"https://\";\n                // If provided, the value of grpc.ssl_target_name_override should be used\n                // to override the target hostname when checking server identity.\n                // This option is used for testing only.\n                if (options[\"grpc.ssl_target_name_override\"]) {\n                    const sslTargetNameOverride = options[\"grpc.ssl_target_name_override\"];\n                    connectionOptions.checkServerIdentity = (host, cert)=>{\n                        return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n                    };\n                    connectionOptions.servername = sslTargetNameOverride;\n                } else {\n                    const authorityHostname = (_c = (_b = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : \"localhost\";\n                    // We want to always set servername to support SNI\n                    connectionOptions.servername = authorityHostname;\n                }\n                if (proxyConnectionResult.socket) {\n                    /* This is part of the workaround for\n                     * https://github.com/nodejs/node/issues/32922. Without that bug,\n                     * proxyConnectionResult.socket would always be a plaintext socket and\n                     * this would say\n                     * connectionOptions.socket = proxyConnectionResult.socket; */ connectionOptions.createConnection = (authority, option)=>{\n                        return proxyConnectionResult.socket;\n                    };\n                }\n            } else {\n                /* In all but the most recent versions of Node, http2.connect does not use\n                 * the options when establishing plaintext connections, so we need to\n                 * establish that connection explicitly. */ connectionOptions.createConnection = (authority, option)=>{\n                    if (proxyConnectionResult.socket) {\n                        return proxyConnectionResult.socket;\n                    } else {\n                        /* net.NetConnectOpts is declared in a way that is more restrictive\n                         * than what net.connect will actually accept, so we use the type\n                         * assertion to work around that. */ return net.connect(address);\n                    }\n                };\n            }\n            connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), {\n                enableTrace: options[\"grpc-node.tls_enable_trace\"] === 1\n            });\n            /* http2.connect uses the options here:\n             * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n             * The spread operator overides earlier values with later ones, so any port\n             * or host values in the options will be used rather than any values extracted\n             * from the first argument. In addition, the path overrides the host and port,\n             * as documented for plaintext connections here:\n             * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n             * and for TLS connections here:\n             * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n             * earlier versions of Node, http2.connect passes these options to\n             * tls.connect but not net.connect, so in the insecure case we still need\n             * to set the createConnection option above to create the connection\n             * explicitly. We cannot do that in the TLS case because http2.connect\n             * passes necessary additional options to tls.connect.\n             * The first argument just needs to be parseable as a URL and the scheme\n             * determines whether the connection will be established over TLS or not.\n             */ const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n            this.session = session;\n            let errorMessage = \"Failed to connect\";\n            session.unref();\n            session.once(\"connect\", ()=>{\n                session.removeAllListeners();\n                resolve(new Http2Transport(session, address, options, remoteName));\n                this.session = null;\n            });\n            session.once(\"close\", ()=>{\n                this.session = null;\n                // Leave time for error event to happen before rejecting\n                setImmediate(()=>{\n                    reject(`${errorMessage} (${new Date().toISOString()})`);\n                });\n            });\n            session.once(\"error\", (error)=>{\n                errorMessage = error.message;\n                this.trace(\"connection failed with error \" + errorMessage);\n            });\n        });\n    }\n    connect(address, credentials, options) {\n        var _a, _b;\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        /* Pass connection options through to the proxy so that it's able to\n         * upgrade it's connection to support tls if needed.\n         * This is a workaround for https://github.com/nodejs/node/issues/32922\n         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */ const connectionOptions = credentials._getConnectionOptions() || {};\n        if (\"secureContext\" in connectionOptions) {\n            connectionOptions.ALPNProtocols = [\n                \"h2\"\n            ];\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (options[\"grpc.ssl_target_name_override\"]) {\n                const sslTargetNameOverride = options[\"grpc.ssl_target_name_override\"];\n                connectionOptions.checkServerIdentity = (host, cert)=>{\n                    return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            } else {\n                if (\"grpc.http_connect_target\" in options) {\n                    /* This is more or less how servername will be set in createSession\n                     * if a connection is successfully established through the proxy.\n                     * If the proxy is not used, these connectionOptions are discarded\n                     * anyway */ const targetPath = (0, resolver_1.getDefaultAuthority)((_a = (0, uri_parser_1.parseUri)(options[\"grpc.http_connect_target\"])) !== null && _a !== void 0 ? _a : {\n                        path: \"localhost\"\n                    });\n                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n                    connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n                }\n            }\n            if (options[\"grpc-node.tls_enable_trace\"]) {\n                connectionOptions.enableTrace = true;\n            }\n        }\n        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then((result)=>this.createSession(address, credentials, options, result));\n    }\n    shutdown() {\n        var _a;\n        this.isShutdown = true;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\n        this.session = null;\n    }\n}\nexports.Http2SubchannelConnector = Http2SubchannelConnector; //# sourceMappingURL=transport.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0NBQWdDLEdBQUcsS0FBSztBQUN4QyxNQUFNRyxRQUFRQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNSSxlQUFlSixtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTSxhQUFhTixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNTyx1QkFBdUJQLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNUSxlQUFlUixtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNUyxNQUFNVCxtQkFBT0EsQ0FBQyxnQkFBSztBQUN6QixNQUFNVSxvQkFBb0JWLG1CQUFPQSxDQUFDLDBGQUFtQjtBQUNyRCxNQUFNVyxnQkFBZ0JYLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLE1BQU1ZLGNBQWM7QUFDcEIsTUFBTUMsMkJBQTJCO0FBQ2pDLE1BQU1DLGdCQUFnQmQsMEdBQXFDO0FBQzNELE1BQU0sRUFBRWdCLHNCQUFzQixFQUFFQyx5QkFBeUIsRUFBRUMsbUJBQW1CLEVBQUVDLGlCQUFpQixFQUFFQyxlQUFlLEVBQUVDLHVCQUF1QixFQUFHLEdBQUd0QixNQUFNdUIsU0FBUztBQUNoSyxNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsbUJBQW1CQyxNQUFNQSxDQUFDQyxJQUFJLENBQUMsa0JBQWtCO0FBQ3ZELE1BQU1DO0lBQ0ZDLFlBQVlDLE9BQU8sRUFB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LElBQUksQ0FBQ25ELE9BQU8sTUFBTSxRQUFRbUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHcUcsS0FBSztRQUNqRSxJQUFJLENBQUN4SixPQUFPLEdBQUc7SUFDbkI7QUFDSjtBQUNBakMsZ0NBQWdDLEdBQUdFLDBCQUNuQyxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy90cmFuc3BvcnQuanM/NmIwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDb25uZWN0b3IgPSB2b2lkIDA7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcbmNvbnN0IHRsc18xID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgaHR0cF9wcm94eV8xID0gcmVxdWlyZShcIi4vaHR0cF9wcm94eVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbmV0ID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfY2FsbF8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1jYWxsXCIpO1xuY29uc3QgY2FsbF9udW1iZXJfMSA9IHJlcXVpcmUoXCIuL2NhbGwtbnVtYmVyXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAndHJhbnNwb3J0JztcbmNvbnN0IEZMT1dfQ09OVFJPTF9UUkFDRVJfTkFNRSA9ICd0cmFuc3BvcnRfZmxvd2N0cmwnO1xuY29uc3QgY2xpZW50VmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5jb25zdCB7IEhUVFAyX0hFQURFUl9BVVRIT1JJVFksIEhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUsIEhUVFAyX0hFQURFUl9NRVRIT0QsIEhUVFAyX0hFQURFUl9QQVRILCBIVFRQMl9IRUFERVJfVEUsIEhUVFAyX0hFQURFUl9VU0VSX0FHRU5ULCB9ID0gaHR0cDIuY29uc3RhbnRzO1xuY29uc3QgS0VFUEFMSVZFX1RJTUVPVVRfTVMgPSAyMDAwMDtcbmNvbnN0IHRvb01hbnlQaW5nc0RhdGEgPSBCdWZmZXIuZnJvbSgndG9vX21hbnlfcGluZ3MnLCAnYXNjaWknKTtcbmNsYXNzIEh0dHAyVHJhbnNwb3J0IHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uLCBzdWJjaGFubmVsQWRkcmVzcywgb3B0aW9ucywgXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgcmVtb3RlIHNlcnZlciwgaWYgaXQgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBzdWJjaGFubmVsXG4gICAgICogYWRkcmVzcywgaS5lLiBpZiBjb25uZWN0aW5nIHRocm91Z2ggYW4gSFRUUCBDT05ORUNUIHByb3h5LlxuICAgICAqL1xuICAgIHJlbW90ZU5hbWUpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5yZW1vdGVOYW1lID0gcmVtb3RlTmFtZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBiZXR3ZWVuIHNlbmRpbmcgcGluZ3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IGFmdGVyIHNlbmRpbmcgYSBwaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9IEtFRVBBTElWRV9USU1FT1VUX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGltZXIgcmVmZXJlbmNlIGZvciB0aW1lb3V0IHRoYXQgaW5kaWNhdGVzIHdoZW4gdG8gc2VuZCB0aGUgbmV4dCBwaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVySWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIGtlZXBhbGl2ZSB0aW1lciByYW4gb3V0IHdoaWxlIHRoZXJlIHdlcmUgbm8gYWN0aXZlXG4gICAgICAgICAqIGNhbGxzLCBhbmQgYSBwaW5nIHNob3VsZCBiZSBzZW50IHRoZSBuZXh0IHRpbWUgYSBjYWxsIHN0YXJ0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lciByZWZlcmVuY2UgdHJhY2tpbmcgd2hlbiB0aGUgbW9zdCByZWNlbnQgcGluZyB3aWxsIGJlIGNvbnNpZGVyZWQgbG9zdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIga2VlcGFsaXZlIHBpbmdzIHNob3VsZCBiZSBzZW50IHdpdGhvdXQgYW55IGFjdGl2ZSBjYWxsc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYWxscyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdEhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlc1NlbnQgPSAwO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzU2VudCA9IDA7XG4gICAgICAgIHRoaXMubWVzc2FnZXNSZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgLyogUG9wdWxhdGUgc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgYW5kIGNoYW5uZWx6UmVmIGJlZm9yZSBkb2luZyBhbnl0aGluZ1xuICAgICAgICAgKiBlbHNlLCBiZWNhdXNlIHRoZXkgYXJlIHVzZWQgaW4gdGhlIHRyYWNlIG1ldGhvZHMuICovXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgPSAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoc3ViY2hhbm5lbEFkZHJlc3MpO1xuICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCkodGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZywgKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAvLyBCdWlsZCB1c2VyLWFnZW50IHN0cmluZy5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQgPSBbXG4gICAgICAgICAgICBvcHRpb25zWydncnBjLnByaW1hcnlfdXNlcl9hZ2VudCddLFxuICAgICAgICAgICAgYGdycGMtbm9kZS1qcy8ke2NsaWVudFZlcnNpb259YCxcbiAgICAgICAgICAgIG9wdGlvbnNbJ2dycGMuc2Vjb25kYXJ5X3VzZXJfYWdlbnQnXSxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUpXG4gICAgICAgICAgICAuam9pbignICcpOyAvLyByZW1vdmUgZmFsc2V5IHZhbHVlcyBmaXJzdFxuICAgICAgICBpZiAoJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5rZWVwYWxpdmVfdGltZW91dF9tcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgPVxuICAgICAgICAgICAgICAgIG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3Blcm1pdF93aXRob3V0X2NhbGxzJ10gPT09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNlc3Npb24ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdzZXNzaW9uIGNsb3NlZCcpO1xuICAgICAgICAgICAgdGhpcy5zdG9wS2VlcGFsaXZlUGluZ3MoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdnb2F3YXknLCAoZXJyb3JDb2RlLCBsYXN0U3RyZWFtSUQsIG9wYXF1ZURhdGEpID0+IHtcbiAgICAgICAgICAgIGxldCB0b29NYW55UGluZ3MgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qIFNlZSB0aGUgbGFzdCBwYXJhZ3JhcGggb2ZcbiAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0E4LWNsaWVudC1zaWRlLWtlZXBhbGl2ZS5tZCNiYXNpYy1rZWVwYWxpdmUgKi9cbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09IGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0VOSEFOQ0VfWU9VUl9DQUxNICYmXG4gICAgICAgICAgICAgICAgb3BhcXVlRGF0YSAmJlxuICAgICAgICAgICAgICAgIG9wYXF1ZURhdGEuZXF1YWxzKHRvb01hbnlQaW5nc0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgdG9vTWFueVBpbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkIGJ5IEdPQVdBWSB3aXRoIGNvZGUgJyArIGVycm9yQ29kZSArICcgYW5kIGRhdGEgJyArIChvcGFxdWVEYXRhID09PSBudWxsIHx8IG9wYXF1ZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wYXF1ZURhdGEudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnREaXNjb25uZWN0VG9Pd25lcih0b29NYW55UGluZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICAgIC8qIERvIG5vdGhpbmcgaGVyZS4gQW55IGVycm9yIHNob3VsZCBhbHNvIHRyaWdnZXIgYSBjbG9zZSBldmVudCwgd2hpY2ggaXNcbiAgICAgICAgICAgICAqIHdoZXJlIHdlIHdhbnQgdG8gaGFuZGxlIHRoYXQuICAqL1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBlcnJvciAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobG9nZ2luZy5pc1RyYWNlckVuYWJsZWQoVFJBQ0VSX05BTUUpKSB7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKCdyZW1vdGVTZXR0aW5ncycsIChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ25ldyBzZXR0aW5ncyByZWNlaXZlZCcgK1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5zZXNzaW9uICE9PSBzZXNzaW9uID8gJyBvbiB0aGUgb2xkIGNvbm5lY3Rpb24nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlc3Npb24ub24oJ2xvY2FsU2V0dGluZ3MnLCAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdsb2NhbCBzZXR0aW5ncyBhY2tub3dsZWRnZWQgYnkgcmVtb3RlJyArXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnNlc3Npb24gIT09IHNlc3Npb24gPyAnIG9uIHRoZSBvbGQgY29ubmVjdGlvbicgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qIFN0YXJ0IHRoZSBrZWVwYWxpdmUgdGltZXIgbGFzdCwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyIHRyYWNlIGxvZ3MsXG4gICAgICAgICAqIHdoaWNoIHNob3VsZCBvbmx5IGhhcHBlbiBhZnRlciBldmVyeXRoaW5nIGVsc2UgaXMgc2V0IHVwLiAqL1xuICAgICAgICBpZiAodGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMpIHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENoYW5uZWx6SW5mbygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHNlc3Npb25Tb2NrZXQgPSB0aGlzLnNlc3Npb24uc29ja2V0O1xuICAgICAgICBjb25zdCByZW1vdGVBZGRyZXNzID0gc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzXG4gICAgICAgICAgICA/ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKShzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3MsIHNlc3Npb25Tb2NrZXQucmVtb3RlUG9ydClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgY29uc3QgbG9jYWxBZGRyZXNzID0gc2Vzc2lvblNvY2tldC5sb2NhbEFkZHJlc3NcbiAgICAgICAgICAgID8gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MpKHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzLCBzZXNzaW9uU29ja2V0LmxvY2FsUG9ydClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgbGV0IHRsc0luZm87XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB0bHNTb2NrZXQgPSBzZXNzaW9uU29ja2V0O1xuICAgICAgICAgICAgY29uc3QgY2lwaGVySW5mbyA9IHRsc1NvY2tldC5nZXRDaXBoZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldENlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBwZWVyQ2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICB0bHNJbmZvID0ge1xuICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlU3RhbmRhcmROYW1lOiAoX2EgPSBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZU90aGVyTmFtZTogY2lwaGVySW5mby5zdGFuZGFyZE5hbWUgPyBudWxsIDogY2lwaGVySW5mby5uYW1lLFxuICAgICAgICAgICAgICAgIGxvY2FsQ2VydGlmaWNhdGU6IGNlcnRpZmljYXRlICYmICdyYXcnIGluIGNlcnRpZmljYXRlID8gY2VydGlmaWNhdGUucmF3IDogbnVsbCxcbiAgICAgICAgICAgICAgICByZW1vdGVDZXJ0aWZpY2F0ZTogcGVlckNlcnRpZmljYXRlICYmICdyYXcnIGluIHBlZXJDZXJ0aWZpY2F0ZVxuICAgICAgICAgICAgICAgICAgICA/IHBlZXJDZXJ0aWZpY2F0ZS5yYXdcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRsc0luZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldEluZm8gPSB7XG4gICAgICAgICAgICByZW1vdGVBZGRyZXNzOiByZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbEFkZHJlc3MsXG4gICAgICAgICAgICBzZWN1cml0eTogdGxzSW5mbyxcbiAgICAgICAgICAgIHJlbW90ZU5hbWU6IHRoaXMucmVtb3RlTmFtZSxcbiAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgc3RyZWFtc1N1Y2NlZWRlZDogdGhpcy5zdHJlYW1UcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgc3RyZWFtc0ZhaWxlZDogdGhpcy5zdHJlYW1UcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbWVzc2FnZXNTZW50OiB0aGlzLm1lc3NhZ2VzU2VudCxcbiAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IHRoaXMubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiB0aGlzLmtlZXBhbGl2ZXNTZW50LFxuICAgICAgICAgICAgbGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogdGhpcy5zdHJlYW1UcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiB0aGlzLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IChfYiA9IHRoaXMuc2Vzc2lvbi5zdGF0ZS5sb2NhbFdpbmRvd1NpemUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwsXG4gICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogKF9jID0gdGhpcy5zZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzb2NrZXRJbmZvO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAga2VlcGFsaXZlVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2tlZXBhbGl2ZScsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgdGV4dCk7XG4gICAgfVxuICAgIGZsb3dDb250cm9sVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgRkxPV19DT05UUk9MX1RSQUNFUl9OQU1FLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICBpbnRlcm5hbHNUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAndHJhbnNwb3J0X2ludGVybmFscycsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgdGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHRvIHRoZSBvd25lciBvZiB0aGlzIG9iamVjdCB0aGF0IHRoaXMgdHJhbnNwb3J0IHNob3VsZCBubyBsb25nZXJcbiAgICAgKiBiZSB1c2VkLiBUaGF0IGhhcHBlbnMgaWYgdGhlIGNvbm5lY3Rpb24gZHJvcHMsIG9yIGlmIHRoZSBzZXJ2ZXIgc2VuZHMgYVxuICAgICAqIEdPQVdBWS5cbiAgICAgKiBAcGFyYW0gdG9vTWFueVBpbmdzIElmIHRydWUsIHRoaXMgd2FzIHRyaWdnZXJlZCBieSBhIEdPQVdBWSB3aXRoIGRhdGFcbiAgICAgKiBpbmRpY2F0aW5nIHRoYXQgdGhlIHNlc3Npb24gd2FzIGNsb3NlZCBiZWNhdWVzIHRoZSBjbGllbnQgc2VudCB0b28gbWFueVxuICAgICAqIHBpbmdzLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcmVwb3J0RGlzY29ubmVjdFRvT3duZXIodG9vTWFueVBpbmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RIYW5kbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNjb25uZWN0SGFuZGxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKHRvb01hbnlQaW5ncykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgY29ubmVjdGlvbiBkcm9wcywgYnV0IG5vdCBHT0FXQVlzLlxuICAgICAqL1xuICAgIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RGlzY29ubmVjdFRvT3duZXIoZmFsc2UpO1xuICAgICAgICAvKiBHaXZlIGNhbGxzIGFuIGV2ZW50IGxvb3AgY3ljbGUgdG8gZmluaXNoIG5hdHVyYWxseSBiZWZvcmUgcmVwb3J0aW5nIHRoZVxuICAgICAgICAgKiBkaXNjb25ubmVjdGlvbiB0byB0aGVtLiAqL1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHRoaXMuYWN0aXZlQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICBjYWxsLm9uRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkRGlzY29ubmVjdExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgY2xlYXJLZWVwYWxpdmVUaW1lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtlZXBhbGl2ZVRpbWVySWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5rZWVwYWxpdmVUaW1lcklkKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lcklkID0gbnVsbDtcbiAgICB9XG4gICAgY2xlYXJLZWVwYWxpdmVUaW1lb3V0KCkge1xuICAgICAgICBpZiAoIXRoaXMua2VlcGFsaXZlVGltZW91dElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcGFsaXZlVGltZW91dElkKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICBjYW5TZW5kUGluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmtlZXBhbGl2ZVRpbWVNcyA+IDAgJiZcbiAgICAgICAgICAgICh0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyB8fCB0aGlzLmFjdGl2ZUNhbGxzLnNpemUgPiAwKSk7XG4gICAgfVxuICAgIG1heWJlU2VuZFBpbmcoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuY2xlYXJLZWVwYWxpdmVUaW1lcigpO1xuICAgICAgICBpZiAoIXRoaXMuY2FuU2VuZFBpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2VuZEtlZXBhbGl2ZVBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1NlbmRpbmcgcGluZyB3aXRoIHRpbWVvdXQgJyArIHRoaXMua2VlcGFsaXZlVGltZW91dE1zICsgJ21zJyk7XG4gICAgICAgIGlmICghdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyB0aW1lb3V0IHBhc3NlZCB3aXRob3V0IHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9LCB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyk7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnBpbmcoKGVyciwgZHVyYXRpb24sIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1BpbmcgZmFpbGVkIHdpdGggZXJyb3IgJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1JlY2VpdmVkIHBpbmcgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIElmIHdlIGZhaWwgdG8gc2VuZCBhIHBpbmcsIHRoZSBjb25uZWN0aW9uIGlzIG5vIGxvbmdlciBmdW5jdGlvbmFsLCBzb1xuICAgICAgICAgICAgICogd2Ugc2hvdWxkIGRpc2NhcmQgaXQuICovXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGtlZXBhbGl2ZSBwaW5nIHRpbWVyIGlmIGFwcHJvcHJpYXRlLiBJZiB0aGUgdGltZXIgYWxyZWFkeSByYW5cbiAgICAgKiBvdXQgd2hpbGUgdGhlcmUgd2VyZSBubyBhY3RpdmUgcmVxdWVzdHMsIGluc3RlYWQgc2VuZCBhIHBpbmcgaW1tZWRpYXRlbHkuXG4gICAgICogSWYgdGhlIHBpbmcgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIG9yIGEgcGluZyBpcyBjdXJyZW50bHkgaW4gZmxpZ2h0LFxuICAgICAqIGluc3RlYWQgZG8gbm90aGluZyBhbmQgd2FpdCBmb3IgdGhlbSB0byByZXNvbHZlLlxuICAgICAqL1xuICAgIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5jYW5TZW5kUGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tYXliZVNlbmRQaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMua2VlcGFsaXZlVGltZXJJZCAmJiAhdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1N0YXJ0aW5nIGtlZXBhbGl2ZSB0aW1lciBmb3IgJyArIHRoaXMua2VlcGFsaXZlVGltZU1zICsgJ21zJyk7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVySWQgPSAoX2IgPSAoX2EgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlU2VuZFBpbmcoKTtcbiAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZU1zKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBPdGhlcndpc2UsIHRoZXJlIGlzIGFscmVhZHkgZWl0aGVyIGEga2VlcGFsaXZlIHRpbWVyIG9yIGEgcGluZyBwZW5kaW5nLFxuICAgICAgICAgKiB3YWl0IGZvciB0aG9zZSB0byByZXNvbHZlLiAqL1xuICAgIH1cbiAgICBzdG9wS2VlcGFsaXZlUGluZ3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVRpbWVySWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBhbGl2ZVRpbWVySWQpO1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lcklkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xuICAgIH1cbiAgICByZW1vdmVBY3RpdmVDYWxsKGNhbGwpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVDYWxscy5kZWxldGUoY2FsbCk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUNhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi51bnJlZigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEFjdGl2ZUNhbGwoY2FsbCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUNhbGxzLmFkZChjYWxsKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2FsbHMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlZigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscykge1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUNhbGwobWV0YWRhdGEsIGhvc3QsIG1ldGhvZCwgbGlzdGVuZXIsIHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBtZXRhZGF0YS50b0h0dHAySGVhZGVycygpO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9BVVRIT1JJVFldID0gaG9zdDtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfVVNFUl9BR0VOVF0gPSB0aGlzLnVzZXJBZ2VudDtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFXSA9ICdhcHBsaWNhdGlvbi9ncnBjJztcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfTUVUSE9EXSA9ICdQT1NUJztcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfUEFUSF0gPSBtZXRob2Q7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX1RFXSA9ICd0cmFpbGVycyc7XG4gICAgICAgIGxldCBodHRwMlN0cmVhbTtcbiAgICAgICAgLyogSW4gdGhlb3J5LCBpZiBhbiBlcnJvciBpcyB0aHJvd24gYnkgc2Vzc2lvbi5yZXF1ZXN0IGJlY2F1c2Ugc2Vzc2lvbiBoYXNcbiAgICAgICAgICogYmVjb21lIHVudXNhYmxlIChlLmcuIGJlY2F1c2UgaXQgaGFzIHJlY2VpdmVkIGEgZ29hd2F5KSwgdGhpcyBzdWJjaGFubmVsXG4gICAgICAgICAqIHNob3VsZCBzb29uIHNlZSB0aGUgY29ycmVzcG9uZGluZyBjbG9zZSBvciBnb2F3YXkgZXZlbnQgYW55d2F5IGFuZCBsZWF2ZVxuICAgICAgICAgKiBSRUFEWS4gQnV0IHdlIGhhdmUgc2VlbiByZXBvcnRzIHRoYXQgdGhpcyBkb2VzIG5vdCBoYXBwZW5cbiAgICAgICAgICogKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL25vZGVqcy1maXJlc3RvcmUvaXNzdWVzLzEwMjMjaXNzdWVjb21tZW50LTY1MzIwNDA5NilcbiAgICAgICAgICogc28gZm9yIGRlZmVuc2UgaW4gZGVwdGgsIHdlIGp1c3QgZGlzY2FyZCB0aGUgc2Vzc2lvbiB3aGVuIHdlIHNlZSBhblxuICAgICAgICAgKiBlcnJvciBoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGh0dHAyU3RyZWFtID0gdGhpcy5zZXNzaW9uLnJlcXVlc3QoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsb3dDb250cm9sVHJhY2UoJ2xvY2FsIHdpbmRvdyBzaXplOiAnICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zdGF0ZS5sb2NhbFdpbmRvd1NpemUgK1xuICAgICAgICAgICAgJyByZW1vdGUgd2luZG93IHNpemU6ICcgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpO1xuICAgICAgICB0aGlzLmludGVybmFsc1RyYWNlKCdzZXNzaW9uLmNsb3NlZD0nICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5jbG9zZWQgK1xuICAgICAgICAgICAgJyBzZXNzaW9uLmRlc3Ryb3llZD0nICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5kZXN0cm95ZWQgK1xuICAgICAgICAgICAgJyBzZXNzaW9uLnNvY2tldC5kZXN0cm95ZWQ9JyArXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc29ja2V0LmRlc3Ryb3llZCk7XG4gICAgICAgIGxldCBldmVudFRyYWNrZXI7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgbGV0IGNhbGw7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgICAgICBldmVudFRyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVNlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzU2VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLmFkZE1lc3NhZ2VTZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhZGRNZXNzYWdlUmVjZWl2ZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzUmVjZWl2ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVJlY2VpdmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNhbGxFbmQ6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIub25DYWxsRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmVDYWxsKGNhbGwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TdHJlYW1FbmQ6IHN1Y2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vblN0cmVhbUVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIsIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZlbnRUcmFja2VyID0ge1xuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VTZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVNlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VSZWNlaXZlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLmFkZE1lc3NhZ2VSZWNlaXZlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25DYWxsRW5kOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uQ2FsbEVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlQ2FsbChjYWxsKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uU3RyZWFtRW5kOiBzdWNjZXNzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vblN0cmVhbUVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIsIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhbGwgPSBuZXcgc3ViY2hhbm5lbF9jYWxsXzEuSHR0cDJTdWJjaGFubmVsQ2FsbChodHRwMlN0cmVhbSwgZXZlbnRUcmFja2VyLCBsaXN0ZW5lciwgdGhpcywgKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCkpO1xuICAgICAgICB0aGlzLmFkZEFjdGl2ZUNhbGwoY2FsbCk7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XG4gICAgfVxuICAgIGdldFBlZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZztcbiAgICB9XG4gICAgc2h1dGRvd24oKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHRoaXMuY2hhbm5lbHpSZWYpO1xuICAgIH1cbn1cbmNsYXNzIEh0dHAyU3ViY2hhbm5lbENvbm5lY3RvciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbFRhcmdldCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxUYXJnZXQgPSBjaGFubmVsVGFyZ2V0O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICB0aGlzLmlzU2h1dGRvd24gPSBmYWxzZTtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMuY2hhbm5lbFRhcmdldCkgKyAnICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgY3JlYXRlU2Vzc2lvbihhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucywgcHJveHlDb25uZWN0aW9uUmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2h1dGRvd24pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGxldCByZW1vdGVOYW1lO1xuICAgICAgICAgICAgaWYgKHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlTmFtZSA9ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGluZyBIVFRQLzIgc2Vzc2lvbiB0aHJvdWdoIHByb3h5IHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKShwcm94eUNvbm5lY3Rpb25SZXN1bHQucmVhbFRhcmdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlTmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnY3JlYXRpbmcgSFRUUC8yIHNlc3Npb24gdG8gJyArICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBdXRob3JpdHkgPSAoMCwgcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KSgoX2EgPSBwcm94eUNvbm5lY3Rpb25SZXN1bHQucmVhbFRhcmdldCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5jaGFubmVsVGFyZ2V0KTtcbiAgICAgICAgICAgIGxldCBjb25uZWN0aW9uT3B0aW9ucyA9IGNyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHx8IHt9O1xuICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMubWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBpZiAoJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5tYXhTZXNzaW9uTWVtb3J5ID1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy1ub2RlLm1heF9zZXNzaW9uX21lbW9yeSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogQnkgZGVmYXVsdCwgc2V0IGEgdmVyeSBsYXJnZSBtYXggc2Vzc2lvbiBtZW1vcnkgbGltaXQsIHRvIGVmZmVjdGl2ZWx5XG4gICAgICAgICAgICAgICAgICogZGlzYWJsZSBlbmZvcmNlbWVudCBvZiB0aGUgbGltaXQuIFNvbWUgdGVzdGluZyBpbmRpY2F0ZXMgdGhhdCBOb2RlJ3NcbiAgICAgICAgICAgICAgICAgKiBiZWhhdmlvciBkZWdyYWRlcyBiYWRseSB3aGVuIHRoaXMgbGltaXQgaXMgcmVhY2hlZCwgc28gd2Ugc29sdmUgdGhhdFxuICAgICAgICAgICAgICAgICAqIGJ5IGRpc2FibGluZyB0aGUgY2hlY2sgZW50aXJlbHkuICovXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMubWF4U2Vzc2lvbk1lbW9yeSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFkZHJlc3NTY2hlbWUgPSAnaHR0cDovLyc7XG4gICAgICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1NjaGVtZSA9ICdodHRwczovLyc7XG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvdmlkZWQsIHRoZSB2YWx1ZSBvZiBncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgICAgICAgIC8vIHRvIG92ZXJyaWRlIHRoZSB0YXJnZXQgaG9zdG5hbWUgd2hlbiBjaGVja2luZyBzZXJ2ZXIgaWRlbnRpdHkuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBvcHRpb24gaXMgdXNlZCBmb3IgdGVzdGluZyBvbmx5LlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNzbFRhcmdldE5hbWVPdmVycmlkZSA9IG9wdGlvbnNbJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJ107XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPSAoaG9zdCwgY2VydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0bHNfMS5jaGVja1NlcnZlcklkZW50aXR5KShzc2xUYXJnZXROYW1lT3ZlcnJpZGUsIGNlcnQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gc3NsVGFyZ2V0TmFtZU92ZXJyaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXR5SG9zdG5hbWUgPSAoX2MgPSAoX2IgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRhcmdldEF1dGhvcml0eSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ob3N0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnbG9jYWxob3N0JztcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBhbHdheXMgc2V0IHNlcnZlcm5hbWUgdG8gc3VwcG9ydCBTTklcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IGF1dGhvcml0eUhvc3RuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGlzIHBhcnQgb2YgdGhlIHdvcmthcm91bmQgZm9yXG4gICAgICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzI5MjIuIFdpdGhvdXQgdGhhdCBidWcsXG4gICAgICAgICAgICAgICAgICAgICAqIHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQgd291bGQgYWx3YXlzIGJlIGEgcGxhaW50ZXh0IHNvY2tldCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICogdGhpcyB3b3VsZCBzYXlcbiAgICAgICAgICAgICAgICAgICAgICogY29ubmVjdGlvbk9wdGlvbnMuc29ja2V0ID0gcHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldDsgKi9cbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuY3JlYXRlQ29ubmVjdGlvbiA9IChhdXRob3JpdHksIG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogSW4gYWxsIGJ1dCB0aGUgbW9zdCByZWNlbnQgdmVyc2lvbnMgb2YgTm9kZSwgaHR0cDIuY29ubmVjdCBkb2VzIG5vdCB1c2VcbiAgICAgICAgICAgICAgICAgKiB0aGUgb3B0aW9ucyB3aGVuIGVzdGFibGlzaGluZyBwbGFpbnRleHQgY29ubmVjdGlvbnMsIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgKiBlc3RhYmxpc2ggdGhhdCBjb25uZWN0aW9uIGV4cGxpY2l0bHkuICovXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuY3JlYXRlQ29ubmVjdGlvbiA9IChhdXRob3JpdHksIG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBuZXQuTmV0Q29ubmVjdE9wdHMgaXMgZGVjbGFyZWQgaW4gYSB3YXkgdGhhdCBpcyBtb3JlIHJlc3RyaWN0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGFuIHdoYXQgbmV0LmNvbm5lY3Qgd2lsbCBhY3R1YWxseSBhY2NlcHQsIHNvIHdlIHVzZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogYXNzZXJ0aW9uIHRvIHdvcmsgYXJvdW5kIHRoYXQuICovXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV0LmNvbm5lY3QoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdGlvbk9wdGlvbnMpLCBhZGRyZXNzKSwgeyBlbmFibGVUcmFjZTogb3B0aW9uc1snZ3JwYy1ub2RlLnRsc19lbmFibGVfdHJhY2UnXSA9PT0gMSB9KTtcbiAgICAgICAgICAgIC8qIGh0dHAyLmNvbm5lY3QgdXNlcyB0aGUgb3B0aW9ucyBoZXJlOlxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvNzBjMzJhNmQxOTBlMmI1ZDdiOWZmOWQ1YjZhNDU5ZDE0ZThiN2Q1OS9saWIvaW50ZXJuYWwvaHR0cDIvY29yZS5qcyNMMzAyOC1MMzAzNlxuICAgICAgICAgICAgICogVGhlIHNwcmVhZCBvcGVyYXRvciBvdmVyaWRlcyBlYXJsaWVyIHZhbHVlcyB3aXRoIGxhdGVyIG9uZXMsIHNvIGFueSBwb3J0XG4gICAgICAgICAgICAgKiBvciBob3N0IHZhbHVlcyBpbiB0aGUgb3B0aW9ucyB3aWxsIGJlIHVzZWQgcmF0aGVyIHRoYW4gYW55IHZhbHVlcyBleHRyYWN0ZWRcbiAgICAgICAgICAgICAqIGZyb20gdGhlIGZpcnN0IGFyZ3VtZW50LiBJbiBhZGRpdGlvbiwgdGhlIHBhdGggb3ZlcnJpZGVzIHRoZSBob3N0IGFuZCBwb3J0LFxuICAgICAgICAgICAgICogYXMgZG9jdW1lbnRlZCBmb3IgcGxhaW50ZXh0IGNvbm5lY3Rpb25zIGhlcmU6XG4gICAgICAgICAgICAgKiBodHRwczovL25vZGVqcy5vcmcvYXBpL25ldC5odG1sI25ldF9zb2NrZXRfY29ubmVjdF9vcHRpb25zX2Nvbm5lY3RsaXN0ZW5lclxuICAgICAgICAgICAgICogYW5kIGZvciBUTFMgY29ubmVjdGlvbnMgaGVyZTpcbiAgICAgICAgICAgICAqIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGxzLmh0bWwjdGxzX3Rsc19jb25uZWN0X29wdGlvbnNfY2FsbGJhY2suIEluXG4gICAgICAgICAgICAgKiBlYXJsaWVyIHZlcnNpb25zIG9mIE5vZGUsIGh0dHAyLmNvbm5lY3QgcGFzc2VzIHRoZXNlIG9wdGlvbnMgdG9cbiAgICAgICAgICAgICAqIHRscy5jb25uZWN0IGJ1dCBub3QgbmV0LmNvbm5lY3QsIHNvIGluIHRoZSBpbnNlY3VyZSBjYXNlIHdlIHN0aWxsIG5lZWRcbiAgICAgICAgICAgICAqIHRvIHNldCB0aGUgY3JlYXRlQ29ubmVjdGlvbiBvcHRpb24gYWJvdmUgdG8gY3JlYXRlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgKiBleHBsaWNpdGx5LiBXZSBjYW5ub3QgZG8gdGhhdCBpbiB0aGUgVExTIGNhc2UgYmVjYXVzZSBodHRwMi5jb25uZWN0XG4gICAgICAgICAgICAgKiBwYXNzZXMgbmVjZXNzYXJ5IGFkZGl0aW9uYWwgb3B0aW9ucyB0byB0bHMuY29ubmVjdC5cbiAgICAgICAgICAgICAqIFRoZSBmaXJzdCBhcmd1bWVudCBqdXN0IG5lZWRzIHRvIGJlIHBhcnNlYWJsZSBhcyBhIFVSTCBhbmQgdGhlIHNjaGVtZVxuICAgICAgICAgICAgICogZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb25uZWN0aW9uIHdpbGwgYmUgZXN0YWJsaXNoZWQgb3ZlciBUTFMgb3Igbm90LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gaHR0cDIuY29ubmVjdChhZGRyZXNzU2NoZW1lICsgdGFyZ2V0QXV0aG9yaXR5LCBjb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdGYWlsZWQgdG8gY29ubmVjdCc7XG4gICAgICAgICAgICBzZXNzaW9uLnVucmVmKCk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBIdHRwMlRyYW5zcG9ydChzZXNzaW9uLCBhZGRyZXNzLCBvcHRpb25zLCByZW1vdGVOYW1lKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIExlYXZlIHRpbWUgZm9yIGVycm9yIGV2ZW50IHRvIGhhcHBlbiBiZWZvcmUgcmVqZWN0aW5nXG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGAke2Vycm9yTWVzc2FnZX0gKCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSlgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbmNlKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gZmFpbGVkIHdpdGggZXJyb3IgJyArIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QoYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuaXNTaHV0ZG93bikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogUGFzcyBjb25uZWN0aW9uIG9wdGlvbnMgdGhyb3VnaCB0byB0aGUgcHJveHkgc28gdGhhdCBpdCdzIGFibGUgdG9cbiAgICAgICAgICogdXBncmFkZSBpdCdzIGNvbm5lY3Rpb24gdG8gc3VwcG9ydCB0bHMgaWYgbmVlZGVkLlxuICAgICAgICAgKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjkyMlxuICAgICAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL3B1bGwvMTM2OSBmb3IgbW9yZSBpbmZvLiAqL1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uT3B0aW9ucyA9IGNyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHx8IHt9O1xuICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5BTFBOUHJvdG9jb2xzID0gWydoMiddO1xuICAgICAgICAgICAgLy8gSWYgcHJvdmlkZWQsIHRoZSB2YWx1ZSBvZiBncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgICAgLy8gdG8gb3ZlcnJpZGUgdGhlIHRhcmdldCBob3N0bmFtZSB3aGVuIGNoZWNraW5nIHNlcnZlciBpZGVudGl0eS5cbiAgICAgICAgICAgIC8vIFRoaXMgb3B0aW9uIGlzIHVzZWQgZm9yIHRlc3Rpbmcgb25seS5cbiAgICAgICAgICAgIGlmIChvcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3NsVGFyZ2V0TmFtZU92ZXJyaWRlID0gb3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID0gKGhvc3QsIGNlcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0bHNfMS5jaGVja1NlcnZlcklkZW50aXR5KShzc2xUYXJnZXROYW1lT3ZlcnJpZGUsIGNlcnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IHNzbFRhcmdldE5hbWVPdmVycmlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFRoaXMgaXMgbW9yZSBvciBsZXNzIGhvdyBzZXJ2ZXJuYW1lIHdpbGwgYmUgc2V0IGluIGNyZWF0ZVNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICogaWYgYSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCB0aHJvdWdoIHRoZSBwcm94eS5cbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIHByb3h5IGlzIG5vdCB1c2VkLCB0aGVzZSBjb25uZWN0aW9uT3B0aW9ucyBhcmUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgICAgICAqIGFueXdheSAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkoKF9hID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkob3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0J10pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnbG9jYWxob3N0JyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IChfYiA9IGhvc3RQb3J0ID09PSBudWxsIHx8IGhvc3RQb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3N0UG9ydC5ob3N0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0YXJnZXRQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zWydncnBjLW5vZGUudGxzX2VuYWJsZV90cmFjZSddKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuZW5hYmxlVHJhY2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaHR0cF9wcm94eV8xLmdldFByb3hpZWRDb25uZWN0aW9uKShhZGRyZXNzLCBvcHRpb25zLCBjb25uZWN0aW9uT3B0aW9ucykudGhlbihyZXN1bHQgPT4gdGhpcy5jcmVhdGVTZXNzaW9uKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zLCByZXN1bHQpKTtcbiAgICB9XG4gICAgc2h1dGRvd24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5pc1NodXRkb3duID0gdHJ1ZTtcbiAgICAgICAgKF9hID0gdGhpcy5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkh0dHAyU3ViY2hhbm5lbENvbm5lY3RvciA9IEh0dHAyU3ViY2hhbm5lbENvbm5lY3Rvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9ydC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJIdHRwMlN1YmNoYW5uZWxDb25uZWN0b3IiLCJodHRwMiIsInJlcXVpcmUiLCJ0bHNfMSIsImNoYW5uZWx6XzEiLCJjb25zdGFudHNfMSIsImh0dHBfcHJveHlfMSIsImxvZ2dpbmciLCJyZXNvbHZlcl8xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJ1cmlfcGFyc2VyXzEiLCJuZXQiLCJzdWJjaGFubmVsX2NhbGxfMSIsImNhbGxfbnVtYmVyXzEiLCJUUkFDRVJfTkFNRSIsIkZMT1dfQ09OVFJPTF9UUkFDRVJfTkFNRSIsImNsaWVudFZlcnNpb24iLCJ2ZXJzaW9uIiwiSFRUUDJfSEVBREVSX0FVVEhPUklUWSIsIkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUiLCJIVFRQMl9IRUFERVJfTUVUSE9EIiwiSFRUUDJfSEVBREVSX1BBVEgiLCJIVFRQMl9IRUFERVJfVEUiLCJIVFRQMl9IRUFERVJfVVNFUl9BR0VOVCIsImNvbnN0YW50cyIsIktFRVBBTElWRV9USU1FT1VUX01TIiwidG9vTWFueVBpbmdzRGF0YSIsIkJ1ZmZlciIsImZyb20iLCJIdHRwMlRyYW5zcG9ydCIsImNvbnN0cnVjdG9yIiwic2Vzc2lvbiIsInN1YmNoYW5uZWxBZGRyZXNzIiwib3B0aW9ucyIsInJlbW90ZU5hbWUiLCJrZWVwYWxpdmVUaW1lTXMiLCJrZWVwYWxpdmVUaW1lb3V0TXMiLCJrZWVwYWxpdmVUaW1lcklkIiwicGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nIiwia2VlcGFsaXZlVGltZW91dElkIiwia2VlcGFsaXZlV2l0aG91dENhbGxzIiwiYWN0aXZlQ2FsbHMiLCJTZXQiLCJkaXNjb25uZWN0TGlzdGVuZXJzIiwiZGlzY29ubmVjdEhhbmRsZWQiLCJjaGFubmVsekVuYWJsZWQiLCJzdHJlYW1UcmFja2VyIiwiQ2hhbm5lbHpDYWxsVHJhY2tlciIsImtlZXBhbGl2ZXNTZW50IiwibWVzc2FnZXNTZW50IiwibWVzc2FnZXNSZWNlaXZlZCIsImxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCIsImxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAiLCJzdWJjaGFubmVsQWRkcmVzc1N0cmluZyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJjaGFubmVselJlZiIsInJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQiLCJnZXRDaGFubmVsekluZm8iLCJ1c2VyQWdlbnQiLCJmaWx0ZXIiLCJlIiwiam9pbiIsIm9uY2UiLCJ0cmFjZSIsInN0b3BLZWVwYWxpdmVQaW5ncyIsImhhbmRsZURpc2Nvbm5lY3QiLCJlcnJvckNvZGUiLCJsYXN0U3RyZWFtSUQiLCJvcGFxdWVEYXRhIiwidG9vTWFueVBpbmdzIiwiTkdIVFRQMl9FTkhBTkNFX1lPVVJfQ0FMTSIsImVxdWFscyIsInRvU3RyaW5nIiwicmVwb3J0RGlzY29ubmVjdFRvT3duZXIiLCJlcnJvciIsIm1lc3NhZ2UiLCJpc1RyYWNlckVuYWJsZWQiLCJvbiIsInNldHRpbmdzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIiLCJfYSIsIl9iIiwiX2MiLCJzZXNzaW9uU29ja2V0Iiwic29ja2V0IiwicmVtb3RlQWRkcmVzcyIsInN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MiLCJyZW1vdGVQb3J0IiwibG9jYWxBZGRyZXNzIiwibG9jYWxQb3J0IiwidGxzSW5mbyIsImVuY3J5cHRlZCIsInRsc1NvY2tldCIsImNpcGhlckluZm8iLCJnZXRDaXBoZXIiLCJjZXJ0aWZpY2F0ZSIsImdldENlcnRpZmljYXRlIiwicGVlckNlcnRpZmljYXRlIiwiZ2V0UGVlckNlcnRpZmljYXRlIiwiY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJjaXBoZXJTdWl0ZU90aGVyTmFtZSIsIm5hbWUiLCJsb2NhbENlcnRpZmljYXRlIiwicmF3IiwicmVtb3RlQ2VydGlmaWNhdGUiLCJzb2NrZXRJbmZvIiwic2VjdXJpdHkiLCJzdHJlYW1zU3RhcnRlZCIsImNhbGxzU3RhcnRlZCIsInN0cmVhbXNTdWNjZWVkZWQiLCJjYWxsc1N1Y2NlZWRlZCIsInN0cmVhbXNGYWlsZWQiLCJjYWxsc0ZhaWxlZCIsImtlZXBBbGl2ZXNTZW50IiwibGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCIsImxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCIsImxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibG9jYWxGbG93Q29udHJvbFdpbmRvdyIsInN0YXRlIiwibG9jYWxXaW5kb3dTaXplIiwicmVtb3RlRmxvd0NvbnRyb2xXaW5kb3ciLCJyZW1vdGVXaW5kb3dTaXplIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiaWQiLCJrZWVwYWxpdmVUcmFjZSIsImZsb3dDb250cm9sVHJhY2UiLCJpbnRlcm5hbHNUcmFjZSIsImZvckVhY2giLCJsaXN0ZW5lciIsInNldEltbWVkaWF0ZSIsImNhbGwiLCJvbkRpc2Nvbm5lY3QiLCJhZGREaXNjb25uZWN0TGlzdGVuZXIiLCJwdXNoIiwiY2xlYXJLZWVwYWxpdmVUaW1lciIsImNsZWFyVGltZW91dCIsImNsZWFyS2VlcGFsaXZlVGltZW91dCIsImNhblNlbmRQaW5nIiwic2l6ZSIsIm1heWJlU2VuZFBpbmciLCJzZXRUaW1lb3V0IiwidW5yZWYiLCJwaW5nIiwiZXJyIiwiZHVyYXRpb24iLCJwYXlsb2FkIiwicmVtb3ZlQWN0aXZlQ2FsbCIsImRlbGV0ZSIsImFkZEFjdGl2ZUNhbGwiLCJhZGQiLCJyZWYiLCJjcmVhdGVDYWxsIiwibWV0YWRhdGEiLCJob3N0IiwibWV0aG9kIiwic3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIiLCJoZWFkZXJzIiwidG9IdHRwMkhlYWRlcnMiLCJodHRwMlN0cmVhbSIsInJlcXVlc3QiLCJjbG9zZWQiLCJkZXN0cm95ZWQiLCJldmVudFRyYWNrZXIiLCJhZGRDYWxsU3RhcnRlZCIsImFkZE1lc3NhZ2VTZW50IiwiRGF0ZSIsImFkZE1lc3NhZ2VSZWNlaXZlZCIsIm9uQ2FsbEVuZCIsInN0YXR1cyIsIm9uU3RyZWFtRW5kIiwic3VjY2VzcyIsImFkZENhbGxTdWNjZWVkZWQiLCJhZGRDYWxsRmFpbGVkIiwiSHR0cDJTdWJjaGFubmVsQ2FsbCIsImdldE5leHRDYWxsTnVtYmVyIiwiZ2V0Q2hhbm5lbHpSZWYiLCJnZXRQZWVyTmFtZSIsInNodXRkb3duIiwiY2xvc2UiLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJjaGFubmVsVGFyZ2V0IiwiaXNTaHV0ZG93biIsInVyaVRvU3RyaW5nIiwiY3JlYXRlU2Vzc2lvbiIsImFkZHJlc3MiLCJjcmVkZW50aWFscyIsInByb3h5Q29ubmVjdGlvblJlc3VsdCIsIlByb21pc2UiLCJyZWplY3QiLCJyZXNvbHZlIiwicmVhbFRhcmdldCIsInRhcmdldEF1dGhvcml0eSIsImdldERlZmF1bHRBdXRob3JpdHkiLCJjb25uZWN0aW9uT3B0aW9ucyIsIl9nZXRDb25uZWN0aW9uT3B0aW9ucyIsIm1heFNlbmRIZWFkZXJCbG9ja0xlbmd0aCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJtYXhTZXNzaW9uTWVtb3J5IiwiYWRkcmVzc1NjaGVtZSIsInNzbFRhcmdldE5hbWVPdmVycmlkZSIsImNoZWNrU2VydmVySWRlbnRpdHkiLCJjZXJ0Iiwic2VydmVybmFtZSIsImF1dGhvcml0eUhvc3RuYW1lIiwic3BsaXRIb3N0UG9ydCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJhdXRob3JpdHkiLCJvcHRpb24iLCJjb25uZWN0IiwiYXNzaWduIiwiZW5hYmxlVHJhY2UiLCJlcnJvck1lc3NhZ2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJ0b0lTT1N0cmluZyIsIkFMUE5Qcm90b2NvbHMiLCJ0YXJnZXRQYXRoIiwicGFyc2VVcmkiLCJwYXRoIiwiaG9zdFBvcnQiLCJnZXRQcm94aWVkQ29ubmVjdGlvbiIsInRoZW4iLCJyZXN1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/transport.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/uri-parser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.uriToString = exports.splitHostPort = exports.parseUri = void 0;\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */ const URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\nfunction parseUri(uriString) {\n    const parsedUri = URI_REGEX.exec(uriString);\n    if (parsedUri === null) {\n        return null;\n    }\n    return {\n        scheme: parsedUri[1],\n        authority: parsedUri[2],\n        path: parsedUri[3]\n    };\n}\nexports.parseUri = parseUri;\nconst NUMBER_REGEX = /^\\d+$/;\nfunction splitHostPort(path) {\n    if (path.startsWith(\"[\")) {\n        const hostEnd = path.indexOf(\"]\");\n        if (hostEnd === -1) {\n            return null;\n        }\n        const host = path.substring(1, hostEnd);\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\n         * address should have at least one colon */ if (host.indexOf(\":\") === -1) {\n            return null;\n        }\n        if (path.length > hostEnd + 1) {\n            if (path[hostEnd + 1] === \":\") {\n                const portString = path.substring(hostEnd + 2);\n                if (NUMBER_REGEX.test(portString)) {\n                    return {\n                        host: host,\n                        port: +portString\n                    };\n                } else {\n                    return null;\n                }\n            } else {\n                return null;\n            }\n        } else {\n            return {\n                host\n            };\n        }\n    } else {\n        const splitPath = path.split(\":\");\n        /* Exactly one colon means that this is host:port. Zero colons means that\n         * there is no port. And multiple colons means that this is a bare IPv6\n         * address with no port */ if (splitPath.length === 2) {\n            if (NUMBER_REGEX.test(splitPath[1])) {\n                return {\n                    host: splitPath[0],\n                    port: +splitPath[1]\n                };\n            } else {\n                return null;\n            }\n        } else {\n            return {\n                host: path\n            };\n        }\n    }\n}\nexports.splitHostPort = splitHostPort;\nfunction uriToString(uri) {\n    let result = \"\";\n    if (uri.scheme !== undefined) {\n        result += uri.scheme + \":\";\n    }\n    if (uri.authority !== undefined) {\n        result += \"//\" + uri.authority + \"/\";\n    }\n    result += uri.path;\n    return result;\n}\nexports.uriToString = uriToString; //# sourceMappingURL=uri-parser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLHFCQUFxQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3RFOzs7OztDQUtDLEdBQ0QsTUFBTUssWUFBWTtBQUNsQixTQUFTRCxTQUFTRSxTQUFTO0lBQ3ZCLE1BQU1DLFlBQVlGLFVBQVVHLElBQUksQ0FBQ0Y7SUFDakMsSUFBSUMsY0FBYyxNQUFNO1FBQ3BCLE9BQU87SUFDWDtJQUNBLE9BQU87UUFDSEUsUUFBUUYsU0FBUyxDQUFDLEVBQUU7UUFDcEJHLFdBQVdILFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCSSxNQUFNSixTQUFTLENBQUMsRUFBRTtJQUN0QjtBQUNKO0FBQ0FQLGdCQUFnQixHQUFHSTtBQUNuQixNQUFNUSxlQUFlO0FBQ3JCLFNBQVNULGNBQWNRLElBQUk7SUFDdkIsSUFBSUEsS0FBS0UsVUFBVSxDQUFDLE1BQU07UUFDdEIsTUFBTUMsVUFBVUgsS0FBS0ksT0FBTyxDQUFDO1FBQzdCLElBQUlELFlBQVksQ0FBQyxHQUFHO1lBQ2hCLE9BQU87UUFDWDtRQUNBLE1BQU1FLE9BQU9MLEtBQUtNLFNBQVMsQ0FBQyxHQUFHSDtRQUMvQjtrREFDMEMsR0FDMUMsSUFBSUUsS0FBS0QsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO1lBQzFCLE9BQU87UUFDWDtRQUNBLElBQUlKLEtBQUtPLE1BQU0sR0FBR0osVUFBVSxHQUFHO1lBQzNCLElBQUlILElBQUksQ0FBQ0csVUFBVSxFQUFFLEtBQUssS0FBSztnQkFDM0IsTUFBTUssYUFBYVIsS0FBS00sU0FBUyxDQUFDSCxVQUFVO2dCQUM1QyxJQUFJRixhQUFhUSxJQUFJLENBQUNELGFBQWE7b0JBQy9CLE9BQU87d0JBQ0hILE1BQU1BO3dCQUNOSyxNQUFNLENBQUNGO29CQUNYO2dCQUNKLE9BQ0s7b0JBQ0QsT0FBTztnQkFDWDtZQUNKLE9BQ0s7Z0JBQ0QsT0FBTztZQUNYO1FBQ0osT0FDSztZQUNELE9BQU87Z0JBQ0hIO1lBQ0o7UUFDSjtJQUNKLE9BQ0s7UUFDRCxNQUFNTSxZQUFZWCxLQUFLWSxLQUFLLENBQUM7UUFDN0I7O2dDQUV3QixHQUN4QixJQUFJRCxVQUFVSixNQUFNLEtBQUssR0FBRztZQUN4QixJQUFJTixhQUFhUSxJQUFJLENBQUNFLFNBQVMsQ0FBQyxFQUFFLEdBQUc7Z0JBQ2pDLE9BQU87b0JBQ0hOLE1BQU1NLFNBQVMsQ0FBQyxFQUFFO29CQUNsQkQsTUFBTSxDQUFDQyxTQUFTLENBQUMsRUFBRTtnQkFDdkI7WUFDSixPQUNLO2dCQUNELE9BQU87WUFDWDtRQUNKLE9BQ0s7WUFDRCxPQUFPO2dCQUNITixNQUFNTDtZQUNWO1FBQ0o7SUFDSjtBQUNKO0FBQ0FYLHFCQUFxQixHQUFHRztBQUN4QixTQUFTRCxZQUFZc0IsR0FBRztJQUNwQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUQsSUFBSWYsTUFBTSxLQUFLaUIsV0FBVztRQUMxQkQsVUFBVUQsSUFBSWYsTUFBTSxHQUFHO0lBQzNCO0lBQ0EsSUFBSWUsSUFBSWQsU0FBUyxLQUFLZ0IsV0FBVztRQUM3QkQsVUFBVSxPQUFPRCxJQUFJZCxTQUFTLEdBQUc7SUFDckM7SUFDQWUsVUFBVUQsSUFBSWIsSUFBSTtJQUNsQixPQUFPYztBQUNYO0FBQ0F6QixtQkFBbUIsR0FBR0UsYUFDdEIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcz8yYWMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIwIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVyaVRvU3RyaW5nID0gZXhwb3J0cy5zcGxpdEhvc3RQb3J0ID0gZXhwb3J0cy5wYXJzZVVyaSA9IHZvaWQgMDtcbi8qXG4gKiBUaGUgZ3JvdXBzIGNvcnJlc3BvbmQgdG8gVVJJIHBhcnRzIGFzIGZvbGxvd3M6XG4gKiAxLiBzY2hlbWVcbiAqIDIuIGF1dGhvcml0eVxuICogMy4gcGF0aFxuICovXG5jb25zdCBVUklfUkVHRVggPSAvXig/OihbQS1aYS16MC05Ky4tXSspOik/KD86XFwvXFwvKFteL10qKVxcLyk/KC4rKSQvO1xuZnVuY3Rpb24gcGFyc2VVcmkodXJpU3RyaW5nKSB7XG4gICAgY29uc3QgcGFyc2VkVXJpID0gVVJJX1JFR0VYLmV4ZWModXJpU3RyaW5nKTtcbiAgICBpZiAocGFyc2VkVXJpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHBhcnNlZFVyaVsxXSxcbiAgICAgICAgYXV0aG9yaXR5OiBwYXJzZWRVcmlbMl0sXG4gICAgICAgIHBhdGg6IHBhcnNlZFVyaVszXSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZVVyaSA9IHBhcnNlVXJpO1xuY29uc3QgTlVNQkVSX1JFR0VYID0gL15cXGQrJC87XG5mdW5jdGlvbiBzcGxpdEhvc3RQb3J0KHBhdGgpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKCdbJykpIHtcbiAgICAgICAgY29uc3QgaG9zdEVuZCA9IHBhdGguaW5kZXhPZignXScpO1xuICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3QgPSBwYXRoLnN1YnN0cmluZygxLCBob3N0RW5kKTtcbiAgICAgICAgLyogT25seSBhbiBJUHY2IGFkZHJlc3Mgc2hvdWxkIGJlIGluIGJyYWNrZXRlZCBub3RhdGlvbiwgYW5kIGFuIElQdjZcbiAgICAgICAgICogYWRkcmVzcyBzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUgY29sb24gKi9cbiAgICAgICAgaWYgKGhvc3QuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gaG9zdEVuZCArIDEpIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2hvc3RFbmQgKyAxXSA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydFN0cmluZyA9IHBhdGguc3Vic3RyaW5nKGhvc3RFbmQgKyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoTlVNQkVSX1JFR0VYLnRlc3QocG9ydFN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiArcG9ydFN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3BsaXRQYXRoID0gcGF0aC5zcGxpdCgnOicpO1xuICAgICAgICAvKiBFeGFjdGx5IG9uZSBjb2xvbiBtZWFucyB0aGF0IHRoaXMgaXMgaG9zdDpwb3J0LiBaZXJvIGNvbG9ucyBtZWFucyB0aGF0XG4gICAgICAgICAqIHRoZXJlIGlzIG5vIHBvcnQuIEFuZCBtdWx0aXBsZSBjb2xvbnMgbWVhbnMgdGhhdCB0aGlzIGlzIGEgYmFyZSBJUHY2XG4gICAgICAgICAqIGFkZHJlc3Mgd2l0aCBubyBwb3J0ICovXG4gICAgICAgIGlmIChzcGxpdFBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoTlVNQkVSX1JFR0VYLnRlc3Qoc3BsaXRQYXRoWzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHNwbGl0UGF0aFswXSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogK3NwbGl0UGF0aFsxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5zcGxpdEhvc3RQb3J0ID0gc3BsaXRIb3N0UG9ydDtcbmZ1bmN0aW9uIHVyaVRvU3RyaW5nKHVyaSkge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBpZiAodXJpLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCArPSB1cmkuc2NoZW1lICsgJzonO1xuICAgIH1cbiAgICBpZiAodXJpLmF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCArPSAnLy8nICsgdXJpLmF1dGhvcml0eSArICcvJztcbiAgICB9XG4gICAgcmVzdWx0ICs9IHVyaS5wYXRoO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVyaVRvU3RyaW5nID0gdXJpVG9TdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmktcGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVyaVRvU3RyaW5nIiwic3BsaXRIb3N0UG9ydCIsInBhcnNlVXJpIiwiVVJJX1JFR0VYIiwidXJpU3RyaW5nIiwicGFyc2VkVXJpIiwiZXhlYyIsInNjaGVtZSIsImF1dGhvcml0eSIsInBhdGgiLCJOVU1CRVJfUkVHRVgiLCJzdGFydHNXaXRoIiwiaG9zdEVuZCIsImluZGV4T2YiLCJob3N0Iiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicG9ydFN0cmluZyIsInRlc3QiLCJwb3J0Iiwic3BsaXRQYXRoIiwic3BsaXQiLCJ1cmkiLCJyZXN1bHQiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.isAnyExtension = exports.Long = void 0;\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(ssr)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(ssr)/./node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return \"@type\" in obj && typeof obj[\"@type\"] === \"string\";\n}\nexports.isAnyExtension = isAnyExtension;\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true\n};\nfunction joinName(baseName, name) {\n    if (baseName === \"\") {\n        return name;\n    } else {\n        return baseName + \".\" + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [\n            [\n                objName,\n                obj\n            ]\n        ];\n    } else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== \"undefined\") {\n            return Object.keys(obj.nested).map((name)=>{\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            }).reduce((accumulator, currentValue)=>accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */ const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: \"/\" + serviceName + \"/\" + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors)\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray){\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 DescriptorProto\",\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 EnumDescriptorProto\",\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */ function createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    } else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    } else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    } else {\n        throw new Error(\"Type mismatch in reflection object handling\");\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor(\"proto3\").file;\n    const bufferList = descriptorList.map((value)=>Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, \"\")){\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */ function load(filename, options) {\n    return (0, util_1.loadProtosWithOptions)(filename, options).then((loadedRoot)=>{\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n(0, util_1.addCommonProtos)(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUNBQXVDLEdBQUdBLHVDQUF1QyxHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLFlBQVksR0FBR0Esc0JBQXNCLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQ3RMLE1BQU1TLFlBQVlDLG1CQUFPQSxDQUFDLHdFQUFrQjtBQUM1QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyw0REFBWTtBQUNyQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywwRkFBMkI7QUFDdEQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMseUVBQVE7QUFDL0IsTUFBTUYsT0FBT0UsbUJBQU9BLENBQUMsb0RBQU07QUFDM0JWLFlBQVksR0FBR1E7QUFDZixTQUFTRCxlQUFlTyxHQUFHO0lBQ3ZCLE9BQU8sV0FBWUEsT0FBUyxPQUFPQSxHQUFHLENBQUMsUUFBUSxLQUFLO0FBQ3hEO0FBQ0FkLHNCQUFzQixHQUFHTztBQUN6QixNQUFNUSxvQkFBb0I7SUFDdEJDLE9BQU9DO0lBQ1BDLE9BQU9EO0lBQ1BFLE9BQU9GO0lBQ1BHLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxNQUFNO0FBQ1Y7QUFDQSxTQUFTQyxTQUFTQyxRQUFRLEVBQUVDLElBQUk7SUFDNUIsSUFBSUQsYUFBYSxJQUFJO1FBQ2pCLE9BQU9DO0lBQ1gsT0FDSztRQUNELE9BQU9ELFdBQVcsTUFBTUM7SUFDNUI7QUFDSjtBQUNBLFNBQVNDLDBCQUEwQlosR0FBRztJQUNsQyxPQUFRQSxlQUFlSCxTQUFTZ0IsT0FBTyxJQUNuQ2IsZUFBZUgsU0FBU2lCLElBQUksSUFDNUJkLGVBQWVILFNBQVNrQixJQUFJO0FBQ3BDO0FBQ0EsU0FBU0MsZ0JBQWdCaEIsR0FBRztJQUN4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O0FBQ0E3Qyx1Q0FBdUMsR0FBR0U7QUFDekMsSUFBR1csT0FBT2lHLGVBQWUsS0FDMUIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcz81ZmE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGV4cG9ydHMuZnJvbUpTT04gPSBleHBvcnRzLmxvYWRTeW5jID0gZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5pc0FueUV4dGVuc2lvbiA9IGV4cG9ydHMuTG9uZyA9IHZvaWQgMDtcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoXCJsb2Rhc2guY2FtZWxjYXNlXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmNvbnN0IGRlc2NyaXB0b3IgPSByZXF1aXJlKFwicHJvdG9idWZqcy9leHQvZGVzY3JpcHRvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBMb25nID0gcmVxdWlyZShcImxvbmdcIik7XG5leHBvcnRzLkxvbmcgPSBMb25nO1xuZnVuY3Rpb24gaXNBbnlFeHRlbnNpb24ob2JqKSB7XG4gICAgcmV0dXJuICgnQHR5cGUnIGluIG9iaikgJiYgKHR5cGVvZiBvYmpbJ0B0eXBlJ10gPT09ICdzdHJpbmcnKTtcbn1cbmV4cG9ydHMuaXNBbnlFeHRlbnNpb24gPSBpc0FueUV4dGVuc2lvbjtcbmNvbnN0IGRlc2NyaXB0b3JPcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgIG9uZW9mczogdHJ1ZSxcbiAgICBqc29uOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGpvaW5OYW1lKGJhc2VOYW1lLCBuYW1lKSB7XG4gICAgaWYgKGJhc2VOYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBiYXNlTmFtZSArICcuJyArIG5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZXNwYWNlQmFzZShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuTmFtZXNwYWNlIHx8IG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlJvb3Q7XG59XG5mdW5jdGlvbiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMob2JqLCBwYXJlbnROYW1lKSB7XG4gICAgY29uc3Qgb2JqTmFtZSA9IGpvaW5OYW1lKHBhcmVudE5hbWUsIG9iai5uYW1lKTtcbiAgICBpZiAoaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBbW29iak5hbWUsIG9ial1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlQmFzZShvYmopICYmIHR5cGVvZiBvYmoubmVzdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iai5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iai5uZXN0ZWRbbmFtZV0sIG9iak5hbWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvci5jb25jYXQoY3VycmVudFZhbHVlKSwgW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2VyaWFsaXplcihjbHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVzZXJpYWxpemUoYXJnQnVmKSB7XG4gICAgICAgIHJldHVybiBjbHMudG9PYmplY3QoY2xzLmRlY29kZShhcmdCdWYpLCBvcHRpb25zKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihjbHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VyaWFsaXplKGFyZykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXJpYWxpemUgbWVzc2FnZTogZXhwZWN0ZWQgb2JqZWN0IHdpdGggJHtjbHMubmFtZX0gc3RydWN0dXJlLCBnb3QgYXJyYXkgaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjbHMuZnJvbU9iamVjdChhcmcpO1xuICAgICAgICByZXR1cm4gY2xzLmVuY29kZShtZXNzYWdlKS5maW5pc2goKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIHNlcnZpY2VOYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICAvKiBUaGlzIGlzIG9ubHkgZXZlciBjYWxsZWQgYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgcm9vdC5yZXNvbHZlQWxsKCksIHNvIHdlXG4gICAgICogY2FuIGFzc3VtZSB0aGF0IHRoZSByZXNvbHZlZCByZXF1ZXN0IGFuZCByZXNwb25zZSB0eXBlcyBhcmUgbm9uLW51bGwgKi9cbiAgICBjb25zdCByZXF1ZXN0VHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlO1xuICAgIGNvbnN0IHJlc3BvbnNlVHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiAnLycgKyBzZXJ2aWNlTmFtZSArICcvJyArIG1ldGhvZC5uYW1lLFxuICAgICAgICByZXF1ZXN0U3RyZWFtOiAhIW1ldGhvZC5yZXF1ZXN0U3RyZWFtLFxuICAgICAgICByZXNwb25zZVN0cmVhbTogISFtZXRob2QucmVzcG9uc2VTdHJlYW0sXG4gICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVxdWVzdFR5cGUpLFxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXF1ZXN0VHlwZSwgb3B0aW9ucyksXG4gICAgICAgIHJlc3BvbnNlU2VyaWFsaXplOiBjcmVhdGVTZXJpYWxpemVyKHJlc3BvbnNlVHlwZSksXG4gICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXNwb25zZVR5cGUsIG9wdGlvbnMpLFxuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzXG4gICAgICAgIG9yaWdpbmFsTmFtZTogY2FtZWxDYXNlKG1ldGhvZC5uYW1lKSxcbiAgICAgICAgcmVxdWVzdFR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlcXVlc3RUeXBlLCBmaWxlRGVzY3JpcHRvcnMpLFxuICAgICAgICByZXNwb25zZVR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlc3BvbnNlVHlwZSwgZmlsZURlc2NyaXB0b3JzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VydmljZURlZmluaXRpb24oc2VydmljZSwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgZGVmID0ge307XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2Ygc2VydmljZS5tZXRob2RzQXJyYXkpIHtcbiAgICAgICAgZGVmW21ldGhvZC5uYW1lXSA9IGNyZWF0ZU1ldGhvZERlZmluaXRpb24obWV0aG9kLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZURlZmluaXRpb24obWVzc2FnZSwgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgbWVzc2FnZURlc2NyaXB0b3IgPSBtZXNzYWdlLnRvRGVzY3JpcHRvcigncHJvdG8zJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0OiAnUHJvdG9jb2wgQnVmZmVyIDMgRGVzY3JpcHRvclByb3RvJyxcbiAgICAgICAgdHlwZTogbWVzc2FnZURlc2NyaXB0b3IuJHR5cGUudG9PYmplY3QobWVzc2FnZURlc2NyaXB0b3IsIGRlc2NyaXB0b3JPcHRpb25zKSxcbiAgICAgICAgZmlsZURlc2NyaXB0b3JQcm90b3M6IGZpbGVEZXNjcmlwdG9ycyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRW51bURlZmluaXRpb24oZW51bVR5cGUsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IGVudW1EZXNjcmlwdG9yID0gZW51bVR5cGUudG9EZXNjcmlwdG9yKCdwcm90bzMnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXQ6ICdQcm90b2NvbCBCdWZmZXIgMyBFbnVtRGVzY3JpcHRvclByb3RvJyxcbiAgICAgICAgdHlwZTogZW51bURlc2NyaXB0b3IuJHR5cGUudG9PYmplY3QoZW51bURlc2NyaXB0b3IsIGRlc2NyaXB0b3JPcHRpb25zKSxcbiAgICAgICAgZmlsZURlc2NyaXB0b3JQcm90b3M6IGZpbGVEZXNjcmlwdG9ycyxcbiAgICB9O1xufVxuLyoqXG4gKiBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuU2VydmljZSwgbmFtZTogc3RyaW5nLCBvcHRpb25zOlxuICogT3B0aW9ucyk6IFNlcnZpY2VEZWZpbml0aW9uOyBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuVHlwZSxcbiAqIG5hbWU6IHN0cmluZywgb3B0aW9uczogT3B0aW9ucyk6IE1lc3NhZ2VUeXBlRGVmaW5pdGlvbjsgZnVuY3Rpb25cbiAqIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5FbnVtLCBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IE9wdGlvbnMpOlxuICogRW51bVR5cGVEZWZpbml0aW9uO1xuICovXG5mdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTWVzc2FnZURlZmluaXRpb24ob2JqLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbnVtRGVmaW5pdGlvbihvYmosIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgbWlzbWF0Y2ggaW4gcmVmbGVjdGlvbiBvYmplY3QgaGFuZGxpbmcnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihyb290LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmID0ge307XG4gICAgcm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgY29uc3QgZGVzY3JpcHRvckxpc3QgPSByb290LnRvRGVzY3JpcHRvcigncHJvdG8zJykuZmlsZTtcbiAgICBjb25zdCBidWZmZXJMaXN0ID0gZGVzY3JpcHRvckxpc3QubWFwKHZhbHVlID0+IEJ1ZmZlci5mcm9tKGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JQcm90by5lbmNvZGUodmFsdWUpLmZpbmlzaCgpKSk7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgb2JqXSBvZiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMocm9vdCwgJycpKSB7XG4gICAgICAgIGRlZltuYW1lXSA9IGNyZWF0ZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBidWZmZXJMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByb290ID0gUHJvdG9idWYuUm9vdC5mcm9tRGVzY3JpcHRvcihkZWNvZGVkRGVzY3JpcHRvclNldCk7XG4gICAgcm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKHJvb3QsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBMb2FkIGEgLnByb3RvIGZpbGUgd2l0aCB0aGUgc3BlY2lmaWVkIG9wdGlvbnMuXG4gKiBAcGFyYW0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGUgcGF0aHMgdG8gbG9hZC4gQ2FuIGJlIGFuIGFic29sdXRlIHBhdGhcbiAqICAgICBvciByZWxhdGl2ZSB0byBhbiBpbmNsdWRlIHBhdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5rZWVwQ2FzZSBQcmVzZXJ2ZSBmaWVsZCBuYW1lcy4gVGhlIGRlZmF1bHQgaXMgdG8gY2hhbmdlIHRoZW1cbiAqICAgICB0byBjYW1lbCBjYXNlLlxuICogQHBhcmFtIG9wdGlvbnMubG9uZ3MgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGxvbmdgIHZhbHVlcy5cbiAqICAgICBWYWxpZCBvcHRpb25zIGFyZSBgTnVtYmVyYCBhbmQgYFN0cmluZ2AuIERlZmF1bHRzIHRvIGEgYExvbmdgIG9iamVjdCB0eXBlXG4gKiAgICAgZnJvbSBhIGxpYnJhcnkuXG4gKiBAcGFyYW0gb3B0aW9ucy5lbnVtcyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgZW51bWAgdmFsdWVzLlxuICogICAgIFRoZSBvbmx5IHZhbGlkIG9wdGlvbiBpcyBgU3RyaW5nYC4gRGVmYXVsdHMgdG8gdGhlIG51bWVyaWMgdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucy5ieXRlcyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgYnl0ZXNgXG4gKiAgICAgdmFsdWVzLiBWYWxpZCBvcHRpb25zIGFyZSBgQXJyYXlgIGFuZCBgU3RyaW5nYC4gVGhlIGRlZmF1bHQgaXMgdG8gdXNlXG4gKiAgICAgYEJ1ZmZlcmAuXG4gKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0cyBTZXQgZGVmYXVsdCB2YWx1ZXMgb24gb3V0cHV0IG9iamVjdHMuIERlZmF1bHRzIHRvXG4gKiAgICAgYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLmFycmF5cyBTZXQgZW1wdHkgYXJyYXlzIGZvciBtaXNzaW5nIGFycmF5IHZhbHVlcyBldmVuIGlmXG4gKiAgICAgYGRlZmF1bHRzYCBpcyBgZmFsc2VgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMub2JqZWN0cyBTZXQgZW1wdHkgb2JqZWN0cyBmb3IgbWlzc2luZyBvYmplY3QgdmFsdWVzIGV2ZW4gaWZcbiAqICAgICBgZGVmYXVsdHNgIGlzIGBmYWxzZWAuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5vbmVvZnMgU2V0IHZpcnR1YWwgb25lb2YgcHJvcGVydGllcyB0byB0aGUgcHJlc2VudCBmaWVsZCdzXG4gKiAgICAgbmFtZVxuICogQHBhcmFtIG9wdGlvbnMuanNvbiBSZXByZXNlbnQgSW5maW5pdHkgYW5kIE5hTiBhcyBzdHJpbmdzIGluIGZsb2F0IGZpZWxkcyxcbiAqICAgICBhbmQgYXV0b21hdGljYWxseSBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLkFueSB2YWx1ZXMuXG4gKiBAcGFyYW0gb3B0aW9ucy5pbmNsdWRlRGlycyBQYXRocyB0byBzZWFyY2ggZm9yIGltcG9ydGVkIGAucHJvdG9gIGZpbGVzLlxuICovXG5mdW5jdGlvbiBsb2FkKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEubG9hZFByb3Rvc1dpdGhPcHRpb25zKShmaWxlbmFtZSwgb3B0aW9ucykudGhlbihsb2FkZWRSb290ID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9ICgwLCB1dGlsXzEubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYykoZmlsZW5hbWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubG9hZFN5bmMgPSBsb2FkU3luYztcbmZ1bmN0aW9uIGZyb21KU09OKGpzb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBsb2FkZWRSb290ID0gUHJvdG9idWYuUm9vdC5mcm9tSlNPTihqc29uKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmZyb21KU09OID0gZnJvbUpTT047XG5mdW5jdGlvbiBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyKGRlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWNvZGVkRGVzY3JpcHRvclNldCA9IGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JTZXQuZGVjb2RlKGRlc2NyaXB0b3JTZXQpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXI7XG5mdW5jdGlvbiBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0KGRlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWNvZGVkRGVzY3JpcHRvclNldCA9IGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JTZXQuZnJvbU9iamVjdChkZXNjcmlwdG9yU2V0KTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QgPSBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0O1xuKDAsIHV0aWxfMS5hZGRDb21tb25Qcm90b3MpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0IiwibG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciIsImZyb21KU09OIiwibG9hZFN5bmMiLCJsb2FkIiwiaXNBbnlFeHRlbnNpb24iLCJMb25nIiwiY2FtZWxDYXNlIiwicmVxdWlyZSIsIlByb3RvYnVmIiwiZGVzY3JpcHRvciIsInV0aWxfMSIsIm9iaiIsImRlc2NyaXB0b3JPcHRpb25zIiwibG9uZ3MiLCJTdHJpbmciLCJlbnVtcyIsImJ5dGVzIiwiZGVmYXVsdHMiLCJvbmVvZnMiLCJqc29uIiwiam9pbk5hbWUiLCJiYXNlTmFtZSIsIm5hbWUiLCJpc0hhbmRsZWRSZWZsZWN0aW9uT2JqZWN0IiwiU2VydmljZSIsIlR5cGUiLCJFbnVtIiwiaXNOYW1lc3BhY2VCYXNlIiwiTmFtZXNwYWNlIiwiUm9vdCIsImdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyIsInBhcmVudE5hbWUiLCJvYmpOYW1lIiwibmVzdGVkIiwia2V5cyIsIm1hcCIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwiY29uY2F0IiwiY3JlYXRlRGVzZXJpYWxpemVyIiwiY2xzIiwib3B0aW9ucyIsImRlc2VyaWFsaXplIiwiYXJnQnVmIiwidG9PYmplY3QiLCJkZWNvZGUiLCJjcmVhdGVTZXJpYWxpemVyIiwic2VyaWFsaXplIiwiYXJnIiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJtZXNzYWdlIiwiZnJvbU9iamVjdCIsImVuY29kZSIsImZpbmlzaCIsImNyZWF0ZU1ldGhvZERlZmluaXRpb24iLCJtZXRob2QiLCJzZXJ2aWNlTmFtZSIsImZpbGVEZXNjcmlwdG9ycyIsInJlcXVlc3RUeXBlIiwicmVzb2x2ZWRSZXF1ZXN0VHlwZSIsInJlc3BvbnNlVHlwZSIsInJlc29sdmVkUmVzcG9uc2VUeXBlIiwicGF0aCIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsInJlcXVlc3RTZXJpYWxpemUiLCJyZXF1ZXN0RGVzZXJpYWxpemUiLCJyZXNwb25zZVNlcmlhbGl6ZSIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJvcmlnaW5hbE5hbWUiLCJjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbiIsImNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uIiwic2VydmljZSIsImRlZiIsIm1ldGhvZHNBcnJheSIsIm1lc3NhZ2VEZXNjcmlwdG9yIiwidG9EZXNjcmlwdG9yIiwiZm9ybWF0IiwidHlwZSIsIiR0eXBlIiwiZmlsZURlc2NyaXB0b3JQcm90b3MiLCJjcmVhdGVFbnVtRGVmaW5pdGlvbiIsImVudW1UeXBlIiwiZW51bURlc2NyaXB0b3IiLCJjcmVhdGVEZWZpbml0aW9uIiwiY3JlYXRlUGFja2FnZURlZmluaXRpb24iLCJyb290IiwicmVzb2x2ZUFsbCIsImRlc2NyaXB0b3JMaXN0IiwiZmlsZSIsImJ1ZmZlckxpc3QiLCJCdWZmZXIiLCJmcm9tIiwiRmlsZURlc2NyaXB0b3JQcm90byIsImNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQiLCJkZWNvZGVkRGVzY3JpcHRvclNldCIsImZyb21EZXNjcmlwdG9yIiwiZmlsZW5hbWUiLCJsb2FkUHJvdG9zV2l0aE9wdGlvbnMiLCJ0aGVuIiwibG9hZGVkUm9vdCIsImxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMiLCJkZXNjcmlwdG9yU2V0IiwiRmlsZURlc2NyaXB0b3JTZXQiLCJhZGRDb21tb25Qcm90b3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/process/browser.js\");\n\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target)=>{\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths){\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            } catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error(\"The includeDirs option must be an array\"));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error(\"The includeDirs option must be an array\");\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */ function addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common(\"api\", apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"descriptor\", descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"source_context\", sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"type\", typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos; //# sourceMappingURL=util.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBR0EsaUNBQWlDLEdBQUdBLDZCQUE2QixHQUFHLEtBQUs7QUFDbkcsTUFBTUssS0FBS0MsbUJBQU9BLENBQUMsY0FBSTtBQUN2QixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyw0REFBWTtBQUNyQyxTQUFTRyx1QkFBdUJDLElBQUksRUFBRUMsWUFBWTtJQUM5QyxNQUFNQyxzQkFBc0JGLEtBQUtHLFdBQVc7SUFDNUNILEtBQUtHLFdBQVcsR0FBRyxDQUFDQyxRQUFRQztRQUN4QixJQUFJUixLQUFLUyxVQUFVLENBQUNELFNBQVM7WUFDekIsT0FBT0E7UUFDWDtRQUNBLEtBQUssTUFBTUUsYUFBYU4sYUFBYztZQUNsQyxNQUFNTyxXQUFXWCxLQUFLWSxJQUFJLENBQUNGLFdBQVdGO1lBQ3RDLElBQUk7Z0JBQ0FWLEdBQUdlLFVBQVUsQ0FBQ0YsVUFBVWIsR0FBR2dCLFNBQVMsQ0FBQ0MsSUFBSTtnQkFDekMsT0FBT0o7WUFDWCxFQUNBLE9BQU9LLEtBQUs7Z0JBQ1I7WUFDSjtRQUNKO1FBQ0FDLE9BQU9BLENBQUNDLFdBQVcsQ0FBQyxDQUFDLEVBQUVWLE9BQU8sdUNBQXVDLEVBQUVKLGFBQWEsQ0FBQztRQUNyRixPQUFPQyxvQkFBb0JFLFFBQVFDO0lBQ3ZDO0FBQ0o7QUFDQSxlQUFlWCxzQkFBc0JzQixRQUFRLEVBQUVDLE9BQU87SUFDbEQsTUFBTWpCLE9BQU8sSUFBSUYsU0FBU29CLElBQUk7SUFDOUJELFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFJLENBQUMsQ0FBQ0EsUUFBUUUsV0FBVyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSixRQUFRRSxXQUFXLEdBQUc7WUFDckMsT0FBT0csUUFBUUMsTUFBTSxDQUFDLElBQUlDLE1BQU07UUFDcEM7UUFDQXpCLHVCQUF1QkMsTUFBTWlCLFFBQVFFLFdBQVc7SUFDcEQ7SUFDQSxNQUFNTSxhQUFhLE1BQU16QixLQUFLMEIsSUFBSSxDQUFDVixVQUFVQztJQUM3Q1EsV0FBV0UsVUFBVTtJQUNyQixPQUFPRjtBQUNYO0FBQ0FuQyw2QkFBNkIsR0FBR0k7QUFDaEMsU0FBU0QsMEJBQTBCdUIsUUFBUSxFQUFFQyxPQUFPO0lBQ2hELE1BQU1qQixPQUFPLElBQUlGLFNBQVNvQixJQUFJO0lBQzlCRCxVQUFVQSxXQUFXLENBQUM7SUFDdEIsSUFBSSxDQUFDLENBQUNBLFFBQVFFLFdBQVcsRUFBRTtRQUN2QixJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0osUUFBUUUsV0FBVyxHQUFHO1lBQ3JDLE1BQU0sSUFBSUssTUFBTTtRQUNwQjtRQUNBekIsdUJBQXVCQyxNQUFNaUIsUUFBUUUsV0FBVztJQUNwRDtJQUNBLE1BQU1NLGFBQWF6QixLQUFLNEIsUUFBUSxDQUFDWixVQUFVQztJQUMzQ1EsV0FBV0UsVUFBVTtJQUNyQixPQUFPRjtBQUNYO0FBQ0FuQyxpQ0FBaUMsR0FBR0c7QUFDcEM7O0NBRUMsR0FDRCxTQUFTRDtJQUNMLDRFQUE0RTtJQUM1RSxxRUFBcUU7SUFDckUsbUVBQW1FO0lBQ25FLE1BQU1xQyxnQkFBZ0JqQyxtQkFBT0EsQ0FBQztJQUM5QixNQUFNa0MsdUJBQXVCbEMsbUJBQU9BLENBQUM7SUFDckMsTUFBTW1DLDBCQUEwQm5DLG1CQUFPQSxDQUFDO0lBQ3hDLE1BQU1vQyxpQkFBaUJwQyxtQkFBT0EsQ0FBQztJQUMvQkUsU0FBU21DLE1BQU0sQ0FBQyxPQUFPSixjQUFjSyxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07SUFDekVwQyxTQUFTbUMsTUFBTSxDQUFDLGNBQWNILHFCQUFxQkksTUFBTSxDQUFDQyxNQUFNLENBQUNELE1BQU0sQ0FBQ0UsUUFBUSxDQUFDRixNQUFNO0lBQ3ZGcEMsU0FBU21DLE1BQU0sQ0FBQyxrQkFBa0JGLHdCQUF3QkcsTUFBTSxDQUFDQyxNQUFNLENBQUNELE1BQU0sQ0FBQ0UsUUFBUSxDQUFDRixNQUFNO0lBQzlGcEMsU0FBU21DLE1BQU0sQ0FBQyxRQUFRRCxlQUFlRSxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07QUFDL0U7QUFDQTVDLHVCQUF1QixHQUFHRSxpQkFDMUIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzPzY0MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBleHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMgPSBleHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmZ1bmN0aW9uIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgaW5jbHVkZVBhdGhzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxSZXNvbHZlUGF0aCA9IHJvb3QucmVzb2x2ZVBhdGg7XG4gICAgcm9vdC5yZXNvbHZlUGF0aCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgICAgICBpZiAocGF0aC5pc0Fic29sdXRlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rvcnkgb2YgaW5jbHVkZVBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIHRhcmdldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLmFjY2Vzc1N5bmMoZnVsbFBhdGgsIGZzLmNvbnN0YW50cy5SX09LKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgJHt0YXJnZXR9IG5vdCBmb3VuZCBpbiBhbnkgb2YgdGhlIGluY2x1ZGUgcGF0aHMgJHtpbmNsdWRlUGF0aHN9YCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlc29sdmVQYXRoKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgcm9vdCA9IG5ldyBQcm90b2J1Zi5Sb290KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCEhb3B0aW9ucy5pbmNsdWRlRGlycykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlRGlycykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRSb290ID0gYXdhaXQgcm9vdC5sb2FkKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zID0gbG9hZFByb3Rvc1dpdGhPcHRpb25zO1xuZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUHJvdG9idWYuUm9vdCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZURpcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgb3B0aW9ucy5pbmNsdWRlRGlycyk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSByb290LmxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyA9IGxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmM7XG4vKipcbiAqIExvYWQgR29vZ2xlJ3Mgd2VsbC1rbm93biBwcm90byBmaWxlcyB0aGF0IGFyZW4ndCBleHBvc2VkIGJ5IFByb3RvYnVmLmpzLlxuICovXG5mdW5jdGlvbiBhZGRDb21tb25Qcm90b3MoKSB7XG4gICAgLy8gUHJvdG9idWYuanMgZXhwb3NlczogYW55LCBkdXJhdGlvbiwgZW1wdHksIGZpZWxkX21hc2ssIHN0cnVjdCwgdGltZXN0YW1wLFxuICAgIC8vIGFuZCB3cmFwcGVycy4gY29tcGlsZXIvcGx1Z2luIGlzIGV4Y2x1ZGVkIGluIFByb3RvYnVmLmpzIGFuZCBoZXJlLlxuICAgIC8vIFVzaW5nIGNvbnN0YW50IHN0cmluZ3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0b29scyBsaWtlIFdlYnBhY2tcbiAgICBjb25zdCBhcGlEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvYXBpLmpzb24nKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IuanNvbicpO1xuICAgIGNvbnN0IHNvdXJjZUNvbnRleHREZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQuanNvbicpO1xuICAgIGNvbnN0IHR5cGVEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvdHlwZS5qc29uJyk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdhcGknLCBhcGlEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdkZXNjcmlwdG9yJywgZGVzY3JpcHRvckRlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3NvdXJjZV9jb250ZXh0Jywgc291cmNlQ29udGV4dERlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3R5cGUnLCB0eXBlRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xufVxuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBhZGRDb21tb25Qcm90b3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZENvbW1vblByb3RvcyIsImxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMiLCJsb2FkUHJvdG9zV2l0aE9wdGlvbnMiLCJmcyIsInJlcXVpcmUiLCJwYXRoIiwiUHJvdG9idWYiLCJhZGRJbmNsdWRlUGF0aFJlc29sdmVyIiwicm9vdCIsImluY2x1ZGVQYXRocyIsIm9yaWdpbmFsUmVzb2x2ZVBhdGgiLCJyZXNvbHZlUGF0aCIsIm9yaWdpbiIsInRhcmdldCIsImlzQWJzb2x1dGUiLCJkaXJlY3RvcnkiLCJmdWxsUGF0aCIsImpvaW4iLCJhY2Nlc3NTeW5jIiwiY29uc3RhbnRzIiwiUl9PSyIsImVyciIsInByb2Nlc3MiLCJlbWl0V2FybmluZyIsImZpbGVuYW1lIiwib3B0aW9ucyIsIlJvb3QiLCJpbmNsdWRlRGlycyIsIkFycmF5IiwiaXNBcnJheSIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsImxvYWRlZFJvb3QiLCJsb2FkIiwicmVzb2x2ZUFsbCIsImxvYWRTeW5jIiwiYXBpRGVzY3JpcHRvciIsImRlc2NyaXB0b3JEZXNjcmlwdG9yIiwic291cmNlQ29udGV4dERlc2NyaXB0b3IiLCJ0eXBlRGVzY3JpcHRvciIsImNvbW1vbiIsIm5lc3RlZCIsImdvb2dsZSIsInByb3RvYnVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/admin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addAdminServicesToServer = exports.registerAdminService = void 0;\nconst registeredAdminServices = [];\nfunction registerAdminService(getServiceDefinition, getHandlers) {\n    registeredAdminServices.push({\n        getServiceDefinition,\n        getHandlers\n    });\n}\nexports.registerAdminService = registerAdminService;\nfunction addAdminServicesToServer(server) {\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices){\n        server.addService(getServiceDefinition(), getHandlers());\n    }\n}\nexports.addAdminServicesToServer = addAdminServicesToServer; //# sourceMappingURL=admin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdDQUFnQyxHQUFHQSw0QkFBNEIsR0FBRyxLQUFLO0FBQ3ZFLE1BQU1JLDBCQUEwQixFQUFFO0FBQ2xDLFNBQVNELHFCQUFxQkUsb0JBQW9CLEVBQUVDLFdBQVc7SUFDM0RGLHdCQUF3QkcsSUFBSSxDQUFDO1FBQUVGO1FBQXNCQztJQUFZO0FBQ3JFO0FBQ0FOLDRCQUE0QixHQUFHRztBQUMvQixTQUFTRCx5QkFBeUJNLE1BQU07SUFDcEMsS0FBSyxNQUFNLEVBQUVILG9CQUFvQixFQUFFQyxXQUFXLEVBQUUsSUFBSUYsd0JBQXlCO1FBQ3pFSSxPQUFPQyxVQUFVLENBQUNKLHdCQUF3QkM7SUFDOUM7QUFDSjtBQUNBTixnQ0FBZ0MsR0FBR0UsMEJBQ25DLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2FkbWluLmpzPzk4NGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyID0gZXhwb3J0cy5yZWdpc3RlckFkbWluU2VydmljZSA9IHZvaWQgMDtcbmNvbnN0IHJlZ2lzdGVyZWRBZG1pblNlcnZpY2VzID0gW107XG5mdW5jdGlvbiByZWdpc3RlckFkbWluU2VydmljZShnZXRTZXJ2aWNlRGVmaW5pdGlvbiwgZ2V0SGFuZGxlcnMpIHtcbiAgICByZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcy5wdXNoKHsgZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzIH0pO1xufVxuZXhwb3J0cy5yZWdpc3RlckFkbWluU2VydmljZSA9IHJlZ2lzdGVyQWRtaW5TZXJ2aWNlO1xuZnVuY3Rpb24gYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyKHNlcnZlcikge1xuICAgIGZvciAoY29uc3QgeyBnZXRTZXJ2aWNlRGVmaW5pdGlvbiwgZ2V0SGFuZGxlcnMgfSBvZiByZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcykge1xuICAgICAgICBzZXJ2ZXIuYWRkU2VydmljZShnZXRTZXJ2aWNlRGVmaW5pdGlvbigpLCBnZXRIYW5kbGVycygpKTtcbiAgICB9XG59XG5leHBvcnRzLmFkZEFkbWluU2VydmljZXNUb1NlcnZlciA9IGFkZEFkbWluU2VydmljZXNUb1NlcnZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkbWluLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZEFkbWluU2VydmljZXNUb1NlcnZlciIsInJlZ2lzdGVyQWRtaW5TZXJ2aWNlIiwicmVnaXN0ZXJlZEFkbWluU2VydmljZXMiLCJnZXRTZXJ2aWNlRGVmaW5pdGlvbiIsImdldEhhbmRsZXJzIiwicHVzaCIsInNlcnZlciIsImFkZFNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */ function uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options){\n        this.callback = callback;\n        /**\n         * The delay time at the start, and after each reset.\n         */ this.initialDelay = INITIAL_BACKOFF_MS;\n        /**\n         * The exponential backoff multiplier.\n         */ this.multiplier = BACKOFF_MULTIPLIER;\n        /**\n         * The maximum delay time\n         */ this.maxDelay = MAX_BACKOFF_MS;\n        /**\n         * The maximum fraction by which the delay time can randomly vary after\n         * applying the multiplier.\n         */ this.jitter = BACKOFF_JITTER;\n        /**\n         * Indicates whether the timer is currently running.\n         */ this.running = false;\n        /**\n         * Indicates whether the timer should keep the Node process running if no\n         * other async operation is doing so.\n         */ this.hasRef = true;\n        /**\n         * The time that the currently running timer was started. Only valid if\n         * running is true.\n         */ this.startTime = new Date();\n        /**\n         * The approximate time that the currently running timer will end. Only valid\n         * if running is true.\n         */ this.endTime = new Date();\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(()=>{}, 0);\n        clearTimeout(this.timerId);\n    }\n    runTimer(delay) {\n        var _a, _b;\n        this.endTime = this.startTime;\n        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);\n        clearTimeout(this.timerId);\n        this.timerId = setTimeout(()=>{\n            this.callback();\n            this.running = false;\n        }, delay);\n        if (!this.hasRef) {\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */ runOnce() {\n        this.running = true;\n        this.startTime = new Date();\n        this.runTimer(this.nextDelay);\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */ stop() {\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value. If the timer is still running,\n     * retroactively apply that reset to the current timer.\n     */ reset() {\n        this.nextDelay = this.initialDelay;\n        if (this.running) {\n            const now = new Date();\n            const newEndTime = this.startTime;\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n            clearTimeout(this.timerId);\n            if (now < newEndTime) {\n                this.runTimer(newEndTime.getTime() - now.getTime());\n            } else {\n                this.running = false;\n            }\n        }\n    }\n    /**\n     * Check whether the timer is currently running.\n     */ isRunning() {\n        return this.running;\n    }\n    /**\n     * Set that while the timer is running, it should keep the Node process\n     * running.\n     */ ref() {\n        var _a, _b;\n        this.hasRef = true;\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Set that while the timer is running, it should not keep the Node process\n     * running.\n     */ unref() {\n        var _a, _b;\n        this.hasRef = false;\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Get the approximate timestamp of when the timer will fire. Only valid if\n     * this.isRunning() is true.\n     */ getEndTime() {\n        return this.endTime;\n    }\n}\nexports.BackoffTimeout = BackoffTimeout; //# sourceMappingURL=backoff-timeout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLE1BQU1HLHFCQUFxQjtBQUMzQixNQUFNQyxxQkFBcUI7QUFDM0IsTUFBTUMsaUJBQWlCO0FBQ3ZCLE1BQU1DLGlCQUFpQjtBQUN2Qjs7OztDQUlDLEdBQ0QsU0FBU0MsY0FBY0MsR0FBRyxFQUFFQyxHQUFHO0lBQzNCLE9BQU9DLEtBQUtDLE1BQU0sS0FBTUYsQ0FBQUEsTUFBTUQsR0FBRSxJQUFLQTtBQUN6QztBQUNBLE1BQU1OO0lBQ0ZVLFlBQVlDLFFBQVEsRUFBRUMsT0FBTyxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQjs7U0FFQyxHQUNELElBQUksQ0FBQ0UsWUFBWSxHQUFHWjtRQUNwQjs7U0FFQyxHQUNELElBQUksQ0FBQ2EsVUFBVSxHQUFHWjtRQUNsQjs7U0FFQyxHQUNELElBQUksQ0FBQ2EsUUFBUSxHQUFHWjtRQUNoQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNhLE1BQU0sR0FBR1o7UUFDZDs7U0FFQyxHQUNELElBQUksQ0FBQ2EsT0FBTyxHQUFHO1FBQ2Y7OztTQUdDLEdBQ0QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZDs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJQztRQUNyQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJRDtRQUNuQixJQUFJUixTQUFTO1lBQ1QsSUFBSUEsUUFBUUMsWUFBWSxFQUFFO2dCQUN0QixJQUFJLENBQUNBLFlBQVksR0FBR0QsUUFBUUMsWUFBWTtZQUM1QztZQUNBLElBQUlELFFBQVFFLFVBQVUsRUFBRTtnQkFDcEIsSUFBSSxDQUFDQSxV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QUlDO1FBQ1IsSUFBSSxDQUFDWCxNQUFNLEdBQUc7UUFDYlcsQ0FBQUEsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ0wsT0FBTyxFQUFFUyxLQUFLLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxJQUFJLENBQUNMO0lBQ2xGO0lBQ0E7OztLQUdDLEdBQ0RnQixhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUN2QixPQUFPO0lBQ3ZCO0FBQ0o7QUFDQXZCLHNCQUFzQixHQUFHRSxnQkFDekIsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzP2ZlNDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFja29mZlRpbWVvdXQgPSB2b2lkIDA7XG5jb25zdCBJTklUSUFMX0JBQ0tPRkZfTVMgPSAxMDAwO1xuY29uc3QgQkFDS09GRl9NVUxUSVBMSUVSID0gMS42O1xuY29uc3QgTUFYX0JBQ0tPRkZfTVMgPSAxMjAwMDA7XG5jb25zdCBCQUNLT0ZGX0pJVFRFUiA9IDAuMjtcbi8qKlxuICogR2V0IGEgbnVtYmVyIHVuaWZvcm1seSBhdCByYW5kb20gaW4gdGhlIHJhbmdlIFttaW4sIG1heClcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqL1xuZnVuY3Rpb24gdW5pZm9ybVJhbmRvbShtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG59XG5jbGFzcyBCYWNrb2ZmVGltZW91dCB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlbGF5IHRpbWUgYXQgdGhlIHN0YXJ0LCBhbmQgYWZ0ZXIgZWFjaCByZXNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbERlbGF5ID0gSU5JVElBTF9CQUNLT0ZGX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGV4cG9uZW50aWFsIGJhY2tvZmYgbXVsdGlwbGllci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXVsdGlwbGllciA9IEJBQ0tPRkZfTVVMVElQTElFUjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIGRlbGF5IHRpbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4RGVsYXkgPSBNQVhfQkFDS09GRl9NUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIGZyYWN0aW9uIGJ5IHdoaWNoIHRoZSBkZWxheSB0aW1lIGNhbiByYW5kb21seSB2YXJ5IGFmdGVyXG4gICAgICAgICAqIGFwcGx5aW5nIHRoZSBtdWx0aXBsaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5qaXR0ZXIgPSBCQUNLT0ZGX0pJVFRFUjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0aW1lciBpcyBjdXJyZW50bHkgcnVubmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVyIHNob3VsZCBrZWVwIHRoZSBOb2RlIHByb2Nlc3MgcnVubmluZyBpZiBub1xuICAgICAgICAgKiBvdGhlciBhc3luYyBvcGVyYXRpb24gaXMgZG9pbmcgc28uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc1JlZiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSB0aGF0IHRoZSBjdXJyZW50bHkgcnVubmluZyB0aW1lciB3YXMgc3RhcnRlZC4gT25seSB2YWxpZCBpZlxuICAgICAgICAgKiBydW5uaW5nIGlzIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXBwcm94aW1hdGUgdGltZSB0aGF0IHRoZSBjdXJyZW50bHkgcnVubmluZyB0aW1lciB3aWxsIGVuZC4gT25seSB2YWxpZFxuICAgICAgICAgKiBpZiBydW5uaW5nIGlzIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5pdGlhbERlbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsRGVsYXkgPSBvcHRpb25zLmluaXRpYWxEZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSBvcHRpb25zLm11bHRpcGxpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5qaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmppdHRlciA9IG9wdGlvbnMuaml0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF4RGVsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1heERlbGF5ID0gb3B0aW9ucy5tYXhEZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHREZWxheSA9IHRoaXMuaW5pdGlhbERlbGF5O1xuICAgICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgIH1cbiAgICBydW5UaW1lcihkZWxheSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5lbmRUaW1lLnNldE1pbGxpc2Vjb25kcyh0aGlzLmVuZFRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aGlzLm5leHREZWxheSk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIGlmICghdGhpcy5oYXNSZWYpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBjYWxsYmFjayBhZnRlciB0aGUgY3VycmVudCBhbW91bnQgb2YgZGVsYXkgdGltZVxuICAgICAqL1xuICAgIHJ1bk9uY2UoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5ydW5UaW1lcih0aGlzLm5leHREZWxheSk7XG4gICAgICAgIGNvbnN0IG5leHRCYWNrb2ZmID0gTWF0aC5taW4odGhpcy5uZXh0RGVsYXkgKiB0aGlzLm11bHRpcGxpZXIsIHRoaXMubWF4RGVsYXkpO1xuICAgICAgICBjb25zdCBqaXR0ZXJNYWduaXR1ZGUgPSBuZXh0QmFja29mZiAqIHRoaXMuaml0dGVyO1xuICAgICAgICB0aGlzLm5leHREZWxheSA9XG4gICAgICAgICAgICBuZXh0QmFja29mZiArIHVuaWZvcm1SYW5kb20oLWppdHRlck1hZ25pdHVkZSwgaml0dGVyTWFnbml0dWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgdGltZXIuIFRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgdW50aWwgYHJ1bk9uY2VgIGlzIGNhbGxlZFxuICAgICAqIGFnYWluLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGRlbGF5IHRpbWUgdG8gaXRzIGluaXRpYWwgdmFsdWUuIElmIHRoZSB0aW1lciBpcyBzdGlsbCBydW5uaW5nLFxuICAgICAqIHJldHJvYWN0aXZlbHkgYXBwbHkgdGhhdCByZXNldCB0byB0aGUgY3VycmVudCB0aW1lci5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPSB0aGlzLmluaXRpYWxEZWxheTtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIG5ld0VuZFRpbWUuc2V0TWlsbGlzZWNvbmRzKG5ld0VuZFRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aGlzLm5leHREZWxheSk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgICAgIGlmIChub3cgPCBuZXdFbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lcihuZXdFbmRUaW1lLmdldFRpbWUoKSAtIG5vdy5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgdGltZXIgaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAgICovXG4gICAgaXNSdW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhhdCB3aGlsZSB0aGUgdGltZXIgaXMgcnVubmluZywgaXQgc2hvdWxkIGtlZXAgdGhlIE5vZGUgcHJvY2Vzc1xuICAgICAqIHJ1bm5pbmcuXG4gICAgICovXG4gICAgcmVmKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmhhc1JlZiA9IHRydWU7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGF0IHdoaWxlIHRoZSB0aW1lciBpcyBydW5uaW5nLCBpdCBzaG91bGQgbm90IGtlZXAgdGhlIE5vZGUgcHJvY2Vzc1xuICAgICAqIHJ1bm5pbmcuXG4gICAgICovXG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuaGFzUmVmID0gZmFsc2U7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhcHByb3hpbWF0ZSB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgdGltZXIgd2lsbCBmaXJlLiBPbmx5IHZhbGlkIGlmXG4gICAgICogdGhpcy5pc1J1bm5pbmcoKSBpcyB0cnVlLlxuICAgICAqL1xuICAgIGdldEVuZFRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZFRpbWU7XG4gICAgfVxufVxuZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IEJhY2tvZmZUaW1lb3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja29mZi10aW1lb3V0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhY2tvZmZUaW1lb3V0IiwiSU5JVElBTF9CQUNLT0ZGX01TIiwiQkFDS09GRl9NVUxUSVBMSUVSIiwiTUFYX0JBQ0tPRkZfTVMiLCJCQUNLT0ZGX0pJVFRFUiIsInVuaWZvcm1SYW5kb20iLCJtaW4iLCJtYXgiLCJNYXRoIiwicmFuZG9tIiwiY29uc3RydWN0b3IiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJpbml0aWFsRGVsYXkiLCJtdWx0aXBsaWVyIiwibWF4RGVsYXkiLCJqaXR0ZXIiLCJydW5uaW5nIiwiaGFzUmVmIiwic3RhcnRUaW1lIiwiRGF0ZSIsImVuZFRpbWUiLCJuZXh0RGVsYXkiLCJ0aW1lcklkIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVyIiwiZGVsYXkiLCJfYSIsIl9iIiwic2V0TWlsbGlzZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwidW5yZWYiLCJjYWxsIiwicnVuT25jZSIsIm5leHRCYWNrb2ZmIiwiaml0dGVyTWFnbml0dWRlIiwic3RvcCIsInJlc2V0Iiwibm93IiwibmV3RW5kVGltZSIsImdldFRpbWUiLCJpc1J1bm5pbmciLCJyZWYiLCJnZXRFbmRUaW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CallCredentials = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction isCurrentOauth2Client(client) {\n    return \"getRequestHeaders\" in client && typeof client.getRequestHeaders === \"function\";\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */ class CallCredentials {\n    /**\n     * Creates a new CallCredentials object from a given function that generates\n     * Metadata objects.\n     * @param metadataGenerator A function that accepts a set of options, and\n     * generates a Metadata object based on these options, which is passed back\n     * to the caller via a supplied (err, metadata) callback.\n     */ static createFromMetadataGenerator(metadataGenerator) {\n        return new SingleCallCredentials(metadataGenerator);\n    }\n    /**\n     * Create a gRPC credential from a Google credential object.\n     * @param googleCredentials The authentication client to use.\n     * @return The resulting CallCredentials object.\n     */ static createFromGoogleCredential(googleCredentials) {\n        return CallCredentials.createFromMetadataGenerator((options, callback)=>{\n            let getHeaders;\n            if (isCurrentOauth2Client(googleCredentials)) {\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n            } else {\n                getHeaders = new Promise((resolve, reject)=>{\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers)=>{\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        if (!headers) {\n                            reject(new Error(\"Headers not set by metadata plugin\"));\n                            return;\n                        }\n                        resolve(headers);\n                    });\n                });\n            }\n            getHeaders.then((headers)=>{\n                const metadata = new metadata_1.Metadata();\n                for (const key of Object.keys(headers)){\n                    metadata.add(key, headers[key]);\n                }\n                callback(null, metadata);\n            }, (err)=>{\n                callback(err);\n            });\n        });\n    }\n    static createEmpty() {\n        return new EmptyCallCredentials();\n    }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n    constructor(creds){\n        super();\n        this.creds = creds;\n    }\n    async generateMetadata(options) {\n        const base = new metadata_1.Metadata();\n        const generated = await Promise.all(this.creds.map((cred)=>cred.generateMetadata(options)));\n        for (const gen of generated){\n            base.merge(gen);\n        }\n        return base;\n    }\n    compose(other) {\n        return new ComposedCallCredentials(this.creds.concat([\n            other\n        ]));\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedCallCredentials) {\n            return this.creds.every((value, index)=>value._equals(other.creds[index]));\n        } else {\n            return false;\n        }\n    }\n}\nclass SingleCallCredentials extends CallCredentials {\n    constructor(metadataGenerator){\n        super();\n        this.metadataGenerator = metadataGenerator;\n    }\n    generateMetadata(options) {\n        return new Promise((resolve, reject)=>{\n            this.metadataGenerator(options, (err, metadata)=>{\n                if (metadata !== undefined) {\n                    resolve(metadata);\n                } else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    compose(other) {\n        return new ComposedCallCredentials([\n            this,\n            other\n        ]);\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SingleCallCredentials) {\n            return this.metadataGenerator === other.metadataGenerator;\n        } else {\n            return false;\n        }\n    }\n}\nclass EmptyCallCredentials extends CallCredentials {\n    generateMetadata(options) {\n        return Promise.resolve(new metadata_1.Metadata());\n    }\n    compose(other) {\n        return other;\n    }\n    _equals(other) {\n        return other instanceof EmptyCallCredentials;\n    }\n} //# sourceMappingURL=call-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxTQUFTQyxzQkFBc0JDLE1BQU07SUFDakMsT0FBUSx1QkFBdUJBLFVBQzNCLE9BQU9BLE9BQU9DLGlCQUFpQixLQUFLO0FBQzVDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUw7SUFDRjs7Ozs7O0tBTUMsR0FDRCxPQUFPTSw0QkFBNEJDLGlCQUFpQixFQUFFO1FBQ2xELE9BQU8sSUFBSUMsc0JBQXNCRDtJQUNyQztJQUNBOzs7O0tBSUMsR0FDRCxPQUFPRSwyQkFBMkJDLGlCQUFpQixFQUFFO1FBQ2pELE9BQU9WLGdCQUFnQk0sMkJBQTJCLENBQUMsQ0FBQ0ssU0FBU0M7WUFDekQsSUFBSUM7WUFDSixJQUFJVixzQkFBc0JPLG9CQUFvQjtnQkFDMUNHLGFBQWFILGtCQUFrQkwsaUJBQWlCLENBQUNNLFFBQVFHLFdBQVc7WUFDeEUsT0FDSztnQkFDREQsYUFBYSxJQUFJRSxRQUFRLENBQUNDLFNBQVNDO29CQUMvQlAsa0JBQWtCUSxrQkFBa0IsQ0FBQ1AsUUFBUUcsV0FBVyxFQUFFLENBQUNLLEtBQUtDO3dCQUM1RCxJQUFJRCxLQUFLOzRCQUNMRixPQUFPRTs0QkFDUDt3QkFDSjt3QkFDQSxJQUFJLENBQUNDLFNBQVM7NEJBQ1ZILE9BQU8sSUFBSUksTUFBTTs0QkFDakI7d0JBQ0o7d0JBQ0FMLFFBQVFJO29CQUNaO2dCQUNKO1lBQ0o7WUFDQVAsV0FBV1MsSUFBSSxDQUFDRixDQUFBQTtnQkFDWixNQUFNRyxXQUFXLElBQUl0QixXQUFXdUIsUUFBUTtnQkFDeEMsS0FBSyxNQUFNQyxPQUFPN0IsT0FBTzhCLElBQUksQ0FBQ04sU0FBVTtvQkFDcENHLFNBQVNJLEdBQUcsQ0FBQ0YsS0FBS0wsT0FBTyxDQUFDSyxJQUFJO2dCQUNsQztnQkFDQWIsU0FBUyxNQUFNVztZQUNuQixHQUFHSixDQUFBQTtnQkFDQ1AsU0FBU087WUFDYjtRQUNKO0lBQ0o7SUFDQSxPQUFPUyxjQUFjO1FBQ2pCLE9BQU8sSUFBSUM7SUFDZjtBQUNKO0FBQ0EvQix1QkFBdUIsR0FBR0U7QUFDMUIsTUFBTThCLGdDQUFnQzlCO0lBQ2xDK0IsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsS0FBSztRQUNMLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE1BQU1DLGlCQUFpQnRCLE9BQU8sRUFBRTtRQUM1QixNQUFNdUIsT0FBTyxJQUFJakMsV0FBV3VCLFFBQVE7UUFDcEMsTUFBTVcsWUFBWSxNQUFNcEIsUUFBUXFCLEdBQUcsQ0FBQyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ssR0FBRyxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLTCxnQkFBZ0IsQ0FBQ3RCO1FBQ2pGLEtBQUssTUFBTTRCLE9BQU9KLFVBQVc7WUFDekJELEtBQUtNLEtBQUssQ0FBQ0Q7UUFDZjtRQUNBLE9BQU9MO0lBQ1g7SUFDQU8sUUFBUUMsS0FBSyxFQUFFO1FBQ1gsT0FBTyxJQUFJWix3QkFBd0IsSUFBSSxDQUFDRSxLQUFLLENBQUNXLE1BQU0sQ0FBQztZQUFDRDtTQUFNO0lBQ2hFO0lBQ0FFLFFBQVFGLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLQSxPQUFPO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUlBLGlCQUFpQloseUJBQXlCO1lBQzFDLE9BQU8sSUFBSSxDQUFDRSxLQUFLLENBQUNhLEtBQUssQ0FBQyxDQUFDOUMsT0FBTytDLFFBQVUvQyxNQUFNNkMsT0FBTyxDQUFDRixNQUFNVixLQUFLLENBQUNjLE1BQU07UUFDOUUsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSxNQUFNdEMsOEJBQThCUjtJQUNoQytCLFlBQVl4QixpQkFBaUIsQ0FBRTtRQUMzQixLQUFLO1FBQ0wsSUFBSSxDQUFDQSxpQkFBaUIsR0FBR0E7SUFDN0I7SUFDQTBCLGlCQUFpQnRCLE9BQU8sRUFBRTtRQUN0QixPQUFPLElBQUlJLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekIsSUFBSSxDQUFDVixpQkFBaUIsQ0FBQ0ksU0FBUyxDQUFDUSxLQUFLSTtnQkFDbEMsSUFBSUEsYUFBYXdCLFdBQVc7b0JBQ3hCL0IsUUFBUU87Z0JBQ1osT0FDSztvQkFDRE4sT0FBT0U7Z0JBQ1g7WUFDSjtRQUNKO0lBQ0o7SUFDQXNCLFFBQVFDLEtBQUssRUFBRTtRQUNYLE9BQU8sSUFBSVosd0JBQXdCO1lBQUMsSUFBSTtZQUFFWTtTQUFNO0lBQ3BEO0lBQ0FFLFFBQVFGLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLQSxPQUFPO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUlBLGlCQUFpQmxDLHVCQUF1QjtZQUN4QyxPQUFPLElBQUksQ0FBQ0QsaUJBQWlCLEtBQUttQyxNQUFNbkMsaUJBQWlCO1FBQzdELE9BQ0s7WUFDRCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0EsTUFBTXNCLDZCQUE2QjdCO0lBQy9CaUMsaUJBQWlCdEIsT0FBTyxFQUFFO1FBQ3RCLE9BQU9JLFFBQVFDLE9BQU8sQ0FBQyxJQUFJZixXQUFXdUIsUUFBUTtJQUNsRDtJQUNBaUIsUUFBUUMsS0FBSyxFQUFFO1FBQ1gsT0FBT0E7SUFDWDtJQUNBRSxRQUFRRixLQUFLLEVBQUU7UUFDWCxPQUFPQSxpQkFBaUJiO0lBQzVCO0FBQ0osRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLWNyZWRlbnRpYWxzLmpzPzI4YjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuZnVuY3Rpb24gaXNDdXJyZW50T2F1dGgyQ2xpZW50KGNsaWVudCkge1xuICAgIHJldHVybiAoJ2dldFJlcXVlc3RIZWFkZXJzJyBpbiBjbGllbnQgJiZcbiAgICAgICAgdHlwZW9mIGNsaWVudC5nZXRSZXF1ZXN0SGVhZGVycyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZ2VuZXJpYyBtZXRob2Qgb2YgYWRkaW5nIGF1dGhlbnRpY2F0aW9uLXJlbGF0ZWRcbiAqIG1ldGFkYXRhIG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMuXG4gKi9cbmNsYXNzIENhbGxDcmVkZW50aWFscyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0IGZyb20gYSBnaXZlbiBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlc1xuICAgICAqIE1ldGFkYXRhIG9iamVjdHMuXG4gICAgICogQHBhcmFtIG1ldGFkYXRhR2VuZXJhdG9yIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgc2V0IG9mIG9wdGlvbnMsIGFuZFxuICAgICAqIGdlbmVyYXRlcyBhIE1ldGFkYXRhIG9iamVjdCBiYXNlZCBvbiB0aGVzZSBvcHRpb25zLCB3aGljaCBpcyBwYXNzZWQgYmFja1xuICAgICAqIHRvIHRoZSBjYWxsZXIgdmlhIGEgc3VwcGxpZWQgKGVyciwgbWV0YWRhdGEpIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IobWV0YWRhdGFHZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVDYWxsQ3JlZGVudGlhbHMobWV0YWRhdGFHZW5lcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBnUlBDIGNyZWRlbnRpYWwgZnJvbSBhIEdvb2dsZSBjcmVkZW50aWFsIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gZ29vZ2xlQ3JlZGVudGlhbHMgVGhlIGF1dGhlbnRpY2F0aW9uIGNsaWVudCB0byB1c2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENhbGxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsKGdvb2dsZUNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHJldHVybiBDYWxsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yKChvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgbGV0IGdldEhlYWRlcnM7XG4gICAgICAgICAgICBpZiAoaXNDdXJyZW50T2F1dGgyQ2xpZW50KGdvb2dsZUNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgIGdldEhlYWRlcnMgPSBnb29nbGVDcmVkZW50aWFscy5nZXRSZXF1ZXN0SGVhZGVycyhvcHRpb25zLnNlcnZpY2VfdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldEhlYWRlcnMgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZUNyZWRlbnRpYWxzLmdldFJlcXVlc3RNZXRhZGF0YShvcHRpb25zLnNlcnZpY2VfdXJsLCAoZXJyLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignSGVhZGVycyBub3Qgc2V0IGJ5IG1ldGFkYXRhIHBsdWdpbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldEhlYWRlcnMudGhlbihoZWFkZXJzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuYWRkKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlDYWxsQ3JlZGVudGlhbHMoKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IENhbGxDcmVkZW50aWFscztcbmNsYXNzIENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzIGV4dGVuZHMgQ2FsbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjcmVkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNyZWRzID0gY3JlZHM7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xuICAgICAgICBjb25zdCBiYXNlID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jcmVkcy5tYXAoY3JlZCA9PiBjcmVkLmdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykpKTtcbiAgICAgICAgZm9yIChjb25zdCBnZW4gb2YgZ2VuZXJhdGVkKSB7XG4gICAgICAgICAgICBiYXNlLm1lcmdlKGdlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENhbGxDcmVkZW50aWFscyh0aGlzLmNyZWRzLmNvbmNhdChbb3RoZXJdKSk7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NlZENhbGxDcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlZHMuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUuX2VxdWFscyhvdGhlci5jcmVkc1tpbmRleF0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNpbmdsZUNhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IobWV0YWRhdGFHZW5lcmF0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9IG1ldGFkYXRhR2VuZXJhdG9yO1xuICAgIH1cbiAgICBnZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFHZW5lcmF0b3Iob3B0aW9ucywgKGVyciwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcG9zZShvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKFt0aGlzLCBvdGhlcl0pO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgU2luZ2xlQ2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9PT0gb3RoZXIubWV0YWRhdGFHZW5lcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBFbXB0eUNhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSk7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEVtcHR5Q2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2FsbENyZWRlbnRpYWxzIiwibWV0YWRhdGFfMSIsInJlcXVpcmUiLCJpc0N1cnJlbnRPYXV0aDJDbGllbnQiLCJjbGllbnQiLCJnZXRSZXF1ZXN0SGVhZGVycyIsImNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvciIsIm1ldGFkYXRhR2VuZXJhdG9yIiwiU2luZ2xlQ2FsbENyZWRlbnRpYWxzIiwiY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWwiLCJnb29nbGVDcmVkZW50aWFscyIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImdldEhlYWRlcnMiLCJzZXJ2aWNlX3VybCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ2V0UmVxdWVzdE1ldGFkYXRhIiwiZXJyIiwiaGVhZGVycyIsIkVycm9yIiwidGhlbiIsIm1ldGFkYXRhIiwiTWV0YWRhdGEiLCJrZXkiLCJrZXlzIiwiYWRkIiwiY3JlYXRlRW1wdHkiLCJFbXB0eUNhbGxDcmVkZW50aWFscyIsIkNvbXBvc2VkQ2FsbENyZWRlbnRpYWxzIiwiY29uc3RydWN0b3IiLCJjcmVkcyIsImdlbmVyYXRlTWV0YWRhdGEiLCJiYXNlIiwiZ2VuZXJhdGVkIiwiYWxsIiwibWFwIiwiY3JlZCIsImdlbiIsIm1lcmdlIiwiY29tcG9zZSIsIm90aGVyIiwiY29uY2F0IiwiX2VxdWFscyIsImV2ZXJ5IiwiaW5kZXgiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-interface.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\nfunction isInterceptingListener(listener) {\n    return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;\n}\nexports.isInterceptingListener = isInterceptingListener;\nclass InterceptingListenerImpl {\n    constructor(listener, nextListener){\n        this.listener = listener;\n        this.nextListener = nextListener;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.processingMessage = false;\n        this.pendingStatus = null;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextListener.onReceiveStatus(this.pendingStatus);\n        }\n    }\n    onReceiveMetadata(metadata) {\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, (metadata)=>{\n            this.processingMetadata = false;\n            this.nextListener.onReceiveMetadata(metadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onReceiveMessage(message) {\n        /* If this listener processes messages asynchronously, the last message may\n         * be reordered with respect to the status */ this.processingMessage = true;\n        this.listener.onReceiveMessage(message, (msg)=>{\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            } else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingStatus();\n            }\n        });\n    }\n    onReceiveStatus(status) {\n        this.listener.onReceiveStatus(status, (processedStatus)=>{\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = processedStatus;\n            } else {\n                this.nextListener.onReceiveStatus(processedStatus);\n            }\n        });\n    }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl; //# sourceMappingURL=call-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdDQUFnQyxHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQ3pFLFNBQVNHLHVCQUF1QkMsUUFBUTtJQUNwQyxPQUFRQSxTQUFTQyxpQkFBaUIsS0FBS0MsYUFDbkNGLFNBQVNDLGlCQUFpQixDQUFDRSxNQUFNLEtBQUs7QUFDOUM7QUFDQVAsOEJBQThCLEdBQUdHO0FBQ2pDLE1BQU1EO0lBQ0ZNLFlBQVlKLFFBQVEsRUFBRUssWUFBWSxDQUFFO1FBQ2hDLElBQUksQ0FBQ0wsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNLLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDekI7SUFDQUMsd0JBQXdCO1FBQ3BCLElBQUksSUFBSSxDQUFDSCxpQkFBaUIsRUFBRTtZQUN4QixJQUFJLENBQUNGLFlBQVksQ0FBQ00sZ0JBQWdCLENBQUMsSUFBSSxDQUFDQyxjQUFjO1lBQ3RELElBQUksQ0FBQ0EsY0FBYyxHQUFHO1lBQ3RCLElBQUksQ0FBQ0wsaUJBQWlCLEdBQUc7UUFDN0I7SUFDSjtJQUNBTSx1QkFBdUI7UUFDbkIsSUFBSSxJQUFJLENBQUNKLGFBQWEsRUFBRTtZQUNwQixJQUFJLENBQUNKLFlBQVksQ0FBQ1MsZUFBZSxDQUFDLElBQUksQ0FBQ0wsYUFBYTtRQUN4RDtJQUNKO0lBQ0FSLGtCQUFrQmMsUUFBUSxFQUFFO1FBQ3hCLElBQUksQ0FBQ1Qsa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDTixRQUFRLENBQUNDLGlCQUFpQixDQUFDYyxVQUFVQSxDQUFBQTtZQUN0QyxJQUFJLENBQUNULGtCQUFrQixHQUFHO1lBQzFCLElBQUksQ0FBQ0QsWUFBWSxDQUFDSixpQkFBaUIsQ0FBQ2M7WUFDcEMsSUFBSSxDQUFDTCxxQkFBcUI7WUFDMUIsSUFBSSxDQUFDRyxvQkFBb0I7UUFDN0I7SUFDSjtJQUNBLDhEQUE4RDtJQUM5REYsaUJBQWlCSyxPQUFPLEVBQUU7UUFDdEI7bURBQzJDLEdBQzNDLElBQUksQ0FBQ1IsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDUixRQUFRLENBQUNXLGdCQUFnQixDQUFDSyxTQUFTQyxDQUFBQTtZQUNwQyxJQUFJLENBQUNULGlCQUFpQixHQUFHO1lBQ3pCLElBQUksSUFBSSxDQUFDRixrQkFBa0IsRUFBRTtnQkFDekIsSUFBSSxDQUFDTSxjQUFjLEdBQUdLO2dCQUN0QixJQUFJLENBQUNWLGlCQUFpQixHQUFHO1lBQzdCLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDRixZQUFZLENBQUNNLGdCQUFnQixDQUFDTTtnQkFDbkMsSUFBSSxDQUFDSixvQkFBb0I7WUFDN0I7UUFDSjtJQUNKO0lBQ0FDLGdCQUFnQkksTUFBTSxFQUFFO1FBQ3BCLElBQUksQ0FBQ2xCLFFBQVEsQ0FBQ2MsZUFBZSxDQUFDSSxRQUFRQyxDQUFBQTtZQUNsQyxJQUFJLElBQUksQ0FBQ2Isa0JBQWtCLElBQUksSUFBSSxDQUFDRSxpQkFBaUIsRUFBRTtnQkFDbkQsSUFBSSxDQUFDQyxhQUFhLEdBQUdVO1lBQ3pCLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDZCxZQUFZLENBQUNTLGVBQWUsQ0FBQ0s7WUFDdEM7UUFDSjtJQUNKO0FBQ0o7QUFDQXZCLGdDQUFnQyxHQUFHRSwwQkFDbkMsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1pbnRlcmZhY2UuanM/OGIzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwgPSBleHBvcnRzLmlzSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBpc0ludGVyY2VwdGluZ0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIChsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhLmxlbmd0aCA9PT0gMSk7XG59XG5leHBvcnRzLmlzSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSBpc0ludGVyY2VwdGluZ0xpc3RlbmVyO1xuY2xhc3MgSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihsaXN0ZW5lciwgbmV4dExpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIgPSBuZXh0TGlzdGVuZXI7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBudWxsO1xuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ01lc3NhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1BlbmRpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKHRoaXMucGVuZGluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdTdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyh0aGlzLnBlbmRpbmdTdGF0dXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSwgbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBJZiB0aGlzIGxpc3RlbmVyIHByb2Nlc3NlcyBtZXNzYWdlcyBhc3luY2hyb25vdXNseSwgdGhlIGxhc3QgbWVzc2FnZSBtYXlcbiAgICAgICAgICogYmUgcmVvcmRlcmVkIHdpdGggcmVzcGVjdCB0byB0aGUgc3RhdHVzICovXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSwgbXNnID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N0YXR1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMsIHByb2Nlc3NlZFN0YXR1cyA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgfHwgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IHByb2Nlc3NlZFN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyhwcm9jZXNzZWRTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCA9IEludGVyY2VwdGluZ0xpc3RlbmVySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtaW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCIsImlzSW50ZXJjZXB0aW5nTGlzdGVuZXIiLCJsaXN0ZW5lciIsIm9uUmVjZWl2ZU1ldGFkYXRhIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiY29uc3RydWN0b3IiLCJuZXh0TGlzdGVuZXIiLCJwcm9jZXNzaW5nTWV0YWRhdGEiLCJoYXNQZW5kaW5nTWVzc2FnZSIsInByb2Nlc3NpbmdNZXNzYWdlIiwicGVuZGluZ1N0YXR1cyIsInByb2Nlc3NQZW5kaW5nTWVzc2FnZSIsIm9uUmVjZWl2ZU1lc3NhZ2UiLCJwZW5kaW5nTWVzc2FnZSIsInByb2Nlc3NQZW5kaW5nU3RhdHVzIiwib25SZWNlaXZlU3RhdHVzIiwibWV0YWRhdGEiLCJtZXNzYWdlIiwibXNnIiwic3RhdHVzIiwicHJvY2Vzc2VkU3RhdHVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-number.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getNextCallNumber = void 0;\nlet nextCallNumber = 0;\nfunction getNextCallNumber() {\n    return nextCallNumber++;\n}\nexports.getNextCallNumber = getNextCallNumber; //# sourceMappingURL=call-number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHlCQUF5QixHQUFHLEtBQUs7QUFDakMsSUFBSUcsaUJBQWlCO0FBQ3JCLFNBQVNEO0lBQ0wsT0FBT0M7QUFDWDtBQUNBSCx5QkFBeUIsR0FBR0UsbUJBQzVCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtbnVtYmVyLmpzP2QzZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0TmV4dENhbGxOdW1iZXIgPSB2b2lkIDA7XG5sZXQgbmV4dENhbGxOdW1iZXIgPSAwO1xuZnVuY3Rpb24gZ2V0TmV4dENhbGxOdW1iZXIoKSB7XG4gICAgcmV0dXJuIG5leHRDYWxsTnVtYmVyKys7XG59XG5leHBvcnRzLmdldE5leHRDYWxsTnVtYmVyID0gZ2V0TmV4dENhbGxOdW1iZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLW51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXROZXh0Q2FsbE51bWJlciIsIm5leHRDYWxsTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */ function callErrorFromStatus(status, callerStack) {\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n    const error = new Error(message);\n    const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n    return Object.assign(new Error(message), status, {\n        stack\n    });\n}\nexports.callErrorFromStatus = callErrorFromStatus;\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n    constructor(){\n        super();\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nclass ClientReadableStreamImpl extends stream_1.Readable {\n    constructor(deserialize){\n        super({\n            objectMode: true\n        });\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nclass ClientWritableStreamImpl extends stream_1.Writable {\n    constructor(serialize){\n        super({\n            objectMode: true\n        });\n        this.serialize = serialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n    constructor(serialize, deserialize){\n        super({\n            objectMode: true\n        });\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl; //# sourceMappingURL=call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsOEJBQThCLEdBQUdBLGdDQUFnQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsMkJBQTJCLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDeEssTUFBTU8sV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsOEVBQWE7QUFDekM7Ozs7O0NBS0MsR0FDRCxTQUFTRixvQkFBb0JLLE1BQU0sRUFBRUMsV0FBVztJQUM1QyxNQUFNQyxVQUFVLENBQUMsRUFBRUYsT0FBT0csSUFBSSxDQUFDLENBQUMsRUFBRUosWUFBWUssTUFBTSxDQUFDSixPQUFPRyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUVILE9BQU9LLE9BQU8sQ0FBQyxDQUFDO0lBQ3RGLE1BQU1DLFFBQVEsSUFBSUMsTUFBTUw7SUFDeEIsTUFBTU0sUUFBUSxDQUFDLEVBQUVGLE1BQU1FLEtBQUssQ0FBQyxlQUFlLEVBQUVQLFlBQVksQ0FBQztJQUMzRCxPQUFPZCxPQUFPc0IsTUFBTSxDQUFDLElBQUlGLE1BQU1MLFVBQVVGLFFBQVE7UUFBRVE7SUFBTTtBQUM3RDtBQUNBbkIsMkJBQTJCLEdBQUdNO0FBQzlCLE1BQU1ELDRCQUE0QkUsU0FBU2MsWUFBWTtJQUNuREMsYUFBYztRQUNWLEtBQUs7SUFDVDtJQUNBQyxTQUFTO1FBQ0wsSUFBSUM7UUFDSEEsQ0FBQUEsS0FBSyxJQUFJLENBQUNDLElBQUksTUFBTSxRQUFRRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdFLGdCQUFnQixDQUFDaEIsWUFBWUssTUFBTSxDQUFDWSxTQUFTLEVBQUU7SUFDNUc7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IndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLmpzP2ZlMzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCA9IGV4cG9ydHMuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLkNsaWVudFVuYXJ5Q2FsbEltcGwgPSBleHBvcnRzLmNhbGxFcnJvckZyb21TdGF0dXMgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogQ29uc3RydWN0IGEgU2VydmljZUVycm9yIGZyb20gYSBTdGF0dXNPYmplY3QuIFRoaXMgZnVuY3Rpb24gZXhpc3RzIHByaW1hcmlseVxuICogYXMgYW4gYXR0ZW1wdCB0byBtYWtlIHRoZSBlcnJvciBzdGFjayB0cmFjZSBjbGVhcmx5IGNvbW11bmljYXRlIHRoYXQgdGhlXG4gKiBlcnJvciBpcyBub3QgbmVjZXNzYXJpbHkgYSBwcm9ibGVtIGluIGdSUEMgaXRzZWxmLlxuICogQHBhcmFtIHN0YXR1c1xuICovXG5mdW5jdGlvbiBjYWxsRXJyb3JGcm9tU3RhdHVzKHN0YXR1cywgY2FsbGVyU3RhY2spIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYCR7c3RhdHVzLmNvZGV9ICR7Y29uc3RhbnRzXzEuU3RhdHVzW3N0YXR1cy5jb2RlXX06ICR7c3RhdHVzLmRldGFpbHN9YDtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBjb25zdCBzdGFjayA9IGAke2Vycm9yLnN0YWNrfVxcbmZvciBjYWxsIGF0XFxuJHtjYWxsZXJTdGFja31gO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihtZXNzYWdlKSwgc3RhdHVzLCB7IHN0YWNrIH0pO1xufVxuZXhwb3J0cy5jYWxsRXJyb3JGcm9tU3RhdHVzID0gY2FsbEVycm9yRnJvbVN0YXR1cztcbmNsYXNzIENsaWVudFVuYXJ5Q2FsbEltcGwgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRVbmFyeUNhbGxJbXBsID0gQ2xpZW50VW5hcnlDYWxsSW1wbDtcbmNsYXNzIENsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLlJlYWRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihkZXNlcmlhbGl6ZSkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0UmVhZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsID0gQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuV3JpdGFibGUge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZSkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBOdW1iZXIoZW5jb2RpbmcpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihmbGFncykpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGNodW5rKTtcbiAgICB9XG4gICAgX2ZpbmFsKGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFsZkNsb3NlKCk7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRXcml0YWJsZVN0cmVhbUltcGwgPSBDbGllbnRXcml0YWJsZVN0cmVhbUltcGw7XG5jbGFzcyBDbGllbnREdXBsZXhTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemUsIGRlc2VyaWFsaXplKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBjYWxsYmFjazogY2IsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZsYWdzID0gTnVtYmVyKGVuY29kaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZmxhZ3MpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBjaHVuayk7XG4gICAgfVxuICAgIF9maW5hbChjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbGZDbG9zZSgpO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCA9IENsaWVudER1cGxleFN0cmVhbUltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNsaWVudER1cGxleFN0cmVhbUltcGwiLCJDbGllbnRXcml0YWJsZVN0cmVhbUltcGwiLCJDbGllbnRSZWFkYWJsZVN0cmVhbUltcGwiLCJDbGllbnRVbmFyeUNhbGxJbXBsIiwiY2FsbEVycm9yRnJvbVN0YXR1cyIsImV2ZW50c18xIiwicmVxdWlyZSIsInN0cmVhbV8xIiwiY29uc3RhbnRzXzEiLCJzdGF0dXMiLCJjYWxsZXJTdGFjayIsIm1lc3NhZ2UiLCJjb2RlIiwiU3RhdHVzIiwiZGV0YWlscyIsImVycm9yIiwiRXJyb3IiLCJzdGFjayIsImFzc2lnbiIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwiY2FuY2VsIiwiX2EiLCJjYWxsIiwiY2FuY2VsV2l0aFN0YXR1cyIsIkNBTkNFTExFRCIsImdldFBlZXIiLCJfYiIsIlJlYWRhYmxlIiwiZGVzZXJpYWxpemUiLCJvYmplY3RNb2RlIiwiX3JlYWQiLCJfc2l6ZSIsInN0YXJ0UmVhZCIsIldyaXRhYmxlIiwic2VyaWFsaXplIiwiX3dyaXRlIiwiY2h1bmsiLCJlbmNvZGluZyIsImNiIiwiY29udGV4dCIsImNhbGxiYWNrIiwiZmxhZ3MiLCJOdW1iZXIiLCJpc05hTiIsInNlbmRNZXNzYWdlV2l0aENvbnRleHQiLCJfZmluYWwiLCJoYWxmQ2xvc2UiLCJEdXBsZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChannelCredentials = void 0;\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n    if (obj && !(obj instanceof Buffer)) {\n        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n    }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */ class ChannelCredentials {\n    constructor(callCredentials){\n        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n    }\n    /**\n     * Gets the set of per-call credentials associated with this instance.\n     */ _getCallCredentials() {\n        return this.callCredentials;\n    }\n    /**\n     * Return a new ChannelCredentials instance with a given set of credentials.\n     * The resulting instance can be used to construct a Channel that communicates\n     * over TLS.\n     * @param rootCerts The root certificate data.\n     * @param privateKey The client certificate private key, if available.\n     * @param certChain The client certificate key chain, if available.\n     * @param verifyOptions Additional options to modify certificate verification\n     */ static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n        var _a;\n        verifyIsBufferOrNull(rootCerts, \"Root certificate\");\n        verifyIsBufferOrNull(privateKey, \"Private key\");\n        verifyIsBufferOrNull(certChain, \"Certificate chain\");\n        if (privateKey && !certChain) {\n            throw new Error(\"Private key must be given with accompanying certificate chain\");\n        }\n        if (!privateKey && certChain) {\n            throw new Error(\"Certificate chain must be given with accompanying private key\");\n        }\n        const secureContext = (0, tls_1.createSecureContext)({\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\n            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        });\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with credentials created using\n     * the provided secureContext. The resulting instances can be used to\n     * construct a Channel that communicates over TLS. gRPC will not override\n     * anything in the provided secureContext, so the environment variables\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n     * not be applied.\n     * @param secureContext The return value of tls.createSecureContext()\n     * @param verifyOptions Additional options to modify certificate verification\n     */ static createFromSecureContext(secureContext, verifyOptions) {\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with no credentials.\n     */ static createInsecure() {\n        return new InsecureChannelCredentialsImpl();\n    }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(callCredentials){\n        super(callCredentials);\n    }\n    compose(callCredentials) {\n        throw new Error(\"Cannot compose insecure credentials\");\n    }\n    _getConnectionOptions() {\n        return null;\n    }\n    _isSecure() {\n        return false;\n    }\n    _equals(other) {\n        return other instanceof InsecureChannelCredentialsImpl;\n    }\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(secureContext, verifyOptions){\n        super();\n        this.secureContext = secureContext;\n        this.verifyOptions = verifyOptions;\n        this.connectionOptions = {\n            secureContext\n        };\n        // Node asserts that this option is a function, so we cannot pass undefined\n        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\n            this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n        }\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        // Copy to prevent callers from mutating this.connectionOptions\n        return Object.assign({}, this.connectionOptions);\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SecureChannelCredentialsImpl) {\n            return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;\n        } else {\n            return false;\n        }\n    }\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n    constructor(channelCredentials, callCreds){\n        super(callCreds);\n        this.channelCredentials = channelCredentials;\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        return this.channelCredentials._getConnectionOptions();\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedChannelCredentialsImpl) {\n            return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);\n        } else {\n            return false;\n        }\n    }\n} //# sourceMappingURL=channel-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDBCQUEwQixHQUFHLEtBQUs7QUFDbEMsTUFBTUcsUUFBUUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUMscUJBQXFCRCxtQkFBT0EsQ0FBQyw0RkFBb0I7QUFDdkQsTUFBTUUsZ0JBQWdCRixtQkFBT0EsQ0FBQyxrRkFBZTtBQUM3Qyw4REFBOEQ7QUFDOUQsU0FBU0cscUJBQXFCQyxHQUFHLEVBQUVDLFlBQVk7SUFDM0MsSUFBSUQsT0FBTyxDQUFFQSxDQUFBQSxlQUFlRSxNQUFLLEdBQUk7UUFDakMsTUFBTSxJQUFJQyxVQUFVLENBQUMsRUFBRUYsYUFBYSxnQ0FBZ0MsQ0FBQztJQUN6RTtBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU1QO0lBQ0ZVLFlBQVlDLGVBQWUsQ0FBRTtRQUN6QixJQUFJLENBQUNBLGVBQWUsR0FBR0EsbUJBQW1CUixtQkFBbUJTLGVBQWUsQ0FBQ0MsV0FBVztJQUM1RjtJQUNBOztLQUVDLEdBQ0RDLHNCQUFzQjtRQUNsQixPQUFPLElBQUksQ0FBQ0gsZUFBZTtJQUMvQjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsT0FBT0ksVUFBVUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsYUFBYSxFQUFFO1FBQzlELElBQUlDO1FBQ0pmLHFCQUFxQlcsV0FBVztRQUNoQ1gscUJBQXFCWSxZQUFZO1FBQ2pDWixxQkFBcUJhLFdBQVc7UUFDaEMsSUFBSUQsY0FBYyxDQUFDQyxXQUFXO1lBQzFCLE1BQU0sSUFBSUcsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ0osY0FBY0MsV0FBVztZQUMxQixNQUFNLElBQUlHLE1BQU07UUFDcEI7UUFDQSxNQUFN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Z0MsK0JBQStCLElBQUksQ0FBQ0Usa0JBQWtCLEVBQUVIO0lBQ3ZFO0lBQ0FOLHdCQUF3QjtRQUNwQixPQUFPLElBQUksQ0FBQ1Msa0JBQWtCLENBQUNULHFCQUFxQjtJQUN4RDtJQUNBQyxZQUFZO1FBQ1IsT0FBTztJQUNYO0lBQ0FDLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLQSxPQUFPO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUlBLGlCQUFpQkksZ0NBQWdDO1lBQ2pELE9BQVEsSUFBSSxDQUFDRSxrQkFBa0IsQ0FBQ1AsT0FBTyxDQUFDQyxNQUFNTSxrQkFBa0IsS0FDNUQsSUFBSSxDQUFDbEMsZUFBZSxDQUFDMkIsT0FBTyxDQUFDQyxNQUFNNUIsZUFBZTtRQUMxRCxPQUNLO1lBQ0QsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWwtY3JlZGVudGlhbHMuanM/OGU3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGFubmVsQ3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCB0bHNfMSA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgdGxzX2hlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3Rscy1oZWxwZXJzXCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHZlcmlmeUlzQnVmZmVyT3JOdWxsKG9iaiwgZnJpZW5kbHlOYW1lKSB7XG4gICAgaWYgKG9iaiAmJiAhKG9iaiBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmcmllbmRseU5hbWV9LCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIEJ1ZmZlci5gKTtcbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyBjcmVkZW50aWFscyBmb3IgY29tbXVuaWNhdGluZyBvdmVyIGEgY2hhbm5lbCwgYXMgd2VsbFxuICogYXMgYSBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHMsIHdoaWNoIGFyZSBhcHBsaWVkIHRvIGV2ZXJ5IG1ldGhvZCBjYWxsIG1hZGVcbiAqIG92ZXIgYSBjaGFubmVsIGluaXRpYWxpemVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqL1xuY2xhc3MgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMgPSBjYWxsQ3JlZGVudGlhbHMgfHwgY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgX2dldENhbGxDcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggYSBnaXZlbiBzZXQgb2YgY3JlZGVudGlhbHMuXG4gICAgICogVGhlIHJlc3VsdGluZyBpbnN0YW5jZSBjYW4gYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBDaGFubmVsIHRoYXQgY29tbXVuaWNhdGVzXG4gICAgICogb3ZlciBUTFMuXG4gICAgICogQHBhcmFtIHJvb3RDZXJ0cyBUaGUgcm9vdCBjZXJ0aWZpY2F0ZSBkYXRhLlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IFRoZSBjbGllbnQgY2VydGlmaWNhdGUgcHJpdmF0ZSBrZXksIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0gY2VydENoYWluIFRoZSBjbGllbnQgY2VydGlmaWNhdGUga2V5IGNoYWluLCBpZiBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIHZlcmlmeU9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIG1vZGlmeSBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3NsKHJvb3RDZXJ0cywgcHJpdmF0ZUtleSwgY2VydENoYWluLCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwocm9vdENlcnRzLCAnUm9vdCBjZXJ0aWZpY2F0ZScpO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChwcml2YXRlS2V5LCAnUHJpdmF0ZSBrZXknKTtcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwoY2VydENoYWluLCAnQ2VydGlmaWNhdGUgY2hhaW4nKTtcbiAgICAgICAgaWYgKHByaXZhdGVLZXkgJiYgIWNlcnRDaGFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcml2YXRlIGtleSBtdXN0IGJlIGdpdmVuIHdpdGggYWNjb21wYW55aW5nIGNlcnRpZmljYXRlIGNoYWluJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcml2YXRlS2V5ICYmIGNlcnRDaGFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDZXJ0aWZpY2F0ZSBjaGFpbiBtdXN0IGJlIGdpdmVuIHdpdGggYWNjb21wYW55aW5nIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VjdXJlQ29udGV4dCA9ICgwLCB0bHNfMS5jcmVhdGVTZWN1cmVDb250ZXh0KSh7XG4gICAgICAgICAgICBjYTogKF9hID0gcm9vdENlcnRzICE9PSBudWxsICYmIHJvb3RDZXJ0cyAhPT0gdm9pZCAwID8gcm9vdENlcnRzIDogKDAsIHRsc19oZWxwZXJzXzEuZ2V0RGVmYXVsdFJvb3RzRGF0YSkoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAga2V5OiBwcml2YXRlS2V5ICE9PSBudWxsICYmIHByaXZhdGVLZXkgIT09IHZvaWQgMCA/IHByaXZhdGVLZXkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjZXJ0OiBjZXJ0Q2hhaW4gIT09IG51bGwgJiYgY2VydENoYWluICE9PSB2b2lkIDAgPyBjZXJ0Q2hhaW4gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaXBoZXJzOiB0bHNfaGVscGVyc18xLkNJUEhFUl9TVUlURVMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucyAhPT0gbnVsbCAmJiB2ZXJpZnlPcHRpb25zICE9PSB2b2lkIDAgPyB2ZXJpZnlPcHRpb25zIDoge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggY3JlZGVudGlhbHMgY3JlYXRlZCB1c2luZ1xuICAgICAqIHRoZSBwcm92aWRlZCBzZWN1cmVDb250ZXh0LiBUaGUgcmVzdWx0aW5nIGluc3RhbmNlcyBjYW4gYmUgdXNlZCB0b1xuICAgICAqIGNvbnN0cnVjdCBhIENoYW5uZWwgdGhhdCBjb21tdW5pY2F0ZXMgb3ZlciBUTFMuIGdSUEMgd2lsbCBub3Qgb3ZlcnJpZGVcbiAgICAgKiBhbnl0aGluZyBpbiB0aGUgcHJvdmlkZWQgc2VjdXJlQ29udGV4dCwgc28gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAqIEdSUENfU1NMX0NJUEhFUl9TVUlURVMgYW5kIEdSUENfREVGQVVMVF9TU0xfUk9PVFNfRklMRV9QQVRIIHdpbGxcbiAgICAgKiBub3QgYmUgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0gc2VjdXJlQ29udGV4dCBUaGUgcmV0dXJuIHZhbHVlIG9mIHRscy5jcmVhdGVTZWN1cmVDb250ZXh0KClcbiAgICAgKiBAcGFyYW0gdmVyaWZ5T3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gbW9kaWZ5IGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tU2VjdXJlQ29udGV4dChzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbChzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zICE9PSBudWxsICYmIHZlcmlmeU9wdGlvbnMgIT09IHZvaWQgMCA/IHZlcmlmeU9wdGlvbnMgOiB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBDaGFubmVsQ3JlZGVudGlhbHMgaW5zdGFuY2Ugd2l0aCBubyBjcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5zZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsQ3JlZGVudGlhbHMgPSBDaGFubmVsQ3JlZGVudGlhbHM7XG5jbGFzcyBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwgZXh0ZW5kcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICBzdXBlcihjYWxsQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBjb21wb3NlKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wb3NlIGluc2VjdXJlIGNyZWRlbnRpYWxzJyk7XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbDtcbiAgICB9XG59XG5jbGFzcyBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VjdXJlQ29udGV4dCA9IHNlY3VyZUNvbnRleHQ7XG4gICAgICAgIHRoaXMudmVyaWZ5T3B0aW9ucyA9IHZlcmlmeU9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzZWN1cmVDb250ZXh0LFxuICAgICAgICB9O1xuICAgICAgICAvLyBOb2RlIGFzc2VydHMgdGhhdCB0aGlzIG9wdGlvbiBpcyBhIGZ1bmN0aW9uLCBzbyB3ZSBjYW5ub3QgcGFzcyB1bmRlZmluZWRcbiAgICAgICAgaWYgKHZlcmlmeU9wdGlvbnMgPT09IG51bGwgfHwgdmVyaWZ5T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPVxuICAgICAgICAgICAgICAgIHZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb3NlKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCBjb21iaW5lZENhbGxDcmVkZW50aWFscyA9IHRoaXMuY2FsbENyZWRlbnRpYWxzLmNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwodGhpcywgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgIC8vIENvcHkgdG8gcHJldmVudCBjYWxsZXJzIGZyb20gbXV0YXRpbmcgdGhpcy5jb25uZWN0aW9uT3B0aW9uc1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuc2VjdXJlQ29udGV4dCA9PT0gb3RoZXIuc2VjdXJlQ29udGV4dCAmJlxuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID09PVxuICAgICAgICAgICAgICAgICAgICBvdGhlci52ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ3JlZGVudGlhbHMsIGNhbGxDcmVkcykge1xuICAgICAgICBzdXBlcihjYWxsQ3JlZHMpO1xuICAgICAgICB0aGlzLmNoYW5uZWxDcmVkZW50aWFscyA9IGNoYW5uZWxDcmVkZW50aWFscztcbiAgICB9XG4gICAgY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMgPSB0aGlzLmNhbGxDcmVkZW50aWFscy5jb21wb3NlKGNhbGxDcmVkZW50aWFscyk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLCBjb21iaW5lZENhbGxDcmVkZW50aWFscyk7XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLl9lcXVhbHMob3RoZXIuY2hhbm5lbENyZWRlbnRpYWxzKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbENyZWRlbnRpYWxzLl9lcXVhbHMob3RoZXIuY2FsbENyZWRlbnRpYWxzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNoYW5uZWxDcmVkZW50aWFscyIsInRsc18xIiwicmVxdWlyZSIsImNhbGxfY3JlZGVudGlhbHNfMSIsInRsc19oZWxwZXJzXzEiLCJ2ZXJpZnlJc0J1ZmZlck9yTnVsbCIsIm9iaiIsImZyaWVuZGx5TmFtZSIsIkJ1ZmZlciIsIlR5cGVFcnJvciIsImNvbnN0cnVjdG9yIiwiY2FsbENyZWRlbnRpYWxzIiwiQ2FsbENyZWRlbnRpYWxzIiwiY3JlYXRlRW1wdHkiLCJfZ2V0Q2FsbENyZWRlbnRpYWxzIiwiY3JlYXRlU3NsIiwicm9vdENlcnRzIiwicHJpdmF0ZUtleSIsImNlcnRDaGFpbiIsInZlcmlmeU9wdGlvbnMiLCJfYSIsIkVycm9yIiwic2VjdXJlQ29udGV4dCIsImNyZWF0ZVNlY3VyZUNvbnRleHQiLCJjYSIsImdldERlZmF1bHRSb290c0RhdGEiLCJ1bmRlZmluZWQiLCJrZXkiLCJjZXJ0IiwiY2lwaGVycyIsIkNJUEhFUl9TVUlURVMiLCJTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIiwiY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQiLCJjcmVhdGVJbnNlY3VyZSIsIkluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCIsImNvbXBvc2UiLCJfZ2V0Q29ubmVjdGlvbk9wdGlvbnMiLCJfaXNTZWN1cmUiLCJfZXF1YWxzIiwib3RoZXIiLCJjb25uZWN0aW9uT3B0aW9ucyIsImNoZWNrU2VydmVySWRlbnRpdHkiLCJjb21iaW5lZENhbGxDcmVkZW50aWFscyIsIkNvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCIsImFzc2lnbiIsImNoYW5uZWxDcmVkZW50aWFscyIsImNhbGxDcmVkcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.channelOptionsEqual = exports.recognizedOptions = void 0;\n/**\n * This is for checking provided options at runtime. This is an object for\n * easier membership checking.\n */ exports.recognizedOptions = {\n    \"grpc.ssl_target_name_override\": true,\n    \"grpc.primary_user_agent\": true,\n    \"grpc.secondary_user_agent\": true,\n    \"grpc.default_authority\": true,\n    \"grpc.keepalive_time_ms\": true,\n    \"grpc.keepalive_timeout_ms\": true,\n    \"grpc.keepalive_permit_without_calls\": true,\n    \"grpc.service_config\": true,\n    \"grpc.max_concurrent_streams\": true,\n    \"grpc.initial_reconnect_backoff_ms\": true,\n    \"grpc.max_reconnect_backoff_ms\": true,\n    \"grpc.use_local_subchannel_pool\": true,\n    \"grpc.max_send_message_length\": true,\n    \"grpc.max_receive_message_length\": true,\n    \"grpc.enable_http_proxy\": true,\n    \"grpc.enable_channelz\": true,\n    \"grpc.dns_min_time_between_resolutions_ms\": true,\n    \"grpc.enable_retries\": true,\n    \"grpc.per_rpc_retry_buffer_size\": true,\n    \"grpc.retry_buffer_size\": true,\n    \"grpc.max_connection_age_ms\": true,\n    \"grpc.max_connection_age_grace_ms\": true,\n    \"grpc-node.max_session_memory\": true,\n    \"grpc.service_config_disable_resolution\": true,\n    \"grpc.client_idle_timeout_ms\": true,\n    \"grpc-node.tls_enable_trace\": true\n};\nfunction channelOptionsEqual(options1, options2) {\n    const keys1 = Object.keys(options1).sort();\n    const keys2 = Object.keys(options2).sort();\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for(let i = 0; i < keys1.length; i += 1){\n        if (keys1[i] !== keys2[i]) {\n            return false;\n        }\n        if (options1[keys1[i]] !== options2[keys2[i]]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.channelOptionsEqual = channelOptionsEqual; //# sourceMappingURL=channel-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUMvRDs7O0NBR0MsR0FDREEseUJBQXlCLEdBQUc7SUFDeEIsaUNBQWlDO0lBQ2pDLDJCQUEyQjtJQUMzQiw2QkFBNkI7SUFDN0IsMEJBQTBCO0lBQzFCLDBCQUEwQjtJQUMxQiw2QkFBNkI7SUFDN0IsdUNBQXVDO0lBQ3ZDLHVCQUF1QjtJQUN2QiwrQkFBK0I7SUFDL0IscUNBQXFDO0lBQ3JDLGlDQUFpQztJQUNqQyxrQ0FBa0M7SUFDbEMsZ0NBQWdDO0lBQ2hDLG1DQUFtQztJQUNuQywwQkFBMEI7SUFDMUIsd0JBQXdCO0lBQ3hCLDRDQUE0QztJQUM1Qyx1QkFBdUI7SUFDdkIsa0NBQWtDO0lBQ2xDLDBCQUEwQjtJQUMxQiw4QkFBOEI7SUFDOUIsb0NBQW9DO0lBQ3BDLGdDQUFnQztJQUNoQywwQ0FBMEM7SUFDMUMsK0JBQStCO0lBQy9CLDhCQUE4QjtBQUNsQztBQUNBLFNBQVNFLG9CQUFvQkUsUUFBUSxFQUFFQyxRQUFRO0lBQzNDLE1BQU1DLFFBQVFSLE9BQU9TLElBQUksQ0FBQ0gsVUFBVUksSUFBSTtJQUN4QyxNQUFNQyxRQUFRWCxPQUFPUyxJQUFJLENBQUNGLFVBQVVHLElBQUk7SUFDeEMsSUFBSUYsTUFBTUksTUFBTSxLQUFLRCxNQUFNQyxNQUFNLEVBQUU7UUFDL0IsT0FBTztJQUNYO0lBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlMLE1BQU1JLE1BQU0sRUFBRUMsS0FBSyxFQUFHO1FBQ3RDLElBQUlMLEtBQUssQ0FBQ0ssRUFBRSxLQUFLRixLQUFLLENBQUNFLEVBQUUsRUFBRTtZQUN2QixPQUFPO1FBQ1g7UUFDQSxJQUFJUCxRQUFRLENBQUNFLEtBQUssQ0FBQ0ssRUFBRSxDQUFDLEtBQUtOLFFBQVEsQ0FBQ0ksS0FBSyxDQUFDRSxFQUFFLENBQUMsRUFBRTtZQUMzQyxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBWCwyQkFBMkIsR0FBR0UscUJBQzlCLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWwtb3B0aW9ucy5qcz83NzZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoYW5uZWxPcHRpb25zRXF1YWwgPSBleHBvcnRzLnJlY29nbml6ZWRPcHRpb25zID0gdm9pZCAwO1xuLyoqXG4gKiBUaGlzIGlzIGZvciBjaGVja2luZyBwcm92aWRlZCBvcHRpb25zIGF0IHJ1bnRpbWUuIFRoaXMgaXMgYW4gb2JqZWN0IGZvclxuICogZWFzaWVyIG1lbWJlcnNoaXAgY2hlY2tpbmcuXG4gKi9cbmV4cG9ydHMucmVjb2duaXplZE9wdGlvbnMgPSB7XG4gICAgJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJzogdHJ1ZSxcbiAgICAnZ3JwYy5wcmltYXJ5X3VzZXJfYWdlbnQnOiB0cnVlLFxuICAgICdncnBjLnNlY29uZGFyeV91c2VyX2FnZW50JzogdHJ1ZSxcbiAgICAnZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSc6IHRydWUsXG4gICAgJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnOiB0cnVlLFxuICAgICdncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnOiB0cnVlLFxuICAgICdncnBjLnNlcnZpY2VfY29uZmlnJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJzogdHJ1ZSxcbiAgICAnZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnOiB0cnVlLFxuICAgICdncnBjLnVzZV9sb2NhbF9zdWJjaGFubmVsX3Bvb2wnOiB0cnVlLFxuICAgICdncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCc6IHRydWUsXG4gICAgJ2dycGMuZW5hYmxlX2h0dHBfcHJveHknOiB0cnVlLFxuICAgICdncnBjLmVuYWJsZV9jaGFubmVseic6IHRydWUsXG4gICAgJ2dycGMuZG5zX21pbl90aW1lX2JldHdlZW5fcmVzb2x1dGlvbnNfbXMnOiB0cnVlLFxuICAgICdncnBjLmVuYWJsZV9yZXRyaWVzJzogdHJ1ZSxcbiAgICAnZ3JwYy5wZXJfcnBjX3JldHJ5X2J1ZmZlcl9zaXplJzogdHJ1ZSxcbiAgICAnZ3JwYy5yZXRyeV9idWZmZXJfc2l6ZSc6IHRydWUsXG4gICAgJ2dycGMubWF4X2Nvbm5lY3Rpb25fYWdlX21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfZ3JhY2VfbXMnOiB0cnVlLFxuICAgICdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JzogdHJ1ZSxcbiAgICAnZ3JwYy5zZXJ2aWNlX2NvbmZpZ19kaXNhYmxlX3Jlc29sdXRpb24nOiB0cnVlLFxuICAgICdncnBjLmNsaWVudF9pZGxlX3RpbWVvdXRfbXMnOiB0cnVlLFxuICAgICdncnBjLW5vZGUudGxzX2VuYWJsZV90cmFjZSc6IHRydWUsXG59O1xuZnVuY3Rpb24gY2hhbm5lbE9wdGlvbnNFcXVhbChvcHRpb25zMSwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9wdGlvbnMxKS5zb3J0KCk7XG4gICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvcHRpb25zMikuc29ydCgpO1xuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5czEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGtleXMxW2ldICE9PSBrZXlzMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zMVtrZXlzMVtpXV0gIT09IG9wdGlvbnMyW2tleXMyW2ldXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5jaGFubmVsT3B0aW9uc0VxdWFsID0gY2hhbm5lbE9wdGlvbnNFcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWwtb3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjaGFubmVsT3B0aW9uc0VxdWFsIiwicmVjb2duaXplZE9wdGlvbnMiLCJvcHRpb25zMSIsIm9wdGlvbnMyIiwia2V5czEiLCJrZXlzIiwic29ydCIsImtleXMyIiwibGVuZ3RoIiwiaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChannelImplementation = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst internal_channel_1 = __webpack_require__(/*! ./internal-channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\");\nclass ChannelImplementation {\n    constructor(target, credentials, options){\n        if (typeof target !== \"string\") {\n            throw new TypeError(\"Channel target must be a string\");\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError(\"Channel credentials must be a ChannelCredentials object\");\n        }\n        if (options) {\n            if (typeof options !== \"object\") {\n                throw new TypeError(\"Channel options must be an object\");\n            }\n        }\n        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);\n    }\n    close() {\n        this.internalChannel.close();\n    }\n    getTarget() {\n        return this.internalChannel.getTarget();\n    }\n    getConnectivityState(tryToConnect) {\n        return this.internalChannel.getConnectivityState(tryToConnect);\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        this.internalChannel.watchConnectivityState(currentState, deadline, callback);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */ getChannelzRef() {\n        return this.internalChannel.getChannelzRef();\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== \"string\") {\n            throw new TypeError(\"Channel#createCall: method must be a string\");\n        }\n        if (!(typeof deadline === \"number\" || deadline instanceof Date)) {\n            throw new TypeError(\"Channel#createCall: deadline must be a number or Date\");\n        }\n        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);\n    }\n}\nexports.ChannelImplementation = ChannelImplementation; //# sourceMappingURL=channel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxNQUFNRyx3QkFBd0JDLG1CQUFPQSxDQUFDLGtHQUF1QjtBQUM3RCxNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDLDRGQUFvQjtBQUN2RCxNQUFNRjtJQUNGSSxZQUFZQyxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsT0FBTyxDQUFFO1FBQ3RDLElBQUksT0FBT0YsV0FBVyxVQUFVO1lBQzVCLE1BQU0sSUFBSUcsVUFBVTtRQUN4QjtRQUNBLElBQUksQ0FBRUYsQ0FBQUEsdUJBQXVCTCxzQkFBc0JRLGtCQUFrQixHQUFHO1lBQ3BFLE1BQU0sSUFBSUQsVUFBVTtRQUN4QjtRQUNBLElBQUlELFNBQVM7WUFDVCxJQUFJLE9BQU9BLFlBQVksVUFBVTtnQkFDN0IsTUFBTSxJQUFJQyxVQUFVO1lBQ3hCO1FBQ0o7UUFDQSxJQUFJLENBQUNFLGVBQWUsR0FBRyxJQUFJUCxtQkFBbUJRLGVBQWUsQ0FBQ04sUUFBUUMsYUFBYUM7SUFDdkY7SUFDQUssUUFBUTtRQUNKLElBQUksQ0FBQ0YsZUFBZSxDQUFDRSxLQUFLO0lBQzlCO0lBQ0FDLFlBQVk7UUFDUixPQUFPLElBQUksQ0FBQ0gsZUFBZSxDQUFDRyxTQUFTO0lBQ3pDO0lBQ0FDLHFCQUFxQkMsWUFBWSxFQUFFO1FBQy9CLE9BQU8sSUFBSSxDQUFDTCxlQUFlLENBQUNJLG9CQUFvQixDQUFDQztJQUNyRDtJQUNBQyx1QkFBdUJDLFlBQVksRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUU7UUFDckQsSUFBSSxDQUFDVCxlQUFlLENBQUNNLHNCQUFzQixDQUFDQyxjQUFjQyxVQUFVQztJQUN4RTtJQUNBOzs7O0tBSUMsR0FDREMsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUNWLGVBQWUsQ0FBQ1UsY0FBYztJQUM5QztJQUNBQyxXQUFXQyxNQUFNLEVBQUVKLFFBQVEsRUFBRUssSUFBSSxFQUFFQyxVQUFVLEVBQUVDLGNBQWMsRUFBRTtRQUMzRCxJQUFJLE9BQU9ILFdBQVcsVUFBVTtZQUM1QixNQUFNLElBQUlkLFVBQVU7UUFDeEI7UUFDQSxJQUFJLENBQUUsUUFBT1UsYUFBYSxZQUFZQSxvQkFBb0JRLElBQUcsR0FBSTtZQUM3RCxNQUFNLElBQUlsQixVQUFVO1FBQ3hCO1FBQ0EsT0FBTyxJQUFJLENBQUNFLGVBQWUsQ0FBQ1csVUFBVSxDQUFDQyxRQUFRSixVQUFVSyxNQUFNQyxZQUFZQztJQUMvRTtBQUNKO0FBQ0EzQiw2QkFBNkIsR0FBR0UsdUJBQ2hDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWwuanM/Y2Q4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGFubmVsSW1wbGVtZW50YXRpb24gPSB2b2lkIDA7XG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgaW50ZXJuYWxfY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwtY2hhbm5lbFwiKTtcbmNsYXNzIENoYW5uZWxJbXBsZW1lbnRhdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjcmVkZW50aWFscywgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgdGFyZ2V0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjcmVkZW50aWFscyBpbnN0YW5jZW9mIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIGNyZWRlbnRpYWxzIG11c3QgYmUgYSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsQ2hhbm5lbCA9IG5ldyBpbnRlcm5hbF9jaGFubmVsXzEuSW50ZXJuYWxDaGFubmVsKHRhcmdldCwgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbENoYW5uZWwuY2xvc2UoKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0VGFyZ2V0KCk7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKHRyeVRvQ29ubmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ5VG9Db25uZWN0KTtcbiAgICB9XG4gICAgd2F0Y2hDb25uZWN0aXZpdHlTdGF0ZShjdXJyZW50U3RhdGUsIGRlYWRsaW5lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmludGVybmFsQ2hhbm5lbC53YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGFubmVseiByZWZlcmVuY2Ugb2JqZWN0IGZvciB0aGlzIGNoYW5uZWwuIFRoZSByZXR1cm5lZCB2YWx1ZSBpc1xuICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKTtcbiAgICB9XG4gICAgY3JlYXRlQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogbWV0aG9kIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0eXBlb2YgZGVhZGxpbmUgPT09ICdudW1iZXInIHx8IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogZGVhZGxpbmUgbXVzdCBiZSBhIG51bWJlciBvciBEYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDaGFubmVsLmNyZWF0ZUNhbGwobWV0aG9kLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50Q2FsbCwgcHJvcGFnYXRlRmxhZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbEltcGxlbWVudGF0aW9uID0gQ2hhbm5lbEltcGxlbWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsX2NyZWRlbnRpYWxzXzEiLCJyZXF1aXJlIiwiaW50ZXJuYWxfY2hhbm5lbF8xIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJjcmVkZW50aWFscyIsIm9wdGlvbnMiLCJUeXBlRXJyb3IiLCJDaGFubmVsQ3JlZGVudGlhbHMiLCJpbnRlcm5hbENoYW5uZWwiLCJJbnRlcm5hbENoYW5uZWwiLCJjbG9zZSIsImdldFRhcmdldCIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwidHJ5VG9Db25uZWN0Iiwid2F0Y2hDb25uZWN0aXZpdHlTdGF0ZSIsImN1cnJlbnRTdGF0ZSIsImRlYWRsaW5lIiwiY2FsbGJhY2siLCJnZXRDaGFubmVselJlZiIsImNyZWF0ZUNhbGwiLCJtZXRob2QiLCJob3N0IiwicGFyZW50Q2FsbCIsInByb3BhZ2F0ZUZsYWdzIiwiRGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channelz.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nfunction channelRefToMessage(ref) {\n    return {\n        channel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction subchannelRefToMessage(ref) {\n    return {\n        subchannel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction serverRefToMessage(ref) {\n    return {\n        server_id: ref.id\n    };\n}\nfunction socketRefToMessage(ref) {\n    return {\n        socket_id: ref.id,\n        name: ref.name\n    };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */ const TARGET_RETAINED_TRACES = 32;\nclass ChannelzTrace {\n    constructor(){\n        this.events = [];\n        this.eventsLogged = 0;\n        this.creationTimestamp = new Date();\n    }\n    addTrace(severity, description, child) {\n        const timestamp = new Date();\n        this.events.push({\n            description: description,\n            severity: severity,\n            timestamp: timestamp,\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === \"channel\" ? child : undefined,\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === \"subchannel\" ? child : undefined\n        });\n        // Whenever the trace array gets too large, discard the first half\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\n        }\n        this.eventsLogged += 1;\n    }\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: this.events.map((event)=>{\n                return {\n                    description: event.description,\n                    severity: event.severity,\n                    timestamp: dateToProtoTimestamp(event.timestamp),\n                    channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n                    subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n                };\n            })\n        };\n    }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n    constructor(){\n        this.channelChildren = new Map();\n        this.subchannelChildren = new Map();\n        this.socketChildren = new Map();\n    }\n    refChild(child) {\n        var _a, _b, _c;\n        switch(child.kind){\n            case \"channel\":\n                {\n                    const trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.channelChildren.set(child.id, trackedChild);\n                    break;\n                }\n            case \"subchannel\":\n                {\n                    const trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.subchannelChildren.set(child.id, trackedChild);\n                    break;\n                }\n            case \"socket\":\n                {\n                    const trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.socketChildren.set(child.id, trackedChild);\n                    break;\n                }\n        }\n    }\n    unrefChild(child) {\n        switch(child.kind){\n            case \"channel\":\n                {\n                    const trackedChild = this.channelChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.channelChildren.delete(child.id);\n                        } else {\n                            this.channelChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n            case \"subchannel\":\n                {\n                    const trackedChild = this.subchannelChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.subchannelChildren.delete(child.id);\n                        } else {\n                            this.subchannelChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n            case \"socket\":\n                {\n                    const trackedChild = this.socketChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.socketChildren.delete(child.id);\n                        } else {\n                            this.socketChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n        }\n    }\n    getChildLists() {\n        const channels = [];\n        for (const { ref } of this.channelChildren.values()){\n            channels.push(ref);\n        }\n        const subchannels = [];\n        for (const { ref } of this.subchannelChildren.values()){\n            subchannels.push(ref);\n        }\n        const sockets = [];\n        for (const { ref } of this.socketChildren.values()){\n            sockets.push(ref);\n        }\n        return {\n            channels,\n            subchannels,\n            sockets\n        };\n    }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzCallTracker {\n    constructor(){\n        this.callsStarted = 0;\n        this.callsSucceeded = 0;\n        this.callsFailed = 0;\n        this.lastCallStartedTimestamp = null;\n    }\n    addCallStarted() {\n        this.callsStarted += 1;\n        this.lastCallStartedTimestamp = new Date();\n    }\n    addCallSucceeded() {\n        this.callsSucceeded += 1;\n    }\n    addCallFailed() {\n        this.callsFailed += 1;\n    }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\nfunction getNextId() {\n    return nextId++;\n}\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"channel\"\n    };\n    if (channelzEnabled) {\n        channels[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzChannel = registerChannelzChannel;\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"subchannel\"\n    };\n    if (channelzEnabled) {\n        subchannels[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        kind: \"server\"\n    };\n    if (channelzEnabled) {\n        servers[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzServer = registerChannelzServer;\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"socket\"\n    };\n    if (channelzEnabled) {\n        sockets[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzSocket = registerChannelzSocket;\nfunction unregisterChannelzRef(ref) {\n    switch(ref.kind){\n        case \"channel\":\n            delete channels[ref.id];\n            return;\n        case \"subchannel\":\n            delete subchannels[ref.id];\n            return;\n        case \"server\":\n            delete servers[ref.id];\n            return;\n        case \"socket\":\n            delete sockets[ref.id];\n            return;\n    }\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */ function parseIPv6Section(addressSection) {\n    const numberValue = Number.parseInt(addressSection, 16);\n    return [\n        numberValue / 256 | 0,\n        numberValue % 256\n    ];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */ function parseIPv6Chunk(addressChunk) {\n    if (addressChunk === \"\") {\n        return [];\n    }\n    const bytePairs = addressChunk.split(\":\").map((section)=>parseIPv6Section(section));\n    const result = [];\n    return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */ function ipAddressStringToBuffer(ipAddress) {\n    if ((0, net_1.isIPv4)(ipAddress)) {\n        return Buffer.from(Uint8Array.from(ipAddress.split(\".\").map((segment)=>Number.parseInt(segment))));\n    } else if ((0, net_1.isIPv6)(ipAddress)) {\n        let leftSection;\n        let rightSection;\n        const doubleColonIndex = ipAddress.indexOf(\"::\");\n        if (doubleColonIndex === -1) {\n            leftSection = ipAddress;\n            rightSection = \"\";\n        } else {\n            leftSection = ipAddress.substring(0, doubleColonIndex);\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\n        }\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n        return Buffer.concat([\n            leftBuffer,\n            middleBuffer,\n            rightBuffer\n        ]);\n    } else {\n        return null;\n    }\n}\nfunction connectivityStateToMessage(state) {\n    switch(state){\n        case connectivity_state_1.ConnectivityState.CONNECTING:\n            return {\n                state: \"CONNECTING\"\n            };\n        case connectivity_state_1.ConnectivityState.IDLE:\n            return {\n                state: \"IDLE\"\n            };\n        case connectivity_state_1.ConnectivityState.READY:\n            return {\n                state: \"READY\"\n            };\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\n            return {\n                state: \"SHUTDOWN\"\n            };\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n            return {\n                state: \"TRANSIENT_FAILURE\"\n            };\n        default:\n            return {\n                state: \"UNKNOWN\"\n            };\n    }\n}\nfunction dateToProtoTimestamp(date) {\n    if (!date) {\n        return null;\n    }\n    const millisSinceEpoch = date.getTime();\n    return {\n        seconds: millisSinceEpoch / 1000 | 0,\n        nanos: millisSinceEpoch % 1000 * 1000000\n    };\n}\nfunction getChannelMessage(channelEntry) {\n    const resolvedInfo = channelEntry.getInfo();\n    return {\n        ref: channelRefToMessage(channelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        channel_ref: resolvedInfo.children.channels.map((ref)=>channelRefToMessage(ref)),\n        subchannel_ref: resolvedInfo.children.subchannels.map((ref)=>subchannelRefToMessage(ref))\n    };\n}\nfunction GetChannel(call, callback) {\n    const channelId = Number.parseInt(call.request.channel_id);\n    const channelEntry = channels[channelId];\n    if (channelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No channel data found for id \" + channelId\n        });\n        return;\n    }\n    callback(null, {\n        channel: getChannelMessage(channelEntry)\n    });\n}\nfunction GetTopChannels(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_channel_id);\n    for(; i < channels.length; i++){\n        const channelEntry = channels[i];\n        if (channelEntry === undefined) {\n            continue;\n        }\n        resultList.push(getChannelMessage(channelEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        channel: resultList,\n        end: i >= servers.length\n    });\n}\nfunction getServerMessage(serverEntry) {\n    const resolvedInfo = serverEntry.getInfo();\n    return {\n        ref: serverRefToMessage(serverEntry.ref),\n        data: {\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        listen_socket: resolvedInfo.listenerChildren.sockets.map((ref)=>socketRefToMessage(ref))\n    };\n}\nfunction GetServer(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No server data found for id \" + serverId\n        });\n        return;\n    }\n    callback(null, {\n        server: getServerMessage(serverEntry)\n    });\n}\nfunction GetServers(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_server_id);\n    for(; i < servers.length; i++){\n        const serverEntry = servers[i];\n        if (serverEntry === undefined) {\n            continue;\n        }\n        resultList.push(getServerMessage(serverEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        server: resultList,\n        end: i >= servers.length\n    });\n}\nfunction GetSubchannel(call, callback) {\n    const subchannelId = Number.parseInt(call.request.subchannel_id);\n    const subchannelEntry = subchannels[subchannelId];\n    if (subchannelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No subchannel data found for id \" + subchannelId\n        });\n        return;\n    }\n    const resolvedInfo = subchannelEntry.getInfo();\n    const subchannelMessage = {\n        ref: subchannelRefToMessage(subchannelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        socket_ref: resolvedInfo.children.sockets.map((ref)=>socketRefToMessage(ref))\n    };\n    callback(null, {\n        subchannel: subchannelMessage\n    });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n    var _a;\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {\n        return {\n            address: \"tcpip_address\",\n            tcpip_address: {\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n                port: subchannelAddress.port\n            }\n        };\n    } else {\n        return {\n            address: \"uds_address\",\n            uds_address: {\n                filename: subchannelAddress.path\n            }\n        };\n    }\n}\nfunction GetSocket(call, callback) {\n    var _a, _b, _c, _d, _e;\n    const socketId = Number.parseInt(call.request.socket_id);\n    const socketEntry = sockets[socketId];\n    if (socketEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No socket data found for id \" + socketId\n        });\n        return;\n    }\n    const resolvedInfo = socketEntry.getInfo();\n    const securityMessage = resolvedInfo.security ? {\n        model: \"tls\",\n        tls: {\n            cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? \"standard_name\" : \"other_name\",\n            standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n            other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n            local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n            remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n        }\n    } : null;\n    const socketMessage = {\n        ref: socketRefToMessage(socketEntry.ref),\n        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n        security: securityMessage,\n        data: {\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\n            streams_started: resolvedInfo.streamsStarted,\n            streams_succeeded: resolvedInfo.streamsSucceeded,\n            streams_failed: resolvedInfo.streamsFailed,\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n            messages_received: resolvedInfo.messagesReceived,\n            messages_sent: resolvedInfo.messagesSent,\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n            local_flow_control_window: resolvedInfo.localFlowControlWindow ? {\n                value: resolvedInfo.localFlowControlWindow\n            } : null,\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {\n                value: resolvedInfo.remoteFlowControlWindow\n            } : null\n        }\n    };\n    callback(null, {\n        socket: socketMessage\n    });\n}\nfunction GetServerSockets(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No server data found for id \" + serverId\n        });\n        return;\n    }\n    const startId = Number.parseInt(call.request.start_socket_id);\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resolvedInfo = serverEntry.getInfo();\n    // If we wanted to include listener sockets in the result, this line would\n    // instead say\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n    const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2)=>ref1.id - ref2.id);\n    const resultList = [];\n    let i = 0;\n    for(; i < allSockets.length; i++){\n        if (allSockets[i].id >= startId) {\n            resultList.push(socketRefToMessage(allSockets[i]));\n            if (resultList.length >= maxResults) {\n                break;\n            }\n        }\n    }\n    callback(null, {\n        socket_ref: resultList,\n        end: i >= allSockets.length\n    });\n}\nfunction getChannelzHandlers() {\n    return {\n        GetChannel,\n        GetTopChannels,\n        GetServer,\n        GetServers,\n        GetSubchannel,\n        GetSocket,\n        GetServerSockets\n    };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n    if (loadedChannelzDefinition) {\n        return loadedChannelzDefinition;\n    }\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n     * runtime for users who will not use/enable channelz. */ const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\n    const loadedProto = loaderLoadSync(\"channelz.proto\", {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n        includeDirs: [\n            `${__dirname}/../../proto`\n        ]\n    });\n    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);\n    loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n    return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup; //# sourceMappingURL=channelz.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxhQUFhLEdBQUdBLG9DQUFvQyxHQUFHQSwyQkFBMkIsR0FBR0EsNkJBQTZCLEdBQUdBLDhCQUE4QixHQUFHQSw4QkFBOEIsR0FBR0Esa0NBQWtDLEdBQUdBLCtCQUErQixHQUFHQSwyQkFBMkIsR0FBR0EsK0JBQStCLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDM1YsTUFBTWEsUUFBUUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUMsdUJBQXVCRCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUcsdUJBQXVCSCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUksVUFBVUosbUJBQU9BLENBQUMsc0VBQVM7QUFDakMsTUFBTUssZ0JBQWdCTCxtQkFBT0EsQ0FBQyxrRkFBZTtBQUM3QyxTQUFTTSxvQkFBb0JDLEdBQUc7SUFDNUIsT0FBTztRQUNIQyxZQUFZRCxJQUFJRSxFQUFFO1FBQ2xCQyxNQUFNSCxJQUFJRyxJQUFJO0lBQ2xCO0FBQ0o7QUFDQSxTQUFTQyx1QkFBdUJKLEdBQUc7SUFDL0IsT0FBTztRQUNISyxlQUFlTCxJQUFJRSxFQUFFO1FBQ3JCQyxNQUFNSCxJQUFJRyxJQUFJO0lBQ2xCO0FBQ0o7QUFDQSxTQUFTRyxtQkFBbUJOLEdBQUc7SUFDM0IsT0FBTztRQUNITyxXQUFXUCxJQUFJRSxFQUFFO0lBQ3JCO0FBQ0o7QUFDQSxTQUFTTSxtQkFBbUJSLEdBQUc7SUFDM0IsT0FBTztRQUNIUyxXQUFXVCxJQUFJRSxFQUFFO1FBQ2pCQyxNQUFNSCxJQUFJRyxJQUFJO0lBQ2xCO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxH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V0FBVzVHLE1BQU0sSUFBSTBHLFlBQVk7Z0JBQ2pDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FULFNBQVMsTUFBTTtRQUNYNEIsWUFBWWpCO1FBQ1pHLEtBQUtGLEtBQUtrRixXQUFXL0wsTUFBTTtJQUMvQjtBQUNKO0FBQ0EsU0FBUzNDO0lBQ0wsT0FBTztRQUNIMEk7UUFDQVU7UUFDQVc7UUFDQUc7UUFDQUU7UUFDQWlCO1FBQ0FrRDtJQUNKO0FBQ0o7QUFDQTNPLDJCQUEyQixHQUFHSTtBQUM5QixJQUFJK08sMkJBQTJCO0FBQy9CLFNBQVNoUDtJQUNMLElBQUlnUCwwQkFBMEI7UUFDMUIsT0FBT0E7SUFDWDtJQUNBOzJEQUN1RCxHQUN2RCxNQUFNQyxpQkFBaUJ0TyxzSEFDVjtJQUNiLE1BQU13TyxjQUFjRixlQUFlLGtCQUFrQjtRQUNqREcsVUFBVTtRQUNWQyxPQUFPQztRQUNQQyxPQUFPRDtRQUNQRSxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsYUFBYTtZQUFDLENBQUMsRUFBRUMsVUFBVSxZQUFZLENBQUM7U0FBQztJQUM3QztJQUNBLE1BQU1DLHFCQUFxQixDQUFDLEdBQUc1TyxjQUFjNk8scUJBQXFCLEVBQUVWO0lBQ3BFSCwyQkFDSVksbUJBQW1CRSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsRUFBRSxDQUFDQyxRQUFRLENBQUNDLE9BQU87SUFDeEQsT0FBT2xCO0FBQ1g7QUFDQW5QLG9DQUFvQyxHQUFHRztBQUN2QyxTQUFTRDtJQUNKLElBQUdnQixRQUFRb1Asb0JBQW9CLEVBQUVuUSw4QkFBOEJDO0FBQ3BFO0FBQ0FKLGFBQWEsR0FBR0UsT0FDaEIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanM/NjI3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpIYW5kbGVycyA9IGV4cG9ydHMudW5yZWdpc3RlckNoYW5uZWx6UmVmID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwgPSBleHBvcnRzLkNoYW5uZWx6Q2FsbFRyYWNrZXIgPSBleHBvcnRzLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyID0gZXhwb3J0cy5DaGFubmVselRyYWNlID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuY29uc3QgbWFrZV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL21ha2UtY2xpZW50XCIpO1xuZnVuY3Rpb24gY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFubmVsX2lkOiByZWYuaWQsXG4gICAgICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgIH07XG59XG5mdW5jdGlvbiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YmNoYW5uZWxfaWQ6IHJlZi5pZCxcbiAgICAgICAgbmFtZTogcmVmLm5hbWUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlcnZlclJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2ZXJfaWQ6IHJlZi5pZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNvY2tldF9pZDogcmVmLmlkLFxuICAgICAgICBuYW1lOiByZWYubmFtZSxcbiAgICB9O1xufVxuLyoqXG4gKiBUaGUgbG9vc2UgdXBwZXIgYm91bmQgb24gdGhlIG51bWJlciBvZiBldmVudHMgdGhhdCBzaG91bGQgYmUgcmV0YWluZWQgaW4gYVxuICogdHJhY2UuIFRoaXMgbWF5IGJlIGV4Y2VlZGVkIGJ5IHVwIHRvIGEgZmFjdG9yIG9mIDIuIEFyYml0cmFyaWx5IGNob3NlbiBhcyBhXG4gKiBudW1iZXIgdGhhdCBzaG91bGQgYmUgbGFyZ2UgZW5vdWdoIHRvIGNvbnRhaW4gdGhlIHJlY2VudCByZWxldmFudFxuICogaW5mb3JtYXRpb24sIGJ1dCBzbWFsbCBlbm91Z2ggdG8gbm90IHVzZSBleGNlc3NpdmUgbWVtb3J5LlxuICovXG5jb25zdCBUQVJHRVRfUkVUQUlORURfVFJBQ0VTID0gMzI7XG5jbGFzcyBDaGFubmVselRyYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHNMb2dnZWQgPSAwO1xuICAgICAgICB0aGlzLmNyZWF0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgYWRkVHJhY2Uoc2V2ZXJpdHksIGRlc2NyaXB0aW9uLCBjaGlsZCkge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNldmVyaXR5OiBzZXZlcml0eSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgY2hpbGRDaGFubmVsOiAoY2hpbGQgPT09IG51bGwgfHwgY2hpbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkLmtpbmQpID09PSAnY2hhbm5lbCcgPyBjaGlsZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoaWxkU3ViY2hhbm5lbDogKGNoaWxkID09PSBudWxsIHx8IGNoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZC5raW5kKSA9PT0gJ3N1YmNoYW5uZWwnID8gY2hpbGQgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXaGVuZXZlciB0aGUgdHJhY2UgYXJyYXkgZ2V0cyB0b28gbGFyZ2UsIGRpc2NhcmQgdGhlIGZpcnN0IGhhbGZcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA+PSBUQVJHRVRfUkVUQUlORURfVFJBQ0VTICogMikge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cy5zbGljZShUQVJHRVRfUkVUQUlORURfVFJBQ0VTKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50c0xvZ2dlZCArPSAxO1xuICAgIH1cbiAgICBnZXRUcmFjZU1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGlvbl90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHRoaXMuY3JlYXRpb25UaW1lc3RhbXApLFxuICAgICAgICAgICAgbnVtX2V2ZW50c19sb2dnZWQ6IHRoaXMuZXZlbnRzTG9nZ2VkLFxuICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cy5tYXAoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBldmVudC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHk6IGV2ZW50LnNldmVyaXR5LFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKGV2ZW50LnRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxfcmVmOiBldmVudC5jaGlsZENoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZENoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxfcmVmOiBldmVudC5jaGlsZFN1YmNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZFN1YmNoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpUcmFjZSA9IENoYW5uZWx6VHJhY2U7XG5jbGFzcyBDaGFubmVsekNoaWxkcmVuVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgcmVmQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSAoX2EgPSB0aGlzLmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogY2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3ViY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSAoX2IgPSB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogY2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc29ja2V0Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrZWRDaGlsZCA9IChfYyA9IHRoaXMuc29ja2V0Q2hpbGRyZW4uZ2V0KGNoaWxkLmlkKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGNoaWxkLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVmQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgc3dpdGNoIChjaGlsZC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdjaGFubmVsJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrZWRDaGlsZCA9IHRoaXMuY2hhbm5lbENoaWxkcmVuLmdldChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDaGlsZHJlbi5kZWxldGUoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3ViY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uZGVsZXRlKGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NvY2tldCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSB0aGlzLnNvY2tldENoaWxkcmVuLmdldChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLmRlbGV0ZShjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDaGlsZExpc3RzKCkge1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5jaGFubmVsQ2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNoYW5uZWxzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJjaGFubmVscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyByZWYgfSBvZiB0aGlzLnNvY2tldENoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXRzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFubmVscywgc3ViY2hhbm5lbHMsIHNvY2tldHMgfTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyID0gQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXI7XG5jbGFzcyBDaGFubmVsekNhbGxUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jYWxsc1N0YXJ0ZWQgPSAwO1xuICAgICAgICB0aGlzLmNhbGxzU3VjY2VlZGVkID0gMDtcbiAgICAgICAgdGhpcy5jYWxsc0ZhaWxlZCA9IDA7XG4gICAgICAgIHRoaXMubGFzdENhbGxTdGFydGVkVGltZXN0YW1wID0gbnVsbDtcbiAgICB9XG4gICAgYWRkQ2FsbFN0YXJ0ZWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdGFydGVkICs9IDE7XG4gICAgICAgIHRoaXMubGFzdENhbGxTdGFydGVkVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgYWRkQ2FsbFN1Y2NlZWRlZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsc1N1Y2NlZWRlZCArPSAxO1xuICAgIH1cbiAgICBhZGRDYWxsRmFpbGVkKCkge1xuICAgICAgICB0aGlzLmNhbGxzRmFpbGVkICs9IDE7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyID0gQ2hhbm5lbHpDYWxsVHJhY2tlcjtcbmxldCBuZXh0SWQgPSAxO1xuZnVuY3Rpb24gZ2V0TmV4dElkKCkge1xuICAgIHJldHVybiBuZXh0SWQrKztcbn1cbmNvbnN0IGNoYW5uZWxzID0gW107XG5jb25zdCBzdWJjaGFubmVscyA9IFtdO1xuY29uc3Qgc2VydmVycyA9IFtdO1xuY29uc3Qgc29ja2V0cyA9IFtdO1xuZnVuY3Rpb24gcmVnaXN0ZXJDaGFubmVsekNoYW5uZWwobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBuYW1lLCBraW5kOiAnY2hhbm5lbCcgfTtcbiAgICBpZiAoY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgIGNoYW5uZWxzW2lkXSA9IHsgcmVmLCBnZXRJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiByZWY7XG59XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsID0gcmVnaXN0ZXJDaGFubmVsekNoYW5uZWw7XG5mdW5jdGlvbiByZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbChuYW1lLCBnZXRJbmZvLCBjaGFubmVsekVuYWJsZWQpIHtcbiAgICBjb25zdCBpZCA9IGdldE5leHRJZCgpO1xuICAgIGNvbnN0IHJlZiA9IHsgaWQsIG5hbWUsIGtpbmQ6ICdzdWJjaGFubmVsJyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc3ViY2hhbm5lbHNbaWRdID0geyByZWYsIGdldEluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwgPSByZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbDtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXIoZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBraW5kOiAnc2VydmVyJyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc2VydmVyc1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gcmVnaXN0ZXJDaGFubmVselNlcnZlcjtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBuYW1lLCBraW5kOiAnc29ja2V0JyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc29ja2V0c1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gcmVnaXN0ZXJDaGFubmVselNvY2tldDtcbmZ1bmN0aW9uIHVucmVnaXN0ZXJDaGFubmVselJlZihyZWYpIHtcbiAgICBzd2l0Y2ggKHJlZi5raW5kKSB7XG4gICAgICAgIGNhc2UgJ2NoYW5uZWwnOlxuICAgICAgICAgICAgZGVsZXRlIGNoYW5uZWxzW3JlZi5pZF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ3N1YmNoYW5uZWwnOlxuICAgICAgICAgICAgZGVsZXRlIHN1YmNoYW5uZWxzW3JlZi5pZF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ3NlcnZlcic6XG4gICAgICAgICAgICBkZWxldGUgc2VydmVyc1tyZWYuaWRdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdzb2NrZXQnOlxuICAgICAgICAgICAgZGVsZXRlIHNvY2tldHNbcmVmLmlkXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG59XG5leHBvcnRzLnVucmVnaXN0ZXJDaGFubmVselJlZiA9IHVucmVnaXN0ZXJDaGFubmVselJlZjtcbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgc2VjdGlvbiBvZiBhbiBJUHY2IGFkZHJlc3MgYXMgdHdvIGJ5dGVzXG4gKiBAcGFyYW0gYWRkcmVzc1NlY3Rpb24gQSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgbGVuZ3RoIHVwIHRvIDRcbiAqIEByZXR1cm5zIFRoZSBwYWlyIG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIGFkZHJlc3Mgc2VjdGlvblxuICovXG5mdW5jdGlvbiBwYXJzZUlQdjZTZWN0aW9uKGFkZHJlc3NTZWN0aW9uKSB7XG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBOdW1iZXIucGFyc2VJbnQoYWRkcmVzc1NlY3Rpb24sIDE2KTtcbiAgICByZXR1cm4gWyhudW1iZXJWYWx1ZSAvIDI1NikgfCAwLCBudW1iZXJWYWx1ZSAlIDI1Nl07XG59XG4vKipcbiAqIFBhcnNlIGEgY2h1bmsgb2YgYW4gSVB2NiBhZGRyZXNzIHN0cmluZyB0byBzb21lIG51bWJlciBvZiBieXRlc1xuICogQHBhcmFtIGFkZHJlc3NDaHVuayBTb21lIG51bWJlciBvZiBzZWdtZW50cyBvZiB1cCB0byA0IGhleGFkZWNpbWFsXG4gKiAgIGNoYXJhY3RlcnMgZWFjaCwgam9pbmVkIGJ5IGNvbG9ucy5cbiAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIGFkZHJlc3MgY2h1bmtcbiAqL1xuZnVuY3Rpb24gcGFyc2VJUHY2Q2h1bmsoYWRkcmVzc0NodW5rKSB7XG4gICAgaWYgKGFkZHJlc3NDaHVuayA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBieXRlUGFpcnMgPSBhZGRyZXNzQ2h1bmtcbiAgICAgICAgLnNwbGl0KCc6JylcbiAgICAgICAgLm1hcChzZWN0aW9uID0+IHBhcnNlSVB2NlNlY3Rpb24oc2VjdGlvbikpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJldHVybiByZXN1bHQuY29uY2F0KC4uLmJ5dGVQYWlycyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgb3IgSVB2NiBhZGRyZXNzIGZyb20gc3RyaW5nIHJlcHJlc2VudGF0aW9uIHRvIGJpbmFyeVxuICogcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSBpcEFkZHJlc3MgYW4gSVAgYWRkcmVzcyBpbiBzdGFuZGFyZCBJUHY0IG9yIElQdjYgdGV4dCBmb3JtYXRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKGlwQWRkcmVzcykge1xuICAgIGlmICgoMCwgbmV0XzEuaXNJUHY0KShpcEFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShVaW50OEFycmF5LmZyb20oaXBBZGRyZXNzLnNwbGl0KCcuJykubWFwKHNlZ21lbnQgPT4gTnVtYmVyLnBhcnNlSW50KHNlZ21lbnQpKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgbmV0XzEuaXNJUHY2KShpcEFkZHJlc3MpKSB7XG4gICAgICAgIGxldCBsZWZ0U2VjdGlvbjtcbiAgICAgICAgbGV0IHJpZ2h0U2VjdGlvbjtcbiAgICAgICAgY29uc3QgZG91YmxlQ29sb25JbmRleCA9IGlwQWRkcmVzcy5pbmRleE9mKCc6OicpO1xuICAgICAgICBpZiAoZG91YmxlQ29sb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxlZnRTZWN0aW9uID0gaXBBZGRyZXNzO1xuICAgICAgICAgICAgcmlnaHRTZWN0aW9uID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWZ0U2VjdGlvbiA9IGlwQWRkcmVzcy5zdWJzdHJpbmcoMCwgZG91YmxlQ29sb25JbmRleCk7XG4gICAgICAgICAgICByaWdodFNlY3Rpb24gPSBpcEFkZHJlc3Muc3Vic3RyaW5nKGRvdWJsZUNvbG9uSW5kZXggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZWZ0QnVmZmVyID0gQnVmZmVyLmZyb20ocGFyc2VJUHY2Q2h1bmsobGVmdFNlY3Rpb24pKTtcbiAgICAgICAgY29uc3QgcmlnaHRCdWZmZXIgPSBCdWZmZXIuZnJvbShwYXJzZUlQdjZDaHVuayhyaWdodFNlY3Rpb24pKTtcbiAgICAgICAgY29uc3QgbWlkZGxlQnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2IC0gbGVmdEJ1ZmZlci5sZW5ndGggLSByaWdodEJ1ZmZlci5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbbGVmdEJ1ZmZlciwgbWlkZGxlQnVmZmVyLCByaWdodEJ1ZmZlcl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2Uoc3RhdGUpIHtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdDT05ORUNUSU5HJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdJRExFJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFk6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnUkVBRFknLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdTSFVURE9XTicsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1RSQU5TSUVOVF9GQUlMVVJFJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnVU5LTk9XTicsXG4gICAgICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRhdGVUb1Byb3RvVGltZXN0YW1wKGRhdGUpIHtcbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1pbGxpc1NpbmNlRXBvY2ggPSBkYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWNvbmRzOiAobWlsbGlzU2luY2VFcG9jaCAvIDEwMDApIHwgMCxcbiAgICAgICAgbmFub3M6IChtaWxsaXNTaW5jZUVwb2NoICUgMTAwMCkgKiAxMDAwMDAwLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpIHtcbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBjaGFubmVsRW50cnkuZ2V0SW5mbygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZjogY2hhbm5lbFJlZlRvTWVzc2FnZShjaGFubmVsRW50cnkucmVmKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGFyZ2V0OiByZXNvbHZlZEluZm8udGFyZ2V0LFxuICAgICAgICAgICAgc3RhdGU6IGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHJlc29sdmVkSW5mby5zdGF0ZSksXG4gICAgICAgICAgICBjYWxsc19zdGFydGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBjYWxsc19mYWlsZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIGxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpLFxuICAgICAgICB9LFxuICAgICAgICBjaGFubmVsX3JlZjogcmVzb2x2ZWRJbmZvLmNoaWxkcmVuLmNoYW5uZWxzLm1hcChyZWYgPT4gY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpKSxcbiAgICAgICAgc3ViY2hhbm5lbF9yZWY6IHJlc29sdmVkSW5mby5jaGlsZHJlbi5zdWJjaGFubmVscy5tYXAocmVmID0+IHN1YmNoYW5uZWxSZWZUb01lc3NhZ2UocmVmKSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEdldENoYW5uZWwoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjaGFubmVsSWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LmNoYW5uZWxfaWQpO1xuICAgIGNvbnN0IGNoYW5uZWxFbnRyeSA9IGNoYW5uZWxzW2NoYW5uZWxJZF07XG4gICAgaWYgKGNoYW5uZWxFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgICAgICAgICBkZXRhaWxzOiAnTm8gY2hhbm5lbCBkYXRhIGZvdW5kIGZvciBpZCAnICsgY2hhbm5lbElkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7IGNoYW5uZWw6IGdldENoYW5uZWxNZXNzYWdlKGNoYW5uZWxFbnRyeSkgfSk7XG59XG5mdW5jdGlvbiBHZXRUb3BDaGFubmVscyhjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1heFJlc3VsdHMgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzKTtcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgbGV0IGkgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X2NoYW5uZWxfaWQpO1xuICAgIGZvciAoOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbEVudHJ5ID0gY2hhbm5lbHNbaV07XG4gICAgICAgIGlmIChjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKGdldENoYW5uZWxNZXNzYWdlKGNoYW5uZWxFbnRyeSkpO1xuICAgICAgICBpZiAocmVzdWx0TGlzdC5sZW5ndGggPj0gbWF4UmVzdWx0cykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICBjaGFubmVsOiByZXN1bHRMaXN0LFxuICAgICAgICBlbmQ6IGkgPj0gc2VydmVycy5sZW5ndGgsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTZXJ2ZXJNZXNzYWdlKHNlcnZlckVudHJ5KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc2VydmVyRW50cnkuZ2V0SW5mbygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZjogc2VydmVyUmVmVG9NZXNzYWdlKHNlcnZlckVudHJ5LnJlZiksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGNhbGxzX3N0YXJ0ZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBjYWxsc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIHRyYWNlOiByZXNvbHZlZEluZm8udHJhY2UuZ2V0VHJhY2VNZXNzYWdlKCksXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3Rlbl9zb2NrZXQ6IHJlc29sdmVkSW5mby5saXN0ZW5lckNoaWxkcmVuLnNvY2tldHMubWFwKHJlZiA9PiBzb2NrZXRSZWZUb01lc3NhZ2UocmVmKSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEdldFNlcnZlcihjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlcnZlcklkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zZXJ2ZXJfaWQpO1xuICAgIGNvbnN0IHNlcnZlckVudHJ5ID0gc2VydmVyc1tzZXJ2ZXJJZF07XG4gICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzZXJ2ZXIgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNlcnZlcklkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7IHNlcnZlcjogZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkgfSk7XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXJzKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMpO1xuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcbiAgICBsZXQgaSA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc3RhcnRfc2VydmVyX2lkKTtcbiAgICBmb3IgKDsgaSA8IHNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJzW2ldO1xuICAgICAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKGdldFNlcnZlck1lc3NhZ2Uoc2VydmVyRW50cnkpKTtcbiAgICAgICAgaWYgKHJlc3VsdExpc3QubGVuZ3RoID49IG1heFJlc3VsdHMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgc2VydmVyOiByZXN1bHRMaXN0LFxuICAgICAgICBlbmQ6IGkgPj0gc2VydmVycy5sZW5ndGgsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBHZXRTdWJjaGFubmVsKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc3ViY2hhbm5lbElkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zdWJjaGFubmVsX2lkKTtcbiAgICBjb25zdCBzdWJjaGFubmVsRW50cnkgPSBzdWJjaGFubmVsc1tzdWJjaGFubmVsSWRdO1xuICAgIGlmIChzdWJjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHN1YmNoYW5uZWwgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHN1YmNoYW5uZWxJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc3ViY2hhbm5lbEVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBzdWJjaGFubmVsTWVzc2FnZSA9IHtcbiAgICAgICAgcmVmOiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHN1YmNoYW5uZWxFbnRyeS5yZWYpLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IHJlc29sdmVkSW5mby50YXJnZXQsXG4gICAgICAgICAgICBzdGF0ZTogY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2UocmVzb2x2ZWRJbmZvLnN0YXRlKSxcbiAgICAgICAgICAgIGNhbGxzX3N0YXJ0ZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBjYWxsc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIHRyYWNlOiByZXNvbHZlZEluZm8udHJhY2UuZ2V0VHJhY2VNZXNzYWdlKCksXG4gICAgICAgIH0sXG4gICAgICAgIHNvY2tldF9yZWY6IHJlc29sdmVkSW5mby5jaGlsZHJlbi5zb2NrZXRzLm1hcChyZWYgPT4gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikpLFxuICAgIH07XG4gICAgY2FsbGJhY2sobnVsbCwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsTWVzc2FnZSB9KTtcbn1cbmZ1bmN0aW9uIHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShzdWJjaGFubmVsQWRkcmVzcykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKHN1YmNoYW5uZWxBZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogJ3RjcGlwX2FkZHJlc3MnLFxuICAgICAgICAgICAgdGNwaXBfYWRkcmVzczoge1xuICAgICAgICAgICAgICAgIGlwX2FkZHJlc3M6IChfYSA9IGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKHN1YmNoYW5uZWxBZGRyZXNzLmhvc3QpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcG9ydDogc3ViY2hhbm5lbEFkZHJlc3MucG9ydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogJ3Vkc19hZGRyZXNzJyxcbiAgICAgICAgICAgIHVkc19hZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHN1YmNoYW5uZWxBZGRyZXNzLnBhdGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIEdldFNvY2tldChjYWxsLCBjYWxsYmFjaykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3Qgc29ja2V0SWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNvY2tldF9pZCk7XG4gICAgY29uc3Qgc29ja2V0RW50cnkgPSBzb2NrZXRzW3NvY2tldElkXTtcbiAgICBpZiAoc29ja2V0RW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHNvY2tldCBkYXRhIGZvdW5kIGZvciBpZCAnICsgc29ja2V0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNvY2tldEVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBzZWN1cml0eU1lc3NhZ2UgPSByZXNvbHZlZEluZm8uc2VjdXJpdHlcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBtb2RlbDogJ3RscycsXG4gICAgICAgICAgICB0bHM6IHtcbiAgICAgICAgICAgICAgICBjaXBoZXJfc3VpdGU6IHJlc29sdmVkSW5mby5zZWN1cml0eS5jaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZVxuICAgICAgICAgICAgICAgICAgICA/ICdzdGFuZGFyZF9uYW1lJ1xuICAgICAgICAgICAgICAgICAgICA6ICdvdGhlcl9uYW1lJyxcbiAgICAgICAgICAgICAgICBzdGFuZGFyZF9uYW1lOiAoX2EgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvdGhlcl9uYW1lOiAoX2IgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVPdGhlck5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsb2NhbF9jZXJ0aWZpY2F0ZTogKF9jID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmxvY2FsQ2VydGlmaWNhdGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZW1vdGVfY2VydGlmaWNhdGU6IChfZCA9IHJlc29sdmVkSW5mby5zZWN1cml0eS5yZW1vdGVDZXJ0aWZpY2F0ZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3Qgc29ja2V0TWVzc2FnZSA9IHtcbiAgICAgICAgcmVmOiBzb2NrZXRSZWZUb01lc3NhZ2Uoc29ja2V0RW50cnkucmVmKSxcbiAgICAgICAgbG9jYWw6IHJlc29sdmVkSW5mby5sb2NhbEFkZHJlc3NcbiAgICAgICAgICAgID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5sb2NhbEFkZHJlc3MpXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIHJlbW90ZTogcmVzb2x2ZWRJbmZvLnJlbW90ZUFkZHJlc3NcbiAgICAgICAgICAgID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzKVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICByZW1vdGVfbmFtZTogKF9lID0gcmVzb2x2ZWRJbmZvLnJlbW90ZU5hbWUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VjdXJpdHk6IHNlY3VyaXR5TWVzc2FnZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAga2VlcF9hbGl2ZXNfc2VudDogcmVzb2x2ZWRJbmZvLmtlZXBBbGl2ZXNTZW50LFxuICAgICAgICAgICAgc3RyZWFtc19zdGFydGVkOiByZXNvbHZlZEluZm8uc3RyZWFtc1N0YXJ0ZWQsXG4gICAgICAgICAgICBzdHJlYW1zX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNTdWNjZWVkZWQsXG4gICAgICAgICAgICBzdHJlYW1zX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2xvY2FsX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbGFzdF9yZW1vdGVfc3RyZWFtX2NyZWF0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8ubGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbWVzc2FnZXNfcmVjZWl2ZWQ6IHJlc29sdmVkSW5mby5tZXNzYWdlc1JlY2VpdmVkLFxuICAgICAgICAgICAgbWVzc2FnZXNfc2VudDogcmVzb2x2ZWRJbmZvLm1lc3NhZ2VzU2VudCxcbiAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9yZWNlaXZlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9zZW50X3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCksXG4gICAgICAgICAgICBsb2NhbF9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ubG9jYWxGbG93Q29udHJvbFdpbmRvd1xuICAgICAgICAgICAgICAgID8geyB2YWx1ZTogcmVzb2x2ZWRJbmZvLmxvY2FsRmxvd0NvbnRyb2xXaW5kb3cgfVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJlbW90ZV9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ucmVtb3RlRmxvd0NvbnRyb2xXaW5kb3dcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IHJlc29sdmVkSW5mby5yZW1vdGVGbG93Q29udHJvbFdpbmRvdyB9XG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgY2FsbGJhY2sobnVsbCwgeyBzb2NrZXQ6IHNvY2tldE1lc3NhZ2UgfSk7XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXJTb2NrZXRzKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VydmVySWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNlcnZlcl9pZCk7XG4gICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJzW3NlcnZlcklkXTtcbiAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHNlcnZlciBkYXRhIGZvdW5kIGZvciBpZCAnICsgc2VydmVySWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X3NvY2tldF9pZCk7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMpO1xuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNlcnZlckVudHJ5LmdldEluZm8oKTtcbiAgICAvLyBJZiB3ZSB3YW50ZWQgdG8gaW5jbHVkZSBsaXN0ZW5lciBzb2NrZXRzIGluIHRoZSByZXN1bHQsIHRoaXMgbGluZSB3b3VsZFxuICAgIC8vIGluc3RlYWQgc2F5XG4gICAgLy8gY29uc3QgYWxsU29ja2V0cyA9IHJlc29sdmVkSW5mby5saXN0ZW5lckNoaWxkcmVuLnNvY2tldHMuY29uY2F0KHJlc29sdmVkSW5mby5zZXNzaW9uQ2hpbGRyZW4uc29ja2V0cykuc29ydCgocmVmMSwgcmVmMikgPT4gcmVmMS5pZCAtIHJlZjIuaWQpO1xuICAgIGNvbnN0IGFsbFNvY2tldHMgPSByZXNvbHZlZEluZm8uc2Vzc2lvbkNoaWxkcmVuLnNvY2tldHMuc29ydCgocmVmMSwgcmVmMikgPT4gcmVmMS5pZCAtIHJlZjIuaWQpO1xuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBhbGxTb2NrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbGxTb2NrZXRzW2ldLmlkID49IHN0YXJ0SWQpIHtcbiAgICAgICAgICAgIHJlc3VsdExpc3QucHVzaChzb2NrZXRSZWZUb01lc3NhZ2UoYWxsU29ja2V0c1tpXSkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdExpc3QubGVuZ3RoID49IG1heFJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHNvY2tldF9yZWY6IHJlc3VsdExpc3QsXG4gICAgICAgIGVuZDogaSA+PSBhbGxTb2NrZXRzLmxlbmd0aCxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWx6SGFuZGxlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgR2V0Q2hhbm5lbCxcbiAgICAgICAgR2V0VG9wQ2hhbm5lbHMsXG4gICAgICAgIEdldFNlcnZlcixcbiAgICAgICAgR2V0U2VydmVycyxcbiAgICAgICAgR2V0U3ViY2hhbm5lbCxcbiAgICAgICAgR2V0U29ja2V0LFxuICAgICAgICBHZXRTZXJ2ZXJTb2NrZXRzLFxuICAgIH07XG59XG5leHBvcnRzLmdldENoYW5uZWx6SGFuZGxlcnMgPSBnZXRDaGFubmVsekhhbmRsZXJzO1xubGV0IGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbiA9IG51bGw7XG5mdW5jdGlvbiBnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uKCkge1xuICAgIGlmIChsb2FkZWRDaGFubmVsekRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbjtcbiAgICB9XG4gICAgLyogVGhlIHB1cnBvc2Ugb2YgdGhpcyBjb21wbGV4aXR5IGlzIHRvIGF2b2lkIGxvYWRpbmcgQGdycGMvcHJvdG8tbG9hZGVyIGF0XG4gICAgICogcnVudGltZSBmb3IgdXNlcnMgd2hvIHdpbGwgbm90IHVzZS9lbmFibGUgY2hhbm5lbHouICovXG4gICAgY29uc3QgbG9hZGVyTG9hZFN5bmMgPSByZXF1aXJlKCdAZ3JwYy9wcm90by1sb2FkZXInKVxuICAgICAgICAubG9hZFN5bmM7XG4gICAgY29uc3QgbG9hZGVkUHJvdG8gPSBsb2FkZXJMb2FkU3luYygnY2hhbm5lbHoucHJvdG8nLCB7XG4gICAgICAgIGtlZXBDYXNlOiB0cnVlLFxuICAgICAgICBsb25nczogU3RyaW5nLFxuICAgICAgICBlbnVtczogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0czogdHJ1ZSxcbiAgICAgICAgb25lb2ZzOiB0cnVlLFxuICAgICAgICBpbmNsdWRlRGlyczogW2Ake19fZGlybmFtZX0vLi4vLi4vcHJvdG9gXSxcbiAgICB9KTtcbiAgICBjb25zdCBjaGFubmVsekdycGNPYmplY3QgPSAoMCwgbWFrZV9jbGllbnRfMS5sb2FkUGFja2FnZURlZmluaXRpb24pKGxvYWRlZFByb3RvKTtcbiAgICBsb2FkZWRDaGFubmVsekRlZmluaXRpb24gPVxuICAgICAgICBjaGFubmVsekdycGNPYmplY3QuZ3JwYy5jaGFubmVsei52MS5DaGFubmVsei5zZXJ2aWNlO1xuICAgIHJldHVybiBsb2FkZWRDaGFubmVsekRlZmluaXRpb247XG59XG5leHBvcnRzLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24gPSBnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uO1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2UpKGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24sIGdldENoYW5uZWx6SGFuZGxlcnMpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbHouanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2V0dXAiLCJnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uIiwiZ2V0Q2hhbm5lbHpIYW5kbGVycyIsInVucmVnaXN0ZXJDaGFubmVselJlZiIsInJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQiLCJyZWdpc3RlckNoYW5uZWx6U2VydmVyIiwicmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwiLCJyZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCIsIkNoYW5uZWx6Q2FsbFRyYWNrZXIiLCJDaGFubmVsekNoaWxkcmVuVHJhY2tlciIsIkNoYW5uZWx6VHJhY2UiLCJuZXRfMSIsInJlcXVpcmUiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsImNvbnN0YW50c18xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJhZG1pbl8xIiwibWFrZV9jbGllbnRfMSIsImNoYW5uZWxSZWZUb01lc3NhZ2UiLCJyZWYiLCJjaGFubmVsX2lkIiwiaWQiLCJuYW1lIiwic3ViY2hhbm5lbFJlZlRvTWVzc2FnZSIsInN1YmNoYW5uZWxfaWQiLCJzZXJ2ZXJSZWZUb01lc3NhZ2UiLCJzZXJ2ZXJfaWQiLCJzb2NrZXRSZWZUb01lc3NhZ2UiLCJzb2NrZXRfaWQiLCJUQVJHRVRfUkVUQUlORURfVFJBQ0VTIiwiY29uc3RydWN0b3IiLCJldmVudHMiLCJldmVudHNMb2dnZWQiLCJjcmVhdGlvblRpbWVzdGFtcCIsIkRhdGUiLCJhZGRUcmFjZSIsInNldmVyaXR5IiwiZGVzY3JpcHRpb24iLCJjaGlsZCIsInRpbWVzdGFtcCIsInB1c2giLCJjaGlsZENoYW5uZWwiLCJraW5kIiwidW5kZWZpbmVkIiwiY2hpbGRTdWJjaGFubmVsIiwibGVuZ3RoIiwic2xpY2UiLCJnZXRUcmFjZU1lc3NhZ2UiLCJjcmVhdGlvbl90aW1lc3RhbXAiLCJkYXRlVG9Qcm90b1RpbWVzdGFtcCIsIm51bV9ldmVudHNfbG9nZ2VkIiwibWFwIiwiZXZlbnQiLCJjaGFubmVsX3JlZiIsInN1YmNoYW5uZWxfcmVmIiwiY2hhbm5lbENoaWxkcmVuIiwiTWFwIiwic3ViY2hhbm5lbENoaWxkcmVuIiwic29ja2V0Q2hpbGRyZW4iLCJyZWZDaGlsZCIsIl9hIiwiX2IiLCJfYyIsInRyYWNrZWRDaGlsZCIsImdldCIsImNvdW50Iiwic2V0IiwidW5yZWZDaGlsZCIsImRlbGV0ZSIsImdldENoaWxkTGlzdHMiLCJjaGFubmVscyIsInZhbHVlcyIsInN1YmNoYW5uZWxzIiwic29ja2V0cyIsImNhbGxzU3RhcnRlZCIsImNhbGxzU3VjY2VlZGVkIiwiY2FsbHNGYWlsZWQiLCJsYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAiLCJhZGRDYWxsU3RhcnRlZCIsImFkZENhbGxTdWNjZWVkZWQiLCJhZGRDYWxsRmFpbGVkIiwibmV4dElkIiwiZ2V0TmV4dElkIiwic2VydmVycyIsImdldEluZm8iLCJjaGFubmVsekVuYWJsZWQiLCJwYXJzZUlQdjZTZWN0aW9uIiwiYWRkcmVzc1NlY3Rpb24iLCJudW1iZXJWYWx1ZSIsIk51bWJlciIsInBhcnNlSW50IiwicGFyc2VJUHY2Q2h1bmsiLCJhZGRyZXNzQ2h1bmsiLCJieXRlUGFpcnMiLCJzcGxpdCIsInNlY3Rpb24iLCJyZXN1bHQiLCJjb25jYXQiLCJpcEFkZHJlc3NTdHJpbmdUb0J1ZmZlciIsImlwQWRkcmVzcyIsImlzSVB2NCIsIkJ1ZmZlciIsImZyb20iLCJVaW50OEFycmF5Iiwic2VnbWVudCIsImlzSVB2NiIsImxlZnRTZWN0aW9uIiwicmlnaHRTZWN0aW9uIiwiZG91YmxlQ29sb25JbmRleCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJsZWZ0QnVmZmVyIiwicmlnaHRCdWZmZXIiLCJtaWRkbGVCdWZmZXIiLCJhbGxvYyIsImNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlIiwic3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIkNPTk5FQ1RJTkciLCJJRExFIiwiUkVBRFkiLCJTSFVURE9XTiIsIlRSQU5TSUVOVF9GQUlMVVJFIiwiZGF0ZSIsIm1pbGxpc1NpbmNlRXBvY2giLCJnZXRUaW1lIiwic2Vjb25kcyIsIm5hbm9zIiwiZ2V0Q2hhbm5lbE1lc3NhZ2UiLCJjaGFubmVsRW50cnkiLCJyZXNvbHZlZEluZm8iLCJkYXRhIiwidGFyZ2V0IiwiY2FsbHNfc3RhcnRlZCIsImNhbGxUcmFja2VyIiwiY2FsbHNfc3VjY2VlZGVkIiwiY2FsbHNfZmFpbGVkIiwibGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wIiwidHJhY2UiLCJjaGlsZHJlbiIsIkdldENoYW5uZWwiLCJjYWxsIiwiY2FsbGJhY2siLCJjaGFubmVsSWQiLCJyZXF1ZXN0IiwiY29kZSIsIlN0YXR1cyIsIk5PVF9GT1VORCIsImRldGFpbHMiLCJjaGFubmVsIiwiR2V0VG9wQ2hhbm5lbHMiLCJtYXhSZXN1bHRzIiwibWF4X3Jlc3VsdHMiLCJyZXN1bHRMaXN0IiwiaSIsInN0YXJ0X2NoYW5uZWxfaWQiLCJlbmQiLCJnZXRTZXJ2ZXJNZXNzYWdlIiwic2VydmVyRW50cnkiLCJsaXN0ZW5fc29ja2V0IiwibGlzdGVuZXJDaGlsZHJlbiIsIkdldFNlcnZlciIsInNlcnZlcklkIiwic2VydmVyIiwiR2V0U2VydmVycyIsInN0YXJ0X3NlcnZlcl9pZCIsIkdldFN1YmNoYW5uZWwiLCJzdWJjaGFubmVsSWQiLCJzdWJjaGFubmVsRW50cnkiLCJzdWJjaGFubmVsTWVzc2FnZSIsInNvY2tldF9yZWYiLCJzdWJjaGFubmVsIiwic3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlIiwic3ViY2hhbm5lbEFkZHJlc3MiLCJpc1RjcFN1YmNoYW5uZWxBZGRyZXNzIiwiYWRkcmVzcyIsInRjcGlwX2FkZHJlc3MiLCJpcF9hZGRyZXNzIiwiaG9zdCIsInBvcnQiLCJ1ZHNfYWRkcmVzcyIsImZpbGVuYW1lIiwicGF0aCIsIkdldFNvY2tldCIsIl9kIiwiX2UiLCJzb2NrZXRJZCIsInNvY2tldEVudHJ5Iiwic2VjdXJpdHlNZXNzYWdlIiwic2VjdXJpdHkiLCJtb2RlbCIsInRscyIsImNpcGhlcl9zdWl0ZSIsImNpcGhlclN1aXRlU3RhbmRhcmROYW1lIiwic3RhbmRhcmRfbmFtZSIsIm90aGVyX25hbWUiLCJjaXBoZXJTdWl0ZU90aGVyTmFtZSIsImxvY2FsX2NlcnRpZmljYXRlIiwibG9jYWxDZXJ0aWZpY2F0ZSIsInJlbW90ZV9jZXJ0aWZpY2F0ZSIsInJlbW90ZUNlcnRpZmljYXRlIiwic29ja2V0TWVzc2FnZSIsImxvY2FsIiwibG9jYWxBZGRyZXNzIiwicmVtb3RlIiwicmVtb3RlQWRkcmVzcyIsInJlbW90ZV9uYW1lIiwicmVtb3RlTmFtZSIsImtlZXBfYWxpdmVzX3NlbnQiLCJrZWVwQWxpdmVzU2VudCIsInN0cmVhbXNfc3RhcnRlZCIsInN0cmVhbXNTdGFydGVkIiwic3RyZWFtc19zdWNjZWVkZWQiLCJzdHJlYW1zU3VjY2VlZGVkIiwic3RyZWFtc19mYWlsZWQiLCJzdHJlYW1zRmFpbGVkIiwibGFzdF9sb2NhbF9zdHJlYW1fY3JlYXRlZF90aW1lc3RhbXAiLCJsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibGFzdF9yZW1vdGVfc3RyZWFtX2NyZWF0ZWRfdGltZXN0YW1wIiwibGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXAiLCJtZXNzYWdlc19yZWNlaXZlZCIsIm1lc3NhZ2VzUmVjZWl2ZWQiLCJtZXNzYWdlc19zZW50IiwibWVzc2FnZXNTZW50IiwibGFzdF9tZXNzYWdlX3JlY2VpdmVkX3RpbWVzdGFtcCIsImxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAiLCJsYXN0X21lc3NhZ2Vfc2VudF90aW1lc3RhbXAiLCJsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAiLCJsb2NhbF9mbG93X2NvbnRyb2xfd2luZG93IiwibG9jYWxGbG93Q29udHJvbFdpbmRvdyIsInJlbW90ZV9mbG93X2NvbnRyb2xfd2luZG93IiwicmVtb3RlRmxvd0NvbnRyb2xXaW5kb3ciLCJzb2NrZXQiLCJHZXRTZXJ2ZXJTb2NrZXRzIiwic3RhcnRJZCIsInN0YXJ0X3NvY2tldF9pZCIsImFsbFNvY2tldHMiLCJzZXNzaW9uQ2hpbGRyZW4iLCJzb3J0IiwicmVmMSIsInJlZjIiLCJsb2FkZWRDaGFubmVsekRlZmluaXRpb24iLCJsb2FkZXJMb2FkU3luYyIsImxvYWRTeW5jIiwibG9hZGVkUHJvdG8iLCJrZWVwQ2FzZSIsImxvbmdzIiwiU3RyaW5nIiwiZW51bXMiLCJkZWZhdWx0cyIsIm9uZW9mcyIsImluY2x1ZGVEaXJzIiwiX19kaXJuYW1lIiwiY2hhbm5lbHpHcnBjT2JqZWN0IiwibG9hZFBhY2thZ2VEZWZpbml0aW9uIiwiZ3JwYyIsImNoYW5uZWx6IiwidjEiLCJDaGFubmVseiIsInNlcnZpY2UiLCJyZWdpc3RlckFkbWluU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */ class InterceptorConfigurationError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"InterceptorConfigurationError\";\n        Error.captureStackTrace(this, InterceptorConfigurationError);\n    }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n    constructor(){\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveStatus(onReceiveStatus) {\n        this.status = onReceiveStatus;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveStatus: this.status\n        };\n    }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n    constructor(){\n        this.start = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withHalfClose(halfClose) {\n        this.halfClose = halfClose;\n        return this;\n    }\n    withCancel(cancel) {\n        this.cancel = cancel;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMessage: this.message,\n            halfClose: this.halfClose,\n            cancel: this.cancel\n        };\n    }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */ const defaultListener = {\n    onReceiveMetadata: (metadata, next)=>{\n        next(metadata);\n    },\n    onReceiveMessage: (message, next)=>{\n        next(message);\n    },\n    onReceiveStatus: (status, next)=>{\n        next(status);\n    }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */ const defaultRequester = {\n    start: (metadata, listener, next)=>{\n        next(metadata, listener);\n    },\n    sendMessage: (message, next)=>{\n        next(message);\n    },\n    halfClose: (next)=>{\n        next();\n    },\n    cancel: (next)=>{\n        next();\n    }\n};\nclass InterceptingCall {\n    constructor(nextCall, requester){\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        /**\n         * Indicates that metadata has been passed to the requester's start\n         * method but it has not been passed to the corresponding next callback\n         */ this.processingMetadata = false;\n        /**\n         * Message context for a pending message that is waiting for\n         */ this.pendingMessageContext = null;\n        /**\n         * Indicates that a message has been passed to the requester's sendMessage\n         * method but it has not been passed to the corresponding next callback\n         */ this.processingMessage = false;\n        /**\n         * Indicates that a status was received but could not be propagated because\n         * a message was still being processed.\n         */ this.pendingHalfClose = false;\n        if (requester) {\n            this.requester = {\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n            };\n        } else {\n            this.requester = defaultRequester;\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.requester.cancel(()=>{\n            this.nextCall.cancelWithStatus(status, details);\n        });\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    processPendingMessage() {\n        if (this.pendingMessageContext) {\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n            this.pendingMessageContext = null;\n            this.pendingMessage = null;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.pendingHalfClose) {\n            this.nextCall.halfClose();\n        }\n    }\n    start(metadata, interceptingListener) {\n        var _a, _b, _c, _d, _e, _f;\n        const fullInterceptingListener = {\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata)=>{},\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message)=>{},\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status)=>{}\n        };\n        this.processingMetadata = true;\n        this.requester.start(metadata, fullInterceptingListener, (md, listener)=>{\n            var _a, _b, _c;\n            this.processingMetadata = false;\n            let finalInterceptingListener;\n            if ((0, call_interface_1.isInterceptingListener)(listener)) {\n                finalInterceptingListener = listener;\n            } else {\n                const fullListener = {\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n                };\n                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n            }\n            this.nextCall.start(md, finalInterceptingListener);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        this.processingMessage = true;\n        this.requester.sendMessage(message, (finalMessage)=>{\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessageContext = context;\n                this.pendingMessage = message;\n            } else {\n                this.nextCall.sendMessageWithContext(context, finalMessage);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    halfClose() {\n        this.requester.halfClose(()=>{\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingHalfClose = true;\n            } else {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n    var _a, _b;\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n    const host = options.host;\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n    const propagateFlags = options.propagate_flags;\n    const credentials = options.credentials;\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n    if (credentials) {\n        call.setCredentials(credentials);\n    }\n    return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */ class BaseInterceptingCall {\n    constructor(call, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    methodDefinition){\n        this.call = call;\n        this.methodDefinition = methodDefinition;\n    }\n    cancelWithStatus(status, details) {\n        this.call.cancelWithStatus(status, details);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        let serialized;\n        try {\n            serialized = this.methodDefinition.requestSerialize(message);\n        } catch (e) {\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);\n            return;\n        }\n        this.call.sendMessageWithContext(context, serialized);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    start(metadata, interceptingListener) {\n        let readError = null;\n        this.call.start(metadata, {\n            onReceiveMetadata: (metadata)=>{\n                var _a;\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n            },\n            onReceiveMessage: (message)=>{\n                var _a;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let deserialized;\n                try {\n                    deserialized = this.methodDefinition.responseDeserialize(message);\n                } catch (e) {\n                    readError = {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,\n                        metadata: new metadata_1.Metadata()\n                    };\n                    this.call.cancelWithStatus(readError.code, readError.details);\n                    return;\n                }\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n            },\n            onReceiveStatus: (status)=>{\n                var _a, _b;\n                if (readError) {\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n                } else {\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n                }\n            }\n        });\n    }\n    startRead() {\n        this.call.startRead();\n    }\n    halfClose() {\n        this.call.halfClose();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */ class BaseUnaryInterceptingCall extends BaseInterceptingCall {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(call, methodDefinition){\n        super(call, methodDefinition);\n    }\n    start(metadata, listener) {\n        var _a, _b;\n        let receivedMessage = false;\n        const wrapperListener = {\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata)=>{},\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage: (message)=>{\n                var _a;\n                receivedMessage = true;\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n            },\n            onReceiveStatus: (status)=>{\n                var _a, _b;\n                if (!receivedMessage) {\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n                }\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n            }\n        };\n        super.start(metadata, wrapperListener);\n        this.call.startRead();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */ class BaseStreamingInterceptingCall extends BaseInterceptingCall {\n}\nfunction getBottomInterceptingCall(channel, options, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n    const call = getCall(channel, methodDefinition.path, options);\n    if (methodDefinition.responseStream) {\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\n    } else {\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\n    }\n}\nfunction getInterceptingCall(interceptorArgs, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n    if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError(\"Both interceptors and interceptor_providers were passed as options \" + \"to the client constructor. Only one of these is allowed.\");\n    }\n    if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError(\"Both interceptors and interceptor_providers were passed as call \" + \"options. Only one of these is allowed.\");\n    }\n    let interceptors = [];\n    // Interceptors passed to the call override interceptors passed to the client constructor\n    if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider)=>provider(methodDefinition))).filter((interceptor)=>interceptor);\n    // Filter out falsy values when providers return nothing\n    } else {\n        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider)=>provider(methodDefinition))).filter((interceptor)=>interceptor);\n    // Filter out falsy values when providers return nothing\n    }\n    const interceptorOptions = Object.assign({}, options, {\n        method_definition: methodDefinition\n    });\n    /* For each interceptor in the list, the nextCall function passed to it is\n     * based on the next interceptor in the list, using a nextCall function\n     * constructed with the following interceptor in the list, and so on. The\n     * initialValue, which is effectively at the end of the list, is a nextCall\n     * function that invokes getBottomInterceptingCall, the result of which\n     * handles (de)serialization and also gets the underlying call from the\n     * channel. */ const getCall = interceptors.reduceRight((nextCall, nextInterceptor)=>{\n        return (currentOptions)=>nextInterceptor(currentOptions, nextCall);\n    }, (finalOptions)=>getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n    return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall; //# sourceMappingURL=client-interceptors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUdBLHdCQUF3QixHQUFHQSx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUdBLHFDQUFxQyxHQUFHLEtBQUs7QUFDM0osTUFBTU8sYUFBYUMsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDbkQsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsc0VBQVM7QUFDakM7OztDQUdDLEdBQ0QsTUFBTUYsc0NBQXNDTTtJQUN4Q0MsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaSCxNQUFNSSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVWO0lBQ2xDO0FBQ0o7QUFDQU4scUNBQXFDLEdBQUdNO0FBQ3hDLE1BQU1EO0lBQ0ZRLGFBQWM7UUFDVixJQUFJLENBQUNJLFFBQVEsR0FBR0M7UUFDaEIsSUFBSSxDQUFDSixPQUFPLEdBQUdJO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdEO0lBQ2xCO0lBQ0FFLHNCQUFzQkMsaUJBQWlCLEVBQUU7UUFDckMsSUFBSSxDQUFDSixRQUFRLEdBQUdJO1FBQ2hCLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLHFCQUFxQkMsZ0JBQWdCLEVBQUU7UUFDbkMsSUFBSSxDQUFDVCxPQUFPLEdBQUdTO1FBQ2YsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsb0JBQW9CQyxlQUFlLEVBQUU7UUFDakMsSUFBSSxDQUFDTixNQUFNLEdBQUdNO1FBQ2QsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsUUFBUTtR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K0U7UUFDaEQsT0FBT0MsQ0FBQUEsaUJBQWtCRCxnQkFBZ0JDLGdCQUFnQmhGO0lBQzdELEdBQUcsQ0FBQ2lGLGVBQWlCcEIsMEJBQTBCOUIsU0FBU2tELGNBQWNwQztJQUN0RSxPQUFPZixRQUFRNkM7QUFDbkI7QUFDQWxILDJCQUEyQixHQUFHRSxxQkFDOUIsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcz8xMzBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLkludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBleHBvcnRzLkxpc3RlbmVyQnVpbGRlciA9IGV4cG9ydHMuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjYWxsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vY2FsbC1pbnRlcmZhY2VcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbi8qKlxuICogRXJyb3IgY2xhc3MgYXNzb2NpYXRlZCB3aXRoIHBhc3NpbmcgYm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yXG4gKiBwcm92aWRlcnMgdG8gYSBjbGllbnQgY29uc3RydWN0b3Igb3IgYXMgY2FsbCBvcHRpb25zLlxuICovXG5jbGFzcyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3InO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcik7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciA9IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yO1xuY2xhc3MgTGlzdGVuZXJCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2l0aE9uUmVjZWl2ZU1ldGFkYXRhKG9uUmVjZWl2ZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBvblJlY2VpdmVNZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVNZXNzYWdlKG9uUmVjZWl2ZU1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gb25SZWNlaXZlTWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVTdGF0dXMob25SZWNlaXZlU3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gb25SZWNlaXZlU3RhdHVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBMaXN0ZW5lckJ1aWxkZXI7XG5jbGFzcyBSZXF1ZXN0ZXJCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHdpdGhTdGFydChzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoU2VuZE1lc3NhZ2Uoc2VuZE1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gc2VuZE1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoSGFsZkNsb3NlKGhhbGZDbG9zZSkge1xuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IGhhbGZDbG9zZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhDYW5jZWwoY2FuY2VsKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBoYWxmQ2xvc2U6IHRoaXMuaGFsZkNsb3NlLFxuICAgICAgICAgICAgY2FuY2VsOiB0aGlzLmNhbmNlbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBSZXF1ZXN0ZXJCdWlsZGVyO1xuLyoqXG4gKiBBIExpc3RlbmVyIHdpdGggYSBkZWZhdWx0IHBhc3MtdGhyb3VnaCBpbXBsZW1lbnRhdGlvbiBvZiBlYWNoIG1ldGhvZC4gVXNlZFxuICogZm9yIGZpbGxpbmcgb3V0IExpc3RlbmVycyB3aXRoIHNvbWUgbWV0aG9kcyBvbWl0dGVkLlxuICovXG5jb25zdCBkZWZhdWx0TGlzdGVuZXIgPSB7XG4gICAgb25SZWNlaXZlTWV0YWRhdGE6IChtZXRhZGF0YSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1ldGFkYXRhKTtcbiAgICB9LFxuICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWVzc2FnZSk7XG4gICAgfSxcbiAgICBvblJlY2VpdmVTdGF0dXM6IChzdGF0dXMsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChzdGF0dXMpO1xuICAgIH0sXG59O1xuLyoqXG4gKiBBIFJlcXVlc3RlciB3aXRoIGEgZGVmYXVsdCBwYXNzLXRocm91Z2ggaW1wbGVtZW50YXRpb24gb2YgZWFjaCBtZXRob2QuIFVzZWRcbiAqIGZvciBmaWxsaW5nIG91dCBSZXF1ZXN0ZXJzIHdpdGggc29tZSBtZXRob2RzIG9taXR0ZWQuXG4gKi9cbmNvbnN0IGRlZmF1bHRSZXF1ZXN0ZXIgPSB7XG4gICAgc3RhcnQ6IChtZXRhZGF0YSwgbGlzdGVuZXIsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXRhZGF0YSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgc2VuZE1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWVzc2FnZSk7XG4gICAgfSxcbiAgICBoYWxmQ2xvc2U6IG5leHQgPT4ge1xuICAgICAgICBuZXh0KCk7XG4gICAgfSxcbiAgICBjYW5jZWw6IG5leHQgPT4ge1xuICAgICAgICBuZXh0KCk7XG4gICAgfSxcbn07XG5jbGFzcyBJbnRlcmNlcHRpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihuZXh0Q2FsbCwgcmVxdWVzdGVyKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5uZXh0Q2FsbCA9IG5leHRDYWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgbWV0YWRhdGEgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSByZXF1ZXN0ZXIncyBzdGFydFxuICAgICAgICAgKiBtZXRob2QgYnV0IGl0IGhhcyBub3QgYmVlbiBwYXNzZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgbmV4dCBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1lc3NhZ2UgY29udGV4dCBmb3IgYSBwZW5kaW5nIG1lc3NhZ2UgdGhhdCBpcyB3YWl0aW5nIGZvclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYSBtZXNzYWdlIGhhcyBiZWVuIHBhc3NlZCB0byB0aGUgcmVxdWVzdGVyJ3Mgc2VuZE1lc3NhZ2VcbiAgICAgICAgICogbWV0aG9kIGJ1dCBpdCBoYXMgbm90IGJlZW4gcGFzc2VkIHRvIHRoZSBjb3JyZXNwb25kaW5nIG5leHQgY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IGEgc3RhdHVzIHdhcyByZWNlaXZlZCBidXQgY291bGQgbm90IGJlIHByb3BhZ2F0ZWQgYmVjYXVzZVxuICAgICAgICAgKiBhIG1lc3NhZ2Ugd2FzIHN0aWxsIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IGZhbHNlO1xuICAgICAgICBpZiAocmVxdWVzdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RlciA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogKF9hID0gcmVxdWVzdGVyLnN0YXJ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0UmVxdWVzdGVyLnN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlOiAoX2IgPSByZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRSZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgaGFsZkNsb3NlOiAoX2MgPSByZXF1ZXN0ZXIuaGFsZkNsb3NlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0UmVxdWVzdGVyLmhhbGZDbG9zZSxcbiAgICAgICAgICAgICAgICBjYW5jZWw6IChfZCA9IHJlcXVlc3Rlci5jYW5jZWwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRSZXF1ZXN0ZXIuY2FuY2VsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVyID0gZGVmYXVsdFJlcXVlc3RlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5jYW5jZWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQodGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQsIHRoaXMucGVuZGluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdIYWxmQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGludGVyY2VwdGluZ0xpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCBmdWxsSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9iID0gKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChpbnRlcmNlcHRpbmdMaXN0ZW5lcikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChtZXRhZGF0YSA9PiB7IH0pLFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9kID0gKF9jID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iaW5kKGludGVyY2VwdGluZ0xpc3RlbmVyKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKG1lc3NhZ2UgPT4geyB9KSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKF9mID0gKF9lID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmJpbmQoaW50ZXJjZXB0aW5nTGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAoc3RhdHVzID0+IHsgfSksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuc3RhcnQobWV0YWRhdGEsIGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lciwgKG1kLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXI7XG4gICAgICAgICAgICBpZiAoKDAsIGNhbGxfaW50ZXJmYWNlXzEuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lcikobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbExpc3RlbmVyID0ge1xuICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9hID0gbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9iID0gbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKF9jID0gbGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0TGlzdGVuZXIub25SZWNlaXZlU3RhdHVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IG5ldyBjYWxsX2ludGVyZmFjZV8xLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbChmdWxsTGlzdGVuZXIsIGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnN0YXJ0KG1kLCBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSwgZmluYWxNZXNzYWdlID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBmaW5hbE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe30sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMubmV4dENhbGwuc3RhcnRSZWFkKCk7XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuaGFsZkNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSB8fCB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dENhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJjZXB0aW5nQ2FsbCA9IEludGVyY2VwdGluZ0NhbGw7XG5mdW5jdGlvbiBnZXRDYWxsKGNoYW5uZWwsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRlYWRsaW5lID0gKF9hID0gb3B0aW9ucy5kZWFkbGluZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSW5maW5pdHk7XG4gICAgY29uc3QgaG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgICBjb25zdCBwYXJlbnQgPSAoX2IgPSBvcHRpb25zLnBhcmVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICBjb25zdCBwcm9wYWdhdGVGbGFncyA9IG9wdGlvbnMucHJvcGFnYXRlX2ZsYWdzO1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscztcbiAgICBjb25zdCBjYWxsID0gY2hhbm5lbC5jcmVhdGVDYWxsKHBhdGgsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnQsIHByb3BhZ2F0ZUZsYWdzKTtcbiAgICBpZiAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY2FsbC5zZXRDcmVkZW50aWFscyhjcmVkZW50aWFscyk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsO1xufVxuLyoqXG4gKiBJbnRlcmNlcHRpbmdDYWxsIGltcGxlbWVudGF0aW9uIHRoYXQgZGlyZWN0bHkgb3ducyB0aGUgdW5kZXJseWluZyBDYWxsXG4gKiBvYmplY3QgYW5kIGhhbmRsZXMgc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJhaXpsaWF0aW9uLlxuICovXG5jbGFzcyBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBtZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0aG9kRGVmaW5pdGlvbiA9IG1ldGhvZERlZmluaXRpb247XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICBsZXQgc2VyaWFsaXplZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSB0aGlzLm1ldGhvZERlZmluaXRpb24ucmVxdWVzdFNlcmlhbGl6ZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCBgUmVxdWVzdCBtZXNzYWdlIHNlcmlhbGl6YXRpb24gZmFpbHVyZTogJHsoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGUpfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIHNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHt9LCBtZXNzYWdlKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGludGVyY2VwdGluZ0xpc3RlbmVyKSB7XG4gICAgICAgIGxldCByZWFkRXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbGwuc3RhcnQobWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiBtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplZCA9IHRoaXMubWV0aG9kRGVmaW5pdGlvbi5yZXNwb25zZURlc2VyaWFsaXplKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVzcG9uc2UgbWVzc2FnZSBwYXJzaW5nIGVycm9yOiAkeygwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZSl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGwuY2FuY2VsV2l0aFN0YXR1cyhyZWFkRXJyb3IuY29kZSwgcmVhZEVycm9yLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgZGVzZXJpYWxpemVkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAocmVhZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCByZWFkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHdpdGggc3BlY2lhbC1jYXNlZCBiZWhhdmlvciBmb3IgbWV0aG9kcyB3aXRoIHVuYXJ5XG4gKiByZXNwb25zZXMuXG4gKi9cbmNsYXNzIEJhc2VVbmFyeUludGVyY2VwdGluZ0NhbGwgZXh0ZW5kcyBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBtZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHN1cGVyKGNhbGwsIG1ldGhvZERlZmluaXRpb24pO1xuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlY2VpdmVkTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCB3cmFwcGVyTGlzdGVuZXIgPSB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9iID0gKF9hID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChsaXN0ZW5lcikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChtZXRhZGF0YSA9PiB7IH0pLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgKF9hID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVyLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmICghcmVjZWl2ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChsaXN0ZW5lciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYiA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGxpc3RlbmVyLCBzdGF0dXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIuc3RhcnQobWV0YWRhdGEsIHdyYXBwZXJMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHdpdGggc3BlY2lhbC1jYXNlZCBiZWhhdmlvciBmb3IgbWV0aG9kcyB3aXRoIHN0cmVhbWluZ1xuICogcmVzcG9uc2VzLlxuICovXG5jbGFzcyBCYXNlU3RyZWFtaW5nSW50ZXJjZXB0aW5nQ2FsbCBleHRlbmRzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcbn1cbmZ1bmN0aW9uIGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwoY2hhbm5lbCwgb3B0aW9ucywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubWV0aG9kRGVmaW5pdGlvbikge1xuICAgIGNvbnN0IGNhbGwgPSBnZXRDYWxsKGNoYW5uZWwsIG1ldGhvZERlZmluaXRpb24ucGF0aCwgb3B0aW9ucyk7XG4gICAgaWYgKG1ldGhvZERlZmluaXRpb24ucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlU3RyZWFtaW5nSW50ZXJjZXB0aW5nQ2FsbChjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZVVuYXJ5SW50ZXJjZXB0aW5nQ2FsbChjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbnRlcmNlcHRpbmdDYWxsKGludGVyY2VwdG9yQXJncywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubWV0aG9kRGVmaW5pdGlvbiwgb3B0aW9ucywgY2hhbm5lbCkge1xuICAgIGlmIChpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIG9wdGlvbnMgJyArXG4gICAgICAgICAgICAndG8gdGhlIGNsaWVudCBjb25zdHJ1Y3Rvci4gT25seSBvbmUgb2YgdGhlc2UgaXMgYWxsb3dlZC4nKTtcbiAgICB9XG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvclByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcignQm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yX3Byb3ZpZGVycyB3ZXJlIHBhc3NlZCBhcyBjYWxsICcgK1xuICAgICAgICAgICAgJ29wdGlvbnMuIE9ubHkgb25lIG9mIHRoZXNlIGlzIGFsbG93ZWQuJyk7XG4gICAgfVxuICAgIGxldCBpbnRlcmNlcHRvcnMgPSBbXTtcbiAgICAvLyBJbnRlcmNlcHRvcnMgcGFzc2VkIHRvIHRoZSBjYWxsIG92ZXJyaWRlIGludGVyY2VwdG9ycyBwYXNzZWQgdG8gdGhlIGNsaWVudCBjb25zdHJ1Y3RvclxuICAgIGlmIChpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9ycy5sZW5ndGggPiAwIHx8XG4gICAgICAgIGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpbnRlcmNlcHRvcnMgPSBbXVxuICAgICAgICAgICAgLmNvbmNhdChpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9ycywgaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvclByb3ZpZGVycy5tYXAocHJvdmlkZXIgPT4gcHJvdmlkZXIobWV0aG9kRGVmaW5pdGlvbikpKVxuICAgICAgICAgICAgLmZpbHRlcihpbnRlcmNlcHRvciA9PiBpbnRlcmNlcHRvcik7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgZmFsc3kgdmFsdWVzIHdoZW4gcHJvdmlkZXJzIHJldHVybiBub3RoaW5nXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnRlcmNlcHRvcnMgPSBbXVxuICAgICAgICAgICAgLmNvbmNhdChpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JzLCBpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnMubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyKG1ldGhvZERlZmluaXRpb24pKSlcbiAgICAgICAgICAgIC5maWx0ZXIoaW50ZXJjZXB0b3IgPT4gaW50ZXJjZXB0b3IpO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IGZhbHN5IHZhbHVlcyB3aGVuIHByb3ZpZGVycyByZXR1cm4gbm90aGluZ1xuICAgIH1cbiAgICBjb25zdCBpbnRlcmNlcHRvck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIG1ldGhvZF9kZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgIH0pO1xuICAgIC8qIEZvciBlYWNoIGludGVyY2VwdG9yIGluIHRoZSBsaXN0LCB0aGUgbmV4dENhbGwgZnVuY3Rpb24gcGFzc2VkIHRvIGl0IGlzXG4gICAgICogYmFzZWQgb24gdGhlIG5leHQgaW50ZXJjZXB0b3IgaW4gdGhlIGxpc3QsIHVzaW5nIGEgbmV4dENhbGwgZnVuY3Rpb25cbiAgICAgKiBjb25zdHJ1Y3RlZCB3aXRoIHRoZSBmb2xsb3dpbmcgaW50ZXJjZXB0b3IgaW4gdGhlIGxpc3QsIGFuZCBzbyBvbi4gVGhlXG4gICAgICogaW5pdGlhbFZhbHVlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0LCBpcyBhIG5leHRDYWxsXG4gICAgICogZnVuY3Rpb24gdGhhdCBpbnZva2VzIGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwsIHRoZSByZXN1bHQgb2Ygd2hpY2hcbiAgICAgKiBoYW5kbGVzIChkZSlzZXJpYWxpemF0aW9uIGFuZCBhbHNvIGdldHMgdGhlIHVuZGVybHlpbmcgY2FsbCBmcm9tIHRoZVxuICAgICAqIGNoYW5uZWwuICovXG4gICAgY29uc3QgZ2V0Q2FsbCA9IGludGVyY2VwdG9ycy5yZWR1Y2VSaWdodCgobmV4dENhbGwsIG5leHRJbnRlcmNlcHRvcikgPT4ge1xuICAgICAgICByZXR1cm4gY3VycmVudE9wdGlvbnMgPT4gbmV4dEludGVyY2VwdG9yKGN1cnJlbnRPcHRpb25zLCBuZXh0Q2FsbCk7XG4gICAgfSwgKGZpbmFsT3B0aW9ucykgPT4gZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbChjaGFubmVsLCBmaW5hbE9wdGlvbnMsIG1ldGhvZERlZmluaXRpb24pKTtcbiAgICByZXR1cm4gZ2V0Q2FsbChpbnRlcmNlcHRvck9wdGlvbnMpO1xufVxuZXhwb3J0cy5nZXRJbnRlcmNlcHRpbmdDYWxsID0gZ2V0SW50ZXJjZXB0aW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC1pbnRlcmNlcHRvcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0SW50ZXJjZXB0aW5nQ2FsbCIsIkludGVyY2VwdGluZ0NhbGwiLCJSZXF1ZXN0ZXJCdWlsZGVyIiwiTGlzdGVuZXJCdWlsZGVyIiwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IiLCJtZXRhZGF0YV8xIiwicmVxdWlyZSIsImNhbGxfaW50ZXJmYWNlXzEiLCJjb25zdGFudHNfMSIsImVycm9yXzEiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm5hbWUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm1ldGFkYXRhIiwidW5kZWZpbmVkIiwic3RhdHVzIiwid2l0aE9uUmVjZWl2ZU1ldGFkYXRhIiwib25SZWNlaXZlTWV0YWRhdGEiLCJ3aXRoT25SZWNlaXZlTWVzc2FnZSIsIm9uUmVjZWl2ZU1lc3NhZ2UiLCJ3aXRoT25SZWNlaXZlU3RhdHVzIiwib25SZWNlaXZlU3RhdHVzIiwiYnVpbGQiLCJzdGFydCIsImhhbGZDbG9zZSIsImNhbmNlbCIsIndpdGhTdGFydCIsIndpdGhTZW5kTWVzc2FnZSIsInNlbmRNZXNzYWdlIiwid2l0aEhhbGZDbG9zZSIsIndpdGhDYW5jZWwiLCJkZWZhdWx0TGlzdGVuZXIiLCJuZXh0IiwiZGVmYXVsdFJlcXVlc3RlciIsImxpc3RlbmVyIiwibmV4dENhbGwiLCJyZXF1ZXN0ZXIiLCJfYSIsIl9iIiwiX2MiLCJfZCIsInByb2Nlc3NpbmdNZXRhZGF0YSIsInBlbmRpbmdNZXNzYWdlQ29udGV4dCIsInByb2Nlc3NpbmdNZXNzYWdlIiwicGVuZGluZ0hhbGZDbG9zZSIsImNhbmNlbFdpdGhTdGF0dXMiLCJkZXRhaWxzIiwiZ2V0UGVlciIsInByb2Nlc3NQZW5kaW5nTWVzc2FnZSIsInNlbmRNZXNzYWdlV2l0aENvbnRleHQiLCJwZW5kaW5nTWVzc2FnZSIsInByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlIiwiaW50ZXJjZXB0aW5nTGlzdGVuZXIiLCJfZSIsIl9mIiwiZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyIiwiYmluZCIsIm1kIiwiZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciIsImlzSW50ZXJjZXB0aW5nTGlzdGVuZXIiLCJmdWxsTGlzdGVuZXIiLCJJbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwiLCJjb250ZXh0IiwiZmluYWxNZXNzYWdlIiwic3RhcnRSZWFkIiwiZ2V0Q2FsbCIsImNoYW5uZWwiLCJwYXRoIiwib3B0aW9ucyIsImRlYWRsaW5lIiwiSW5maW5pdHkiLCJob3N0IiwicGFyZW50IiwicHJvcGFnYXRlRmxhZ3MiLCJwcm9wYWdhdGVfZmxhZ3MiLCJjcmVkZW50aWFscyIsImNhbGwiLCJjcmVhdGVDYWxsIiwic2V0Q3JlZGVudGlhbHMiLCJCYXNlSW50ZXJjZXB0aW5nQ2FsbCIsIm1ldGhvZERlZmluaXRpb24iLCJzZXJpYWxpemVkIiwicmVxdWVzdFNlcmlhbGl6ZSIsImUiLCJTdGF0dXMiLCJJTlRFUk5BTCIsImdldEVycm9yTWVzc2FnZSIsInJlYWRFcnJvciIsImRlc2VyaWFsaXplZCIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJjb2RlIiwiTWV0YWRhdGEiLCJCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsIiwicmVjZWl2ZWRNZXNzYWdlIiwid3JhcHBlckxpc3RlbmVyIiwiQmFzZVN0cmVhbWluZ0ludGVyY2VwdGluZ0NhbGwiLCJnZXRCb3R0b21JbnRlcmNlcHRpbmdDYWxsIiwicmVzcG9uc2VTdHJlYW0iLCJpbnRlcmNlcHRvckFyZ3MiLCJjbGllbnRJbnRlcmNlcHRvcnMiLCJsZW5ndGgiLCJjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVycyIsImNhbGxJbnRlcmNlcHRvcnMiLCJjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMiLCJpbnRlcmNlcHRvcnMiLCJjb25jYXQiLCJtYXAiLCJwcm92aWRlciIsImZpbHRlciIsImludGVyY2VwdG9yIiwiaW50ZXJjZXB0b3JPcHRpb25zIiwiYXNzaWduIiwibWV0aG9kX2RlZmluaXRpb24iLCJyZWR1Y2VSaWdodCIsIm5leHRJbnRlcmNlcHRvciIsImN1cnJlbnRPcHRpb25zIiwiZmluYWxPcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Client = void 0;\nconst call_1 = __webpack_require__(/*! ./call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js\");\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n    return typeof arg === \"function\";\n}\nfunction getErrorStackString(error) {\n    return error.stack.split(\"\\n\").slice(1).join(\"\\n\");\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */ class Client {\n    constructor(address, credentials, options = {}){\n        var _a, _b;\n        options = Object.assign({}, options);\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n        delete options.interceptors;\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n        delete options.interceptor_providers;\n        if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n            throw new Error(\"Both interceptors and interceptor_providers were passed as options \" + \"to the client constructor. Only one of these is allowed.\");\n        }\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;\n        delete options.callInvocationTransformer;\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        } else if (options.channelFactoryOverride) {\n            const channelFactoryOverride = options.channelFactoryOverride;\n            delete options.channelFactoryOverride;\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n        } else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err)=>{\n            if (err) {\n                callback(new Error(\"Failed to connect before the deadline\"));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            } catch (e) {\n                callback(new Error(\"The channel has been closed\"));\n                return;\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                callback();\n            } else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                } catch (e) {\n                    callback(new Error(\"The channel has been closed\"));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (isFunction(arg1)) {\n            return {\n                metadata: new metadata_1.Metadata(),\n                options: {},\n                callback: arg1\n            };\n        } else if (isFunction(arg2)) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return {\n                    metadata: arg1,\n                    options: {},\n                    callback: arg2\n                };\n            } else {\n                return {\n                    metadata: new metadata_1.Metadata(),\n                    options: arg1,\n                    callback: arg2\n                };\n            }\n        } else {\n            if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {\n                throw new Error(\"Incorrect arguments passed\");\n            }\n            return {\n                metadata: arg1,\n                options: arg2,\n                callback: arg3\n            };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientUnaryCallImpl(),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata)=>{\n                emitter.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, \"Too many responses received\");\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.INTERNAL,\n                            details: \"No message received\",\n                            metadata: status.metadata\n                        }, callerStack));\n                    } else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                } else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                emitter.emit(\"status\", status);\n            }\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return emitter;\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientWritableStreamImpl(serialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata)=>{\n                emitter.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, \"Too many responses received\");\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.INTERNAL,\n                            details: \"No message received\",\n                            metadata: status.metadata\n                        }, callerStack));\n                    } else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                } else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                emitter.emit(\"status\", status);\n            }\n        });\n        return emitter;\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            } else {\n                options = {};\n            }\n        } else {\n            if (arg1) {\n                options = arg1;\n            } else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return {\n            metadata,\n            options\n        };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientReadableStreamImpl(deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata (metadata) {\n                stream.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                stream.push(message);\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit(\"error\", (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                stream.emit(\"status\", status);\n            }\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return stream;\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata (metadata) {\n                stream.emit(\"metadata\", metadata);\n            },\n            onReceiveMessage (message) {\n                stream.push(message);\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit(\"error\", (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                stream.emit(\"status\", status);\n            }\n        });\n        return stream;\n    }\n}\nexports.Client = Client; //# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyxvRUFBUTtBQUMvQixNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQywwRUFBVztBQUNyQyxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNSSxhQUFhSixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSyx3QkFBd0JMLG1CQUFPQSxDQUFDLGtHQUF1QjtBQUM3RCxNQUFNTSxpQkFBaUJDO0FBQ3ZCLE1BQU1DLHFCQUFxQkQ7QUFDM0IsTUFBTUUsOEJBQThCRjtBQUNwQyxNQUFNRyxxQ0FBcUNIO0FBQzNDLFNBQVNJLFdBQVdDLEdBQUc7SUFDbkIsT0FBTyxPQUFPQSxRQUFRO0FBQzFCO0FBQ0EsU0FBU0Msb0JBQW9CQyxLQUFLO0lBQzlCLE9BQU9BLE1BQU1DLEtBQUssQ0FBQ0MsS0FBSyxDQUFDLE1BQU1DLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUM7QUFDakQ7QUFDQTs7O0NBR0MsR0FDRCxNQUFNcEI7SUFDRnFCLFlBQVlDLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQzVDLElBQUlDLElBQUlDO1FBQ1JGLFVBQVU1QixPQUFPK0IsTUFBTSxDQUFDLENBQUMsR0FBR0g7UUFDNUIsSUFBSSxDQUFDZCxtQkFBbUIsR0FBRyxDQUFDZSxLQUFLRCxRQUFRSSxZQUFZLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtRQUMxRixPQUFPRCxRQUFRSSxZQUFZO1FBQzNCLElBQUksQ0FBQ2pC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RTtRQUN6SDtRQUNBLE1BQU0yQyxPQUFPLENBQUMsR0FBRzlELHNCQUFzQndFLG1CQUFtQixFQUFFTCxpQkFBaUJOLGVBQWVOLGdCQUFnQixFQUFFTSxlQUFlSSxXQUFXLEVBQUVKLGVBQWVHLE9BQU87UUFDaEs7Ozs0QkFHb0IsR0FDcEJrQyxPQUFPcEMsSUFBSSxHQUFHQTtRQUNkLElBQUlZLGlCQUFpQjtRQUNyQixJQUFJQyxtQkFBbUIsSUFBSW5EO1FBQzNCc0MsS0FBS2MsS0FBSyxDQUFDZixlQUFlZCxRQUFRLEVBQUU7WUFDaEM4QixtQkFBa0I5QixRQUFRO2dCQUN0Qm1ELE9BQU9wQixJQUFJLENBQUMsWUFBWS9CO1lBQzVCO1lBQ0FnQyxrQkFBaUJDLE9BQU87Z0JBQ3BCa0IsT0FBT0MsSUFBSSxDQUFDbkI7WUFDaEI7WUFDQUksaUJBQWdCQyxNQUFNO2dCQUNsQixJQUFJWCxnQkFBZ0I7b0JBQ2hCO2dCQUNKO2dCQUNBQSxpQkFBaUI7Z0JBQ2pCd0IsT0FBT0MsSUFBSSxDQUFDO2dCQUNaLElBQUlkLE9BQU9DLElBQUksS0FBS3hGLFlBQVlvRixNQUFNLENBQUNLLEVBQUUsRUFBRTtvQkFDdkMsTUFBTUMsY0FBY2hGLG9CQUFvQm1FO29CQUN4Q3VCLE9BQU9wQixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUdwRixPQUFPK0YsbUJBQW1CLEVBQUVKLFFBQVFHO2dCQUNqRTtnQkFDQTs2Q0FDNkIsR0FDN0JiLG1CQUFtQjtnQkFDbkJ1QixPQUFPcEIsSUFBSSxDQUFDLFVBQVVPO1lBQzFCO1FBQ0o7UUFDQSxPQUFPYTtJQUNYO0FBQ0o7QUFDQTNHLGNBQWMsR0FBR0UsUUFDakIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzPzgyNjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgY2FsbF8xID0gcmVxdWlyZShcIi4vY2FsbFwiKTtcbmNvbnN0IGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgY2xpZW50X2ludGVyY2VwdG9yc18xID0gcmVxdWlyZShcIi4vY2xpZW50LWludGVyY2VwdG9yc1wiKTtcbmNvbnN0IENIQU5ORUxfU1lNQk9MID0gU3ltYm9sKCk7XG5jb25zdCBJTlRFUkNFUFRPUl9TWU1CT0wgPSBTeW1ib2woKTtcbmNvbnN0IElOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTCA9IFN5bWJvbCgpO1xuY29uc3QgQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTCA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGdldEVycm9yU3RhY2tTdHJpbmcoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDEpLmpvaW4oJ1xcbicpO1xufVxuLyoqXG4gKiBBIGdlbmVyaWMgZ1JQQyBjbGllbnQuIFByaW1hcmlseSB1c2VmdWwgYXMgYSBiYXNlIGNsYXNzIGZvciBhbGwgZ2VuZXJhdGVkXG4gKiBjbGllbnRzLlxuICovXG5jbGFzcyBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0gPSAoX2EgPSBvcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmludGVyY2VwdG9ycztcbiAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdID0gKF9iID0gb3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnM7XG4gICAgICAgIGlmICh0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yX3Byb3ZpZGVycyB3ZXJlIHBhc3NlZCBhcyBvcHRpb25zICcgK1xuICAgICAgICAgICAgICAgICd0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yLiBPbmx5IG9uZSBvZiB0aGVzZSBpcyBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0gPVxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyO1xuICAgICAgICBpZiAob3B0aW9ucy5jaGFubmVsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gb3B0aW9ucy5jaGFubmVsT3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRmFjdG9yeU92ZXJyaWRlID0gb3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2hhbm5lbEZhY3RvcnlPdmVycmlkZTtcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gY2hhbm5lbEZhY3RvcnlPdmVycmlkZShhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXSA9IG5ldyBjaGFubmVsXzEuQ2hhbm5lbEltcGxlbWVudGF0aW9uKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0uY2xvc2UoKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbQ0hBTk5FTF9TWU1CT0xdO1xuICAgIH1cbiAgICB3YWl0Rm9yUmVhZHkoZGVhZGxpbmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrU3RhdGUgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCBiZWZvcmUgdGhlIGRlYWRsaW5lJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXdTdGF0ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzW0NIQU5ORUxfU1lNQk9MXS5nZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUaGUgY2hhbm5lbCBoYXMgYmVlbiBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXS53YXRjaENvbm5lY3Rpdml0eVN0YXRlKG5ld1N0YXRlLCBkZWFkbGluZSwgY2hlY2tTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignVGhlIGNoYW5uZWwgaGFzIGJlZW4gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNoZWNrU3RhdGUpO1xuICAgIH1cbiAgICBjaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZzEpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSwgb3B0aW9uczoge30sIGNhbGxiYWNrOiBhcmcxIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihhcmcyKSkge1xuICAgICAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IGFyZzEsIG9wdGlvbnM6IHt9LCBjYWxsYmFjazogYXJnMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksIG9wdGlvbnM6IGFyZzEsIGNhbGxiYWNrOiBhcmcyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShhcmcxIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5NZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgIGFyZzIgaW5zdGFuY2VvZiBPYmplY3QgJiZcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGFyZzMpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGFyZ3VtZW50cyBwYXNzZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBhcmcxLCBvcHRpb25zOiBhcmcyLCBjYWxsYmFjazogYXJnMyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1ha2VVbmFyeVJlcXVlc3QobWV0aG9kLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBhcmd1bWVudCwgbWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzKG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnQsXG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50VW5hcnlDYWxsSW1wbCgpLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjaGVja2VkQXJndW1lbnRzLmNhbGxiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbCA9ICgwLCBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbCkoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cbiAgICAgICAgZW1pdHRlci5jYWxsID0gY2FsbDtcbiAgICAgICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgJ1RvbyBtYW55IHJlc3BvbnNlcyByZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBtZXNzYWdlIHJlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKG51bGwsIHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKShzdGF0dXMsIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIEF2b2lkIHJldGFpbmluZyB0aGUgY2FsbGVyU3RhY2tFcnJvciBvYmplY3QgaW4gdGhlIGNhbGwgY29udGV4dCBvZlxuICAgICAgICAgICAgICAgICAqIHRoZSBzdGF0dXMgZXZlbnQgaGFuZGxlci4gKi9cbiAgICAgICAgICAgICAgICBjYWxsZXJTdGFja0Vycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZShhcmd1bWVudCk7XG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgIH1cbiAgICBtYWtlQ2xpZW50U3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsKHNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNoZWNrZWRBcmd1bWVudHMuY2FsbGJhY2ssXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xuICAgICAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCAnVG9vIG1hbnkgcmVzcG9uc2VzIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ05vIG1lc3NhZ2UgcmVjZWl2ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0dXMubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICB9XG4gICAgY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMoYXJnMSwgYXJnMikge1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gYXJnMTtcbiAgICAgICAgICAgIGlmIChhcmcyKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1ldGFkYXRhLCBvcHRpb25zIH07XG4gICAgfVxuICAgIG1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgYXJndW1lbnQsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbChkZXNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBzdHJlYW0uY2FsbCA9IGNhbGw7XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsICgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBBdm9pZCByZXRhaW5pbmcgdGhlIGNhbGxlclN0YWNrRXJyb3Igb2JqZWN0IGluIHRoZSBjYWxsIGNvbnRleHQgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3RhdHVzIGV2ZW50IGhhbmRsZXIuICovXG4gICAgICAgICAgICAgICAgY2FsbGVyU3RhY2tFcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZShhcmd1bWVudCk7XG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIG1ha2VCaWRpU3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbChzZXJpYWxpemUsIGRlc2VyaWFsaXplKSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwpKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxuICAgICAgICAgKiBlbmZvcmNlIHRoaXMgd2l0aCB0aGUgdHlwZSBzeXN0ZW0uIFdlIG5lZWQgdG8gY29uc3RydWN0IHRoaXMgZW1pdHRlclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXG4gICAgICAgIHN0cmVhbS5jYWxsID0gY2FsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ21ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCAoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2xpZW50IiwiY2FsbF8xIiwicmVxdWlyZSIsImNoYW5uZWxfMSIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwiY29uc3RhbnRzXzEiLCJtZXRhZGF0YV8xIiwiY2xpZW50X2ludGVyY2VwdG9yc18xIiwiQ0hBTk5FTF9TWU1CT0wiLCJTeW1ib2wiLCJJTlRFUkNFUFRPUl9TWU1CT0wiLCJJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0wiLCJDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MIiwiaXNGdW5jdGlvbiIsImFyZyIsImdldEVycm9yU3RhY2tTdHJpbmciLCJlcnJvciIsInN0YWNrIiwic3BsaXQiLCJzbGljZSIsImpvaW4iLCJjb25zdHJ1Y3RvciIsImFkZHJlc3MiLCJjcmVkZW50aWFscyIsIm9wdGlvbnMiLCJfYSIsIl9iIiwiYXNzaWduIiwiaW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3JfcHJvdmlkZXJzIiwibGVuZ3RoIiwiRXJyb3IiLCJjYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyIiwiY2hhbm5lbE92ZXJyaWRlIiwiY2hhbm5lbEZhY3RvcnlPdmVycmlkZSIsIkNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNsb3NlIiwiZ2V0Q2hhbm5lbCIsIndhaXRGb3JSZWFkeSIsImRlYWRsaW5lIiwiY2FsbGJhY2siLCJjaGVja1N0YXRlIiwiZXJyIiwibmV3U3RhdGUiLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsImUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIlJFQURZIiwid2F0Y2hDb25uZWN0aXZpdHlTdGF0ZSIsInNldEltbWVkaWF0ZSIsImNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzIiwiYXJnMSIsImFyZzIiLCJhcmczIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsIm1ha2VVbmFyeVJlcXVlc3QiLCJtZXRob2QiLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsImFyZ3VtZW50IiwiY2hlY2tlZEFyZ3VtZW50cyIsIm1ldGhvZERlZmluaXRpb24iLCJwYXRoIiwicmVxdWVzdFN0cmVhbSIsInJlc3BvbnNlU3RyZWFtIiwicmVxdWVzdFNlcmlhbGl6ZSIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJjYWxsUHJvcGVydGllcyIsImNhbGwiLCJDbGllbnRVbmFyeUNhbGxJbXBsIiwiY2hhbm5lbCIsImNhbGxPcHRpb25zIiwiZW1pdHRlciIsImludGVyY2VwdG9yQXJncyIsImNsaWVudEludGVyY2VwdG9ycyIsImNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzIiwiY2FsbEludGVyY2VwdG9ycyIsImNhbGxJbnRlcmNlcHRvclByb3ZpZGVycyIsImdldEludGVyY2VwdGluZ0NhbGwiLCJyZXNwb25zZU1lc3NhZ2UiLCJyZWNlaXZlZFN0YXR1cyIsImNhbGxlclN0YWNrRXJyb3IiLCJzdGFydCIsIm9uUmVjZWl2ZU1ldGFkYXRhIiwiZW1pdCIsIm9uUmVjZWl2ZU1lc3NhZ2UiLCJtZXNzYWdlIiwiY2FuY2VsV2l0aFN0YXR1cyIsIlN0YXR1cyIsIklOVEVSTkFMIiwib25SZWNlaXZlU3RhdHVzIiwic3RhdHVzIiwiY29kZSIsIk9LIiwiY2FsbGVyU3RhY2siLCJjYWxsRXJyb3JGcm9tU3RhdHVzIiwiZGV0YWlscyIsInNlbmRNZXNzYWdlIiwiaGFsZkNsb3NlIiwibWFrZUNsaWVudFN0cmVhbVJlcXVlc3QiLCJDbGllbnRXcml0YWJsZVN0cmVhbUltcGwiLCJjaGVja01ldGFkYXRhQW5kT3B0aW9ucyIsIm1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0IiwiQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsIiwic3RyZWFtIiwicHVzaCIsIm1ha2VCaWRpU3RyZWFtUmVxdWVzdCIsIkNsaWVudER1cGxleFN0cmVhbUltcGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CompressionAlgorithms = void 0;\nvar CompressionAlgorithms;\n(function(CompressionAlgorithms) {\n    CompressionAlgorithms[CompressionAlgorithms[\"identity\"] = 0] = \"identity\";\n    CompressionAlgorithms[CompressionAlgorithms[\"deflate\"] = 1] = \"deflate\";\n    CompressionAlgorithms[CompressionAlgorithms[\"gzip\"] = 2] = \"gzip\";\n})(CompressionAlgorithms || (exports.CompressionAlgorithms = CompressionAlgorithms = {})); //# sourceMappingURL=compression-algorithms.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxJQUFJRTtBQUNILFVBQVVBLHFCQUFxQjtJQUM1QkEscUJBQXFCLENBQUNBLHFCQUFxQixDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDL0RBLHFCQUFxQixDQUFDQSxxQkFBcUIsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzlEQSxxQkFBcUIsQ0FBQ0EscUJBQXFCLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztBQUMvRCxHQUFHQSx5QkFBMEJGLENBQUFBLDZCQUE2QixHQUFHRSx3QkFBd0IsQ0FBQyxLQUN0RixrREFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzPzI5MjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcHJlc3Npb25BbGdvcml0aG1zID0gdm9pZCAwO1xudmFyIENvbXByZXNzaW9uQWxnb3JpdGhtcztcbihmdW5jdGlvbiAoQ29tcHJlc3Npb25BbGdvcml0aG1zKSB7XG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImlkZW50aXR5XCJdID0gMF0gPSBcImlkZW50aXR5XCI7XG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImRlZmxhdGVcIl0gPSAxXSA9IFwiZGVmbGF0ZVwiO1xuICAgIENvbXByZXNzaW9uQWxnb3JpdGhtc1tDb21wcmVzc2lvbkFsZ29yaXRobXNbXCJnemlwXCJdID0gMl0gPSBcImd6aXBcIjtcbn0pKENvbXByZXNzaW9uQWxnb3JpdGhtcyB8fCAoZXhwb3J0cy5Db21wcmVzc2lvbkFsZ29yaXRobXMgPSBDb21wcmVzc2lvbkFsZ29yaXRobXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb21wcmVzc2lvbkFsZ29yaXRobXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst isCompressionAlgorithmKey = (key)=>{\n    return typeof key === \"number\" && typeof compression_algorithms_1.CompressionAlgorithms[key] === \"string\";\n};\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */ async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */ async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */ output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.deflate(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.inflate(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.gzip(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.unzip(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName){\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName) {\n    switch(compressionName){\n        case \"identity\":\n            return new IdentityHandler();\n        case \"deflate\":\n            return new DeflateHandler();\n        case \"gzip\":\n            return new GzipHandler();\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor(channelOptions, sharedFilterConfig){\n        var _a;\n        super();\n        this.sharedFilterConfig = sharedFilterConfig;\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = \"identity\";\n        const compressionAlgorithmKey = channelOptions[\"grpc.default_compression_algorithm\"];\n        if (compressionAlgorithmKey !== undefined) {\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n                const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(\",\");\n                /**\n                 * There are two possible situations here:\n                 * 1) We don't have any info yet from the server about what compression it supports\n                 *    In that case we should just use what the client tells us to use\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\n                 */ if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);\n                }\n            } else {\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n            }\n        }\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set(\"grpc-accept-encoding\", \"identity,deflate,gzip\");\n        headers.set(\"accept-encoding\", \"identity\");\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n        if (this.currentCompressionAlgorithm === \"identity\") {\n            headers.remove(\"grpc-encoding\");\n        } else {\n            headers.set(\"grpc-encoding\", this.currentCompressionAlgorithm);\n        }\n        return headers;\n    }\n    receiveMetadata(metadata) {\n        const receiveEncoding = metadata.get(\"grpc-encoding\");\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === \"string\") {\n                this.receiveCompression = getCompressionHandler(encoding);\n            }\n        }\n        metadata.remove(\"grpc-encoding\");\n        /* Check to see if the compression we're using to send messages is supported by the server\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */ const serverSupportedEncodingsHeader = metadata.get(\"grpc-accept-encoding\")[0];\n        if (serverSupportedEncodingsHeader) {\n            this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(\",\");\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n                this.sendCompression = new IdentityHandler();\n                this.currentCompressionAlgorithm = \"identity\";\n            }\n        }\n        metadata.remove(\"grpc-accept-encoding\");\n        return metadata;\n    }\n    async sendMessage(message) {\n        var _a;\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */ const resolvedMessage = await message;\n        let compress;\n        if (this.sendCompression instanceof IdentityHandler) {\n            compress = false;\n        } else {\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* WriteFlags.NoCompress */ ) === 0;\n        }\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */ return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel, options){\n        this.options = options;\n        this.sharedFilterConfig = {};\n    }\n    createFilter() {\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory; //# sourceMappingURL=compression-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0NBQWdDLEdBQUdBLHlCQUF5QixHQUFHLEtBQUs7QUFDcEUsTUFBTUksT0FBT0MsbUJBQU9BLENBQUMsa0JBQU07QUFDM0IsTUFBTUMsMkJBQTJCRCxtQkFBT0EsQ0FBQyx3R0FBMEI7QUFDbkUsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUksVUFBVUosbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTUssNEJBQTRCLENBQUNDO0lBQy9CLE9BQVEsT0FBT0EsUUFBUSxZQUFZLE9BQU9MLHlCQUF5Qk0scUJBQXFCLENBQUNELElBQUksS0FBSztBQUN0RztBQUNBLE1BQU1FO0lBQ0Y7Ozs7S0FJQyxHQUNELE1BQU1DLGFBQWFDLE9BQU8sRUFBRUMsUUFBUSxFQUFFO1FBQ2xDLElBQUlDLGdCQUFnQkY7UUFDcEIsSUFBSUMsVUFBVTtZQUNWQyxnQkFBZ0IsTUFBTSxJQUFJLENBQUNDLGVBQWUsQ0FBQ0Q7UUFDL0M7UUFDQSxNQUFNRSxTQUFTQyxNQUFNQSxDQUFDQyxXQUFXLENBQUNKLGNBQWNLLE1BQU0sR0FBRztRQUN6REgsT0FBT0ksVUFBVSxDQUFDUCxXQUFXLElBQUksR0FBRztRQUNwQ0csT0FBT0ssYUFBYSxDQUFDUCxjQUFjSyxNQUFNLEVBQUU7UUFDM0NMLGNBQWNRLElBQUksQ0FBQ04sUUFBUTtRQUMzQixPQUFPQTtJQUNYO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTU8sWUFBWUMsSUFBSSxFQUFFO1FBQ3BCLE1BQU1DLGFBQWFELEtBQUtFLFNBQVMsQ0FBQyxPQUFPO1FBQ3pDLElBQUla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QUFPO1lBQ0hwQyxTQUFTLE1BQU0sSUFBSSxDQUFDcUMsZUFBZSxDQUFDdEMsWUFBWSxDQUFDOEQsZ0JBQWdCN0QsT0FBTyxFQUFFQztZQUMxRTZELE9BQU9ELGdCQUFnQkMsS0FBSztRQUNoQztJQUNKO0lBQ0EsTUFBTUMsZUFBZS9ELE9BQU8sRUFBRTtRQUMxQjs7O3lCQUdpQixHQUNqQixPQUFPLElBQUksQ0FBQ3NDLGtCQUFrQixDQUFDM0IsV0FBVyxDQUFDLE1BQU1YO0lBQ3JEO0FBQ0o7QUFDQWYseUJBQXlCLEdBQUdHO0FBQzVCLE1BQU1EO0lBQ0YyQyxZQUFZa0MsT0FBTyxFQUFFQyxPQUFPLENBQUU7UUFDMUIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDOUIsa0JBQWtCLEdBQUcsQ0FBQztJQUMvQjtJQUNBK0IsZUFBZTtRQUNYLE9BQU8sSUFBSTlFLGtCQUFrQixJQUFJLENBQUM2RSxPQUFPLEVBQUUsSUFBSSxDQUFDOUIsa0JBQWtCO0lBQ3RFO0FBQ0o7QUFDQWxELGdDQUFnQyxHQUFHRSwwQkFDbkMsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzPzc1ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlciA9IHZvaWQgMDtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWFsZ29yaXRobXNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGZpbHRlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBpc0NvbXByZXNzaW9uQWxnb3JpdGhtS2V5ID0gKGtleSkgPT4ge1xuICAgIHJldHVybiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMS5Db21wcmVzc2lvbkFsZ29yaXRobXNba2V5XSA9PT0gJ3N0cmluZycpO1xufTtcbmNsYXNzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgUmF3IHVuY29tcHJlc3NlZCBtZXNzYWdlIGJ5dGVzXG4gICAgICogQHBhcmFtIGNvbXByZXNzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtZXNzYWdlIHNob3VsZCBiZSBjb21wcmVzc2VkXG4gICAgICogQHJldHVybiBGcmFtZWQgbWVzc2FnZSwgY29tcHJlc3NlZCBpZiBhcHBsaWNhYmxlXG4gICAgICovXG4gICAgYXN5bmMgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIGNvbXByZXNzKSB7XG4gICAgICAgIGxldCBtZXNzYWdlQnVmZmVyID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGNvbXByZXNzKSB7XG4gICAgICAgICAgICBtZXNzYWdlQnVmZmVyID0gYXdhaXQgdGhpcy5jb21wcmVzc01lc3NhZ2UobWVzc2FnZUJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lc3NhZ2VCdWZmZXIubGVuZ3RoICsgNSk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KGNvbXByZXNzID8gMSA6IDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShtZXNzYWdlQnVmZmVyLmxlbmd0aCwgMSk7XG4gICAgICAgIG1lc3NhZ2VCdWZmZXIuY29weShvdXRwdXQsIDUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YSBGcmFtZWQgbWVzc2FnZSwgcG9zc2libHkgY29tcHJlc3NlZFxuICAgICAqIEByZXR1cm4gVW5jb21wcmVzc2VkIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyByZWFkTWVzc2FnZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSBkYXRhLnJlYWRVSW50OCgwKSA9PT0gMTtcbiAgICAgICAgbGV0IG1lc3NhZ2VCdWZmZXIgPSBkYXRhLnNsaWNlKDUpO1xuICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgbWVzc2FnZUJ1ZmZlciA9IGF3YWl0IHRoaXMuZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZUJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VCdWZmZXI7XG4gICAgfVxufVxuY2xhc3MgSWRlbnRpdHlIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBhc3luYyBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIGNvbXByZXNzKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXNzYWdlLmxlbmd0aCArIDUpO1xuICAgICAgICAvKiBXaXRoIFwiaWRlbnRpdHlcIiBjb21wcmVzc2lvbiwgbWVzc2FnZXMgc2hvdWxkIGFsd2F5cyBiZSBtYXJrZWQgYXNcbiAgICAgICAgICogdW5jb21wcmVzc2VkICovXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShtZXNzYWdlLmxlbmd0aCwgMSk7XG4gICAgICAgIG1lc3NhZ2UuY29weShvdXRwdXQsIDUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1JlY2VpdmVkIGNvbXByZXNzZWQgbWVzc2FnZSBidXQgXCJncnBjLWVuY29kaW5nXCIgaGVhZGVyIHdhcyBpZGVudGl0eScpKTtcbiAgICB9XG59XG5jbGFzcyBEZWZsYXRlSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHpsaWIuZGVmbGF0ZShtZXNzYWdlLCAoZXJyLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgemxpYi5pbmZsYXRlKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEd6aXBIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgemxpYi5nemlwKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB6bGliLnVuemlwKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVua25vd25IYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wcmVzc2lvbk5hbWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbk5hbWUgPSBjb21wcmVzc2lvbk5hbWU7XG4gICAgfVxuICAgIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFJlY2VpdmVkIG1lc3NhZ2UgY29tcHJlc3NlZCB3aXRoIHVuc3VwcG9ydGVkIGNvbXByZXNzaW9uIG1ldGhvZCAke3RoaXMuY29tcHJlc3Npb25OYW1lfWApKTtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB1bnJlYWNoYWJsZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBDb21wcmVzc2lvbiBtZXRob2Qgbm90IHN1cHBvcnRlZDogJHt0aGlzLmNvbXByZXNzaW9uTmFtZX1gKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKGNvbXByZXNzaW9uTmFtZSkge1xuICAgIHN3aXRjaCAoY29tcHJlc3Npb25OYW1lKSB7XG4gICAgICAgIGNhc2UgJ2lkZW50aXR5JzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgIGNhc2UgJ2RlZmxhdGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWZsYXRlSGFuZGxlcigpO1xuICAgICAgICBjYXNlICdnemlwJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3ppcEhhbmRsZXIoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5rbm93bkhhbmRsZXIoY29tcHJlc3Npb25OYW1lKTtcbiAgICB9XG59XG5jbGFzcyBDb21wcmVzc2lvbkZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxPcHRpb25zLCBzaGFyZWRGaWx0ZXJDb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyA9IHNoYXJlZEZpbHRlckNvbmZpZztcbiAgICAgICAgdGhpcy5zZW5kQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uID0gbmV3IElkZW50aXR5SGFuZGxlcigpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9ICdpZGVudGl0eSc7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5ID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMuZGVmYXVsdF9jb21wcmVzc2lvbl9hbGdvcml0aG0nXTtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzaW9uQWxnb3JpdGhtS2V5KGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFNlbGVjdGVkRW5jb2RpbmcgPSBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zW2NvbXByZXNzaW9uQWxnb3JpdGhtS2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgPSAoX2EgPSBzaGFyZWRGaWx0ZXJDb25maWcuc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdIZWFkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZXJlIGFyZSB0d28gcG9zc2libGUgc2l0dWF0aW9ucyBoZXJlOlxuICAgICAgICAgICAgICAgICAqIDEpIFdlIGRvbid0IGhhdmUgYW55IGluZm8geWV0IGZyb20gdGhlIHNlcnZlciBhYm91dCB3aGF0IGNvbXByZXNzaW9uIGl0IHN1cHBvcnRzXG4gICAgICAgICAgICAgICAgICogICAgSW4gdGhhdCBjYXNlIHdlIHNob3VsZCBqdXN0IHVzZSB3aGF0IHRoZSBjbGllbnQgdGVsbHMgdXMgdG8gdXNlXG4gICAgICAgICAgICAgICAgICogMikgV2UndmUgcHJldmlvdXNseSByZWNlaXZlZCBhIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciBpbmNsdWRpbmcgYSBncnBjLWFjY2VwdC1lbmNvZGluZyBoZWFkZXJcbiAgICAgICAgICAgICAgICAgKiAgICBJbiB0aGF0IGNhc2Ugd2Ugb25seSB3YW50IHRvIHVzZSB0aGUgZW5jb2RpbmcgY2hvc2VuIGJ5IHRoZSBjbGllbnQgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBpdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncy5pbmNsdWRlcyhjbGllbnRTZWxlY3RlZEVuY29kaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9IGNsaWVudFNlbGVjdGVkRW5jb2Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBJbnZhbGlkIHZhbHVlIHByb3ZpZGVkIGZvciBncnBjLmRlZmF1bHRfY29tcHJlc3Npb25fYWxnb3JpdGhtIG9wdGlvbjogJHtjb21wcmVzc2lvbkFsZ29yaXRobUtleX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IG1ldGFkYXRhO1xuICAgICAgICBoZWFkZXJzLnNldCgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHksZGVmbGF0ZSxnemlwJyk7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHknKTtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZW5kIHRoZSBoZWFkZXIgaWYgaXQncyBcImlkZW50aXR5XCIgLSAgYmVoYXZpb3IgaXMgaWRlbnRpY2FsOyBzYXZlIHRoZSBiYW5kd2lkdGhcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ2dycGMtZW5jb2RpbmcnLCB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCByZWNlaXZlRW5jb2RpbmcgPSBtZXRhZGF0YS5nZXQoJ2dycGMtZW5jb2RpbmcnKTtcbiAgICAgICAgaWYgKHJlY2VpdmVFbmNvZGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGluZyA9IHJlY2VpdmVFbmNvZGluZ1swXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlQ29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbkhhbmRsZXIoZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICAvKiBDaGVjayB0byBzZWUgaWYgdGhlIGNvbXByZXNzaW9uIHdlJ3JlIHVzaW5nIHRvIHNlbmQgbWVzc2FnZXMgaXMgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXJcbiAgICAgICAgICogSWYgbm90LCByZXNldCB0aGUgc2VuZENvbXByZXNzaW9uIGZpbHRlciBhbmQgaGF2ZSBpdCB1c2UgdGhlIGRlZmF1bHQgSWRlbnRpdHlIYW5kbGVyICovXG4gICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlciA9IG1ldGFkYXRhLmdldCgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKVswXTtcbiAgICAgICAgaWYgKHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcuc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdIZWFkZXIgPVxuICAgICAgICAgICAgICAgIHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyA9IHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgaWYgKCFzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MuaW5jbHVkZXModGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPSAnaWRlbnRpdHknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLyogVGhpcyBmaWx0ZXIgaXMgc3BlY2lhbC4gVGhlIGlucHV0IG1lc3NhZ2UgaXMgdGhlIGJhcmUgbWVzc2FnZSBieXRlcyxcbiAgICAgICAgICogYW5kIHRoZSBvdXRwdXQgaXMgYSBmcmFtZWQgYW5kIHBvc3NpYmx5IGNvbXByZXNzZWQgbWVzc2FnZS4gRm9yIHRoaXNcbiAgICAgICAgICogcmVhc29uLCB0aGlzIGZpbHRlciBzaG91bGQgYmUgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZmlsdGVyIHN0YWNrICovXG4gICAgICAgIGNvbnN0IHJlc29sdmVkTWVzc2FnZSA9IGF3YWl0IG1lc3NhZ2U7XG4gICAgICAgIGxldCBjb21wcmVzcztcbiAgICAgICAgaWYgKHRoaXMuc2VuZENvbXByZXNzaW9uIGluc3RhbmNlb2YgSWRlbnRpdHlIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcHJlc3MgPSAoKChfYSA9IHJlc29sdmVkTWVzc2FnZS5mbGFncykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgJiAyIC8qIFdyaXRlRmxhZ3MuTm9Db21wcmVzcyAqLykgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHRoaXMuc2VuZENvbXByZXNzaW9uLndyaXRlTWVzc2FnZShyZXNvbHZlZE1lc3NhZ2UubWVzc2FnZSwgY29tcHJlc3MpLFxuICAgICAgICAgICAgZmxhZ3M6IHJlc29sdmVkTWVzc2FnZS5mbGFncyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBUaGlzIGZpbHRlciBpcyBhbHNvIHNwZWNpYWwuIFRoZSBpbnB1dCBtZXNzYWdlIGlzIGZyYW1lZCBhbmQgcG9zc2libHlcbiAgICAgICAgICogY29tcHJlc3NlZCwgYW5kIHRoZSBvdXRwdXQgbWVzc2FnZSBpcyBkZWZyYW1lZCBhbmQgdW5jb21wcmVzc2VkLiBTb1xuICAgICAgICAgKiB0aGlzIGlzIGFub3RoZXIgcmVhc29uIHRoYXQgdGhpcyBmaWx0ZXIgc2hvdWxkIGJlIGF0IHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAgICAqIGZpbHRlciBzdGFjay4gKi9cbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uLnJlYWRNZXNzYWdlKGF3YWl0IG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXIgPSBDb21wcmVzc2lvbkZpbHRlcjtcbmNsYXNzIENvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyA9IHt9O1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcHJlc3Npb25GaWx0ZXIodGhpcy5vcHRpb25zLCB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkgPSBDb21wcmVzc2lvbkZpbHRlckZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2lvbi1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5IiwiQ29tcHJlc3Npb25GaWx0ZXIiLCJ6bGliIiwicmVxdWlyZSIsImNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSIsImNvbnN0YW50c18xIiwiZmlsdGVyXzEiLCJsb2dnaW5nIiwiaXNDb21wcmVzc2lvbkFsZ29yaXRobUtleSIsImtleSIsIkNvbXByZXNzaW9uQWxnb3JpdGhtcyIsIkNvbXByZXNzaW9uSGFuZGxlciIsIndyaXRlTWVzc2FnZSIsIm1lc3NhZ2UiLCJjb21wcmVzcyIsIm1lc3NhZ2VCdWZmZXIiLCJjb21wcmVzc01lc3NhZ2UiLCJvdXRwdXQiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImxlbmd0aCIsIndyaXRlVUludDgiLCJ3cml0ZVVJbnQzMkJFIiwiY29weSIsInJlYWRNZXNzYWdlIiwiZGF0YSIsImNvbXByZXNzZWQiLCJyZWFkVUludDgiLCJzbGljZSIsImRlY29tcHJlc3NNZXNzYWdlIiwiSWRlbnRpdHlIYW5kbGVyIiwiUHJvbWlzZSIsInJlamVjdCIsIkVycm9yIiwiRGVmbGF0ZUhhbmRsZXIiLCJyZXNvbHZlIiwiZGVmbGF0ZSIsImVyciIsImluZmxhdGUiLCJHemlwSGFuZGxlciIsImd6aXAiLCJ1bnppcCIsIlVua25vd25IYW5kbGVyIiwiY29uc3RydWN0b3IiLCJjb21wcmVzc2lvbk5hbWUiLCJnZXRDb21wcmVzc2lvbkhhbmRsZXIiLCJCYXNlRmlsdGVyIiwiY2hhbm5lbE9wdGlvbnMiLCJzaGFyZWRGaWx0ZXJDb25maWciLCJfYSIsInNlbmRDb21wcmVzc2lvbiIsInJlY2VpdmVDb21wcmVzc2lvbiIsImN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSIsImNvbXByZXNzaW9uQWxnb3JpdGhtS2V5IiwidW5kZWZpbmVkIiwiY2xpZW50U2VsZWN0ZWRFbmNvZGluZyIsInNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyIsInNlcnZlclN1cHBvcnRlZEVuY29kaW5nSGVhZGVyIiwic3BsaXQiLCJpbmNsdWRlcyIsImxvZyIsIkxvZ1ZlcmJvc2l0eSIsIkVSUk9SIiwic2VuZE1ldGFkYXRhIiwibWV0YWRhdGEiLCJoZWFkZXJzIiwic2V0IiwicmVtb3ZlIiwicmVjZWl2ZU1ldGFkYXRhIiwicmVjZWl2ZUVuY29kaW5nIiwiZ2V0IiwiZW5jb2RpbmciLCJzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIiLCJzZW5kTWVzc2FnZSIsInJlc29sdmVkTWVzc2FnZSIsImZsYWdzIiwicmVjZWl2ZU1lc3NhZ2UiLCJjaGFubmVsIiwib3B0aW9ucyIsImNyZWF0ZUZpbHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/connectivity-state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ConnectivityState = void 0;\nvar ConnectivityState;\n(function(ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState || (exports.ConnectivityState = ConnectivityState = {})); //# sourceMappingURL=connectivity-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pDLElBQUlFO0FBQ0gsVUFBVUEsaUJBQWlCO0lBQ3hCQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUNuREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDekRBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ3BEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQ2hFQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztBQUMzRCxHQUFHQSxxQkFBc0JGLENBQUFBLHlCQUF5QixHQUFHRSxvQkFBb0IsQ0FBQyxLQUMxRSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25uZWN0aXZpdHktc3RhdGUuanM/NGVlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25uZWN0aXZpdHlTdGF0ZSA9IHZvaWQgMDtcbnZhciBDb25uZWN0aXZpdHlTdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGl2aXR5U3RhdGUpIHtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIklETEVcIl0gPSAwXSA9IFwiSURMRVwiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiQ09OTkVDVElOR1wiXSA9IDFdID0gXCJDT05ORUNUSU5HXCI7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJSRUFEWVwiXSA9IDJdID0gXCJSRUFEWVwiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiVFJBTlNJRU5UX0ZBSUxVUkVcIl0gPSAzXSA9IFwiVFJBTlNJRU5UX0ZBSUxVUkVcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlNIVVRET1dOXCJdID0gNF0gPSBcIlNIVVRET1dOXCI7XG59KShDb25uZWN0aXZpdHlTdGF0ZSB8fCAoZXhwb3J0cy5Db25uZWN0aXZpdHlTdGF0ZSA9IENvbm5lY3Rpdml0eVN0YXRlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpdml0eS1zdGF0ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb25uZWN0aXZpdHlTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;\nvar Status;\n(function(Status) {\n    Status[Status[\"OK\"] = 0] = \"OK\";\n    Status[Status[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    Status[Status[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    Status[Status[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    Status[Status[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    Status[Status[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    Status[Status[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    Status[Status[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    Status[Status[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    Status[Status[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    Status[Status[\"ABORTED\"] = 10] = \"ABORTED\";\n    Status[Status[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    Status[Status[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    Status[Status[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    Status[Status[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    Status[Status[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n    Status[Status[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n})(Status || (exports.Status = Status = {}));\nvar LogVerbosity;\n(function(LogVerbosity) {\n    LogVerbosity[LogVerbosity[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogVerbosity[LogVerbosity[\"INFO\"] = 1] = \"INFO\";\n    LogVerbosity[LogVerbosity[\"ERROR\"] = 2] = \"ERROR\";\n    LogVerbosity[LogVerbosity[\"NONE\"] = 3] = \"NONE\";\n})(LogVerbosity || (exports.LogVerbosity = LogVerbosity = {}));\n/**\n * NOTE: This enum is not currently used in any implemented API in this\n * library. It is included only for type parity with the other implementation.\n */ var Propagate;\n(function(Propagate) {\n    Propagate[Propagate[\"DEADLINE\"] = 1] = \"DEADLINE\";\n    Propagate[Propagate[\"CENSUS_STATS_CONTEXT\"] = 2] = \"CENSUS_STATS_CONTEXT\";\n    Propagate[Propagate[\"CENSUS_TRACING_CONTEXT\"] = 4] = \"CENSUS_TRACING_CONTEXT\";\n    Propagate[Propagate[\"CANCELLATION\"] = 8] = \"CANCELLATION\";\n    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\n    Propagate[Propagate[\"DEFAULTS\"] = 65535] = \"DEFAULTS\";\n})(Propagate || (exports.Propagate = Propagate = {}));\n// -1 means unlimited\nexports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\n// 4 MB default\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQ0FBMEMsR0FBR0EsdUNBQXVDLEdBQUdBLGlCQUFpQixHQUFHQSxvQkFBb0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDeEosSUFBSU07QUFDSCxVQUFVQSxNQUFNO0lBQ2JBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUc7SUFDM0JBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDbENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDaENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUN6Q0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQzFDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztJQUMxQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMscUJBQXFCLEdBQUcsRUFBRSxHQUFHO0lBQzNDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxzQkFBc0IsR0FBRyxFQUFFLEdBQUc7SUFDNUNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFVBQVUsR0FBRyxHQUFHLEdBQUc7SUFDakNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGVBQWUsR0FBRyxHQUFHLEdBQUc7SUFDdENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUN2Q0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUNsQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsY0FBYyxHQUFHLEdBQUcsR0FBRztJQUNyQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsWUFBWSxHQUFHLEdBQUcsR0FBRztJQUNuQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxHQUFHO0FBQzdDLEdBQUdBLFVBQVdOLENBQUFBLGNBQWMsR0FBR00sU0FBUyxDQUFDO0FBQ3pDLElBQUlEO0FBQ0gsVUFBVUEsWUFBWTtJQUNuQkEsWUFBWSxDQUFDQSxZQUFZLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUMxQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUN6Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUMxQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztBQUM3QyxHQUFHQSxnQkFBaUJMLENBQUFBLG9CQUFvQixHQUFHSyxlQUFlLENBQUM7QUFDM0Q7OztDQUdDLEdBQ0QsSUFBSUQ7QUFDSCxVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyx1QkFBdUIsR0FBRyxFQUFFLEdBQUc7SUFDbkRBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLHlCQUF5QixHQUFHLEVBQUUsR0FBRztJQUNyREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUMzQyw0RkFBNEY7SUFDNUZBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFdBQVcsR0FBRyxNQUFNLEdBQUc7QUFDL0MsR0FBR0EsYUFBY0osQ0FBQUEsaUJBQWlCLEdBQUdJLFlBQVksQ0FBQztBQUNsRCxxQkFBcUI7QUFDckJKLHVDQUF1QyxHQUFHLENBQUM7QUFDM0MsZUFBZTtBQUNmQSwwQ0FBMEMsR0FBRyxJQUFJLE9BQU8sTUFDeEQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzPzFjMmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCA9IGV4cG9ydHMuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCA9IGV4cG9ydHMuUHJvcGFnYXRlID0gZXhwb3J0cy5Mb2dWZXJib3NpdHkgPSBleHBvcnRzLlN0YXR1cyA9IHZvaWQgMDtcbnZhciBTdGF0dXM7XG4oZnVuY3Rpb24gKFN0YXR1cykge1xuICAgIFN0YXR1c1tTdGF0dXNbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJDQU5DRUxMRURcIl0gPSAxXSA9IFwiQ0FOQ0VMTEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOS05PV05cIl0gPSAyXSA9IFwiVU5LTk9XTlwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gM10gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiREVBRExJTkVfRVhDRUVERURcIl0gPSA0XSA9IFwiREVBRExJTkVfRVhDRUVERURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiTk9UX0ZPVU5EXCJdID0gNV0gPSBcIk5PVF9GT1VORFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJBTFJFQURZX0VYSVNUU1wiXSA9IDZdID0gXCJBTFJFQURZX0VYSVNUU1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJQRVJNSVNTSU9OX0RFTklFRFwiXSA9IDddID0gXCJQRVJNSVNTSU9OX0RFTklFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkZBSUxFRF9QUkVDT05ESVRJT05cIl0gPSA5XSA9IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJBQk9SVEVEXCJdID0gMTBdID0gXCJBQk9SVEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOSU1QTEVNRU5URURcIl0gPSAxMl0gPSBcIlVOSU1QTEVNRU5URURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiSU5URVJOQUxcIl0gPSAxM10gPSBcIklOVEVSTkFMXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJEQVRBX0xPU1NcIl0gPSAxNV0gPSBcIkRBVEFfTE9TU1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJVTkFVVEhFTlRJQ0FURURcIl0gPSAxNl0gPSBcIlVOQVVUSEVOVElDQVRFRFwiO1xufSkoU3RhdHVzIHx8IChleHBvcnRzLlN0YXR1cyA9IFN0YXR1cyA9IHt9KSk7XG52YXIgTG9nVmVyYm9zaXR5O1xuKGZ1bmN0aW9uIChMb2dWZXJib3NpdHkpIHtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiREVCVUdcIl0gPSAwXSA9IFwiREVCVUdcIjtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiSU5GT1wiXSA9IDFdID0gXCJJTkZPXCI7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIkVSUk9SXCJdID0gMl0gPSBcIkVSUk9SXCI7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIk5PTkVcIl0gPSAzXSA9IFwiTk9ORVwiO1xufSkoTG9nVmVyYm9zaXR5IHx8IChleHBvcnRzLkxvZ1ZlcmJvc2l0eSA9IExvZ1ZlcmJvc2l0eSA9IHt9KSk7XG4vKipcbiAqIE5PVEU6IFRoaXMgZW51bSBpcyBub3QgY3VycmVudGx5IHVzZWQgaW4gYW55IGltcGxlbWVudGVkIEFQSSBpbiB0aGlzXG4gKiBsaWJyYXJ5LiBJdCBpcyBpbmNsdWRlZCBvbmx5IGZvciB0eXBlIHBhcml0eSB3aXRoIHRoZSBvdGhlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xudmFyIFByb3BhZ2F0ZTtcbihmdW5jdGlvbiAoUHJvcGFnYXRlKSB7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkRFQURMSU5FXCJdID0gMV0gPSBcIkRFQURMSU5FXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19TVEFUU19DT05URVhUXCJdID0gMl0gPSBcIkNFTlNVU19TVEFUU19DT05URVhUXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19UUkFDSU5HX0NPTlRFWFRcIl0gPSA0XSA9IFwiQ0VOU1VTX1RSQUNJTkdfQ09OVEVYVFwiO1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDQU5DRUxMQVRJT05cIl0gPSA4XSA9IFwiQ0FOQ0VMTEFUSU9OXCI7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9pbmNsdWRlL2dycGMvaW1wbC9jb2RlZ2VuL3Byb3BhZ2F0aW9uX2JpdHMuaCNMNDNcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiREVGQVVMVFNcIl0gPSA2NTUzNV0gPSBcIkRFRkFVTFRTXCI7XG59KShQcm9wYWdhdGUgfHwgKGV4cG9ydHMuUHJvcGFnYXRlID0gUHJvcGFnYXRlID0ge30pKTtcbi8vIC0xIG1lYW5zIHVubGltaXRlZFxuZXhwb3J0cy5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIID0gLTE7XG4vLyA0IE1CIGRlZmF1bHRcbmV4cG9ydHMuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCA9IDQgKiAxMDI0ICogMTAyNDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIIiwiREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCIsIlByb3BhZ2F0ZSIsIkxvZ1ZlcmJvc2l0eSIsIlN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/control-plane-status.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.restrictControlPlaneStatusCode = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\n    constants_1.Status.OK,\n    constants_1.Status.INVALID_ARGUMENT,\n    constants_1.Status.NOT_FOUND,\n    constants_1.Status.ALREADY_EXISTS,\n    constants_1.Status.FAILED_PRECONDITION,\n    constants_1.Status.ABORTED,\n    constants_1.Status.OUT_OF_RANGE,\n    constants_1.Status.DATA_LOSS\n];\nfunction restrictControlPlaneStatusCode(code, details) {\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n        return {\n            code: constants_1.Status.INTERNAL,\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`\n        };\n    } else {\n        return {\n            code,\n            details\n        };\n    }\n}\nexports.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode; //# sourceMappingURL=control-plane-status.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29udHJvbC1wbGFuZS1zdGF0dXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNDQUFzQyxHQUFHLEtBQUs7QUFDOUMsTUFBTUcsY0FBY0MsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUMsb0NBQW9DO0lBQ3RDRixZQUFZRyxNQUFNLENBQUNDLEVBQUU7SUFDckJKLFlBQVlHLE1BQU0sQ0FBQ0UsZ0JBQWdCO0lBQ25DTCxZQUFZRyxNQUFNLENBQUNHLFNBQVM7SUFDNUJOLFlBQVlHLE1BQU0sQ0FBQ0ksY0FBYztJQUNqQ1AsWUFBWUcsTUFBTSxDQUFDSyxtQkFBbUI7SUFDdENSLFlBQVlHLE1BQU0sQ0FBQ00sT0FBTztJQUMxQlQsWUFBWUcsTUFBTSxDQUFDTyxZQUFZO0lBQy9CVixZQUFZRyxNQUFNLENBQUNRLFNBQVM7Q0FDL0I7QUFDRCxTQUFTWiwrQkFBK0JhLElBQUksRUFBRUMsT0FBTztJQUNqRCxJQUFJWCxrQ0FBa0NZLFFBQVEsQ0FBQ0YsT0FBTztRQUNsRCxPQUFPO1lBQ0hBLE1BQU1aLFlBQVlHLE1BQU0sQ0FBQ1ksUUFBUTtZQUNqQ0YsU0FBUyxDQUFDLG1DQUFtQyxFQUFFRCxLQUFLLENBQUMsRUFBRVosWUFBWUcsTUFBTSxDQUFDUyxLQUFLLENBQUMsQ0FBQyxFQUFFQyxRQUFRLENBQUM7UUFDaEc7SUFDSixPQUNLO1FBQ0QsT0FBTztZQUFFRDtZQUFNQztRQUFRO0lBQzNCO0FBQ0o7QUFDQWhCLHNDQUFzQyxHQUFHRSxnQ0FDekMsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29udHJvbC1wbGFuZS1zdGF0dXMuanM/NzU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IElOQVBQUk9QUklBVEVfQ09OVFJPTF9QTEFORV9DT0RFUyA9IFtcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLklOVkFMSURfQVJHVU1FTlQsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuQUxSRUFEWV9FWElTVFMsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkZBSUxFRF9QUkVDT05ESVRJT04sXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkFCT1JURUQsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk9VVF9PRl9SQU5HRSxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuREFUQV9MT1NTLFxuXTtcbmZ1bmN0aW9uIHJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZShjb2RlLCBkZXRhaWxzKSB7XG4gICAgaWYgKElOQVBQUk9QUklBVEVfQ09OVFJPTF9QTEFORV9DT0RFUy5pbmNsdWRlcyhjb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgZGV0YWlsczogYEludmFsaWQgc3RhdHVzIGZyb20gY29udHJvbCBwbGFuZTogJHtjb2RlfSAke2NvbnN0YW50c18xLlN0YXR1c1tjb2RlXX0gJHtkZXRhaWxzfWAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBjb2RlLCBkZXRhaWxzIH07XG4gICAgfVxufVxuZXhwb3J0cy5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUgPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sLXBsYW5lLXN0YXR1cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUiLCJjb25zdGFudHNfMSIsInJlcXVpcmUiLCJJTkFQUFJPUFJJQVRFX0NPTlRST0xfUExBTkVfQ09ERVMiLCJTdGF0dXMiLCJPSyIsIklOVkFMSURfQVJHVU1FTlQiLCJOT1RfRk9VTkQiLCJBTFJFQURZX0VYSVNUUyIsIkZBSUxFRF9QUkVDT05ESVRJT04iLCJBQk9SVEVEIiwiT1VUX09GX1JBTkdFIiwiREFUQV9MT1NTIiwiY29kZSIsImRldGFpbHMiLCJpbmNsdWRlcyIsIklOVEVSTkFMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/deadline.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.deadlineToString = exports.getRelativeTimeout = exports.getDeadlineTimeoutString = exports.minDeadline = void 0;\nfunction minDeadline(...deadlineList) {\n    let minValue = Infinity;\n    for (const deadline of deadlineList){\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n        if (deadlineMsecs < minValue) {\n            minValue = deadlineMsecs;\n        }\n    }\n    return minValue;\n}\nexports.minDeadline = minDeadline;\nconst units = [\n    [\n        \"m\",\n        1\n    ],\n    [\n        \"S\",\n        1000\n    ],\n    [\n        \"M\",\n        60 * 1000\n    ],\n    [\n        \"H\",\n        60 * 60 * 1000\n    ]\n];\nfunction getDeadlineTimeoutString(deadline) {\n    const now = new Date().getTime();\n    if (deadline instanceof Date) {\n        deadline = deadline.getTime();\n    }\n    const timeoutMs = Math.max(deadline - now, 0);\n    for (const [unit, factor] of units){\n        const amount = timeoutMs / factor;\n        if (amount < 1e8) {\n            return String(Math.ceil(amount)) + unit;\n        }\n    }\n    throw new Error(\"Deadline is too far in the future\");\n}\nexports.getDeadlineTimeoutString = getDeadlineTimeoutString;\n/**\n * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\n * In particular, \"When delay is larger than 2147483647 or less than 1, the\n * delay will be set to 1. Non-integer delays are truncated to an integer.\"\n * This number of milliseconds is almost 25 days.\n */ const MAX_TIMEOUT_TIME = 2147483647;\n/**\n * Get the timeout value that should be passed to setTimeout now for the timer\n * to end at the deadline. For any deadline before now, the timer should end\n * immediately, represented by a value of 0. For any deadline more than\n * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will\n * end at that time, so it is treated as infinitely far in the future.\n * @param deadline\n * @returns\n */ function getRelativeTimeout(deadline) {\n    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;\n    const now = new Date().getTime();\n    const timeout = deadlineMs - now;\n    if (timeout < 0) {\n        return 0;\n    } else if (timeout > MAX_TIMEOUT_TIME) {\n        return Infinity;\n    } else {\n        return timeout;\n    }\n}\nexports.getRelativeTimeout = getRelativeTimeout;\nfunction deadlineToString(deadline) {\n    if (deadline instanceof Date) {\n        return deadline.toISOString();\n    } else {\n        const dateDeadline = new Date(deadline);\n        if (Number.isNaN(dateDeadline.getTime())) {\n            return \"\" + deadline;\n        } else {\n            return dateDeadline.toISOString();\n        }\n    }\n}\nexports.deadlineToString = deadlineToString; //# sourceMappingURL=deadline.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHQSwwQkFBMEIsR0FBR0EsZ0NBQWdDLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDdEgsU0FBU0ssWUFBWSxHQUFHQyxZQUFZO0lBQ2hDLElBQUlDLFdBQVdDO0lBQ2YsS0FBSyxNQUFNQyxZQUFZSCxhQUFjO1FBQ2pDLE1BQU1JLGdCQUFnQkQsb0JBQW9CRSxPQUFPRixTQUFTRyxPQUFPLEtBQUtIO1FBQ3RFLElBQUlDLGdCQUFnQkgsVUFBVTtZQUMxQkEsV0FBV0c7UUFDZjtJQUNKO0lBQ0EsT0FBT0g7QUFDWDtBQUNBUCxtQkFBbUIsR0FBR0s7QUFDdEIsTUFBTVEsUUFBUTtJQUNWO1FBQUM7UUFBSztLQUFFO0lBQ1I7UUFBQztRQUFLO0tBQUs7SUFDWDtRQUFDO1FBQUssS0FBSztLQUFLO0lBQ2hCO1FBQUM7UUFBSyxLQUFLLEtBQUs7S0FBSztDQUN4QjtBQUNELFNBQVNULHlCQUF5QkssUUFBUTtJQUN0QyxNQUFNSyxNQUFNLElBQUlILE9BQU9DLE9BQU87SUFDOUIsSUFBSUgsb0JBQW9CRSxNQUFNO1FBQzFCRixXQUFXQSxTQUFTRyxPQUFPO0lBQy9CO0lBQ0EsTUFBTUcsWUFBWUMsS0FBS0MsR0FBRyxDQUFDUixXQUFXSyxLQUFLO0lBQzNDLEtBQUssTUFBTSxDQUFDSSxNQUFNQyxPQUFPLElBQUlOLE1BQU87UUFDaEMsTUFBTU8sU0FBU0wsWUFBWUk7UUFDM0IsSUFBSUMsU0FBUyxLQUFLO1lBQ2QsT0FBT0MsT0FBT0wsS0FBS00sSUFBSSxDQUFDRixXQUFXRjtRQUN2QztJQUNKO0lBQ0EsTUFBTSxJQUFJSyxNQUFNO0FBQ3BCO0FBQ0F2QixnQ0FBZ0MsR0FBR0k7QUFDbkM7Ozs7O0NBS0MsR0FDRCxNQUFNb0IsbUJBQW1CO0FBQ3pCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU3JCLG1CQUFtQk0sUUFBUTtJQUNoQyxNQUFNZ0IsYUFBYWhCLG9CQUFvQkUsT0FBT0YsU0FBU0csT0FBTyxLQUFLSDtJQUNuRSxNQUFNSyxNQUFNLElBQUlILE9BQU9DLE9BQU87SUFDOUIsTUFBTWMsVUFBVUQsYUFBYVg7SUFDN0IsSUFBSVksVUFBVSxHQUFHO1FBQ2IsT0FBTztJQUNYLE9BQ0ssSUFBSUEsVUFBVUYsa0JBQWtCO1FBQ2pDLE9BQU9oQjtJQUNYLE9BQ0s7UUFDRCxPQUFPa0I7SUFDWDtBQUNKO0FBQ0ExQiwwQkFBMEIsR0FBR0c7QUFDN0IsU0FBU0QsaUJBQWlCTyxRQUFRO0lBQzlCLElBQUlBLG9CQUFvQkUsTUFBTTtRQUMxQixPQUFPRixTQUFTa0IsV0FBVztJQUMvQixPQUNLO1FBQ0QsTUFBTUMsZUFBZSxJQUFJakIsS0FBS0Y7UUFDOUIsSUFBSW9CLE9BQU9DLEtBQUssQ0FBQ0YsYUFBYWhCLE9BQU8sS0FBSztZQUN0QyxPQUFPLEtBQUtIO1FBQ2hCLE9BQ0s7WUFDRCxPQUFPbUIsYUFBYUQsV0FBVztRQUNuQztJQUNKO0FBQ0o7QUFDQTNCLHdCQUF3QixHQUFHRSxrQkFDM0Isb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanM/ZGVjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWFkbGluZVRvU3RyaW5nID0gZXhwb3J0cy5nZXRSZWxhdGl2ZVRpbWVvdXQgPSBleHBvcnRzLmdldERlYWRsaW5lVGltZW91dFN0cmluZyA9IGV4cG9ydHMubWluRGVhZGxpbmUgPSB2b2lkIDA7XG5mdW5jdGlvbiBtaW5EZWFkbGluZSguLi5kZWFkbGluZUxpc3QpIHtcbiAgICBsZXQgbWluVmFsdWUgPSBJbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IGRlYWRsaW5lIG9mIGRlYWRsaW5lTGlzdCkge1xuICAgICAgICBjb25zdCBkZWFkbGluZU1zZWNzID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUuZ2V0VGltZSgpIDogZGVhZGxpbmU7XG4gICAgICAgIGlmIChkZWFkbGluZU1zZWNzIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgIG1pblZhbHVlID0gZGVhZGxpbmVNc2VjcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluVmFsdWU7XG59XG5leHBvcnRzLm1pbkRlYWRsaW5lID0gbWluRGVhZGxpbmU7XG5jb25zdCB1bml0cyA9IFtcbiAgICBbJ20nLCAxXSxcbiAgICBbJ1MnLCAxMDAwXSxcbiAgICBbJ00nLCA2MCAqIDEwMDBdLFxuICAgIFsnSCcsIDYwICogNjAgKiAxMDAwXSxcbl07XG5mdW5jdGlvbiBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmcoZGVhZGxpbmUpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBpZiAoZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGRlYWRsaW5lID0gZGVhZGxpbmUuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lb3V0TXMgPSBNYXRoLm1heChkZWFkbGluZSAtIG5vdywgMCk7XG4gICAgZm9yIChjb25zdCBbdW5pdCwgZmFjdG9yXSBvZiB1bml0cykge1xuICAgICAgICBjb25zdCBhbW91bnQgPSB0aW1lb3V0TXMgLyBmYWN0b3I7XG4gICAgICAgIGlmIChhbW91bnQgPCAxZTgpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5jZWlsKGFtb3VudCkpICsgdW5pdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlYWRsaW5lIGlzIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZScpO1xufVxuZXhwb3J0cy5nZXREZWFkbGluZVRpbWVvdXRTdHJpbmcgPSBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmc7XG4vKipcbiAqIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3RpbWVycy5odG1sI3NldHRpbWVvdXRjYWxsYmFjay1kZWxheS1hcmdzXG4gKiBJbiBwYXJ0aWN1bGFyLCBcIldoZW4gZGVsYXkgaXMgbGFyZ2VyIHRoYW4gMjE0NzQ4MzY0NyBvciBsZXNzIHRoYW4gMSwgdGhlXG4gKiBkZWxheSB3aWxsIGJlIHNldCB0byAxLiBOb24taW50ZWdlciBkZWxheXMgYXJlIHRydW5jYXRlZCB0byBhbiBpbnRlZ2VyLlwiXG4gKiBUaGlzIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXMgYWxtb3N0IDI1IGRheXMuXG4gKi9cbmNvbnN0IE1BWF9USU1FT1VUX1RJTUUgPSAyMTQ3NDgzNjQ3O1xuLyoqXG4gKiBHZXQgdGhlIHRpbWVvdXQgdmFsdWUgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHNldFRpbWVvdXQgbm93IGZvciB0aGUgdGltZXJcbiAqIHRvIGVuZCBhdCB0aGUgZGVhZGxpbmUuIEZvciBhbnkgZGVhZGxpbmUgYmVmb3JlIG5vdywgdGhlIHRpbWVyIHNob3VsZCBlbmRcbiAqIGltbWVkaWF0ZWx5LCByZXByZXNlbnRlZCBieSBhIHZhbHVlIG9mIDAuIEZvciBhbnkgZGVhZGxpbmUgbW9yZSB0aGFuXG4gKiBNQVhfVElNRU9VVF9USU1FIG1pbGxpc2Vjb25kcyBpbiB0aGUgZnV0dXJlLCBhIHRpbWVyIGNhbm5vdCBiZSBzZXQgdGhhdCB3aWxsXG4gKiBlbmQgYXQgdGhhdCB0aW1lLCBzbyBpdCBpcyB0cmVhdGVkIGFzIGluZmluaXRlbHkgZmFyIGluIHRoZSBmdXR1cmUuXG4gKiBAcGFyYW0gZGVhZGxpbmVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldFJlbGF0aXZlVGltZW91dChkZWFkbGluZSkge1xuICAgIGNvbnN0IGRlYWRsaW5lTXMgPSBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUgPyBkZWFkbGluZS5nZXRUaW1lKCkgOiBkZWFkbGluZTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCB0aW1lb3V0ID0gZGVhZGxpbmVNcyAtIG5vdztcbiAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRpbWVvdXQgPiBNQVhfVElNRU9VVF9USU1FKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aW1lb3V0O1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0UmVsYXRpdmVUaW1lb3V0ID0gZ2V0UmVsYXRpdmVUaW1lb3V0O1xuZnVuY3Rpb24gZGVhZGxpbmVUb1N0cmluZyhkZWFkbGluZSkge1xuICAgIGlmIChkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRlYWRsaW5lLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBkYXRlRGVhZGxpbmUgPSBuZXcgRGF0ZShkZWFkbGluZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oZGF0ZURlYWRsaW5lLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIGRlYWRsaW5lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVEZWFkbGluZS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWFkbGluZVRvU3RyaW5nID0gZGVhZGxpbmVUb1N0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYWRsaW5lLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlYWRsaW5lVG9TdHJpbmciLCJnZXRSZWxhdGl2ZVRpbWVvdXQiLCJnZXREZWFkbGluZVRpbWVvdXRTdHJpbmciLCJtaW5EZWFkbGluZSIsImRlYWRsaW5lTGlzdCIsIm1pblZhbHVlIiwiSW5maW5pdHkiLCJkZWFkbGluZSIsImRlYWRsaW5lTXNlY3MiLCJEYXRlIiwiZ2V0VGltZSIsInVuaXRzIiwibm93IiwidGltZW91dE1zIiwiTWF0aCIsIm1heCIsInVuaXQiLCJmYWN0b3IiLCJhbW91bnQiLCJTdHJpbmciLCJjZWlsIiwiRXJyb3IiLCJNQVhfVElNRU9VVF9USU1FIiwiZGVhZGxpbmVNcyIsInRpbWVvdXQiLCJ0b0lTT1N0cmluZyIsImRhdGVEZWFkbGluZSIsIk51bWJlciIsImlzTmFOIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/duration.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isDuration = exports.durationToMs = exports.msToDuration = void 0;\nfunction msToDuration(millis) {\n    return {\n        seconds: millis / 1000 | 0,\n        nanos: millis % 1000 * 1000000 | 0\n    };\n}\nexports.msToDuration = msToDuration;\nfunction durationToMs(duration) {\n    return duration.seconds * 1000 + duration.nanos / 1000000 | 0;\n}\nexports.durationToMs = durationToMs;\nfunction isDuration(value) {\n    return typeof value.seconds === \"number\" && typeof value.nanos === \"number\";\n}\nexports.isDuration = isDuration; //# sourceMappingURL=duration.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUN4RSxTQUFTSSxhQUFhQyxNQUFNO0lBQ3hCLE9BQU87UUFDSEMsU0FBUyxTQUFVLE9BQVE7UUFDM0JDLE9BQU8sU0FBVyxPQUFRLFVBQVc7SUFDekM7QUFDSjtBQUNBUCxvQkFBb0IsR0FBR0k7QUFDdkIsU0FBU0QsYUFBYUssUUFBUTtJQUMxQixPQUFPLFNBQVVGLE9BQU8sR0FBRyxPQUFPRSxTQUFTRCxLQUFLLEdBQUcsVUFBVztBQUNsRTtBQUNBUCxvQkFBb0IsR0FBR0c7QUFDdkIsU0FBU0QsV0FBV0QsS0FBSztJQUNyQixPQUFPLE9BQU9BLE1BQU1LLE9BQU8sS0FBSyxZQUFZLE9BQU9MLE1BQU1NLEtBQUssS0FBSztBQUN2RTtBQUNBUCxrQkFBa0IsR0FBR0UsWUFDckIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanM/ZDExMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0R1cmF0aW9uID0gZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBleHBvcnRzLm1zVG9EdXJhdGlvbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIG1zVG9EdXJhdGlvbihtaWxsaXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWNvbmRzOiAobWlsbGlzIC8gMTAwMCkgfCAwLFxuICAgICAgICBuYW5vczogKChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDApIHwgMCxcbiAgICB9O1xufVxuZXhwb3J0cy5tc1RvRHVyYXRpb24gPSBtc1RvRHVyYXRpb247XG5mdW5jdGlvbiBkdXJhdGlvblRvTXMoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gKGR1cmF0aW9uLnNlY29uZHMgKiAxMDAwICsgZHVyYXRpb24ubmFub3MgLyAxMDAwMDAwKSB8IDA7XG59XG5leHBvcnRzLmR1cmF0aW9uVG9NcyA9IGR1cmF0aW9uVG9NcztcbmZ1bmN0aW9uIGlzRHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnNlY29uZHMgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5uYW5vcyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzRHVyYXRpb24gPSBpc0R1cmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHVyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNEdXJhdGlvbiIsImR1cmF0aW9uVG9NcyIsIm1zVG9EdXJhdGlvbiIsIm1pbGxpcyIsInNlY29uZHMiLCJuYW5vcyIsImR1cmF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getErrorCode = exports.getErrorMessage = void 0;\nfunction getErrorMessage(error) {\n    if (error instanceof Error) {\n        return error.message;\n    } else {\n        return String(error);\n    }\n}\nexports.getErrorMessage = getErrorMessage;\nfunction getErrorCode(error) {\n    if (typeof error === \"object\" && error !== null && \"code\" in error && typeof error.code === \"number\") {\n        return error.code;\n    } else {\n        return null;\n    }\n}\nexports.getErrorCode = getErrorCode; //# sourceMappingURL=error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQ3RELFNBQVNHLGdCQUFnQkMsS0FBSztJQUMxQixJQUFJQSxpQkFBaUJDLE9BQU87UUFDeEIsT0FBT0QsTUFBTUUsT0FBTztJQUN4QixPQUNLO1FBQ0QsT0FBT0MsT0FBT0g7SUFDbEI7QUFDSjtBQUNBSix1QkFBdUIsR0FBR0c7QUFDMUIsU0FBU0QsYUFBYUUsS0FBSztJQUN2QixJQUFJLE9BQU9BLFVBQVUsWUFDakJBLFVBQVUsUUFDVixVQUFVQSxTQUNWLE9BQU9BLE1BQU1JLElBQUksS0FBSyxVQUFVO1FBQ2hDLE9BQU9KLE1BQU1JLElBQUk7SUFDckIsT0FDSztRQUNELE9BQU87SUFDWDtBQUNKO0FBQ0FSLG9CQUFvQixHQUFHRSxjQUN2QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9lcnJvci5qcz9lYzk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVycm9yQ29kZSA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGVycm9yKTtcbiAgICB9XG59XG5leHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTtcbmZ1bmN0aW9uIGdldEVycm9yQ29kZShlcnJvcikge1xuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgICAgICdjb2RlJyBpbiBlcnJvciAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLmNvZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmdldEVycm9yQ29kZSA9IGdldEVycm9yQ29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEVycm9yQ29kZSIsImdldEVycm9yTWVzc2FnZSIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiU3RyaW5nIiwiY29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/experimental.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OutlierDetectionLoadBalancingConfig = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.subchannelAddressToString = exports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.durationToMs = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = void 0;\nvar logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nObject.defineProperty(exports, \"trace\", ({\n    enumerable: true,\n    get: function() {\n        return logging_1.trace;\n    }\n}));\nObject.defineProperty(exports, \"log\", ({\n    enumerable: true,\n    get: function() {\n        return logging_1.log;\n    }\n}));\nvar resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nObject.defineProperty(exports, \"registerResolver\", ({\n    enumerable: true,\n    get: function() {\n        return resolver_1.registerResolver;\n    }\n}));\nObject.defineProperty(exports, \"createResolver\", ({\n    enumerable: true,\n    get: function() {\n        return resolver_1.createResolver;\n    }\n}));\nvar uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nObject.defineProperty(exports, \"uriToString\", ({\n    enumerable: true,\n    get: function() {\n        return uri_parser_1.uriToString;\n    }\n}));\nvar duration_1 = __webpack_require__(/*! ./duration */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nObject.defineProperty(exports, \"durationToMs\", ({\n    enumerable: true,\n    get: function() {\n        return duration_1.durationToMs;\n    }\n}));\nvar backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nObject.defineProperty(exports, \"BackoffTimeout\", ({\n    enumerable: true,\n    get: function() {\n        return backoff_timeout_1.BackoffTimeout;\n    }\n}));\nvar load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nObject.defineProperty(exports, \"createChildChannelControlHelper\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.createChildChannelControlHelper;\n    }\n}));\nObject.defineProperty(exports, \"registerLoadBalancerType\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.registerLoadBalancerType;\n    }\n}));\nObject.defineProperty(exports, \"getFirstUsableConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.getFirstUsableConfig;\n    }\n}));\nObject.defineProperty(exports, \"validateLoadBalancingConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.validateLoadBalancingConfig;\n    }\n}));\nvar subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nObject.defineProperty(exports, \"subchannelAddressToString\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_address_1.subchannelAddressToString;\n    }\n}));\nvar load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nObject.defineProperty(exports, \"ChildLoadBalancerHandler\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_child_handler_1.ChildLoadBalancerHandler;\n    }\n}));\nvar picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nObject.defineProperty(exports, \"UnavailablePicker\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.UnavailablePicker;\n    }\n}));\nObject.defineProperty(exports, \"QueuePicker\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.QueuePicker;\n    }\n}));\nObject.defineProperty(exports, \"PickResultType\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.PickResultType;\n    }\n}));\nvar filter_1 = __webpack_require__(/*! ./filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nObject.defineProperty(exports, \"BaseFilter\", ({\n    enumerable: true,\n    get: function() {\n        return filter_1.BaseFilter;\n    }\n}));\nvar filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nObject.defineProperty(exports, \"FilterStackFactory\", ({\n    enumerable: true,\n    get: function() {\n        return filter_stack_1.FilterStackFactory;\n    }\n}));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"registerAdminService\", ({\n    enumerable: true,\n    get: function() {\n        return admin_1.registerAdminService;\n    }\n}));\nvar subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nObject.defineProperty(exports, \"BaseSubchannelWrapper\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_interface_1.BaseSubchannelWrapper;\n    }\n}));\nvar load_balancer_outlier_detection_1 = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nObject.defineProperty(exports, \"OutlierDetectionLoadBalancingConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_outlier_detection_1.OutlierDetectionLoadBalancingConfig;\n    }\n})); //# sourceMappingURL=experimental.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQ0FBMkMsR0FBR0EsNkJBQTZCLEdBQUdBLDRCQUE0QixHQUFHQSwwQkFBMEIsR0FBR0Esa0JBQWtCLEdBQUdBLHNCQUFzQixHQUFHQSxtQkFBbUIsR0FBR0EseUJBQXlCLEdBQUdBLGdDQUFnQyxHQUFHQSxpQ0FBaUMsR0FBR0EsbUNBQW1DLEdBQUdBLDRCQUE0QixHQUFHQSxnQ0FBZ0MsR0FBR0EsdUNBQXVDLEdBQUdBLHNCQUFzQixHQUFHQSxvQkFBb0IsR0FBR0EsbUJBQW1CLEdBQUdBLHNCQUFzQixHQUFHQSx3QkFBd0IsR0FBR0EsV0FBVyxHQUFHQSxhQUFhLEdBQUcsS0FBSztBQUNobUIsSUFBSXVCLFlBQVlDLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DMUIseUNBQXdDO0lBQUUyQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxVQUFVRCxLQUFLO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDM0d4Qix1Q0FBc0M7SUFBRTJCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILFVBQVVGLEdBQUc7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN2RyxJQUFJTSxhQUFhSCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUNyQzFCLG9EQUFtRDtJQUFFMkIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsV0FBV1AsZ0JBQWdCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEl0QixrREFBaUQ7SUFBRTJCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLFdBQVdSLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM5SCxJQUFJUyxlQUFlSixtQkFBT0EsQ0FBQyxnRkFBYztBQUN6QzFCLCtDQUE4QztJQUFFMkIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Us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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9leHBlcmltZW50YWwuanM/NGFkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcgPSBleHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IGV4cG9ydHMucmVnaXN0ZXJBZG1pblNlcnZpY2UgPSBleHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUZpbHRlciA9IGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSBleHBvcnRzLlF1ZXVlUGlja2VyID0gZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IGV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gZXhwb3J0cy52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcgPSBleHBvcnRzLmdldEZpcnN0VXNhYmxlQ29uZmlnID0gZXhwb3J0cy5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUgPSBleHBvcnRzLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSBleHBvcnRzLkJhY2tvZmZUaW1lb3V0ID0gZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBleHBvcnRzLnVyaVRvU3RyaW5nID0gZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IGV4cG9ydHMubG9nID0gZXhwb3J0cy50cmFjZSA9IHZvaWQgMDtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHJhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZ2dpbmdfMS50cmFjZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2luZ18xLmxvZzsgfSB9KTtcbnZhciByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdpc3RlclJlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcjsgfSB9KTtcbnZhciB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXJpVG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZzsgfSB9KTtcbnZhciBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4vZHVyYXRpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkdXJhdGlvblRvTXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zOyB9IH0pO1xudmFyIGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFja29mZlRpbWVvdXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0OyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEZpcnN0VXNhYmxlQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuZ2V0Rmlyc3RVc2FibGVDb25maWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWc7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nOyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7IH0gfSk7XG52YXIgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmF2YWlsYWJsZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRdWV1ZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUXVldWVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaWNrUmVzdWx0VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGU7IH0gfSk7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlRmlsdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfMS5CYXNlRmlsdGVyOyB9IH0pO1xudmFyIGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsdGVyU3RhY2tGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfc3RhY2tfMS5GaWx0ZXJTdGFja0ZhY3Rvcnk7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJBZG1pblNlcnZpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2U7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlcjsgfSB9KTtcbnZhciBsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb25fMS5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZzsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGVyaW1lbnRhbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyIsIkJhc2VTdWJjaGFubmVsV3JhcHBlciIsInJlZ2lzdGVyQWRtaW5TZXJ2aWNlIiwiRmlsdGVyU3RhY2tGYWN0b3J5IiwiQmFzZUZpbHRlciIsIlBpY2tSZXN1bHRUeXBlIiwiUXVldWVQaWNrZXIiLCJVbmF2YWlsYWJsZVBpY2tlciIsIkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlciIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWciLCJnZXRGaXJzdFVzYWJsZUNvbmZpZyIsInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSIsImNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIiLCJCYWNrb2ZmVGltZW91dCIsImR1cmF0aW9uVG9NcyIsInVyaVRvU3RyaW5nIiwiY3JlYXRlUmVzb2x2ZXIiLCJyZWdpc3RlclJlc29sdmVyIiwibG9nIiwidHJhY2UiLCJsb2dnaW5nXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsInJlc29sdmVyXzEiLCJ1cmlfcGFyc2VyXzEiLCJkdXJhdGlvbl8xIiwiYmFja29mZl90aW1lb3V0XzEiLCJsb2FkX2JhbGFuY2VyXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsImxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xIiwicGlja2VyXzEiLCJmaWx0ZXJfMSIsImZpbHRlcl9zdGFja18xIiwiYWRtaW5fMSIsInN1YmNoYW5uZWxfaW50ZXJmYWNlXzEiLCJsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter-stack.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FilterStackFactory = exports.FilterStack = void 0;\nclass FilterStack {\n    constructor(filters){\n        this.filters = filters;\n    }\n    sendMetadata(metadata) {\n        let result = metadata;\n        for(let i = 0; i < this.filters.length; i++){\n            result = this.filters[i].sendMetadata(result);\n        }\n        return result;\n    }\n    receiveMetadata(metadata) {\n        let result = metadata;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveMetadata(result);\n        }\n        return result;\n    }\n    sendMessage(message) {\n        let result = message;\n        for(let i = 0; i < this.filters.length; i++){\n            result = this.filters[i].sendMessage(result);\n        }\n        return result;\n    }\n    receiveMessage(message) {\n        let result = message;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveMessage(result);\n        }\n        return result;\n    }\n    receiveTrailers(status) {\n        let result = status;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveTrailers(result);\n        }\n        return result;\n    }\n    push(filters) {\n        this.filters.unshift(...filters);\n    }\n    getFilters() {\n        return this.filters;\n    }\n}\nexports.FilterStack = FilterStack;\nclass FilterStackFactory {\n    constructor(factories){\n        this.factories = factories;\n    }\n    push(filterFactories) {\n        this.factories.unshift(...filterFactories);\n    }\n    clone() {\n        return new FilterStackFactory([\n            ...this.factories\n        ]);\n    }\n    createFilter() {\n        return new FilterStack(this.factories.map((factory)=>factory.createFilter()));\n    }\n}\nexports.FilterStackFactory = FilterStackFactory; //# sourceMappingURL=filter-stack.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUN4RCxNQUFNRztJQUNGQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FDLGFBQWFDLFFBQVEsRUFBRTtRQUNuQixJQUFJQyxTQUFTRDtRQUNiLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxNQUFNLEVBQUVELElBQUs7WUFDMUNELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0gsWUFBWSxDQUFDRTtRQUMxQztRQUNBLE9BQU9BO0lBQ1g7SUFDQUcsZ0JBQWdCSixRQUFRLEVBQUU7UUFDdEIsSUFBSUMsU0FBU0Q7UUFDYixJQUFLLElBQUlFLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0UsZUFBZSxDQUFDSDtRQUM3QztRQUNBLE9BQU9BO0lBQ1g7SUFDQUksWUFBWUMsT0FBTyxFQUFFO1FBQ2pCLElBQUlMLFNBQVNLO1FBQ2IsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sRUFBRUQsSUFBSztZQUMxQ0QsU0FBUyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ksRUFBRSxDQUFDRyxXQUFXLENBQUNKO1FBQ3pDO1FBQ0EsT0FBT0E7SUFDWDtJQUNBTSxlQUFlRCxPQUFPLEVBQUU7UUFDcEIsSUFBSUwsU0FBU0s7UUFDYixJQUFLLElBQUlKLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0ssY0FBYyxDQUFDTjtRQUM1QztRQUNBLE9BQU9BO0lBQ1g7SUFDQU8sZ0JBQWdCQyxNQUFNLEVBQUU7UUFDcEIsSUFBSVIsU0FBU1E7UUFDYixJQUFLLElBQUlQLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ00sZUFBZSxDQUFDUDtRQUM3QztRQUNBLE9BQU9BO0lBQ1g7SUFDQVMsS0FBS1osT0FBTyxFQUFFO1FBQ1YsSUFBSSxDQUFDQSxPQUFPLENBQUNhLE9BQU8sSUFBSWI7SUFDNUI7SUFDQWMsYUFBYTtRQUNULE9BQU8sSUFBSSxDQUFDZCxPQUFPO0lBQ3ZCO0FBQ0o7QUFDQUwsbUJBQW1CLEdBQUdHO0FBQ3RCLE1BQU1EO0lBQ0ZFLFlBQVlnQixTQUFTLENBQUU7UUFDbkIsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0FILEtBQUtJLGVBQWUsRUFBRTtRQUNsQixJQUFJLENBQUNELFNBQVMsQ0FBQ0YsT0FBTyxJQUFJRztJQUM5QjtJQUNBQyxRQUFRO1FBQ0osT0FBTyxJQUFJcEIsbUJBQW1CO2VBQUksSUFBSSxDQUFDa0IsU0FBUztTQUFDO0lBQ3JEO0lBQ0FHLGVBQWU7UUFDWCxPQUFPLElBQUlwQixZQUFZLElBQUksQ0FBQ2lCLFNBQVMsQ0FBQ0ksR0FBRyxDQUFDQyxDQUFBQSxVQUFXQSxRQUFRRixZQUFZO0lBQzdFO0FBQ0o7QUFDQXZCLDBCQUEwQixHQUFHRSxvQkFDN0Isd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzPzc1MzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmlsdGVyU3RhY2tGYWN0b3J5ID0gZXhwb3J0cy5GaWx0ZXJTdGFjayA9IHZvaWQgMDtcbmNsYXNzIEZpbHRlclN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0uc2VuZE1ldGFkYXRhKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnJlY2VpdmVNZXRhZGF0YShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1lc3NhZ2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0uc2VuZE1lc3NhZ2UocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXNzYWdlO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0ucmVjZWl2ZU1lc3NhZ2UocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZWNlaXZlVHJhaWxlcnMoc3RhdHVzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzdGF0dXM7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlVHJhaWxlcnMocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwdXNoKGZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnVuc2hpZnQoLi4uZmlsdGVycyk7XG4gICAgfVxuICAgIGdldEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJTdGFjayA9IEZpbHRlclN0YWNrO1xuY2xhc3MgRmlsdGVyU3RhY2tGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3JpZXMpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XG4gICAgfVxuICAgIHB1c2goZmlsdGVyRmFjdG9yaWVzKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yaWVzLnVuc2hpZnQoLi4uZmlsdGVyRmFjdG9yaWVzKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsdGVyU3RhY2tGYWN0b3J5KFsuLi50aGlzLmZhY3Rvcmllc10pO1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsdGVyU3RhY2sodGhpcy5mYWN0b3JpZXMubWFwKGZhY3RvcnkgPT4gZmFjdG9yeS5jcmVhdGVGaWx0ZXIoKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVyU3RhY2tGYWN0b3J5ID0gRmlsdGVyU3RhY2tGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLXN0YWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZpbHRlclN0YWNrRmFjdG9yeSIsIkZpbHRlclN0YWNrIiwiY29uc3RydWN0b3IiLCJmaWx0ZXJzIiwic2VuZE1ldGFkYXRhIiwibWV0YWRhdGEiLCJyZXN1bHQiLCJpIiwibGVuZ3RoIiwicmVjZWl2ZU1ldGFkYXRhIiwic2VuZE1lc3NhZ2UiLCJtZXNzYWdlIiwicmVjZWl2ZU1lc3NhZ2UiLCJyZWNlaXZlVHJhaWxlcnMiLCJzdGF0dXMiLCJwdXNoIiwidW5zaGlmdCIsImdldEZpbHRlcnMiLCJmYWN0b3JpZXMiLCJmaWx0ZXJGYWN0b3JpZXMiLCJjbG9uZSIsImNyZWF0ZUZpbHRlciIsIm1hcCIsImZhY3RvcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseFilter = void 0;\nclass BaseFilter {\n    async sendMetadata(metadata) {\n        return metadata;\n    }\n    receiveMetadata(metadata) {\n        return metadata;\n    }\n    async sendMessage(message) {\n        return message;\n    }\n    async receiveMessage(message) {\n        return message;\n    }\n    receiveTrailers(status) {\n        return status;\n    }\n}\nexports.BaseFilter = BaseFilter; //# sourceMappingURL=filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBRyxLQUFLO0FBQzFCLE1BQU1FO0lBQ0YsTUFBTUMsYUFBYUMsUUFBUSxFQUFFO1FBQ3pCLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCRCxRQUFRLEVBQUU7UUFDdEIsT0FBT0E7SUFDWDtJQUNBLE1BQU1FLFlBQVlDLE9BQU8sRUFBRTtRQUN2QixPQUFPQTtJQUNYO0lBQ0EsTUFBTUMsZUFBZUQsT0FBTyxFQUFFO1FBQzFCLE9BQU9BO0lBQ1g7SUFDQUUsZ0JBQWdCQyxNQUFNLEVBQUU7UUFDcEIsT0FBT0E7SUFDWDtBQUNKO0FBQ0FWLGtCQUFrQixHQUFHRSxZQUNyQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9maWx0ZXIuanM/MGYzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlRmlsdGVyID0gdm9pZCAwO1xuY2xhc3MgQmFzZUZpbHRlciB7XG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUZpbHRlciA9IEJhc2VGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQmFzZUZpbHRlciIsInNlbmRNZXRhZGF0YSIsIm1ldGFkYXRhIiwicmVjZWl2ZU1ldGFkYXRhIiwic2VuZE1lc3NhZ2UiLCJtZXNzYWdlIiwicmVjZWl2ZU1lc3NhZ2UiLCJyZWNlaXZlVHJhaWxlcnMiLCJzdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/http_proxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst resolver_dns_1 = __webpack_require__(/*! ./resolver-dns */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst TRACER_NAME = \"proxy\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = \"\";\n    let envVar = \"\";\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */ if (process.env.grpc_proxy) {\n        envVar = \"grpc_proxy\";\n        proxyEnv = process.env.grpc_proxy;\n    } else if (process.env.https_proxy) {\n        envVar = \"https_proxy\";\n        proxyEnv = process.env.https_proxy;\n    } else if (process.env.http_proxy) {\n        envVar = \"http_proxy\";\n        proxyEnv = process.env.http_proxy;\n    } else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    } catch (e) {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== \"http:\") {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            (0, logging_1.log)(constants_1.LogVerbosity.INFO, \"userinfo found in proxy URI\");\n            userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n        } else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const hostname = proxyUrl.hostname;\n    let port = proxyUrl.port;\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\n     * 80. We need to set that explicitly here if it is omitted because otherwise\n     * it will use gRPC's default port 443. */ if (port === \"\") {\n        port = \"80\";\n    }\n    const result = {\n        address: `${hostname}:${port}`\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace(\"Proxy server \" + result.address + \" set by environment variable \" + envVar);\n    return result;\n}\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */ let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = \"no_grpc_proxy\";\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = \"no_proxy\";\n    }\n    if (noProxyStr) {\n        trace(\"No proxy server list set by environment variable \" + envVar);\n        return noProxyStr.split(\",\");\n    } else {\n        return [];\n    }\n}\nfunction mapProxyName(target, options) {\n    var _a;\n    const noProxyResult = {\n        target: target,\n        extraOptions: {}\n    };\n    if (((_a = options[\"grpc.enable_http_proxy\"]) !== null && _a !== void 0 ? _a : 1) === 0) {\n        return noProxyResult;\n    }\n    if (target.scheme === \"unix\") {\n        return noProxyResult;\n    }\n    const proxyInfo = getProxyInfo();\n    if (!proxyInfo.address) {\n        return noProxyResult;\n    }\n    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n    if (!hostPort) {\n        return noProxyResult;\n    }\n    const serverHost = hostPort.host;\n    for (const host of getNoProxyHostList()){\n        if (host === serverHost) {\n            trace(\"Not using proxy for target in no_proxy list: \" + (0, uri_parser_1.uriToString)(target));\n            return noProxyResult;\n        }\n    }\n    const extraOptions = {\n        \"grpc.http_connect_target\": (0, uri_parser_1.uriToString)(target)\n    };\n    if (proxyInfo.creds) {\n        extraOptions[\"grpc.http_connect_creds\"] = proxyInfo.creds;\n    }\n    return {\n        target: {\n            scheme: \"dns\",\n            path: proxyInfo.address\n        },\n        extraOptions: extraOptions\n    };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n    var _a;\n    if (!(\"grpc.http_connect_target\" in channelOptions)) {\n        return Promise.resolve({});\n    }\n    const realTarget = channelOptions[\"grpc.http_connect_target\"];\n    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\n    if (parsedTarget === null) {\n        return Promise.resolve({});\n    }\n    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);\n    if (splitHostPost === null) {\n        return Promise.resolve({});\n    }\n    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;\n    const options = {\n        method: \"CONNECT\",\n        path: hostPort\n    };\n    const headers = {\n        Host: hostPort\n    };\n    // Connect to the subchannel address as a proxy\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n        options.host = address.host;\n        options.port = address.port;\n    } else {\n        options.socketPath = address.path;\n    }\n    if (\"grpc.http_connect_creds\" in channelOptions) {\n        headers[\"Proxy-Authorization\"] = \"Basic \" + Buffer.from(channelOptions[\"grpc.http_connect_creds\"]).toString(\"base64\");\n    }\n    options.headers = headers;\n    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n    trace(\"Using proxy \" + proxyAddressString + \" to connect to \" + options.path);\n    return new Promise((resolve, reject)=>{\n        const request = http.request(options);\n        request.once(\"connect\", (res, socket, head)=>{\n            var _a;\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === 200) {\n                trace(\"Successfully connected to \" + options.path + \" through proxy \" + proxyAddressString);\n                if (\"secureContext\" in connectionOptions) {\n                    /* The proxy is connecting to a TLS server, so upgrade this socket\n                     * connection to a TLS connection.\n                     * This is a workaround for https://github.com/nodejs/node/issues/32922\n                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */ const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);\n                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n                    const cts = tls.connect(Object.assign({\n                        host: remoteHost,\n                        servername: remoteHost,\n                        socket: socket\n                    }, connectionOptions), ()=>{\n                        trace(\"Successfully established a TLS connection to \" + options.path + \" through proxy \" + proxyAddressString);\n                        resolve({\n                            socket: cts,\n                            realTarget: parsedTarget\n                        });\n                    });\n                    cts.on(\"error\", (error)=>{\n                        trace(\"Failed to establish a TLS connection to \" + options.path + \" through proxy \" + proxyAddressString + \" with error \" + error.message);\n                        reject();\n                    });\n                } else {\n                    trace(\"Successfully established a plaintext connection to \" + options.path + \" through proxy \" + proxyAddressString);\n                    resolve({\n                        socket,\n                        realTarget: parsedTarget\n                    });\n                }\n            } else {\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, \"Failed to connect to \" + options.path + \" through proxy \" + proxyAddressString + \" with status \" + res.statusCode);\n                reject();\n            }\n        });\n        request.once(\"error\", (err)=>{\n            request.removeAllListeners();\n            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, \"Failed to connect to proxy \" + proxyAddressString + \" with error \" + err.message);\n            reject();\n        });\n        request.end();\n    });\n}\nexports.getProxiedConnection = getProxiedConnection; //# sourceMappingURL=http_proxy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaHR0cF9wcm94eS5qcyIsIm1hcHBpbmdzIjoiOztBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw0QkFBNEIsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUMzRCxNQUFNSSxZQUFZQyxtQkFBT0EsQ0FBQywwRUFBVztBQUNyQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNSSxNQUFNSixtQkFBT0EsQ0FBQyxnQkFBSztBQUN6QixNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTSx1QkFBdUJOLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNTyxlQUFlUCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNUSxRQUFRUixtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNUyxpQkFBaUJULG1CQUFPQSxDQUFDLG9GQUFnQjtBQUMvQyxNQUFNVSxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZlAsUUFBUU0sS0FBSyxDQUFDVixZQUFZWSxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQSxTQUFTRztJQUNMLElBQUlDLFdBQVc7SUFDZixJQUFJQyxTQUFTO0lBQ2I7OztLQUdDLEdBQ0QsSUFBSUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxVQUFVLEVBQUU7UUFDeEJILFNBQVM7UUFDVEQsV0FBV0UsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxVQUFVO0lBQ3JDLE9BQ0ssSUFBSUYsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRSxXQUFXLEVBQUU7UUFDOUJKLFNBQVM7UUFDVEQsV0FBV0UsT0FBT0Es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Y2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9odHRwX3Byb3h5LmpzPzI4ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UHJveGllZENvbm5lY3Rpb24gPSBleHBvcnRzLm1hcFByb3h5TmFtZSA9IHZvaWQgMDtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHJlc29sdmVyX2Ruc18xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItZG5zXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncHJveHknO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5mdW5jdGlvbiBnZXRQcm94eUluZm8oKSB7XG4gICAgbGV0IHByb3h5RW52ID0gJyc7XG4gICAgbGV0IGVudlZhciA9ICcnO1xuICAgIC8qIFByZWZlciB1c2luZyAnZ3JwY19wcm94eScuIEZhbGxiYWNrIG9uICdodHRwX3Byb3h5JyBpZiBpdCBpcyBub3Qgc2V0LlxuICAgICAqIEFsc28gcHJlZmVyIHVzaW5nICdodHRwc19wcm94eScgd2l0aCBmYWxsYmFjayBvbiAnaHR0cF9wcm94eScuIFRoZVxuICAgICAqIGZhbGxiYWNrIGJlaGF2aW9yIGNhbiBiZSByZW1vdmVkIGlmIHRoZXJlJ3MgYSBkZW1hbmQgZm9yIGl0LlxuICAgICAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5ncnBjX3Byb3h5KSB7XG4gICAgICAgIGVudlZhciA9ICdncnBjX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5ncnBjX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5odHRwc19wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnaHR0cHNfcHJveHknO1xuICAgICAgICBwcm94eUVudiA9IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5odHRwX3Byb3h5KSB7XG4gICAgICAgIGVudlZhciA9ICdodHRwX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5odHRwX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBsZXQgcHJveHlVcmw7XG4gICAgdHJ5IHtcbiAgICAgICAgcHJveHlVcmwgPSBuZXcgdXJsXzEuVVJMKHByb3h5RW52KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYGNhbm5vdCBwYXJzZSB2YWx1ZSBvZiBcIiR7ZW52VmFyfVwiIGVudiB2YXJgKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAocHJveHlVcmwucHJvdG9jb2wgIT09ICdodHRwOicpIHtcbiAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYFwiJHtwcm94eVVybC5wcm90b2NvbH1cIiBzY2hlbWUgbm90IHN1cHBvcnRlZCBpbiBwcm94eSBVUklgKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBsZXQgdXNlckNyZWQgPSBudWxsO1xuICAgIGlmIChwcm94eVVybC51c2VybmFtZSkge1xuICAgICAgICBpZiAocHJveHlVcmwucGFzc3dvcmQpIHtcbiAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTywgJ3VzZXJpbmZvIGZvdW5kIGluIHByb3h5IFVSSScpO1xuICAgICAgICAgICAgdXNlckNyZWQgPSBgJHtwcm94eVVybC51c2VybmFtZX06JHtwcm94eVVybC5wYXNzd29yZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlckNyZWQgPSBwcm94eVVybC51c2VybmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBob3N0bmFtZSA9IHByb3h5VXJsLmhvc3RuYW1lO1xuICAgIGxldCBwb3J0ID0gcHJveHlVcmwucG9ydDtcbiAgICAvKiBUaGUgcHJveHkgVVJMIHVzZXMgdGhlIHNjaGVtZSBcImh0dHA6XCIsIHdoaWNoIGhhcyBhIGRlZmF1bHQgcG9ydCBudW1iZXIgb2ZcbiAgICAgKiA4MC4gV2UgbmVlZCB0byBzZXQgdGhhdCBleHBsaWNpdGx5IGhlcmUgaWYgaXQgaXMgb21pdHRlZCBiZWNhdXNlIG90aGVyd2lzZVxuICAgICAqIGl0IHdpbGwgdXNlIGdSUEMncyBkZWZhdWx0IHBvcnQgNDQzLiAqL1xuICAgIGlmIChwb3J0ID09PSAnJykge1xuICAgICAgICBwb3J0ID0gJzgwJztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBhZGRyZXNzOiBgJHtob3N0bmFtZX06JHtwb3J0fWAsXG4gICAgfTtcbiAgICBpZiAodXNlckNyZWQpIHtcbiAgICAgICAgcmVzdWx0LmNyZWRzID0gdXNlckNyZWQ7XG4gICAgfVxuICAgIHRyYWNlKCdQcm94eSBzZXJ2ZXIgJyArIHJlc3VsdC5hZGRyZXNzICsgJyBzZXQgYnkgZW52aXJvbm1lbnQgdmFyaWFibGUgJyArIGVudlZhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE5vUHJveHlIb3N0TGlzdCgpIHtcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ25vX2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnbm9fcHJveHknIGlmIGl0IGlzIG5vdCBzZXQuICovXG4gICAgbGV0IG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19ncnBjX3Byb3h5O1xuICAgIGxldCBlbnZWYXIgPSAnbm9fZ3JwY19wcm94eSc7XG4gICAgaWYgKCFub1Byb3h5U3RyKSB7XG4gICAgICAgIG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19wcm94eTtcbiAgICAgICAgZW52VmFyID0gJ25vX3Byb3h5JztcbiAgICB9XG4gICAgaWYgKG5vUHJveHlTdHIpIHtcbiAgICAgICAgdHJhY2UoJ05vIHByb3h5IHNlcnZlciBsaXN0IHNldCBieSBlbnZpcm9ubWVudCB2YXJpYWJsZSAnICsgZW52VmFyKTtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlTdHIuc3BsaXQoJywnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBQcm94eU5hbWUodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG5vUHJveHlSZXN1bHQgPSB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBleHRyYU9wdGlvbnM6IHt9LFxuICAgIH07XG4gICAgaWYgKCgoX2EgPSBvcHRpb25zWydncnBjLmVuYWJsZV9odHRwX3Byb3h5J10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnNjaGVtZSA9PT0gJ3VuaXgnKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBwcm94eUluZm8gPSBnZXRQcm94eUluZm8oKTtcbiAgICBpZiAoIXByb3h5SW5mby5hZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0LnBhdGgpO1xuICAgIGlmICghaG9zdFBvcnQpIHtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHNlcnZlckhvc3QgPSBob3N0UG9ydC5ob3N0O1xuICAgIGZvciAoY29uc3QgaG9zdCBvZiBnZXROb1Byb3h5SG9zdExpc3QoKSkge1xuICAgICAgICBpZiAoaG9zdCA9PT0gc2VydmVySG9zdCkge1xuICAgICAgICAgICAgdHJhY2UoJ05vdCB1c2luZyBwcm94eSBmb3IgdGFyZ2V0IGluIG5vX3Byb3h5IGxpc3Q6ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpKTtcbiAgICAgICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhT3B0aW9ucyA9IHtcbiAgICAgICAgJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCc6ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCksXG4gICAgfTtcbiAgICBpZiAocHJveHlJbmZvLmNyZWRzKSB7XG4gICAgICAgIGV4dHJhT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSA9IHByb3h5SW5mby5jcmVkcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICBzY2hlbWU6ICdkbnMnLFxuICAgICAgICAgICAgcGF0aDogcHJveHlJbmZvLmFkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhT3B0aW9uczogZXh0cmFPcHRpb25zLFxuICAgIH07XG59XG5leHBvcnRzLm1hcFByb3h5TmFtZSA9IG1hcFByb3h5TmFtZTtcbmZ1bmN0aW9uIGdldFByb3hpZWRDb25uZWN0aW9uKGFkZHJlc3MsIGNoYW5uZWxPcHRpb25zLCBjb25uZWN0aW9uT3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoISgnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JyBpbiBjaGFubmVsT3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWxUYXJnZXQgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0J107XG4gICAgY29uc3QgcGFyc2VkVGFyZ2V0ID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkocmVhbFRhcmdldCk7XG4gICAgaWYgKHBhcnNlZFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9XG4gICAgY29uc3Qgc3BsaXRIb3N0UG9zdCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkocGFyc2VkVGFyZ2V0LnBhdGgpO1xuICAgIGlmIChzcGxpdEhvc3RQb3N0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgIH1cbiAgICBjb25zdCBob3N0UG9ydCA9IGAke3NwbGl0SG9zdFBvc3QuaG9zdH06JHsoX2EgPSBzcGxpdEhvc3RQb3N0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlc29sdmVyX2Ruc18xLkRFRkFVTFRfUE9SVH1gO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ0NPTk5FQ1QnLFxuICAgICAgICBwYXRoOiBob3N0UG9ydCxcbiAgICB9O1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgIEhvc3Q6IGhvc3RQb3J0LFxuICAgIH07XG4gICAgLy8gQ29ubmVjdCB0byB0aGUgc3ViY2hhbm5lbCBhZGRyZXNzIGFzIGEgcHJveHlcbiAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKGFkZHJlc3MpKSB7XG4gICAgICAgIG9wdGlvbnMuaG9zdCA9IGFkZHJlc3MuaG9zdDtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gYWRkcmVzcy5wb3J0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gYWRkcmVzcy5wYXRoO1xuICAgIH1cbiAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X2NyZWRzJyBpbiBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPVxuICAgICAgICAgICAgJ0Jhc2ljICcgK1xuICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF9jcmVkcyddKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgY29uc3QgcHJveHlBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpO1xuICAgIHRyYWNlKCdVc2luZyBwcm94eSAnICsgcHJveHlBZGRyZXNzU3RyaW5nICsgJyB0byBjb25uZWN0IHRvICcgKyBvcHRpb25zLnBhdGgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3Qub25jZSgnY29ubmVjdCcsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBjb25uZWN0ZWQgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFRoZSBwcm94eSBpcyBjb25uZWN0aW5nIHRvIGEgVExTIHNlcnZlciwgc28gdXBncmFkZSB0aGlzIHNvY2tldFxuICAgICAgICAgICAgICAgICAgICAgKiBjb25uZWN0aW9uIHRvIGEgVExTIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzMyOTIyXG4gICAgICAgICAgICAgICAgICAgICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjLW5vZGUvcHVsbC8xMzY5IGZvciBtb3JlIGluZm8uICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSAoMCwgcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KShwYXJzZWRUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUhvc3QgPSAoX2EgPSBob3N0UG9ydCA9PT0gbnVsbCB8fCBob3N0UG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9zdFBvcnQuaG9zdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGFyZ2V0UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3RzID0gdGxzLmNvbm5lY3QoT2JqZWN0LmFzc2lnbih7IGhvc3Q6IHJlbW90ZUhvc3QsIHNlcnZlcm5hbWU6IHJlbW90ZUhvc3QsIHNvY2tldDogc29ja2V0IH0sIGNvbm5lY3Rpb25PcHRpb25zKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCBhIFRMUyBjb25uZWN0aW9uIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgc29ja2V0OiBjdHMsIHJlYWxUYXJnZXQ6IHBhcnNlZFRhcmdldCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cy5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKCdGYWlsZWQgdG8gZXN0YWJsaXNoIGEgVExTIGNvbm5lY3Rpb24gdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnU3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkIGEgcGxhaW50ZXh0IGNvbm5lY3Rpb24gdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsVGFyZ2V0OiBwYXJzZWRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsICdGYWlsZWQgdG8gY29ubmVjdCB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAnIHdpdGggc3RhdHVzICcgK1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIGNvbm5lY3QgdG8gcHJveHkgJyArXG4gICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRQcm94aWVkQ29ubmVjdGlvbiA9IGdldFByb3hpZWRDb25uZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cF9wcm94eS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRQcm94aWVkQ29ubmVjdGlvbiIsIm1hcFByb3h5TmFtZSIsImxvZ2dpbmdfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsInJlc29sdmVyXzEiLCJodHRwIiwidGxzIiwibG9nZ2luZyIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwidXJpX3BhcnNlcl8xIiwidXJsXzEiLCJyZXNvbHZlcl9kbnNfMSIsIlRSQUNFUl9OQU1FIiwidHJhY2UiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJnZXRQcm94eUluZm8iLCJwcm94eUVudiIsImVudlZhciIsInByb2Nlc3MiLCJlbnYiLCJncnBjX3Byb3h5IiwiaHR0cHNfcHJveHkiLCJodHRwX3Byb3h5IiwicHJveHlVcmwiLCJVUkwiLCJlIiwibG9nIiwiRVJST1IiLCJwcm90b2NvbCIsInVzZXJDcmVkIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIklORk8iLCJob3N0bmFtZSIsInBvcnQiLCJyZXN1bHQiLCJhZGRyZXNzIiwiY3JlZHMiLCJnZXROb1Byb3h5SG9zdExpc3QiLCJub1Byb3h5U3RyIiwibm9fZ3JwY19wcm94eSIsIm5vX3Byb3h5Iiwic3BsaXQiLCJ0YXJnZXQiLCJvcHRpb25zIiwiX2EiLCJub1Byb3h5UmVzdWx0IiwiZXh0cmFPcHRpb25zIiwic2NoZW1lIiwicHJveHlJbmZvIiwiaG9zdFBvcnQiLCJzcGxpdEhvc3RQb3J0IiwicGF0aCIsInNlcnZlckhvc3QiLCJob3N0IiwidXJpVG9TdHJpbmciLCJjaGFubmVsT3B0aW9ucyIsImNvbm5lY3Rpb25PcHRpb25zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWFsVGFyZ2V0IiwicGFyc2VkVGFyZ2V0IiwicGFyc2VVcmkiLCJzcGxpdEhvc3RQb3N0IiwiREVGQVVMVF9QT1JUIiwibWV0aG9kIiwiaGVhZGVycyIsIkhvc3QiLCJpc1RjcFN1YmNoYW5uZWxBZGRyZXNzIiwic29ja2V0UGF0aCIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsInByb3h5QWRkcmVzc1N0cmluZyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJyZWplY3QiLCJyZXF1ZXN0Iiwib25jZSIsInJlcyIsInNvY2tldCIsImhlYWQiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJzdGF0dXNDb2RlIiwidGFyZ2V0UGF0aCIsImdldERlZmF1bHRBdXRob3JpdHkiLCJyZW1vdGVIb3N0IiwiY3RzIiwiY29ubmVjdCIsImFzc2lnbiIsInNlcnZlcm5hbWUiLCJvbiIsImVycm9yIiwibWVzc2FnZSIsImVyciIsImVuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.experimental = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nObject.defineProperty(exports, \"CallCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return call_credentials_1.CallCredentials;\n    }\n}));\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nObject.defineProperty(exports, \"Channel\", ({\n    enumerable: true,\n    get: function() {\n        return channel_1.ChannelImplementation;\n    }\n}));\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nObject.defineProperty(exports, \"compressionAlgorithms\", ({\n    enumerable: true,\n    get: function() {\n        return compression_algorithms_1.CompressionAlgorithms;\n    }\n}));\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nObject.defineProperty(exports, \"connectivityState\", ({\n    enumerable: true,\n    get: function() {\n        return connectivity_state_1.ConnectivityState;\n    }\n}));\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nObject.defineProperty(exports, \"ChannelCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return channel_credentials_1.ChannelCredentials;\n    }\n}));\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\");\nObject.defineProperty(exports, \"Client\", ({\n    enumerable: true,\n    get: function() {\n        return client_1.Client;\n    }\n}));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nObject.defineProperty(exports, \"logVerbosity\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.LogVerbosity;\n    }\n}));\nObject.defineProperty(exports, \"status\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.Status;\n    }\n}));\nObject.defineProperty(exports, \"propagate\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.Propagate;\n    }\n}));\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nObject.defineProperty(exports, \"loadPackageDefinition\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.loadPackageDefinition;\n    }\n}));\nObject.defineProperty(exports, \"makeClientConstructor\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.makeClientConstructor;\n    }\n}));\nObject.defineProperty(exports, \"makeGenericClientConstructor\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.makeClientConstructor;\n    }\n}));\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nObject.defineProperty(exports, \"Metadata\", ({\n    enumerable: true,\n    get: function() {\n        return metadata_1.Metadata;\n    }\n}));\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js\");\nObject.defineProperty(exports, \"Server\", ({\n    enumerable: true,\n    get: function() {\n        return server_1.Server;\n    }\n}));\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nObject.defineProperty(exports, \"ServerCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return server_credentials_1.ServerCredentials;\n    }\n}));\nconst status_builder_1 = __webpack_require__(/*! ./status-builder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\");\nObject.defineProperty(exports, \"StatusBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return status_builder_1.StatusBuilder;\n    }\n}));\n/**** Client Credentials ****/ // Using assign only copies enumerable properties, which is what we want\nexports.credentials = {\n    /**\n     * Combine a ChannelCredentials with any number of CallCredentials into a\n     * single ChannelCredentials object.\n     * @param channelCredentials The ChannelCredentials object.\n     * @param callCredentials Any number of CallCredentials objects.\n     * @return The resulting ChannelCredentials object.\n     */ combineChannelCredentials: (channelCredentials, ...callCredentials)=>{\n        return callCredentials.reduce((acc, other)=>acc.compose(other), channelCredentials);\n    },\n    /**\n     * Combine any number of CallCredentials into a single CallCredentials\n     * object.\n     * @param first The first CallCredentials object.\n     * @param additional Any number of additional CallCredentials objects.\n     * @return The resulting CallCredentials object.\n     */ combineCallCredentials: (first, ...additional)=>{\n        return additional.reduce((acc, other)=>acc.compose(other), first);\n    },\n    // from channel-credentials.ts\n    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,\n    createSsl: channel_credentials_1.ChannelCredentials.createSsl,\n    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,\n    // from call-credentials.ts\n    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,\n    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,\n    createEmpty: call_credentials_1.CallCredentials.createEmpty\n};\n/**\n * Close a Client object.\n * @param client The client to close.\n */ const closeClient = (client)=>client.close();\nexports.closeClient = closeClient;\nconst waitForClientReady = (client, deadline, callback)=>client.waitForReady(deadline, callback);\nexports.waitForClientReady = waitForClientReady;\n/* eslint-enable @typescript-eslint/no-explicit-any */ /**** Unimplemented function stubs ****/ /* eslint-disable @typescript-eslint/no-explicit-any */ const loadObject = (value, options)=>{\n    throw new Error(\"Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead\");\n};\nexports.loadObject = loadObject;\nconst load = (filename, format, options)=>{\n    throw new Error(\"Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead\");\n};\nexports.load = load;\nconst setLogger = (logger)=>{\n    logging.setLogger(logger);\n};\nexports.setLogger = setLogger;\nconst setLogVerbosity = (verbosity)=>{\n    logging.setLoggerVerbosity(verbosity);\n};\nexports.setLogVerbosity = setLogVerbosity;\nconst getClientChannel = (client)=>{\n    return client_1.Client.prototype.getChannel.call(client);\n};\nexports.getClientChannel = getClientChannel;\nvar client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nObject.defineProperty(exports, \"ListenerBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.ListenerBuilder;\n    }\n}));\nObject.defineProperty(exports, \"RequesterBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.RequesterBuilder;\n    }\n}));\nObject.defineProperty(exports, \"InterceptingCall\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.InterceptingCall;\n    }\n}));\nObject.defineProperty(exports, \"InterceptorConfigurationError\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.InterceptorConfigurationError;\n    }\n}));\nvar channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nObject.defineProperty(exports, \"getChannelzServiceDefinition\", ({\n    enumerable: true,\n    get: function() {\n        return channelz_1.getChannelzServiceDefinition;\n    }\n}));\nObject.defineProperty(exports, \"getChannelzHandlers\", ({\n    enumerable: true,\n    get: function() {\n        return channelz_1.getChannelzHandlers;\n    }\n}));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"addAdminServicesToServer\", ({\n    enumerable: true,\n    get: function() {\n        return admin_1.addAdminServicesToServer;\n    }\n}));\nconst experimental = __webpack_require__(/*! ./experimental */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nexports.experimental = experimental;\nconst resolver_dns = __webpack_require__(/*! ./resolver-dns */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst resolver_uds = __webpack_require__(/*! ./resolver-uds */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\");\nconst resolver_ip = __webpack_require__(/*! ./resolver-ip */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\");\nconst load_balancer_pick_first = __webpack_require__(/*! ./load-balancer-pick-first */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst load_balancer_round_robin = __webpack_require__(/*! ./load-balancer-round-robin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\");\nconst load_balancer_outlier_detection = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nconst channelz = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\n(()=>{\n    resolver_dns.setup();\n    resolver_uds.setup();\n    resolver_ip.setup();\n    load_balancer_pick_first.setup();\n    load_balancer_round_robin.setup();\n    load_balancer_outlier_detection.setup();\n    channelz.setup();\n})(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSxnQ0FBZ0MsR0FBR0EsMkJBQTJCLEdBQUdBLG9DQUFvQyxHQUFHQSxxQ0FBcUMsR0FBR0Esd0JBQXdCLEdBQUdBLHdCQUF3QixHQUFHQSx1QkFBdUIsR0FBR0EscUJBQXFCLEdBQUdBLHdCQUF3QixHQUFHQSx5QkFBeUIsR0FBR0EsY0FBYyxHQUFHQSx1QkFBdUIsR0FBR0EsaUJBQWlCLEdBQUdBLFlBQVksR0FBR0Esa0JBQWtCLEdBQUdBLHVCQUF1QixHQUFHQSwwQkFBMEIsR0FBR0EsMEJBQTBCLEdBQUdBLG1CQUFtQixHQUFHQSxlQUFlLEdBQUdBLG9DQUFvQyxHQUFHQSw2QkFBNkIsR0FBR0EsNkJBQTZCLEdBQUdBLGNBQWMsR0FBR0EsNkJBQTZCLEdBQUdBLGlCQUFpQixHQUFHQSx5QkFBeUIsR0FBR0EsY0FBYyxHQUFHQSxvQkFBb0IsR0FBR0EsZ0JBQWdCLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDbjBCLE1BQU1rQyxxQkFBcUJDLG1CQUFPQSxDQUFDLDRGQUFvQjtBQUN2RHJDLG1EQUFrRDtJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsbUJBQW1CaEIsZUFBZTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hJLE1BQU1vQixZQUFZSCxtQkFBT0EsQ0FBQywwRUFBVztBQUNyQ3JDLDJDQUEwQztJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsVUFBVUMscUJBQXFCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0gsTUFBTUMsMkJBQTJCTCxtQkFBT0EsQ0FBQyx3R0FBMEI7QUFDbkVyQyx5REFBd0Q7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9B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QUMzQyxNQUFNMEQsMkJBQTJCMUQsbUJBQU9BLENBQUMsNEdBQTRCO0FBQ3JFLE1BQU0yRCw0QkFBNEIzRCxtQkFBT0EsQ0FBQyw4R0FBNkI7QUFDdkUsTUFBTTRELGtDQUFrQzVELG1CQUFPQSxDQUFDLDBIQUFtQztBQUNuRixNQUFNNkQsV0FBVzdELG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3BDO0lBQ0d1RCxhQUFhTyxLQUFLO0lBQ2xCTixhQUFhTSxLQUFLO0lBQ2xCTCxZQUFZSyxLQUFLO0lBQ2pCSix5QkFBeUJJLEtBQUs7SUFDOUJILDBCQUEwQkcsS0FBSztJQUMvQkYsZ0NBQWdDRSxLQUFLO0lBQ3JDRCxTQUFTQyxLQUFLO0FBQ2xCLE1BQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanM/Mzk1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHBlcmltZW50YWwgPSBleHBvcnRzLmFkZEFkbWluU2VydmljZXNUb1NlcnZlciA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpIYW5kbGVycyA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGV4cG9ydHMuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgPSBleHBvcnRzLkludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBleHBvcnRzLkxpc3RlbmVyQnVpbGRlciA9IGV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IGV4cG9ydHMuZ2V0Q2xpZW50Q2hhbm5lbCA9IGV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSBleHBvcnRzLlNlcnZlciA9IGV4cG9ydHMuc2V0TG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5zZXRMb2dnZXIgPSBleHBvcnRzLmxvYWQgPSBleHBvcnRzLmxvYWRPYmplY3QgPSBleHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IGV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gZXhwb3J0cy53YWl0Rm9yQ2xpZW50UmVhZHkgPSBleHBvcnRzLmNsb3NlQ2xpZW50ID0gZXhwb3J0cy5DaGFubmVsID0gZXhwb3J0cy5tYWtlR2VuZXJpY0NsaWVudENvbnN0cnVjdG9yID0gZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSBleHBvcnRzLmxvYWRQYWNrYWdlRGVmaW5pdGlvbiA9IGV4cG9ydHMuQ2xpZW50ID0gZXhwb3J0cy5jb21wcmVzc2lvbkFsZ29yaXRobXMgPSBleHBvcnRzLnByb3BhZ2F0ZSA9IGV4cG9ydHMuY29ubmVjdGl2aXR5U3RhdGUgPSBleHBvcnRzLnN0YXR1cyA9IGV4cG9ydHMubG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5NZXRhZGF0YSA9IGV4cG9ydHMuY3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbENyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzOyB9IH0pO1xuY29uc3QgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoYW5uZWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWxfMS5DaGFubmVsSW1wbGVtZW50YXRpb247IH0gfSk7XG5jb25zdCBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbi1hbGdvcml0aG1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHJlc3Npb25BbGdvcml0aG1zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zOyB9IH0pO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25uZWN0aXZpdHlTdGF0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGU7IH0gfSk7XG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hhbm5lbENyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzOyB9IH0pO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF8xLkNsaWVudDsgfSB9KTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9nVmVyYm9zaXR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdGF0dXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLlN0YXR1czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByb3BhZ2F0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuUHJvcGFnYXRlOyB9IH0pO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBtYWtlX2NsaWVudF8xID0gcmVxdWlyZShcIi4vbWFrZS1jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2FkUGFja2FnZURlZmluaXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubG9hZFBhY2thZ2VEZWZpbml0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZUNsaWVudENvbnN0cnVjdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWtlX2NsaWVudF8xLm1ha2VDbGllbnRDb25zdHJ1Y3RvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VHZW5lcmljQ2xpZW50Q29uc3RydWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubWFrZUNsaWVudENvbnN0cnVjdG9yOyB9IH0pO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWV0YWRhdGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ldGFkYXRhXzEuTWV0YWRhdGE7IH0gfSk7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyXzEuU2VydmVyOyB9IH0pO1xuY29uc3Qgc2VydmVyX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItY3JlZGVudGlhbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyX2NyZWRlbnRpYWxzXzEuU2VydmVyQ3JlZGVudGlhbHM7IH0gfSk7XG5jb25zdCBzdGF0dXNfYnVpbGRlcl8xID0gcmVxdWlyZShcIi4vc3RhdHVzLWJ1aWxkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdGF0dXNCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0dXNfYnVpbGRlcl8xLlN0YXR1c0J1aWxkZXI7IH0gfSk7XG4vKioqKiBDbGllbnQgQ3JlZGVudGlhbHMgKioqKi9cbi8vIFVzaW5nIGFzc2lnbiBvbmx5IGNvcGllcyBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIHdoaWNoIGlzIHdoYXQgd2Ugd2FudFxuZXhwb3J0cy5jcmVkZW50aWFscyA9IHtcbiAgICAvKipcbiAgICAgKiBDb21iaW5lIGEgQ2hhbm5lbENyZWRlbnRpYWxzIHdpdGggYW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgaW50byBhXG4gICAgICogc2luZ2xlIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICogQHBhcmFtIGNoYW5uZWxDcmVkZW50aWFscyBUaGUgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY2FsbENyZWRlbnRpYWxzIEFueSBudW1iZXIgb2YgQ2FsbENyZWRlbnRpYWxzIG9iamVjdHMuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgY29tYmluZUNoYW5uZWxDcmVkZW50aWFsczogKGNoYW5uZWxDcmVkZW50aWFscywgLi4uY2FsbENyZWRlbnRpYWxzKSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxsQ3JlZGVudGlhbHMucmVkdWNlKChhY2MsIG90aGVyKSA9PiBhY2MuY29tcG9zZShvdGhlciksIGNoYW5uZWxDcmVkZW50aWFscyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDb21iaW5lIGFueSBudW1iZXIgb2YgQ2FsbENyZWRlbnRpYWxzIGludG8gYSBzaW5nbGUgQ2FsbENyZWRlbnRpYWxzXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgQ2FsbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbCBBbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgQ2FsbENyZWRlbnRpYWxzIG9iamVjdHMuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENhbGxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgY29tYmluZUNhbGxDcmVkZW50aWFsczogKGZpcnN0LCAuLi5hZGRpdGlvbmFsKSA9PiB7XG4gICAgICAgIHJldHVybiBhZGRpdGlvbmFsLnJlZHVjZSgoYWNjLCBvdGhlcikgPT4gYWNjLmNvbXBvc2Uob3RoZXIpLCBmaXJzdCk7XG4gICAgfSxcbiAgICAvLyBmcm9tIGNoYW5uZWwtY3JlZGVudGlhbHMudHNcbiAgICBjcmVhdGVJbnNlY3VyZTogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVJbnNlY3VyZSxcbiAgICBjcmVhdGVTc2w6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlU3NsLFxuICAgIGNyZWF0ZUZyb21TZWN1cmVDb250ZXh0OiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21TZWN1cmVDb250ZXh0LFxuICAgIC8vIGZyb20gY2FsbC1jcmVkZW50aWFscy50c1xuICAgIGNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcjogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IsXG4gICAgY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWw6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWwsXG4gICAgY3JlYXRlRW1wdHk6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRW1wdHksXG59O1xuLyoqXG4gKiBDbG9zZSBhIENsaWVudCBvYmplY3QuXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBjbGllbnQgdG8gY2xvc2UuXG4gKi9cbmNvbnN0IGNsb3NlQ2xpZW50ID0gKGNsaWVudCkgPT4gY2xpZW50LmNsb3NlKCk7XG5leHBvcnRzLmNsb3NlQ2xpZW50ID0gY2xvc2VDbGllbnQ7XG5jb25zdCB3YWl0Rm9yQ2xpZW50UmVhZHkgPSAoY2xpZW50LCBkZWFkbGluZSwgY2FsbGJhY2spID0+IGNsaWVudC53YWl0Rm9yUmVhZHkoZGVhZGxpbmUsIGNhbGxiYWNrKTtcbmV4cG9ydHMud2FpdEZvckNsaWVudFJlYWR5ID0gd2FpdEZvckNsaWVudFJlYWR5O1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKioqKiBVbmltcGxlbWVudGVkIGZ1bmN0aW9uIHN0dWJzICoqKiovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBsb2FkT2JqZWN0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXZhaWxhYmxlIGluIHRoaXMgbGlicmFyeS4gVXNlIEBncnBjL3Byb3RvLWxvYWRlciBhbmQgbG9hZFBhY2thZ2VEZWZpbml0aW9uIGluc3RlYWQnKTtcbn07XG5leHBvcnRzLmxvYWRPYmplY3QgPSBsb2FkT2JqZWN0O1xuY29uc3QgbG9hZCA9IChmaWxlbmFtZSwgZm9ybWF0LCBvcHRpb25zKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXZhaWxhYmxlIGluIHRoaXMgbGlicmFyeS4gVXNlIEBncnBjL3Byb3RvLWxvYWRlciBhbmQgbG9hZFBhY2thZ2VEZWZpbml0aW9uIGluc3RlYWQnKTtcbn07XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuY29uc3Qgc2V0TG9nZ2VyID0gKGxvZ2dlcikgPT4ge1xuICAgIGxvZ2dpbmcuc2V0TG9nZ2VyKGxvZ2dlcik7XG59O1xuZXhwb3J0cy5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XG5jb25zdCBzZXRMb2dWZXJib3NpdHkgPSAodmVyYm9zaXR5KSA9PiB7XG4gICAgbG9nZ2luZy5zZXRMb2dnZXJWZXJib3NpdHkodmVyYm9zaXR5KTtcbn07XG5leHBvcnRzLnNldExvZ1ZlcmJvc2l0eSA9IHNldExvZ1ZlcmJvc2l0eTtcbmNvbnN0IGdldENsaWVudENoYW5uZWwgPSAoY2xpZW50KSA9PiB7XG4gICAgcmV0dXJuIGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUuZ2V0Q2hhbm5lbC5jYWxsKGNsaWVudCk7XG59O1xuZXhwb3J0cy5nZXRDbGllbnRDaGFubmVsID0gZ2V0Q2xpZW50Q2hhbm5lbDtcbnZhciBjbGllbnRfaW50ZXJjZXB0b3JzXzEgPSByZXF1aXJlKFwiLi9jbGllbnQtaW50ZXJjZXB0b3JzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlzdGVuZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuTGlzdGVuZXJCdWlsZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdGVyQnVpbGRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50X2ludGVyY2VwdG9yc18xLlJlcXVlc3RlckJ1aWxkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcmNlcHRpbmdDYWxsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuSW50ZXJjZXB0aW5nQ2FsbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3I7IH0gfSk7XG52YXIgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbHpfMS5nZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q2hhbm5lbHpIYW5kbGVyc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbHpfMS5nZXRDaGFubmVsekhhbmRsZXJzOyB9IH0pO1xudmFyIGFkbWluXzEgPSByZXF1aXJlKFwiLi9hZG1pblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZEFkbWluU2VydmljZXNUb1NlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRtaW5fMS5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXI7IH0gfSk7XG5jb25zdCBleHBlcmltZW50YWwgPSByZXF1aXJlKFwiLi9leHBlcmltZW50YWxcIik7XG5leHBvcnRzLmV4cGVyaW1lbnRhbCA9IGV4cGVyaW1lbnRhbDtcbmNvbnN0IHJlc29sdmVyX2RucyA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyLWRuc1wiKTtcbmNvbnN0IHJlc29sdmVyX3VkcyA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyLXVkc1wiKTtcbmNvbnN0IHJlc29sdmVyX2lwID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItaXBcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3QgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3RcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX3JvdW5kX3JvYmluID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1yb3VuZC1yb2JpblwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb24gPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uXCIpO1xuY29uc3QgY2hhbm5lbHogPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbigoKSA9PiB7XG4gICAgcmVzb2x2ZXJfZG5zLnNldHVwKCk7XG4gICAgcmVzb2x2ZXJfdWRzLnNldHVwKCk7XG4gICAgcmVzb2x2ZXJfaXAuc2V0dXAoKTtcbiAgICBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3Quc2V0dXAoKTtcbiAgICBsb2FkX2JhbGFuY2VyX3JvdW5kX3JvYmluLnNldHVwKCk7XG4gICAgbG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbi5zZXR1cCgpO1xuICAgIGNoYW5uZWx6LnNldHVwKCk7XG59KSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZXhwZXJpbWVudGFsIiwiYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyIiwiZ2V0Q2hhbm5lbHpIYW5kbGVycyIsImdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24iLCJJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciIsIkludGVyY2VwdGluZ0NhbGwiLCJSZXF1ZXN0ZXJCdWlsZGVyIiwiTGlzdGVuZXJCdWlsZGVyIiwiU3RhdHVzQnVpbGRlciIsImdldENsaWVudENoYW5uZWwiLCJTZXJ2ZXJDcmVkZW50aWFscyIsIlNlcnZlciIsInNldExvZ1ZlcmJvc2l0eSIsInNldExvZ2dlciIsImxvYWQiLCJsb2FkT2JqZWN0IiwiQ2FsbENyZWRlbnRpYWxzIiwiQ2hhbm5lbENyZWRlbnRpYWxzIiwid2FpdEZvckNsaWVudFJlYWR5IiwiY2xvc2VDbGllbnQiLCJDaGFubmVsIiwibWFrZUdlbmVyaWNDbGllbnRDb25zdHJ1Y3RvciIsIm1ha2VDbGllbnRDb25zdHJ1Y3RvciIsImxvYWRQYWNrYWdlRGVmaW5pdGlvbiIsIkNsaWVudCIsImNvbXByZXNzaW9uQWxnb3JpdGhtcyIsInByb3BhZ2F0ZSIsImNvbm5lY3Rpdml0eVN0YXRlIiwic3RhdHVzIiwibG9nVmVyYm9zaXR5IiwiTWV0YWRhdGEiLCJjcmVkZW50aWFscyIsImNhbGxfY3JlZGVudGlhbHNfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY2hhbm5lbF8xIiwiQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY29tcHJlc3Npb25fYWxnb3JpdGhtc18xIiwiQ29tcHJlc3Npb25BbGdvcml0aG1zIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJDb25uZWN0aXZpdHlTdGF0ZSIsImNoYW5uZWxfY3JlZGVudGlhbHNfMSIsImNsaWVudF8xIiwiY29uc3RhbnRzXzEiLCJMb2dWZXJib3NpdHkiLCJTdGF0dXMiLCJQcm9wYWdhdGUiLCJsb2dnaW5nIiwibWFrZV9jbGllbnRfMSIsIm1ldGFkYXRhXzEiLCJzZXJ2ZXJfMSIsInNlcnZlcl9jcmVkZW50aWFsc18xIiwic3RhdHVzX2J1aWxkZXJfMSIsImNvbWJpbmVDaGFubmVsQ3JlZGVudGlhbHMiLCJjaGFubmVsQ3JlZGVudGlhbHMiLCJjYWxsQ3JlZGVudGlhbHMiLCJyZWR1Y2UiLCJhY2MiLCJvdGhlciIsImNvbXBvc2UiLCJjb21iaW5lQ2FsbENyZWRlbnRpYWxzIiwiZmlyc3QiLCJhZGRpdGlvbmFsIiwiY3JlYXRlSW5zZWN1cmUiLCJjcmVhdGVTc2wiLCJjcmVhdGVGcm9tU2VjdXJlQ29udGV4dCIsImNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvciIsImNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsIiwiY3JlYXRlRW1wdHkiLCJjbGllbnQiLCJjbG9zZSIsImRlYWRsaW5lIiwiY2FsbGJhY2siLCJ3YWl0Rm9yUmVhZHkiLCJvcHRpb25zIiwiRXJyb3IiLCJmaWxlbmFtZSIsImZvcm1hdCIsImxvZ2dlciIsInZlcmJvc2l0eSIsInNldExvZ2dlclZlcmJvc2l0eSIsInByb3RvdHlwZSIsImdldENoYW5uZWwiLCJjYWxsIiwiY2xpZW50X2ludGVyY2VwdG9yc18xIiwiY2hhbm5lbHpfMSIsImFkbWluXzEiLCJyZXNvbHZlcl9kbnMiLCJyZXNvbHZlcl91ZHMiLCJyZXNvbHZlcl9pcCIsImxvYWRfYmFsYW5jZXJfcGlja19maXJzdCIsImxvYWRfYmFsYW5jZXJfcm91bmRfcm9iaW4iLCJsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uIiwiY2hhbm5lbHoiLCJzZXR1cCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/internal-channel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InternalChannel = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst resolving_load_balancer_1 = __webpack_require__(/*! ./resolving-load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\");\nconst subchannel_pool_1 = __webpack_require__(/*! ./subchannel-pool */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst max_message_size_filter_1 = __webpack_require__(/*! ./max-message-size-filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst load_balancing_call_1 = __webpack_require__(/*! ./load-balancing-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst resolving_call_1 = __webpack_require__(/*! ./resolving-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst retrying_call_1 = __webpack_require__(/*! ./retrying-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */ const MAX_TIMEOUT_TIME = 2147483647;\nconst MIN_IDLE_TIMEOUT_MS = 1000;\n// 30 minutes\nconst DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;\nconst RETRY_THROTTLER_MAP = new Map();\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\nclass ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, channel){\n        super(childSubchannel);\n        this.channel = channel;\n        this.refCount = 0;\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime)=>{\n            channel.throttleKeepalive(keepaliveTime);\n        };\n        childSubchannel.addConnectivityStateListener(this.subchannelStateListener);\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            this.child.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channel.removeWrappedSubchannel(this);\n        }\n    }\n}\nclass InternalChannel {\n    constructor(target, credentials, options){\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */ this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        this.configSelector = null;\n        /**\n         * This is the error from the name resolver if it failed most recently. It\n         * is only used to end calls that start while there is no config selector\n         * and the name resolver is in backoff, so it should be nulled if\n         * configSelector becomes set or the channel state becomes anything other\n         * than TRANSIENT_FAILURE.\n         */ this.currentResolutionError = null;\n        this.wrappedSubchannels = new Set();\n        this.callCount = 0;\n        this.idleTimer = null;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        if (typeof target !== \"string\") {\n            throw new TypeError(\"Channel target must be a string\");\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError(\"Channel credentials must be a ChannelCredentials object\");\n        }\n        if (options) {\n            if (typeof options !== \"object\") {\n                throw new TypeError(\"Channel options must be an object\");\n            }\n        }\n        this.originalTarget = target;\n        const originalTargetUri = (0, uri_parser_1.parseUri)(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */ const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        this.callRefTimer = setInterval(()=>{}, MAX_TIMEOUT_TIME);\n        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (this.options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Channel created\");\n        }\n        if (this.options[\"grpc.default_authority\"]) {\n            this.defaultAuthority = this.options[\"grpc.default_authority\"];\n        } else {\n            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);\n        }\n        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */ this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c = options[\"grpc.use_local_subchannel_pool\"]) !== null && _c !== void 0 ? _c : 0) === 0);\n        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options[\"grpc.retry_buffer_size\"]) !== null && _d !== void 0 ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options[\"grpc.per_rpc_retry_buffer_size\"]) !== null && _e !== void 0 ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);\n        this.keepaliveTime = (_f = options[\"grpc.keepalive_time_ms\"]) !== null && _f !== void 0 ? _f : -1;\n        this.idleTimeoutMs = Math.max((_g = options[\"grpc.client_idle_timeout_ms\"]) !== null && _g !== void 0 ? _g : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs)=>{\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n                subchannel.throttleKeepalive(this.keepaliveTime);\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace(\"CT_INFO\", \"Created subchannel or used existing subchannel\", subchannel.getChannelzRef());\n                }\n                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);\n                this.wrappedSubchannels.add(wrappedSubchannel);\n                return wrappedSubchannel;\n            },\n            updateState: (connectivityState, picker)=>{\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                this.callRefTimerUnref();\n                for (const call of queueCopy){\n                    call.doPick();\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: ()=>{\n                // This should never be called.\n                throw new Error(\"Resolving load balancer should never call requestReresolution\");\n            },\n            addChannelzChild: (child)=>{\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(child);\n                }\n            },\n            removeChannelzChild: (child)=>{\n                if (this.channelzEnabled) {\n                    this.childrenTracker.unrefChild(child);\n                }\n            }\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector)=>{\n            if (serviceConfig.retryThrottling) {\n                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));\n            } else {\n                RETRY_THROTTLER_MAP.delete(this.getTarget());\n            }\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Address resolution succeeded\");\n            }\n            this.configSelector = configSelector;\n            this.currentResolutionError = null;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */ process.nextTick(()=>{\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                this.callRefTimerUnref();\n                for (const call of localQueue){\n                    call.getConfig();\n                }\n                this.configSelectionQueue = [];\n            });\n        }, (status)=>{\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_WARNING\", \"Address resolution failed with code \" + status.code + ' and details \"' + status.details + '\"');\n            }\n            if (this.configSelectionQueue.length > 0) {\n                this.trace(\"Name resolution failed with calls queued for config selection\");\n            }\n            if (this.configSelector === null) {\n                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), {\n                    metadata: status.metadata\n                });\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            this.callRefTimerUnref();\n            for (const call of localQueue){\n                call.reportResolverError(status);\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),\n            new compression_filter_1.CompressionFilterFactory(this, this.options)\n        ]);\n        this.trace(\"Channel constructed with options \" + JSON.stringify(options, undefined, 2));\n        const error = new Error();\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, \"channel_stacktrace\", \"(\" + this.channelzRef.id + \") \" + \"Channel constructed \\n\" + ((_h = error.stack) === null || _h === void 0 ? void 0 : _h.substring(error.stack.indexOf(\"\\n\") + 1)));\n    }\n    getChannelzInfo() {\n        return {\n            target: this.originalTarget,\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists()\n        };\n    }\n    trace(text, verbosityOverride) {\n        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, \"channel\", \"(\" + this.channelzRef.id + \") \" + (0, uri_parser_1.uriToString)(this.target) + \" \" + text);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            this.trace(\"callRefTimer.ref | configSelectionQueue.length=\" + this.configSelectionQueue.length + \" pickQueue.length=\" + this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b;\n        // If the hasRef function does not exist, always run the code\n        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n            this.trace(\"callRefTimer.unref | configSelectionQueue.length=\" + this.configSelectionQueue.length + \" pickQueue.length=\" + this.pickQueue.length);\n            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex((value)=>value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, \"connectivity_state\", \"(\" + this.channelzRef.id + \") \" + (0, uri_parser_1.uriToString)(this.target) + \" \" + connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Connectivity state change to \" + connectivity_state_1.ConnectivityState[newState]);\n        }\n        this.connectivityState = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy){\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            this.currentResolutionError = null;\n        }\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n            for (const wrappedSubchannel of this.wrappedSubchannels){\n                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\n            }\n        }\n    }\n    removeWrappedSubchannel(wrappedSubchannel) {\n        this.wrappedSubchannels.delete(wrappedSubchannel);\n    }\n    doPick(metadata, extraPickInfo) {\n        return this.currentPicker.pick({\n            metadata: metadata,\n            extraPickInfo: extraPickInfo\n        });\n    }\n    queueCallForPick(call) {\n        this.pickQueue.push(call);\n        this.callRefTimerRef();\n    }\n    getConfig(method, metadata) {\n        this.resolvingLoadBalancer.exitIdle();\n        if (this.configSelector) {\n            return {\n                type: \"SUCCESS\",\n                config: this.configSelector(method, metadata)\n            };\n        } else {\n            if (this.currentResolutionError) {\n                return {\n                    type: \"ERROR\",\n                    error: this.currentResolutionError\n                };\n            } else {\n                return {\n                    type: \"NONE\"\n                };\n            }\n        }\n    }\n    queueCallForConfig(call) {\n        this.configSelectionQueue.push(call);\n        this.callRefTimerRef();\n    }\n    enterIdle() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE);\n        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);\n    }\n    maybeStartIdleTimer() {\n        var _a, _b;\n        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN && this.callCount === 0) {\n            this.idleTimer = setTimeout(()=>{\n                this.trace(\"Idle timer triggered after \" + this.idleTimeoutMs + \"ms of inactivity\");\n                this.enterIdle();\n            }, this.idleTimeoutMs);\n            (_b = (_a = this.idleTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    onCallStart() {\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n        }\n        this.callCount += 1;\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n            this.idleTimer = null;\n        }\n    }\n    onCallEnd(status) {\n        if (this.channelzEnabled) {\n            if (status.code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            } else {\n                this.callTracker.addCallFailed();\n            }\n        }\n        this.callCount -= 1;\n        this.maybeStartIdleTimer();\n    }\n    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace(\"createLoadBalancingCall [\" + callNumber + '] method=\"' + method + '\"');\n        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);\n    }\n    createRetryingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace(\"createRetryingCall [\" + callNumber + '] method=\"' + method + '\"');\n        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));\n    }\n    createInnerCall(callConfig, method, host, credentials, deadline) {\n        // Create a RetryingCall if retries are enabled\n        if (this.options[\"grpc.enable_retries\"] === 0) {\n            return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);\n        } else {\n            return this.createRetryingCall(callConfig, method, host, credentials, deadline);\n        }\n    }\n    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace(\"createResolvingCall [\" + callNumber + '] method=\"' + method + '\", deadline=' + (0, deadline_1.deadlineToString)(deadline));\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall\n        };\n        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);\n        this.onCallStart();\n        call.addStatusWatcher((status)=>{\n            this.onCallEnd(status);\n        });\n        return call;\n    }\n    close() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n        clearInterval(this.callRefTimer);\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n        }\n        if (this.channelzEnabled) {\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        }\n        this.subchannelPool.unrefUnusedSubchannels();\n    }\n    getTarget() {\n        return (0, uri_parser_1.uriToString)(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n            this.maybeStartIdleTimer();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error(\"Channel has been shut down\");\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error(\"Deadline passed without connectivity state change\"));\n                return;\n            }\n            timer = setTimeout(()=>{\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error(\"Deadline passed without connectivity state change\"));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== \"string\") {\n            throw new TypeError(\"Channel#createCall: method must be a string\");\n        }\n        if (!(typeof deadline === \"number\" || deadline instanceof Date)) {\n            throw new TypeError(\"Channel#createCall: deadline must be a number or Date\");\n        }\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error(\"Channel has been shut down\");\n        }\n        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);\n    }\n}\nexports.InternalChannel = InternalChannel; //# sourceMappingURL=internal-channel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW50ZXJuYWwtY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHLEtBQUs7QUFDL0IsTUFBTUcsd0JBQXdCQyxtQkFBT0EsQ0FBQyxrR0FBdUI7QUFDN0QsTUFBTUMsNEJBQTRCRCxtQkFBT0EsQ0FBQywwR0FBMkI7QUFDckUsTUFBTUUsb0JBQW9CRixtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUksY0FBY0osbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUssaUJBQWlCTCxtQkFBT0EsQ0FBQyxvRkFBZ0I7QUFDL0MsTUFBTU0sdUJBQXVCTixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTVEsWUFBWVIsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTVMsNEJBQTRCVCxtQkFBT0EsQ0FBQywwR0FBMkI7QUFDckUsTUFBTVUsZUFBZVYsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVcsZUFBZVgsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVksdUJBQXVCWixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTWEsYUFBYWIsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTWMsd0JBQXdCZCxtQkFBT0EsQ0FBQyxrR0FBdUI7QUFDN0QsTUFBTWUsYUFBYWYsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTWdCLG1CQUFtQmhCLG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNuRCxNQUFNaUIsZ0JBQWdCakIsbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0MsTUFBTWtCLHlCQUF5QmxCLG1CQUFP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LElBQUlsSCxNQUFNO1FBQ3BCO1FBQ0EsT0FBTyxJQUFJLENBQUNxSSxtQkFBbUIsQ0FBQzVCLFFBQVFxQixVQUFVRCxNQUFNUyxZQUFZQztJQUN4RTtBQUNKO0FBQ0E1Tix1QkFBdUIsR0FBR0UsaUJBQzFCLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2ludGVybmFsLWNoYW5uZWwuanM/MzRkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRlcm5hbENoYW5uZWwgPSB2b2lkIDA7XG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgcmVzb2x2aW5nX2xvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmluZy1sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9wb29sXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLXBvb2xcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZmlsdGVyX3N0YWNrXzEgPSByZXF1aXJlKFwiLi9maWx0ZXItc3RhY2tcIik7XG5jb25zdCBjb21wcmVzc2lvbl9maWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWZpbHRlclwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBtYXhfbWVzc2FnZV9zaXplX2ZpbHRlcl8xID0gcmVxdWlyZShcIi4vbWF4LW1lc3NhZ2Utc2l6ZS1maWx0ZXJcIik7XG5jb25zdCBodHRwX3Byb3h5XzEgPSByZXF1aXJlKFwiLi9odHRwX3Byb3h5XCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgbG9hZF9iYWxhbmNpbmdfY2FsbF8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNpbmctY2FsbFwiKTtcbmNvbnN0IGRlYWRsaW5lXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZVwiKTtcbmNvbnN0IHJlc29sdmluZ19jYWxsXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZpbmctY2FsbFwiKTtcbmNvbnN0IGNhbGxfbnVtYmVyXzEgPSByZXF1aXJlKFwiLi9jYWxsLW51bWJlclwiKTtcbmNvbnN0IGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEgPSByZXF1aXJlKFwiLi9jb250cm9sLXBsYW5lLXN0YXR1c1wiKTtcbmNvbnN0IHJldHJ5aW5nX2NhbGxfMSA9IHJlcXVpcmUoXCIuL3JldHJ5aW5nLWNhbGxcIik7XG5jb25zdCBzdWJjaGFubmVsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1pbnRlcmZhY2VcIik7XG4vKipcbiAqIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3RpbWVycy5odG1sI3RpbWVyc19zZXRpbnRlcnZhbF9jYWxsYmFja19kZWxheV9hcmdzXG4gKi9cbmNvbnN0IE1BWF9USU1FT1VUX1RJTUUgPSAyMTQ3NDgzNjQ3O1xuY29uc3QgTUlOX0lETEVfVElNRU9VVF9NUyA9IDEwMDA7XG4vLyAzMCBtaW51dGVzXG5jb25zdCBERUZBVUxUX0lETEVfVElNRU9VVF9NUyA9IDMwICogNjAgKiAxMDAwO1xuY29uc3QgUkVUUllfVEhST1RUTEVSX01BUCA9IG5ldyBNYXAoKTtcbmNvbnN0IERFRkFVTFRfUkVUUllfQlVGRkVSX1NJWkVfQllURVMgPSAxIDw8IDI0OyAvLyAxNiBNQlxuY29uc3QgREVGQVVMVF9QRVJfUlBDX1JFVFJZX0JVRkZFUl9TSVpFX0JZVEVTID0gMSA8PCAyMDsgLy8gMSBNQlxuY2xhc3MgQ2hhbm5lbFN1YmNoYW5uZWxXcmFwcGVyIGV4dGVuZHMgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMS5CYXNlU3ViY2hhbm5lbFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkU3ViY2hhbm5lbCwgY2hhbm5lbCkge1xuICAgICAgICBzdXBlcihjaGlsZFN1YmNoYW5uZWwpO1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lciA9IChzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwga2VlcGFsaXZlVGltZSkgPT4ge1xuICAgICAgICAgICAgY2hhbm5lbC50aHJvdHRsZUtlZXBhbGl2ZShrZWVwYWxpdmVUaW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGRTdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCArPSAxO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC51bnJlZigpO1xuICAgICAgICB0aGlzLnJlZkNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLnJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5yZW1vdmVXcmFwcGVkU3ViY2hhbm5lbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEludGVybmFsQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjcmVkZW50aWFscywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxzIHF1ZXVlZCB1cCB0byBnZXQgYSBjYWxsIGNvbmZpZy4gU2hvdWxkIG9ubHkgYmUgcG9wdWxhdGVkIGJlZm9yZSB0aGVcbiAgICAgICAgICogZmlyc3QgdGltZSB0aGUgcmVzb2x2ZXIgcmV0dXJucyBhIHJlc3VsdCwgd2hpY2ggaW5jbHVkZXMgdGhlIENvbmZpZ1NlbGVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnBpY2tRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3RvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBlcnJvciBmcm9tIHRoZSBuYW1lIHJlc29sdmVyIGlmIGl0IGZhaWxlZCBtb3N0IHJlY2VudGx5LiBJdFxuICAgICAgICAgKiBpcyBvbmx5IHVzZWQgdG8gZW5kIGNhbGxzIHRoYXQgc3RhcnQgd2hpbGUgdGhlcmUgaXMgbm8gY29uZmlnIHNlbGVjdG9yXG4gICAgICAgICAqIGFuZCB0aGUgbmFtZSByZXNvbHZlciBpcyBpbiBiYWNrb2ZmLCBzbyBpdCBzaG91bGQgYmUgbnVsbGVkIGlmXG4gICAgICAgICAqIGNvbmZpZ1NlbGVjdG9yIGJlY29tZXMgc2V0IG9yIHRoZSBjaGFubmVsIHN0YXRlIGJlY29tZXMgYW55dGhpbmcgb3RoZXJcbiAgICAgICAgICogdGhhbiBUUkFOU0lFTlRfRkFJTFVSRS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMud3JhcHBlZFN1YmNoYW5uZWxzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmNhbGxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgLy8gQ2hhbm5lbHogaW5mb1xuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIHRhcmdldCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY3JlZGVudGlhbHMgaW5zdGFuY2VvZiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBjcmVkZW50aWFscyBtdXN0IGJlIGEgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmlnaW5hbFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUYXJnZXRVcmkgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKSh0YXJnZXQpO1xuICAgICAgICBpZiAob3JpZ2luYWxUYXJnZXRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIHNjaGVtZSB0aGF0IGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGVcbiAgICAgICAgICogcmVzb2x2ZXIgKi9cbiAgICAgICAgY29uc3QgZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCA9ICgwLCByZXNvbHZlcl8xLm1hcFVyaURlZmF1bHRTY2hlbWUpKG9yaWdpbmFsVGFyZ2V0VXJpKTtcbiAgICAgICAgaWYgKGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBkZWZhdWx0IHNjaGVtZSBmb3IgdGFyZ2V0IG5hbWUgXCIke3RhcmdldH1cImApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB9LCBNQVhfVElNRU9VVF9USU1FKTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYWxsUmVmVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwpKHRhcmdldCwgKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDaGFubmVsIGNyZWF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmRlZmF1bHRfYXV0aG9yaXR5J10pIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEF1dGhvcml0eSA9IHRoaXMub3B0aW9uc1snZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QXV0aG9yaXR5ID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJveHlNYXBSZXN1bHQgPSAoMCwgaHR0cF9wcm94eV8xLm1hcFByb3h5TmFtZSkoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gcHJveHlNYXBSZXN1bHQudGFyZ2V0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHByb3h5TWFwUmVzdWx0LmV4dHJhT3B0aW9ucyk7XG4gICAgICAgIC8qIFRoZSBnbG9iYWwgYm9vbGVhbiBwYXJhbWV0ZXIgdG8gZ2V0U3ViY2hhbm5lbFBvb2wgaGFzIHRoZSBpbnZlcnNlIG1lYW5pbmcgdG8gd2hhdFxuICAgICAgICAgKiB0aGUgZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sIGNoYW5uZWwgb3B0aW9uIG1lYW5zLiAqL1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxQb29sID0gKDAsIHN1YmNoYW5uZWxfcG9vbF8xLmdldFN1YmNoYW5uZWxQb29sKSgoKF9jID0gb3B0aW9uc1snZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sJ10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDApID09PSAwKTtcbiAgICAgICAgdGhpcy5yZXRyeUJ1ZmZlclRyYWNrZXIgPSBuZXcgcmV0cnlpbmdfY2FsbF8xLk1lc3NhZ2VCdWZmZXJUcmFja2VyKChfZCA9IG9wdGlvbnNbJ2dycGMucmV0cnlfYnVmZmVyX3NpemUnXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogREVGQVVMVF9SRVRSWV9CVUZGRVJfU0laRV9CWVRFUywgKF9lID0gb3B0aW9uc1snZ3JwYy5wZXJfcnBjX3JldHJ5X2J1ZmZlcl9zaXplJ10pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IERFRkFVTFRfUEVSX1JQQ19SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IChfZiA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogLTE7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXRNcyA9IE1hdGgubWF4KChfZyA9IG9wdGlvbnNbJ2dycGMuY2xpZW50X2lkbGVfdGltZW91dF9tcyddKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBERUZBVUxUX0lETEVfVElNRU9VVF9NUywgTUlOX0lETEVfVElNRU9VVF9NUyk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxDb250cm9sSGVscGVyID0ge1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWwgPSB0aGlzLnN1YmNoYW5uZWxQb29sLmdldE9yQ3JlYXRlU3ViY2hhbm5lbCh0aGlzLnRhcmdldCwgc3ViY2hhbm5lbEFkZHJlc3MsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgc3ViY2hhbm5lbEFyZ3MpLCB0aGlzLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKHRoaXMua2VlcGFsaXZlVGltZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDcmVhdGVkIHN1YmNoYW5uZWwgb3IgdXNlZCBleGlzdGluZyBzdWJjaGFubmVsJywgc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZFN1YmNoYW5uZWwgPSBuZXcgQ2hhbm5lbFN1YmNoYW5uZWxXcmFwcGVyKHN1YmNoYW5uZWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlZFN1YmNoYW5uZWxzLmFkZCh3cmFwcGVkU3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRTdWJjaGFubmVsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZUNvcHkgPSB0aGlzLnBpY2tRdWV1ZS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGlja1F1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJVbnJlZigpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBxdWV1ZUNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5kb1BpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBsb2FkIGJhbGFuY2VyIHNob3VsZCBuZXZlciBjYWxsIHJlcXVlc3RSZXJlc29sdXRpb24nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkOiAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIgPSBuZXcgcmVzb2x2aW5nX2xvYWRfYmFsYW5jZXJfMS5SZXNvbHZpbmdMb2FkQmFsYW5jZXIodGhpcy50YXJnZXQsIGNoYW5uZWxDb250cm9sSGVscGVyLCBvcHRpb25zLCAoc2VydmljZUNvbmZpZywgY29uZmlnU2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZykge1xuICAgICAgICAgICAgICAgIFJFVFJZX1RIUk9UVExFUl9NQVAuc2V0KHRoaXMuZ2V0VGFyZ2V0KCksIG5ldyByZXRyeWluZ19jYWxsXzEuUmV0cnlUaHJvdHRsZXIoc2VydmljZUNvbmZpZy5yZXRyeVRocm90dGxpbmcubWF4VG9rZW5zLCBzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZy50b2tlblJhdGlvLCBSRVRSWV9USFJPVFRMRVJfTUFQLmdldCh0aGlzLmdldFRhcmdldCgpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUkVUUllfVEhST1RUTEVSX01BUC5kZWxldGUodGhpcy5nZXRUYXJnZXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQWRkcmVzcyByZXNvbHV0aW9uIHN1Y2NlZWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3RvciA9IGNvbmZpZ1NlbGVjdG9yO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIC8qIFdlIHByb2Nlc3MgdGhlIHF1ZXVlIGFzeW5jaHJvbm91c2x5IHRvIGVuc3VyZSB0aGF0IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAgKiBsb2FkIGJhbGFuY2VyIHVwZGF0ZSBoYXMgY29tcGxldGVkLiAqL1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxRdWV1ZSA9IHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyVW5yZWYoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgbG9jYWxRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgc3RhdHVzID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfV0FSTklORycsICdBZGRyZXNzIHJlc29sdXRpb24gZmFpbGVkIHdpdGggY29kZSAnICtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmNvZGUgK1xuICAgICAgICAgICAgICAgICAgICAnIGFuZCBkZXRhaWxzIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnTmFtZSByZXNvbHV0aW9uIGZhaWxlZCB3aXRoIGNhbGxzIHF1ZXVlZCBmb3IgY29uZmlnIHNlbGVjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkoc3RhdHVzLmNvZGUsIHN0YXR1cy5kZXRhaWxzKSksIHsgbWV0YWRhdGE6IHN0YXR1cy5tZXRhZGF0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsUXVldWUgPSB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlO1xuICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJVbnJlZigpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIGxvY2FsUXVldWUpIHtcbiAgICAgICAgICAgICAgICBjYWxsLnJlcG9ydFJlc29sdmVyRXJyb3Ioc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5ID0gbmV3IGZpbHRlcl9zdGFja18xLkZpbHRlclN0YWNrRmFjdG9yeShbXG4gICAgICAgICAgICBuZXcgbWF4X21lc3NhZ2Vfc2l6ZV9maWx0ZXJfMS5NYXhNZXNzYWdlU2l6ZUZpbHRlckZhY3RvcnkodGhpcy5vcHRpb25zKSxcbiAgICAgICAgICAgIG5ldyBjb21wcmVzc2lvbl9maWx0ZXJfMS5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkodGhpcywgdGhpcy5vcHRpb25zKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMudHJhY2UoJ0NoYW5uZWwgY29uc3RydWN0ZWQgd2l0aCBvcHRpb25zICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgdW5kZWZpbmVkLCAyKSk7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgICgwLCBsb2dnaW5nXzEudHJhY2UpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2NoYW5uZWxfc3RhY2t0cmFjZScsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgJ0NoYW5uZWwgY29uc3RydWN0ZWQgXFxuJyArXG4gICAgICAgICAgICAoKF9oID0gZXJyb3Iuc3RhY2spID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5zdWJzdHJpbmcoZXJyb3Iuc3RhY2suaW5kZXhPZignXFxuJykgKyAxKSkpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMub3JpZ2luYWxUYXJnZXQsXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSxcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXG4gICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLmNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlKHRleHQsIHZlcmJvc2l0eU92ZXJyaWRlKSB7XG4gICAgICAgICgwLCBsb2dnaW5nXzEudHJhY2UpKHZlcmJvc2l0eU92ZXJyaWRlICE9PSBudWxsICYmIHZlcmJvc2l0eU92ZXJyaWRlICE9PSB2b2lkIDAgPyB2ZXJib3NpdHlPdmVycmlkZSA6IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2NoYW5uZWwnLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArICcgJyArIHRleHQpO1xuICAgIH1cbiAgICBjYWxsUmVmVGltZXJSZWYoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gSWYgdGhlIGhhc1JlZiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCwgYWx3YXlzIHJ1biB0aGUgY29kZVxuICAgICAgICBpZiAoISgoX2IgPSAoX2EgPSB0aGlzLmNhbGxSZWZUaW1lcikuaGFzUmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjYWxsUmVmVGltZXIucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAnIHBpY2tRdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMuY2FsbFJlZlRpbWVyKS5yZWYpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsUmVmVGltZXJVbnJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gSWYgdGhlIGhhc1JlZiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCwgYWx3YXlzIHJ1biB0aGUgY29kZVxuICAgICAgICBpZiAoIXRoaXMuY2FsbFJlZlRpbWVyLmhhc1JlZiB8fCB0aGlzLmNhbGxSZWZUaW1lci5oYXNSZWYoKSkge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2FsbFJlZlRpbWVyLnVucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAnIHBpY2tRdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHdhdGNoZXJJbmRleCA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPT09IHdhdGNoZXJPYmplY3QpO1xuICAgICAgICBpZiAod2F0Y2hlckluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5zcGxpY2Uod2F0Y2hlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICAoMCwgbG9nZ2luZ18xLnRyYWNlKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjb25uZWN0aXZpdHlfc3RhdGUnLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UgdG8gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBjb25zdCB3YXRjaGVyc0NvcHkgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yIChjb25zdCB3YXRjaGVyT2JqZWN0IG9mIHdhdGNoZXJzQ29weSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB3YXRjaGVyT2JqZWN0LmN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICh3YXRjaGVyT2JqZWN0LnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh3YXRjaGVyT2JqZWN0LnRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXIod2F0Y2hlck9iamVjdCk7XG4gICAgICAgICAgICAgICAgd2F0Y2hlck9iamVjdC5jYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3R0bGVLZWVwYWxpdmUobmV3S2VlcGFsaXZlVGltZSkge1xuICAgICAgICBpZiAobmV3S2VlcGFsaXZlVGltZSA+IHRoaXMua2VlcGFsaXZlVGltZSkge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gbmV3S2VlcGFsaXZlVGltZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd3JhcHBlZFN1YmNoYW5uZWwgb2YgdGhpcy53cmFwcGVkU3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkU3ViY2hhbm5lbC50aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVXcmFwcGVkU3ViY2hhbm5lbCh3cmFwcGVkU3ViY2hhbm5lbCkge1xuICAgICAgICB0aGlzLndyYXBwZWRTdWJjaGFubmVscy5kZWxldGUod3JhcHBlZFN1YmNoYW5uZWwpO1xuICAgIH1cbiAgICBkb1BpY2sobWV0YWRhdGEsIGV4dHJhUGlja0luZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBpY2tlci5waWNrKHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YSxcbiAgICAgICAgICAgIGV4dHJhUGlja0luZm86IGV4dHJhUGlja0luZm8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBxdWV1ZUNhbGxGb3JQaWNrKGNhbGwpIHtcbiAgICAgICAgdGhpcy5waWNrUXVldWUucHVzaChjYWxsKTtcbiAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJSZWYoKTtcbiAgICB9XG4gICAgZ2V0Q29uZmlnKG1ldGhvZCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1NVQ0NFU1MnLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWdTZWxlY3RvcihtZXRob2QsIG1ldGFkYXRhKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0VSUk9SJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ05PTkUnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWVDYWxsRm9yQ29uZmlnKGNhbGwpIHtcbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5wdXNoKGNhbGwpO1xuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclJlZigpO1xuICAgIH1cbiAgICBlbnRlcklkbGUoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyKTtcbiAgICB9XG4gICAgbWF5YmVTdGFydElkbGVUaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOICYmIHRoaXMuY2FsbENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0lkbGUgdGltZXIgdHJpZ2dlcmVkIGFmdGVyICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkbGVUaW1lb3V0TXMgK1xuICAgICAgICAgICAgICAgICAgICAnbXMgb2YgaW5hY3Rpdml0eScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJJZGxlKCk7XG4gICAgICAgICAgICB9LCB0aGlzLmlkbGVUaW1lb3V0TXMpO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5pZGxlVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DYWxsU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbENvdW50ICs9IDE7XG4gICAgICAgIGlmICh0aGlzLmlkbGVUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNhbGxFbmQoc3RhdHVzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbENvdW50IC09IDE7XG4gICAgICAgIHRoaXMubWF5YmVTdGFydElkbGVUaW1lcigpO1xuICAgIH1cbiAgICBjcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSkge1xuICAgICAgICBjb25zdCBjYWxsTnVtYmVyID0gKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsIFsnICsgY2FsbE51bWJlciArICddIG1ldGhvZD1cIicgKyBtZXRob2QgKyAnXCInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBsb2FkX2JhbGFuY2luZ19jYWxsXzEuTG9hZEJhbGFuY2luZ0NhbGwodGhpcywgY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIpO1xuICAgIH1cbiAgICBjcmVhdGVSZXRyeWluZ0NhbGwoY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUpIHtcbiAgICAgICAgY29uc3QgY2FsbE51bWJlciA9ICgwLCBjYWxsX251bWJlcl8xLmdldE5leHRDYWxsTnVtYmVyKSgpO1xuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVSZXRyeWluZ0NhbGwgWycgKyBjYWxsTnVtYmVyICsgJ10gbWV0aG9kPVwiJyArIG1ldGhvZCArICdcIicpO1xuICAgICAgICByZXR1cm4gbmV3IHJldHJ5aW5nX2NhbGxfMS5SZXRyeWluZ0NhbGwodGhpcywgY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIsIHRoaXMucmV0cnlCdWZmZXJUcmFja2VyLCBSRVRSWV9USFJPVFRMRVJfTUFQLmdldCh0aGlzLmdldFRhcmdldCgpKSk7XG4gICAgfVxuICAgIGNyZWF0ZUlubmVyQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBSZXRyeWluZ0NhbGwgaWYgcmV0cmllcyBhcmUgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmVuYWJsZV9yZXRyaWVzJ10gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsKGNhbGxDb25maWcsIG1ldGhvZCwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJldHJ5aW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlUmVzb2x2aW5nQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xuICAgICAgICBjb25zdCBjYWxsTnVtYmVyID0gKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZVJlc29sdmluZ0NhbGwgWycgK1xuICAgICAgICAgICAgY2FsbE51bWJlciArXG4gICAgICAgICAgICAnXSBtZXRob2Q9XCInICtcbiAgICAgICAgICAgIG1ldGhvZCArXG4gICAgICAgICAgICAnXCIsIGRlYWRsaW5lPScgK1xuICAgICAgICAgICAgKDAsIGRlYWRsaW5lXzEuZGVhZGxpbmVUb1N0cmluZykoZGVhZGxpbmUpKTtcbiAgICAgICAgY29uc3QgZmluYWxPcHRpb25zID0ge1xuICAgICAgICAgICAgZGVhZGxpbmU6IGRlYWRsaW5lLFxuICAgICAgICAgICAgZmxhZ3M6IHByb3BhZ2F0ZUZsYWdzICE9PSBudWxsICYmIHByb3BhZ2F0ZUZsYWdzICE9PSB2b2lkIDAgPyBwcm9wYWdhdGVGbGFncyA6IGNvbnN0YW50c18xLlByb3BhZ2F0ZS5ERUZBVUxUUyxcbiAgICAgICAgICAgIGhvc3Q6IGhvc3QgIT09IG51bGwgJiYgaG9zdCAhPT0gdm9pZCAwID8gaG9zdCA6IHRoaXMuZGVmYXVsdEF1dGhvcml0eSxcbiAgICAgICAgICAgIHBhcmVudENhbGw6IHBhcmVudENhbGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSBuZXcgcmVzb2x2aW5nX2NhbGxfMS5SZXNvbHZpbmdDYWxsKHRoaXMsIG1ldGhvZCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeS5jbG9uZSgpLCB0aGlzLmNyZWRlbnRpYWxzLl9nZXRDYWxsQ3JlZGVudGlhbHMoKSwgY2FsbE51bWJlcik7XG4gICAgICAgIHRoaXMub25DYWxsU3RhcnQoKTtcbiAgICAgICAgY2FsbC5hZGRTdGF0dXNXYXRjaGVyKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQ2FsbEVuZChzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2FsbFJlZlRpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKSh0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxQb29sLnVucmVmVW51c2VkU3ViY2hhbm5lbHMoKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnlUb0Nvbm5lY3QpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGl2aXR5U3RhdGUgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xuICAgICAgICBpZiAodHJ5VG9Db25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SWRsZVRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpdml0eVN0YXRlO1xuICAgIH1cbiAgICB3YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFubmVsIGhhcyBiZWVuIHNodXQgZG93bicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGlmIChkZWFkbGluZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lRGF0ZSA9IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSA/IGRlYWRsaW5lIDogbmV3IERhdGUoZGVhZGxpbmUpO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGlmIChkZWFkbGluZSA9PT0gLUluZmluaXR5IHx8IGRlYWRsaW5lRGF0ZSA8PSBub3cpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XG4gICAgICAgICAgICB9LCBkZWFkbGluZURhdGUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2F0Y2hlck9iamVjdCA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgdGltZXIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5wdXNoKHdhdGNoZXJPYmplY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5uZWx6IHJlZmVyZW5jZSBvYmplY3QgZm9yIHRoaXMgY2hhbm5lbC4gVGhlIHJldHVybmVkIHZhbHVlIGlzXG4gICAgICogZ2FyYmFnZSBpZiBjaGFubmVseiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjaGFubmVsLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBtZXRob2QgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHR5cGVvZiBkZWFkbGluZSA9PT0gJ251bWJlcicgfHwgZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBkZWFkbGluZSBtdXN0IGJlIGEgbnVtYmVyIG9yIERhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhbm5lbCBoYXMgYmVlbiBzaHV0IGRvd24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXNvbHZpbmdDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKTtcbiAgICB9XG59XG5leHBvcnRzLkludGVybmFsQ2hhbm5lbCA9IEludGVybmFsQ2hhbm5lbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLWNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW50ZXJuYWxDaGFubmVsIiwiY2hhbm5lbF9jcmVkZW50aWFsc18xIiwicmVxdWlyZSIsInJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEiLCJzdWJjaGFubmVsX3Bvb2xfMSIsInBpY2tlcl8xIiwiY29uc3RhbnRzXzEiLCJmaWx0ZXJfc3RhY2tfMSIsImNvbXByZXNzaW9uX2ZpbHRlcl8xIiwicmVzb2x2ZXJfMSIsImxvZ2dpbmdfMSIsIm1heF9tZXNzYWdlX3NpemVfZmlsdGVyXzEiLCJodHRwX3Byb3h5XzEiLCJ1cmlfcGFyc2VyXzEiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsImNoYW5uZWx6XzEiLCJsb2FkX2JhbGFuY2luZ19jYWxsXzEiLCJkZWFkbGluZV8xIiwicmVzb2x2aW5nX2NhbGxfMSIsImNhbGxfbnVtYmVyXzEiLCJjb250cm9sX3BsYW5lX3N0YXR1c18xIiwicmV0cnlpbmdfY2FsbF8xIiwic3ViY2hhbm5lbF9pbnRlcmZhY2VfMSIsIk1BWF9USU1FT1VUX1RJTUUiLCJNSU5fSURMRV9USU1FT1VUX01TIiwiREVGQVVMVF9JRExFX1RJTUVPVVRfTVMiLCJSRVRSWV9USFJPVFRMRVJfTUFQIiwiTWFwIiwiREVGQVVMVF9SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyIsIkRFRkFVTFRfUEVSX1JQQ19SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyIsIkNoYW5uZWxTdWJjaGFubmVsV3JhcHBlciIsIkJhc2VTdWJjaGFubmVsV3JhcHBlciIsImNvbnN0cnVjdG9yIiwiY2hpbGRTdWJjaGFubmVsIiwiY2hhbm5lbCIsInJlZkNvdW50Iiwic3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIiLCJzdWJjaGFubmVsIiwicHJldmlvdXNTdGF0ZSIsIm5ld1N0YXRlIiwia2VlcGFsaXZlVGltZSIsInRocm90dGxlS2VlcGFsaXZlIiwiYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInJlZiIsImNoaWxkIiwidW5yZWYiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwicmVtb3ZlV3JhcHBlZFN1YmNoYW5uZWwiLCJ0YXJnZXQiLCJjcmVkZW50aWFscyIsIm9wdGlvbnMiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsIl9oIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJjdXJyZW50UGlja2VyIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJjb25maWdTZWxlY3Rpb25RdWV1ZSIsInBpY2tRdWV1ZSIsImNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMiLCJjb25maWdTZWxlY3RvciIsImN1cnJlbnRSZXNvbHV0aW9uRXJyb3IiLCJ3cmFwcGVkU3ViY2hhbm5lbHMiLCJTZXQiLCJjYWxsQ291bnQiLCJpZGxlVGltZXIiLCJjaGFubmVsekVuYWJsZWQiLCJjYWxsVHJhY2tlciIsIkNoYW5uZWx6Q2FsbFRyYWNrZXIiLCJjaGlsZHJlblRyYWNrZXIiLCJDaGFubmVsekNoaWxkcmVuVHJhY2tlciIsIlR5cGVFcnJvciIsIkNoYW5uZWxDcmVkZW50aWFscyIsIm9yaWdpbmFsVGFyZ2V0Iiwib3JpZ2luYWxUYXJnZXRVcmkiLCJwYXJzZVVyaSIsIkVycm9yIiwiZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCIsIm1hcFVyaURlZmF1bHRTY2hlbWUiLCJjYWxsUmVmVGltZXIiLCJzZXRJbnRlcnZhbCIsImNhbGwiLCJjaGFubmVselRyYWNlIiwiQ2hhbm5lbHpUcmFjZSIsImNoYW5uZWx6UmVmIiwicmVnaXN0ZXJDaGFubmVsekNoYW5uZWwiLCJnZXRDaGFubmVsekluZm8iLCJhZGRUcmFjZSIsImRlZmF1bHRBdXRob3JpdHkiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicHJveHlNYXBSZXN1bHQiLCJtYXBQcm94eU5hbWUiLCJhc3NpZ24iLCJleHRyYU9wdGlvbnMiLCJzdWJjaGFubmVsUG9vbCIsImdldFN1YmNoYW5uZWxQb29sIiwicmV0cnlCdWZmZXJUcmFja2VyIiwiTWVzc2FnZUJ1ZmZlclRyYWNrZXIiLCJpZGxlVGltZW91dE1zIiwiTWF0aCIsIm1heCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwiY3JlYXRlU3ViY2hhbm5lbCIsInN1YmNoYW5uZWxBZGRyZXNzIiwic3ViY2hhbm5lbEFyZ3MiLCJnZXRPckNyZWF0ZVN1YmNoYW5uZWwiLCJnZXRDaGFubmVselJlZiIsIndyYXBwZWRTdWJjaGFubmVsIiwiYWRkIiwidXBkYXRlU3RhdGUiLCJwaWNrZXIiLCJxdWV1ZUNvcHkiLCJzbGljZSIsImNhbGxSZWZUaW1lclVucmVmIiwiZG9QaWNrIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZWZDaGlsZCIsInJlbW92ZUNoYW5uZWx6Q2hpbGQiLCJ1bnJlZkNoaWxkIiwicmVzb2x2aW5nTG9hZEJhbGFuY2VyIiwiUmVzb2x2aW5nTG9hZEJhbGFuY2VyIiwic2VydmljZUNvbmZpZyIsInJldHJ5VGhyb3R0bGluZyIsInNldCIsImdldFRhcmdldCIsIlJldHJ5VGhyb3R0bGVyIiwibWF4VG9rZW5zIiwidG9rZW5SYXRpbyIsImdldCIsImRlbGV0ZSIsInByb2Nlc3MiLCJuZXh0VGljayIsImxvY2FsUXVldWUiLCJnZXRDb25maWciLCJzdGF0dXMiLCJjb2RlIiwiZGV0YWlscyIsImxlbmd0aCIsInRyYWNlIiwicmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlIiwibWV0YWRhdGEiLCJyZXBvcnRSZXNvbHZlckVycm9yIiwiZmlsdGVyU3RhY2tGYWN0b3J5IiwiRmlsdGVyU3RhY2tGYWN0b3J5IiwiTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5IiwiQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVuZGVmaW5lZCIsImVycm9yIiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJpZCIsInN0YWNrIiwic3Vic3RyaW5nIiwiaW5kZXhPZiIsInN0YXRlIiwiY2hpbGRyZW4iLCJnZXRDaGlsZExpc3RzIiwidGV4dCIsInZlcmJvc2l0eU92ZXJyaWRlIiwidXJpVG9TdHJpbmciLCJjYWxsUmVmVGltZXJSZWYiLCJoYXNSZWYiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXIiLCJ3YXRjaGVyT2JqZWN0Iiwid2F0Y2hlckluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwid2F0Y2hlcnNDb3B5IiwiY3VycmVudFN0YXRlIiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJjYWxsYmFjayIsIlRSQU5TSUVOVF9GQUlMVVJFIiwibmV3S2VlcGFsaXZlVGltZSIsImV4dHJhUGlja0luZm8iLCJwaWNrIiwicXVldWVDYWxsRm9yUGljayIsInB1c2giLCJtZXRob2QiLCJleGl0SWRsZSIsInR5cGUiLCJjb25maWciLCJxdWV1ZUNhbGxGb3JDb25maWciLCJlbnRlcklkbGUiLCJkZXN0cm95IiwiUXVldWVQaWNrZXIiLCJtYXliZVN0YXJ0SWRsZVRpbWVyIiwiU0hVVERPV04iLCJzZXRUaW1lb3V0Iiwib25DYWxsU3RhcnQiLCJhZGRDYWxsU3RhcnRlZCIsIm9uQ2FsbEVuZCIsIlN0YXR1cyIsIk9LIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsImFkZENhbGxGYWlsZWQiLCJjcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbCIsImNhbGxDb25maWciLCJob3N0IiwiZGVhZGxpbmUiLCJjYWxsTnVtYmVyIiwiZ2V0TmV4dENhbGxOdW1iZXIiLCJMb2FkQmFsYW5jaW5nQ2FsbCIsImNyZWF0ZVJldHJ5aW5nQ2FsbCIsIlJldHJ5aW5nQ2FsbCIsImNyZWF0ZUlubmVyQ2FsbCIsImNyZWF0ZVJlc29sdmluZ0NhbGwiLCJwYXJlbnRDYWxsIiwicHJvcGFnYXRlRmxhZ3MiLCJkZWFkbGluZVRvU3RyaW5nIiwiZmluYWxPcHRpb25zIiwiZmxhZ3MiLCJQcm9wYWdhdGUiLCJERUZBVUxUUyIsIlJlc29sdmluZ0NhbGwiLCJjbG9uZSIsIl9nZXRDYWxsQ3JlZGVudGlhbHMiLCJhZGRTdGF0dXNXYXRjaGVyIiwiY2xvc2UiLCJjbGVhckludGVydmFsIiwidW5yZWdpc3RlckNoYW5uZWx6UmVmIiwidW5yZWZVbnVzZWRTdWJjaGFubmVscyIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwidHJ5VG9Db25uZWN0Iiwid2F0Y2hDb25uZWN0aXZpdHlTdGF0ZSIsIkluZmluaXR5IiwiZGVhZGxpbmVEYXRlIiwiRGF0ZSIsIm5vdyIsImdldFRpbWUiLCJjcmVhdGVDYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChildLoadBalancerHandler = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst TYPE_NAME = \"child_load_balancer_helper\";\nclass ChildLoadBalancerHandler {\n    constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        this.currentChild = null;\n        this.pendingChild = null;\n        this.latestConfig = null;\n        this.ChildPolicyHelper = class {\n            constructor(parent){\n                this.parent = parent;\n                this.child = null;\n            }\n            createSubchannel(subchannelAddress, subchannelArgs) {\n                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n            }\n            updateState(connectivityState, picker) {\n                var _a;\n                if (this.calledByPendingChild()) {\n                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                        return;\n                    }\n                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n                    this.parent.currentChild = this.parent.pendingChild;\n                    this.parent.pendingChild = null;\n                } else if (!this.calledByCurrentChild()) {\n                    return;\n                }\n                this.parent.channelControlHelper.updateState(connectivityState, picker);\n            }\n            requestReresolution() {\n                var _a;\n                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n                if (this.child === latestChild) {\n                    this.parent.channelControlHelper.requestReresolution();\n                }\n            }\n            setChild(newChild) {\n                this.child = newChild;\n            }\n            addChannelzChild(child) {\n                this.parent.channelControlHelper.addChannelzChild(child);\n            }\n            removeChannelzChild(child) {\n                this.parent.channelControlHelper.removeChannelzChild(child);\n            }\n            calledByPendingChild() {\n                return this.child === this.parent.pendingChild;\n            }\n            calledByCurrentChild() {\n                return this.child === this.parent.currentChild;\n            }\n        };\n    }\n    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {\n        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();\n    }\n    /**\n     * Prerequisites: lbConfig !== null and lbConfig.name is registered\n     * @param addressList\n     * @param lbConfig\n     * @param attributes\n     */ updateAddressList(addressList, lbConfig, attributes) {\n        let childToUpdate;\n        if (this.currentChild === null || this.latestConfig === null || this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {\n            const newHelper = new this.ChildPolicyHelper(this);\n            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper);\n            newHelper.setChild(newChild);\n            if (this.currentChild === null) {\n                this.currentChild = newChild;\n                childToUpdate = this.currentChild;\n            } else {\n                if (this.pendingChild) {\n                    this.pendingChild.destroy();\n                }\n                this.pendingChild = newChild;\n                childToUpdate = this.pendingChild;\n            }\n        } else {\n            if (this.pendingChild === null) {\n                childToUpdate = this.currentChild;\n            } else {\n                childToUpdate = this.pendingChild;\n            }\n        }\n        this.latestConfig = lbConfig;\n        childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n    }\n    exitIdle() {\n        if (this.currentChild) {\n            this.currentChild.exitIdle();\n            if (this.pendingChild) {\n                this.pendingChild.exitIdle();\n            }\n        }\n    }\n    resetBackoff() {\n        if (this.currentChild) {\n            this.currentChild.resetBackoff();\n            if (this.pendingChild) {\n                this.pendingChild.resetBackoff();\n            }\n        }\n    }\n    destroy() {\n        /* Note: state updates are only propagated from the child balancer if that\n         * object is equal to this.currentChild or this.pendingChild. Since this\n         * function sets both of those to null, no further state updates will\n         * occur after this function returns. */ if (this.currentChild) {\n            this.currentChild.destroy();\n            this.currentChild = null;\n        }\n        if (this.pendingChild) {\n            this.pendingChild.destroy();\n            this.pendingChild = null;\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler; //# sourceMappingURL=load-balancer-child-handler.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBRyxLQUFLO0FBQ3hDLE1BQU1HLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1FLFlBQVk7QUFDbEIsTUFBTUo7SUFDRkssWUFBWUMsb0JBQW9CLENBQUU7UUFDOUIsSUFBSSxDQUFDQSxvQkFBb0IsR0FBR0E7UUFDNUIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztZQUNyQkwsWUFBWU0sTUFBTSxDQUFFO2dCQUNoQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7Z0JBQ2QsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDakI7WUFDQUMsaUJBQWlCQyxpQkFBaUIsRUFBRUMsY0FBYyxFQUFFO2dCQUNoRCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDTCxvQkFBb0IsQ0FBQ08sZ0JBQWdCLENBQUNDLG1CQUFtQkM7WUFDaEY7WUFDQUMsWUFBWUMsaUJBQWlCLEVBQUVDLE1BQU0sRUFBRTtnQkFDbkMsSUFBSUM7Z0JBQ0osSUFBSSxJQUFJLENBQUNDLG9CQUFvQixJQUFJO29CQUM3QixJQUFJSCxzQkFBc0JkLHFCQUFxQmtCLGlCQUFpQixDQUFDQyxVQUFVLEVBQUU7d0JBQ3pFO29CQUNKO29CQUNDSCxDQUFBQSxLQUFLLElBQUksQ0FBQ1IsTUFBTSxDQUFDSixZQUFZLE1BQU0sUUFBUVksT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxH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QUFJLENBQUNBLFlBQVksQ0FBQ21DLFFBQVE7WUFDMUIsSUFBSSxJQUFJLENBQUNsQyxZQUFZLEVBQUU7Z0JBQ25CLElBQUksQ0FBQ0EsWUFBWSxDQUFDa0MsUUFBUTtZQUM5QjtRQUNKO0lBQ0o7SUFDQUMsZUFBZTtRQUNYLElBQUksSUFBSSxDQUFDcEMsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsWUFBWSxDQUFDb0MsWUFBWTtZQUM5QixJQUFJLElBQUksQ0FBQ25DLFlBQVksRUFBRTtnQkFDbkIsSUFBSSxDQUFDQSxZQUFZLENBQUNtQyxZQUFZO1lBQ2xDO1FBQ0o7SUFDSjtJQUNBcEIsVUFBVTtRQUNOOzs7OENBR3NDLEdBQ3RDLElBQUksSUFBSSxDQUFDaEIsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsWUFBWSxDQUFDZ0IsT0FBTztZQUN6QixJQUFJLENBQUNoQixZQUFZLEdBQUc7UUFDeEI7UUFDQSxJQUFJLElBQUksQ0FBQ0MsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsWUFBWSxDQUFDZSxPQUFPO1lBQ3pCLElBQUksQ0FBQ2YsWUFBWSxHQUFHO1FBQ3hCO0lBQ0o7SUFDQW9DLGNBQWM7UUFDVixPQUFPeEM7SUFDWDtBQUNKO0FBQ0FOLGdDQUFnQyxHQUFHRSwwQkFDbkMsdURBQXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzPzdlMTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgVFlQRV9OQU1FID0gJ2NoaWxkX2xvYWRfYmFsYW5jZXJfaGVscGVyJztcbmNsYXNzIENoaWxkTG9hZEJhbGFuY2VySGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLkNoaWxkUG9saWN5SGVscGVyID0gY2xhc3Mge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxlZEJ5UGVuZGluZ0NoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5wYXJlbnQuY3VycmVudENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQgPSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNhbGxlZEJ5Q3VycmVudENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdENoaWxkID0gKF9hID0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGQgPT09IGxhdGVzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDaGlsZChuZXdDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxlZEJ5UGVuZGluZ0NoaWxkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkID09PSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsZWRCeUN1cnJlbnRDaGlsZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZCA9PT0gdGhpcy5wYXJlbnQuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25maWdVcGRhdGVSZXF1aXJlc05ld1BvbGljeUluc3RhbmNlKG9sZENvbmZpZywgbmV3Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiBvbGRDb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpICE9PSBuZXdDb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVyZXF1aXNpdGVzOiBsYkNvbmZpZyAhPT0gbnVsbCBhbmQgbGJDb25maWcubmFtZSBpcyByZWdpc3RlcmVkXG4gICAgICogQHBhcmFtIGFkZHJlc3NMaXN0XG4gICAgICogQHBhcmFtIGxiQ29uZmlnXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbGV0IGNoaWxkVG9VcGRhdGU7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnVXBkYXRlUmVxdWlyZXNOZXdQb2xpY3lJbnN0YW5jZSh0aGlzLmxhdGVzdENvbmZpZywgbGJDb25maWcpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdIZWxwZXIgPSBuZXcgdGhpcy5DaGlsZFBvbGljeUhlbHBlcih0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gKDAsIGxvYWRfYmFsYW5jZXJfMS5jcmVhdGVMb2FkQmFsYW5jZXIpKGxiQ29uZmlnLCBuZXdIZWxwZXIpO1xuICAgICAgICAgICAgbmV3SGVscGVyLnNldENoaWxkKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBsYkNvbmZpZztcbiAgICAgICAgY2hpbGRUb1VwZGF0ZS51cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5leGl0SWRsZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQucmVzZXRCYWNrb2ZmKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5yZXNldEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvKiBOb3RlOiBzdGF0ZSB1cGRhdGVzIGFyZSBvbmx5IHByb3BhZ2F0ZWQgZnJvbSB0aGUgY2hpbGQgYmFsYW5jZXIgaWYgdGhhdFxuICAgICAgICAgKiBvYmplY3QgaXMgZXF1YWwgdG8gdGhpcy5jdXJyZW50Q2hpbGQgb3IgdGhpcy5wZW5kaW5nQ2hpbGQuIFNpbmNlIHRoaXNcbiAgICAgICAgICogZnVuY3Rpb24gc2V0cyBib3RoIG9mIHRob3NlIHRvIG51bGwsIG5vIGZ1cnRoZXIgc3RhdGUgdXBkYXRlcyB3aWxsXG4gICAgICAgICAqIG9jY3VyIGFmdGVyIHRoaXMgZnVuY3Rpb24gcmV0dXJucy4gKi9cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIgPSBDaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIiwibG9hZF9iYWxhbmNlcl8xIiwicmVxdWlyZSIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwiVFlQRV9OQU1FIiwiY29uc3RydWN0b3IiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImN1cnJlbnRDaGlsZCIsInBlbmRpbmdDaGlsZCIsImxhdGVzdENvbmZpZyIsIkNoaWxkUG9saWN5SGVscGVyIiwicGFyZW50IiwiY2hpbGQiLCJjcmVhdGVTdWJjaGFubmVsIiwic3ViY2hhbm5lbEFkZHJlc3MiLCJzdWJjaGFubmVsQXJncyIsInVwZGF0ZVN0YXRlIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJwaWNrZXIiLCJfYSIsImNhbGxlZEJ5UGVuZGluZ0NoaWxkIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJDT05ORUNUSU5HIiwiZGVzdHJveSIsImNhbGxlZEJ5Q3VycmVudENoaWxkIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImxhdGVzdENoaWxkIiwic2V0Q2hpbGQiLCJuZXdDaGlsZCIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZW1vdmVDaGFubmVsekNoaWxkIiwiY29uZmlnVXBkYXRlUmVxdWlyZXNOZXdQb2xpY3lJbnN0YW5jZSIsIm9sZENvbmZpZyIsIm5ld0NvbmZpZyIsImdldExvYWRCYWxhbmNlck5hbWUiLCJ1cGRhdGVBZGRyZXNzTGlzdCIsImFkZHJlc3NMaXN0IiwibGJDb25maWciLCJhdHRyaWJ1dGVzIiwiY2hpbGRUb1VwZGF0ZSIsIm5ld0hlbHBlciIsImNyZWF0ZUxvYWRCYWxhbmNlciIsImV4aXRJZGxlIiwicmVzZXRCYWNrb2ZmIiwiZ2V0VHlwZU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var _a;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nconst experimental_1 = __webpack_require__(/*! ./experimental */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"outlier_detection\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"outlier_detection\";\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : \"true\") === \"true\";\nconst defaultSuccessRateEjectionConfig = {\n    stdev_factor: 1900,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 100\n};\nconst defaultFailurePercentageEjectionConfig = {\n    threshold: 85,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 50\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n    if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n    }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    if (fieldName in obj) {\n        if (!(0, duration_1.isDuration)(obj[fieldName])) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n        }\n        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n        }\n    }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    validateFieldType(obj, fieldName, \"number\", objectName);\n    if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n    }\n}\nclass OutlierDetectionLoadBalancingConfig {\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy){\n        this.childPolicy = childPolicy;\n        if (childPolicy.length > 0 && childPolicy[0].getLoadBalancerName() === \"pick_first\") {\n            throw new Error(\"outlier_detection LB policy cannot have a pick_first child policy\");\n        }\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n        this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            interval: (0, duration_1.msToDuration)(this.intervalMs),\n            base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),\n            max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),\n            max_ejection_percent: this.maxEjectionPercent,\n            success_rate_ejection: this.successRateEjection,\n            failure_percentage_ejection: this.failurePercentageEjection,\n            child_policy: this.childPolicy.map((policy)=>policy.toJsonObject())\n        };\n    }\n    getIntervalMs() {\n        return this.intervalMs;\n    }\n    getBaseEjectionTimeMs() {\n        return this.baseEjectionTimeMs;\n    }\n    getMaxEjectionTimeMs() {\n        return this.maxEjectionTimeMs;\n    }\n    getMaxEjectionPercent() {\n        return this.maxEjectionPercent;\n    }\n    getSuccessRateEjectionConfig() {\n        return this.successRateEjection;\n    }\n    getFailurePercentageEjectionConfig() {\n        return this.failurePercentageEjection;\n    }\n    getChildPolicy() {\n        return this.childPolicy;\n    }\n    copyWithChildPolicy(childPolicy) {\n        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n    }\n    static createFromJson(obj) {\n        var _a;\n        validatePositiveDuration(obj, \"interval\");\n        validatePositiveDuration(obj, \"base_ejection_time\");\n        validatePositiveDuration(obj, \"max_ejection_time\");\n        validatePercentage(obj, \"max_ejection_percent\");\n        if (\"success_rate_ejection\" in obj) {\n            if (typeof obj.success_rate_ejection !== \"object\") {\n                throw new Error(\"outlier detection config success_rate_ejection must be an object\");\n            }\n            validateFieldType(obj.success_rate_ejection, \"stdev_factor\", \"number\", \"success_rate_ejection\");\n            validatePercentage(obj.success_rate_ejection, \"enforcement_percentage\", \"success_rate_ejection\");\n            validateFieldType(obj.success_rate_ejection, \"minimum_hosts\", \"number\", \"success_rate_ejection\");\n            validateFieldType(obj.success_rate_ejection, \"request_volume\", \"number\", \"success_rate_ejection\");\n        }\n        if (\"failure_percentage_ejection\" in obj) {\n            if (typeof obj.failure_percentage_ejection !== \"object\") {\n                throw new Error(\"outlier detection config failure_percentage_ejection must be an object\");\n            }\n            validatePercentage(obj.failure_percentage_ejection, \"threshold\", \"failure_percentage_ejection\");\n            validatePercentage(obj.failure_percentage_ejection, \"enforcement_percentage\", \"failure_percentage_ejection\");\n            validateFieldType(obj.failure_percentage_ejection, \"minimum_hosts\", \"number\", \"failure_percentage_ejection\");\n            validateFieldType(obj.failure_percentage_ejection, \"request_volume\", \"number\", \"failure_percentage_ejection\");\n        }\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n    }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, mapEntry){\n        super(childSubchannel);\n        this.mapEntry = mapEntry;\n        this.stateListeners = [];\n        this.ejected = false;\n        this.refCount = 0;\n        this.childSubchannelState = childSubchannel.getConnectivityState();\n        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState, keepaliveTime)=>{\n            this.childSubchannelState = newState;\n            if (!this.ejected) {\n                for (const listener of this.stateListeners){\n                    listener(this, previousState, newState, keepaliveTime);\n                }\n            }\n        });\n    }\n    getConnectivityState() {\n        if (this.ejected) {\n            return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n        } else {\n            return this.childSubchannelState;\n        }\n    }\n    /**\n     * Add a listener function to be called whenever the wrapper's\n     * connectivity state changes.\n     * @param listener\n     */ addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */ removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            if (this.mapEntry) {\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\n                if (index >= 0) {\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\n                }\n            }\n        }\n    }\n    eject() {\n        this.ejected = true;\n        for (const listener of this.stateListeners){\n            listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, -1);\n        }\n    }\n    uneject() {\n        this.ejected = false;\n        for (const listener of this.stateListeners){\n            listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState, -1);\n        }\n    }\n    getMapEntry() {\n        return this.mapEntry;\n    }\n    getWrappedSubchannel() {\n        return this.child;\n    }\n}\nfunction createEmptyBucket() {\n    return {\n        success: 0,\n        failure: 0\n    };\n}\nclass CallCounter {\n    constructor(){\n        this.activeBucket = createEmptyBucket();\n        this.inactiveBucket = createEmptyBucket();\n    }\n    addSuccess() {\n        this.activeBucket.success += 1;\n    }\n    addFailure() {\n        this.activeBucket.failure += 1;\n    }\n    switchBuckets() {\n        this.inactiveBucket = this.activeBucket;\n        this.activeBucket = createEmptyBucket();\n    }\n    getLastSuccesses() {\n        return this.inactiveBucket.success;\n    }\n    getLastFailures() {\n        return this.inactiveBucket.failure;\n    }\n}\nclass OutlierDetectionPicker {\n    constructor(wrappedPicker, countCalls){\n        this.wrappedPicker = wrappedPicker;\n        this.countCalls = countCalls;\n    }\n    pick(pickArgs) {\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n            const subchannelWrapper = wrappedPick.subchannel;\n            const mapEntry = subchannelWrapper.getMapEntry();\n            if (mapEntry) {\n                let onCallEnded = wrappedPick.onCallEnded;\n                if (this.countCalls) {\n                    onCallEnded = (statusCode)=>{\n                        var _a;\n                        if (statusCode === constants_1.Status.OK) {\n                            mapEntry.counter.addSuccess();\n                        } else {\n                            mapEntry.counter.addFailure();\n                        }\n                        (_a = wrappedPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(wrappedPick, statusCode);\n                    };\n                }\n                return Object.assign(Object.assign({}, wrappedPick), {\n                    subchannel: subchannelWrapper.getWrappedSubchannel(),\n                    onCallEnded: onCallEnded\n                });\n            } else {\n                return Object.assign(Object.assign({}, wrappedPick), {\n                    subchannel: subchannelWrapper.getWrappedSubchannel()\n                });\n            }\n        } else {\n            return wrappedPick;\n        }\n    }\n}\nclass OutlierDetectionLoadBalancer {\n    constructor(channelControlHelper){\n        this.addressMap = new Map();\n        this.latestConfig = null;\n        this.timerStartTime = null;\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {\n            createSubchannel: (subchannelAddress, subchannelArgs)=>{\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n                const mapEntry = this.addressMap.get((0, subchannel_address_1.subchannelAddressToString)(subchannelAddress));\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n                    // If the address is ejected, propagate that to the new subchannel wrapper\n                    subchannelWrapper.eject();\n                }\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n                return subchannelWrapper;\n            },\n            updateState: (connectivityState, picker)=>{\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\n                } else {\n                    channelControlHelper.updateState(connectivityState, picker);\n                }\n            }\n        }));\n        this.ejectionTimer = setInterval(()=>{}, 0);\n        clearInterval(this.ejectionTimer);\n    }\n    isCountingEnabled() {\n        return this.latestConfig !== null && (this.latestConfig.getSuccessRateEjectionConfig() !== null || this.latestConfig.getFailurePercentageEjectionConfig() !== null);\n    }\n    getCurrentEjectionPercent() {\n        let ejectionCount = 0;\n        for (const mapEntry of this.addressMap.values()){\n            if (mapEntry.currentEjectionTimestamp !== null) {\n                ejectionCount += 1;\n            }\n        }\n        return ejectionCount * 100 / this.addressMap.size;\n    }\n    runSuccessRateCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n        if (!successRateConfig) {\n            return;\n        }\n        trace(\"Running success rate check\");\n        // Step 1\n        const targetRequestVolume = successRateConfig.request_volume;\n        let addresesWithTargetVolume = 0;\n        const successRates = [];\n        for (const [address, mapEntry] of this.addressMap){\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace(\"Stats for \" + address + \": successes=\" + successes + \" failures=\" + failures + \" targetRequestVolume=\" + targetRequestVolume);\n            if (successes + failures >= targetRequestVolume) {\n                addresesWithTargetVolume += 1;\n                successRates.push(successes / (successes + failures));\n            }\n        }\n        trace(\"Found \" + addresesWithTargetVolume + \" success rate candidates; currentEjectionPercent=\" + this.getCurrentEjectionPercent() + \" successRates=[\" + successRates + \"]\");\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        const successRateMean = successRates.reduce((a, b)=>a + b) / successRates.length;\n        let successRateDeviationSum = 0;\n        for (const rate of successRates){\n            const deviation = rate - successRateMean;\n            successRateDeviationSum += deviation * deviation;\n        }\n        const successRateVariance = successRateDeviationSum / successRates.length;\n        const successRateStdev = Math.sqrt(successRateVariance);\n        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n        trace(\"stdev=\" + successRateStdev + \" ejectionThreshold=\" + ejectionThreshold);\n        // Step 3\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            // Step 3.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 3.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures < targetRequestVolume) {\n                continue;\n            }\n            // Step 3.iii\n            const successRate = successes / (successes + failures);\n            trace(\"Checking candidate \" + address + \" successRate=\" + successRate);\n            if (successRate < ejectionThreshold) {\n                const randomNumber = Math.random() * 100;\n                trace(\"Candidate \" + address + \" randomNumber=\" + randomNumber + \" enforcement_percentage=\" + successRateConfig.enforcement_percentage);\n                if (randomNumber < successRateConfig.enforcement_percentage) {\n                    trace(\"Ejecting candidate \" + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    runFailurePercentageCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n        if (!failurePercentageConfig) {\n            return;\n        }\n        trace(\"Running failure percentage check. threshold=\" + failurePercentageConfig.threshold + \" request volume threshold=\" + failurePercentageConfig.request_volume);\n        // Step 1\n        let addressesWithTargetVolume = 0;\n        for (const mapEntry of this.addressMap.values()){\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= failurePercentageConfig.request_volume) {\n                addressesWithTargetVolume += 1;\n            }\n        }\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            // Step 2.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 2.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace(\"Candidate successes=\" + successes + \" failures=\" + failures);\n            if (successes + failures < failurePercentageConfig.request_volume) {\n                continue;\n            }\n            // Step 2.iii\n            const failurePercentage = failures * 100 / (failures + successes);\n            if (failurePercentage > failurePercentageConfig.threshold) {\n                const randomNumber = Math.random() * 100;\n                trace(\"Candidate \" + address + \" randomNumber=\" + randomNumber + \" enforcement_percentage=\" + failurePercentageConfig.enforcement_percentage);\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n                    trace(\"Ejecting candidate \" + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    eject(mapEntry, ejectionTimestamp) {\n        mapEntry.currentEjectionTimestamp = new Date();\n        mapEntry.ejectionTimeMultiplier += 1;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers){\n            subchannelWrapper.eject();\n        }\n    }\n    uneject(mapEntry) {\n        mapEntry.currentEjectionTimestamp = null;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers){\n            subchannelWrapper.uneject();\n        }\n    }\n    switchAllBuckets() {\n        for (const mapEntry of this.addressMap.values()){\n            mapEntry.counter.switchBuckets();\n        }\n    }\n    startTimer(delayMs) {\n        var _a, _b;\n        this.ejectionTimer = setTimeout(()=>this.runChecks(), delayMs);\n        (_b = (_a = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    runChecks() {\n        const ejectionTimestamp = new Date();\n        trace(\"Ejection timer running\");\n        this.switchAllBuckets();\n        if (!this.latestConfig) {\n            return;\n        }\n        this.timerStartTime = ejectionTimestamp;\n        this.startTimer(this.latestConfig.getIntervalMs());\n        this.runSuccessRateCheck(ejectionTimestamp);\n        this.runFailurePercentageCheck(ejectionTimestamp);\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            if (mapEntry.currentEjectionTimestamp === null) {\n                if (mapEntry.ejectionTimeMultiplier > 0) {\n                    mapEntry.ejectionTimeMultiplier -= 1;\n                }\n            } else {\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n                returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n                if (returnTime < new Date()) {\n                    trace(\"Unejecting \" + address);\n                    this.uneject(mapEntry);\n                }\n            }\n        }\n    }\n    updateAddressList(addressList, lbConfig, attributes) {\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n            return;\n        }\n        const subchannelAddresses = new Set();\n        for (const address of addressList){\n            subchannelAddresses.add((0, subchannel_address_1.subchannelAddressToString)(address));\n        }\n        for (const address of subchannelAddresses){\n            if (!this.addressMap.has(address)) {\n                trace(\"Adding map entry for \" + address);\n                this.addressMap.set(address, {\n                    counter: new CallCounter(),\n                    currentEjectionTimestamp: null,\n                    ejectionTimeMultiplier: 0,\n                    subchannelWrappers: []\n                });\n            }\n        }\n        for (const key of this.addressMap.keys()){\n            if (!subchannelAddresses.has(key)) {\n                trace(\"Removing map entry for \" + key);\n                this.addressMap.delete(key);\n            }\n        }\n        const childPolicy = (0, load_balancer_1.getFirstUsableConfig)(lbConfig.getChildPolicy(), true);\n        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n        if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {\n            if (this.timerStartTime) {\n                trace(\"Previous timer existed. Replacing timer\");\n                clearTimeout(this.ejectionTimer);\n                const remainingDelay = lbConfig.getIntervalMs() - (new Date().getTime() - this.timerStartTime.getTime());\n                this.startTimer(remainingDelay);\n            } else {\n                trace(\"Starting new timer\");\n                this.timerStartTime = new Date();\n                this.startTimer(lbConfig.getIntervalMs());\n                this.switchAllBuckets();\n            }\n        } else {\n            trace(\"Counting disabled. Cancelling timer.\");\n            this.timerStartTime = null;\n            clearTimeout(this.ejectionTimer);\n            for (const mapEntry of this.addressMap.values()){\n                this.uneject(mapEntry);\n                mapEntry.ejectionTimeMultiplier = 0;\n            }\n        }\n        this.latestConfig = lbConfig;\n    }\n    exitIdle() {\n        this.childBalancer.exitIdle();\n    }\n    resetBackoff() {\n        this.childBalancer.resetBackoff();\n    }\n    destroy() {\n        clearTimeout(this.ejectionTimer);\n        this.childBalancer.destroy();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n    if (OUTLIER_DETECTION_ENABLED) {\n        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n    }\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-outlier-detection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxJQUFJQTtBQUNKQyw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSxvQ0FBb0MsR0FBR0EsMkNBQTJDLEdBQUcsS0FBSztBQUMxRyxNQUFNSyx1QkFBdUJDLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRyxpQkFBaUJILG1CQUFPQSxDQUFDLG9GQUFnQjtBQUMvQyxNQUFNSSxrQkFBa0JKLG1CQUFPQSxDQUFDLHNGQUFpQjtBQUNqRCxNQUFNSyxnQ0FBZ0NMLG1CQUFPQSxDQUFDLGtIQUErQjtBQUM3RSxNQUFNTSxXQUFXTixtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNTyx1QkFBdUJQLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNUSx5QkFBeUJSLG1CQUFPQSxDQUFDLG9HQUF3QjtBQUMvRCxNQUFNUyxVQUFVVCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNVSxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZkgsUUFBUUUsS0FBSyxDQUFDVixZQUFZWSxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQSxNQUFNRyxZQUFZO0FBQ2xCLE1BQU1DLDRCQUE0QixDQUFDLENBQUN6QixLQUFLMEIsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQywwQ0FBMEMsTUFBTSxRQUFRNUIsT0FBTyxLQUFLLElBQUlBLEtBQUssTUFBSyxNQUFPO0FBQzlJLE1BQU02QixtQ0FBbUM7SUFDckNDLGNBQWM7SUFDZEMsd0JBQXdCO0lBQ3hC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VixPQUFPM007SUFDWDtBQUNKO0FBQ0FyQixvQ0FBb0MsR0FBR0c7QUFDdkMsU0FBU0Q7SUFDTCxJQUFJb0IsMkJBQTJCO1FBQzFCLElBQUdiLGVBQWV3Tix3QkFBd0IsRUFBRTVNLFdBQVdsQiw4QkFBOEJDO0lBQzFGO0FBQ0o7QUFDQUosYUFBYSxHQUFHRSxPQUNoQiwyREFBMkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzPzAwNmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIgPSBleHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnID0gdm9pZCAwO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGR1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi9kdXJhdGlvblwiKTtcbmNvbnN0IGV4cGVyaW1lbnRhbF8xID0gcmVxdWlyZShcIi4vZXhwZXJpbWVudGFsXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWludGVyZmFjZVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnb3V0bGllcl9kZXRlY3Rpb24nO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBUWVBFX05BTUUgPSAnb3V0bGllcl9kZXRlY3Rpb24nO1xuY29uc3QgT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCA9ICgoX2EgPSBwcm9jZXNzLmVudi5HUlBDX0VYUEVSSU1FTlRBTF9FTkFCTEVfT1VUTElFUl9ERVRFQ1RJT04pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd0cnVlJykgPT09ICd0cnVlJztcbmNvbnN0IGRlZmF1bHRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnID0ge1xuICAgIHN0ZGV2X2ZhY3RvcjogMTkwMCxcbiAgICBlbmZvcmNlbWVudF9wZXJjZW50YWdlOiAxMDAsXG4gICAgbWluaW11bV9ob3N0czogNSxcbiAgICByZXF1ZXN0X3ZvbHVtZTogMTAwLFxufTtcbmNvbnN0IGRlZmF1bHRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnID0ge1xuICAgIHRocmVzaG9sZDogODUsXG4gICAgZW5mb3JjZW1lbnRfcGVyY2VudGFnZTogMTAwLFxuICAgIG1pbmltdW1faG9zdHM6IDUsXG4gICAgcmVxdWVzdF92b2x1bWU6IDUwLFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGRUeXBlKG9iaiwgZmllbGROYW1lLCBleHBlY3RlZFR5cGUsIG9iamVjdE5hbWUpIHtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpZWxkTmFtZV0gIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IGV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlfSwgZ290ICR7dHlwZW9mIG9ialtmaWVsZE5hbWVdfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosIGZpZWxkTmFtZSwgb2JqZWN0TmFtZSkge1xuICAgIGNvbnN0IGZ1bGxGaWVsZE5hbWUgPSBvYmplY3ROYW1lID8gYCR7b2JqZWN0TmFtZX0uJHtmaWVsZE5hbWV9YCA6IGZpZWxkTmFtZTtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaikge1xuICAgICAgICBpZiAoISgwLCBkdXJhdGlvbl8xLmlzRHVyYXRpb24pKG9ialtmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogZXhwZWN0ZWQgRHVyYXRpb24sIGdvdCAke3R5cGVvZiBvYmpbZmllbGROYW1lXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvYmpbZmllbGROYW1lXS5zZWNvbmRzID49IDAgJiZcbiAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdLnNlY29uZHMgPD0gMzE1NTc2MDAwMDAwICYmXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5uYW5vcyA+PSAwICYmXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5uYW5vcyA8PSA5OTk5OTk5OTkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiB2YWx1ZXMgb3V0IG9mIHJhbmdlIGZvciBub24tbmVnYXRpdmUgRHVhcmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCBmaWVsZE5hbWUsIG9iamVjdE5hbWUpIHtcbiAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsICdudW1iZXInLCBvYmplY3ROYW1lKTtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJiAhKG9ialtmaWVsZE5hbWVdID49IDAgJiYgb2JqW2ZpZWxkTmFtZV0gPD0gMTAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiB2YWx1ZSBvdXQgb2YgcmFuZ2UgZm9yIHBlcmNlbnRhZ2UgKDAtMTAwKWApO1xuICAgIH1cbn1cbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnZhbE1zLCBiYXNlRWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uVGltZU1zLCBtYXhFamVjdGlvblBlcmNlbnQsIHN1Y2Nlc3NSYXRlRWplY3Rpb24sIGZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24sIGNoaWxkUG9saWN5KSB7XG4gICAgICAgIHRoaXMuY2hpbGRQb2xpY3kgPSBjaGlsZFBvbGljeTtcbiAgICAgICAgaWYgKGNoaWxkUG9saWN5Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGNoaWxkUG9saWN5WzBdLmdldExvYWRCYWxhbmNlck5hbWUoKSA9PT0gJ3BpY2tfZmlyc3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXJfZGV0ZWN0aW9uIExCIHBvbGljeSBjYW5ub3QgaGF2ZSBhIHBpY2tfZmlyc3QgY2hpbGQgcG9saWN5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcnZhbE1zID0gaW50ZXJ2YWxNcyAhPT0gbnVsbCAmJiBpbnRlcnZhbE1zICE9PSB2b2lkIDAgPyBpbnRlcnZhbE1zIDogMTAwMDA7XG4gICAgICAgIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zID0gYmFzZUVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIGJhc2VFamVjdGlvblRpbWVNcyAhPT0gdm9pZCAwID8gYmFzZUVqZWN0aW9uVGltZU1zIDogMzAwMDA7XG4gICAgICAgIHRoaXMubWF4RWplY3Rpb25UaW1lTXMgPSBtYXhFamVjdGlvblRpbWVNcyAhPT0gbnVsbCAmJiBtYXhFamVjdGlvblRpbWVNcyAhPT0gdm9pZCAwID8gbWF4RWplY3Rpb25UaW1lTXMgOiAzMDAwMDA7XG4gICAgICAgIHRoaXMubWF4RWplY3Rpb25QZXJjZW50ID0gbWF4RWplY3Rpb25QZXJjZW50ICE9PSBudWxsICYmIG1heEVqZWN0aW9uUGVyY2VudCAhPT0gdm9pZCAwID8gbWF4RWplY3Rpb25QZXJjZW50IDogMTA7XG4gICAgICAgIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbiA9IHN1Y2Nlc3NSYXRlRWplY3Rpb25cbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZyksIHN1Y2Nlc3NSYXRlRWplY3Rpb24pIDogbnVsbDtcbiAgICAgICAgdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uID0gZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvblxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKSwgZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXRMb2FkQmFsYW5jZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbiAgICB0b0pzb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnZhbDogKDAsIGR1cmF0aW9uXzEubXNUb0R1cmF0aW9uKSh0aGlzLmludGVydmFsTXMpLFxuICAgICAgICAgICAgYmFzZV9lamVjdGlvbl90aW1lOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zKSxcbiAgICAgICAgICAgIG1heF9lamVjdGlvbl90aW1lOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMubWF4RWplY3Rpb25UaW1lTXMpLFxuICAgICAgICAgICAgbWF4X2VqZWN0aW9uX3BlcmNlbnQ6IHRoaXMubWF4RWplY3Rpb25QZXJjZW50LFxuICAgICAgICAgICAgc3VjY2Vzc19yYXRlX2VqZWN0aW9uOiB0aGlzLnN1Y2Nlc3NSYXRlRWplY3Rpb24sXG4gICAgICAgICAgICBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb246IHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbixcbiAgICAgICAgICAgIGNoaWxkX3BvbGljeTogdGhpcy5jaGlsZFBvbGljeS5tYXAocG9saWN5ID0+IHBvbGljeS50b0pzb25PYmplY3QoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEludGVydmFsTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVydmFsTXM7XG4gICAgfVxuICAgIGdldEJhc2VFamVjdGlvblRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zO1xuICAgIH1cbiAgICBnZXRNYXhFamVjdGlvblRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RWplY3Rpb25UaW1lTXM7XG4gICAgfVxuICAgIGdldE1heEVqZWN0aW9uUGVyY2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RWplY3Rpb25QZXJjZW50O1xuICAgIH1cbiAgICBnZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uO1xuICAgIH1cbiAgICBnZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uO1xuICAgIH1cbiAgICBnZXRDaGlsZFBvbGljeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRQb2xpY3k7XG4gICAgfVxuICAgIGNvcHlXaXRoQ2hpbGRQb2xpY3koY2hpbGRQb2xpY3kpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyh0aGlzLmludGVydmFsTXMsIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zLCB0aGlzLm1heEVqZWN0aW9uVGltZU1zLCB0aGlzLm1heEVqZWN0aW9uUGVyY2VudCwgdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uLCB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24sIGNoaWxkUG9saWN5KTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21Kc29uKG9iaikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdpbnRlcnZhbCcpO1xuICAgICAgICB2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24ob2JqLCAnYmFzZV9lamVjdGlvbl90aW1lJyk7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdtYXhfZWplY3Rpb25fdGltZScpO1xuICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCAnbWF4X2VqZWN0aW9uX3BlcmNlbnQnKTtcbiAgICAgICAgaWYgKCdzdWNjZXNzX3JhdGVfZWplY3Rpb24nIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0bGllciBkZXRlY3Rpb24gY29uZmlnIHN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ3N0ZGV2X2ZhY3RvcicsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ2VuZm9yY2VtZW50X3BlcmNlbnRhZ2UnLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAnbWluaW11bV9ob3N0cycsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAncmVxdWVzdF92b2x1bWUnLCAnbnVtYmVyJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAndGhyZXNob2xkJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICdlbmZvcmNlbWVudF9wZXJjZW50YWdlJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ21pbmltdW1faG9zdHMnLCAnbnVtYmVyJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ3JlcXVlc3Rfdm9sdW1lJywgJ251bWJlcicsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKG9iai5pbnRlcnZhbCA/ICgwLCBkdXJhdGlvbl8xLmR1cmF0aW9uVG9Ncykob2JqLmludGVydmFsKSA6IG51bGwsIG9iai5iYXNlX2VqZWN0aW9uX3RpbWUgPyAoMCwgZHVyYXRpb25fMS5kdXJhdGlvblRvTXMpKG9iai5iYXNlX2VqZWN0aW9uX3RpbWUpIDogbnVsbCwgb2JqLm1heF9lamVjdGlvbl90aW1lID8gKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKShvYmoubWF4X2VqZWN0aW9uX3RpbWUpIDogbnVsbCwgKF9hID0gb2JqLm1heF9lamVjdGlvbl9wZXJjZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLCBvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCBvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCBvYmouY2hpbGRfcG9saWN5Lm1hcChsb2FkX2JhbGFuY2VyXzEudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKSk7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyA9IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnO1xuY2xhc3MgT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyIGV4dGVuZHMgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMS5CYXNlU3ViY2hhbm5lbFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkU3ViY2hhbm5lbCwgbWFwRW50cnkpIHtcbiAgICAgICAgc3VwZXIoY2hpbGRTdWJjaGFubmVsKTtcbiAgICAgICAgdGhpcy5tYXBFbnRyeSA9IG1hcEVudHJ5O1xuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZSA9IGNoaWxkU3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgICAgICBjaGlsZFN1YmNoYW5uZWwuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcigoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGtlZXBhbGl2ZVRpbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5lamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBrZWVwYWxpdmVUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWplY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSB3cmFwcGVyJ3NcbiAgICAgKiBjb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIHByZXZpb3VzbHkgYWRkZWQgd2l0aCBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQSByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHBhc3NlZCB0b1xuICAgICAqICAgICBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKi9cbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVySW5kZXggPSB0aGlzLnN0YXRlTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAobGlzdGVuZXJJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzLnNwbGljZShsaXN0ZW5lckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XG4gICAgICAgIHRoaXMucmVmQ291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXBFbnRyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlamVjdCgpIHtcbiAgICAgICAgdGhpcy5lamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcih0aGlzLCB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgLTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuZWplY3QoKSB7XG4gICAgICAgIHRoaXMuZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlLCAtMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWFwRW50cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcEVudHJ5O1xuICAgIH1cbiAgICBnZXRXcmFwcGVkU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQ7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlCdWNrZXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogMCxcbiAgICAgICAgZmFpbHVyZTogMCxcbiAgICB9O1xufVxuY2xhc3MgQ2FsbENvdW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgICAgIHRoaXMuaW5hY3RpdmVCdWNrZXQgPSBjcmVhdGVFbXB0eUJ1Y2tldCgpO1xuICAgIH1cbiAgICBhZGRTdWNjZXNzKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldC5zdWNjZXNzICs9IDE7XG4gICAgfVxuICAgIGFkZEZhaWx1cmUoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0LmZhaWx1cmUgKz0gMTtcbiAgICB9XG4gICAgc3dpdGNoQnVja2V0cygpIHtcbiAgICAgICAgdGhpcy5pbmFjdGl2ZUJ1Y2tldCA9IHRoaXMuYWN0aXZlQnVja2V0O1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgfVxuICAgIGdldExhc3RTdWNjZXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluYWN0aXZlQnVja2V0LnN1Y2Nlc3M7XG4gICAgfVxuICAgIGdldExhc3RGYWlsdXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5hY3RpdmVCdWNrZXQuZmFpbHVyZTtcbiAgICB9XG59XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uUGlja2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih3cmFwcGVkUGlja2VyLCBjb3VudENhbGxzKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZFBpY2tlciA9IHdyYXBwZWRQaWNrZXI7XG4gICAgICAgIHRoaXMuY291bnRDYWxscyA9IGNvdW50Q2FsbHM7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZFBpY2sgPSB0aGlzLndyYXBwZWRQaWNrZXIucGljayhwaWNrQXJncyk7XG4gICAgICAgIGlmICh3cmFwcGVkUGljay5waWNrUmVzdWx0VHlwZSA9PT0gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyID0gd3JhcHBlZFBpY2suc3ViY2hhbm5lbDtcbiAgICAgICAgICAgIGNvbnN0IG1hcEVudHJ5ID0gc3ViY2hhbm5lbFdyYXBwZXIuZ2V0TWFwRW50cnkoKTtcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeSkge1xuICAgICAgICAgICAgICAgIGxldCBvbkNhbGxFbmRlZCA9IHdyYXBwZWRQaWNrLm9uQ2FsbEVuZGVkO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvdW50Q2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DYWxsRW5kZWQgPSBzdGF0dXNDb2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBFbnRyeS5jb3VudGVyLmFkZFN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuYWRkRmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gd3JhcHBlZFBpY2sub25DYWxsRW5kZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHdyYXBwZWRQaWNrLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JhcHBlZFBpY2spLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxXcmFwcGVyLmdldFdyYXBwZWRTdWJjaGFubmVsKCksIG9uQ2FsbEVuZGVkOiBvbkNhbGxFbmRlZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyYXBwZWRQaWNrKSwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsV3JhcHBlci5nZXRXcmFwcGVkU3ViY2hhbm5lbCgpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRQaWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIgPSBuZXcgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyKCgwLCBleHBlcmltZW50YWxfMS5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKShjaGFubmVsQ29udHJvbEhlbHBlciwge1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3ViY2hhbm5lbCA9IGNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBFbnRyeSA9IHRoaXMuYWRkcmVzc01hcC5nZXQoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKHN1YmNoYW5uZWxBZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSBuZXcgT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyKG9yaWdpbmFsU3ViY2hhbm5lbCwgbWFwRW50cnkpO1xuICAgICAgICAgICAgICAgIGlmICgobWFwRW50cnkgPT09IG51bGwgfHwgbWFwRW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFkZHJlc3MgaXMgZWplY3RlZCwgcHJvcGFnYXRlIHRoYXQgdG8gdGhlIG5ldyBzdWJjaGFubmVsIHdyYXBwZXJcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRW50cnkgPT09IG51bGwgfHwgbWFwRW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5wdXNoKHN1YmNoYW5uZWxXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbFdyYXBwZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgbmV3IE91dGxpZXJEZXRlY3Rpb25QaWNrZXIocGlja2VyLCB0aGlzLmlzQ291bnRpbmdFbmFibGVkKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5lamVjdGlvblRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmVqZWN0aW9uVGltZXIpO1xuICAgIH1cbiAgICBpc0NvdW50aW5nRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxhdGVzdENvbmZpZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgKHRoaXMubGF0ZXN0Q29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSAhPT0gbnVsbCkpO1xuICAgIH1cbiAgICBnZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkge1xuICAgICAgICBsZXQgZWplY3Rpb25Db3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWplY3Rpb25Db3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZWplY3Rpb25Db3VudCAqIDEwMCkgLyB0aGlzLmFkZHJlc3NNYXAuc2l6ZTtcbiAgICB9XG4gICAgcnVuU3VjY2Vzc1JhdGVDaGVjayhlamVjdGlvblRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoIXRoaXMubGF0ZXN0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVDb25maWcgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCk7XG4gICAgICAgIGlmICghc3VjY2Vzc1JhdGVDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUnVubmluZyBzdWNjZXNzIHJhdGUgY2hlY2snKTtcbiAgICAgICAgLy8gU3RlcCAxXG4gICAgICAgIGNvbnN0IHRhcmdldFJlcXVlc3RWb2x1bWUgPSBzdWNjZXNzUmF0ZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZTtcbiAgICAgICAgbGV0IGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSA9IDA7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBtYXBFbnRyeV0gb2YgdGhpcy5hZGRyZXNzTWFwKSB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIHRyYWNlKCdTdGF0cyBmb3IgJyArXG4gICAgICAgICAgICAgICAgYWRkcmVzcyArXG4gICAgICAgICAgICAgICAgJzogc3VjY2Vzc2VzPScgK1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NlcyArXG4gICAgICAgICAgICAgICAgJyBmYWlsdXJlcz0nICtcbiAgICAgICAgICAgICAgICBmYWlsdXJlcyArXG4gICAgICAgICAgICAgICAgJyB0YXJnZXRSZXF1ZXN0Vm9sdW1lPScgK1xuICAgICAgICAgICAgICAgIHRhcmdldFJlcXVlc3RWb2x1bWUpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzID49IHRhcmdldFJlcXVlc3RWb2x1bWUpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgKz0gMTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZXMucHVzaChzdWNjZXNzZXMgLyAoc3VjY2Vzc2VzICsgZmFpbHVyZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnRm91bmQgJyArXG4gICAgICAgICAgICBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgK1xuICAgICAgICAgICAgJyBzdWNjZXNzIHJhdGUgY2FuZGlkYXRlczsgY3VycmVudEVqZWN0aW9uUGVyY2VudD0nICtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpICtcbiAgICAgICAgICAgICcgc3VjY2Vzc1JhdGVzPVsnICtcbiAgICAgICAgICAgIHN1Y2Nlc3NSYXRlcyArXG4gICAgICAgICAgICAnXScpO1xuICAgICAgICBpZiAoYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lIDwgc3VjY2Vzc1JhdGVDb25maWcubWluaW11bV9ob3N0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMlxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZU1lYW4gPSBzdWNjZXNzUmF0ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyBzdWNjZXNzUmF0ZXMubGVuZ3RoO1xuICAgICAgICBsZXQgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHJhdGUgb2Ygc3VjY2Vzc1JhdGVzKSB7XG4gICAgICAgICAgICBjb25zdCBkZXZpYXRpb24gPSByYXRlIC0gc3VjY2Vzc1JhdGVNZWFuO1xuICAgICAgICAgICAgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gKz0gZGV2aWF0aW9uICogZGV2aWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlVmFyaWFuY2UgPSBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSAvIHN1Y2Nlc3NSYXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlU3RkZXYgPSBNYXRoLnNxcnQoc3VjY2Vzc1JhdGVWYXJpYW5jZSk7XG4gICAgICAgIGNvbnN0IGVqZWN0aW9uVGhyZXNob2xkID0gc3VjY2Vzc1JhdGVNZWFuIC1cbiAgICAgICAgICAgIHN1Y2Nlc3NSYXRlU3RkZXYgKiAoc3VjY2Vzc1JhdGVDb25maWcuc3RkZXZfZmFjdG9yIC8gMTAwMCk7XG4gICAgICAgIHRyYWNlKCdzdGRldj0nICsgc3VjY2Vzc1JhdGVTdGRldiArICcgZWplY3Rpb25UaHJlc2hvbGQ9JyArIGVqZWN0aW9uVGhyZXNob2xkKTtcbiAgICAgICAgLy8gU3RlcCAzXG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBTdGVwIDMuaVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpID49XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMy5paVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPCB0YXJnZXRSZXF1ZXN0Vm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIDMuaWlpXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9IHN1Y2Nlc3NlcyAvIChzdWNjZXNzZXMgKyBmYWlsdXJlcyk7XG4gICAgICAgICAgICB0cmFjZSgnQ2hlY2tpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzICsgJyBzdWNjZXNzUmF0ZT0nICsgc3VjY2Vzc1JhdGUpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NSYXRlIDwgZWplY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgK1xuICAgICAgICAgICAgICAgICAgICAnIHJhbmRvbU51bWJlcj0nICtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tTnVtYmVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBlbmZvcmNlbWVudF9wZXJjZW50YWdlPScgK1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZG9tTnVtYmVyIDwgc3VjY2Vzc1JhdGVDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRWplY3RpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5GYWlsdXJlUGVyY2VudGFnZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKTtcbiAgICAgICAgaWYgKCFmYWlsdXJlUGVyY2VudGFnZUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSdW5uaW5nIGZhaWx1cmUgcGVyY2VudGFnZSBjaGVjay4gdGhyZXNob2xkPScgK1xuICAgICAgICAgICAgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcudGhyZXNob2xkICtcbiAgICAgICAgICAgICcgcmVxdWVzdCB2b2x1bWUgdGhyZXNob2xkPScgK1xuICAgICAgICAgICAgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpO1xuICAgICAgICAvLyBTdGVwIDFcbiAgICAgICAgbGV0IGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPj0gZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgPCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5taW5pbXVtX2hvc3RzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RlcCAyXG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBTdGVwIDIuaVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpID49XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMi5paVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICB0cmFjZSgnQ2FuZGlkYXRlIHN1Y2Nlc3Nlcz0nICsgc3VjY2Vzc2VzICsgJyBmYWlsdXJlcz0nICsgZmFpbHVyZXMpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMi5paWlcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVQZXJjZW50YWdlID0gKGZhaWx1cmVzICogMTAwKSAvIChmYWlsdXJlcyArIHN1Y2Nlc3Nlcyk7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZVBlcmNlbnRhZ2UgPiBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgK1xuICAgICAgICAgICAgICAgICAgICAnIHJhbmRvbU51bWJlcj0nICtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tTnVtYmVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBlbmZvcmNlbWVudF9wZXJjZW50YWdlPScgK1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZG9tTnVtYmVyIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRWplY3RpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApIHtcbiAgICAgICAgbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciArPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyIG9mIG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmVqZWN0KG1hcEVudHJ5KSB7XG4gICAgICAgIG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgb2YgbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlci51bmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoQWxsQnVja2V0cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmFkZHJlc3NNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuc3dpdGNoQnVja2V0cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VGltZXIoZGVsYXlNcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmVqZWN0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucnVuQ2hlY2tzKCksIGRlbGF5TXMpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmVqZWN0aW9uVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIHJ1bkNoZWNrcygpIHtcbiAgICAgICAgY29uc3QgZWplY3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0cmFjZSgnRWplY3Rpb24gdGltZXIgcnVubmluZycpO1xuICAgICAgICB0aGlzLnN3aXRjaEFsbEJ1Y2tldHMoKTtcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBlamVjdGlvblRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWVyKHRoaXMubGF0ZXN0Q29uZmlnLmdldEludGVydmFsTXMoKSk7XG4gICAgICAgIHRoaXMucnVuU3VjY2Vzc1JhdGVDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgIHRoaXMucnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlRWplY3Rpb25UaW1lTXMgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRCYXNlRWplY3Rpb25UaW1lTXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhFamVjdGlvblRpbWVNcyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldE1heEVqZWN0aW9uVGltZU1zKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVGltZSA9IG5ldyBEYXRlKG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcC5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIHJldHVyblRpbWUuc2V0TWlsbGlzZWNvbmRzKHJldHVyblRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihiYXNlRWplY3Rpb25UaW1lTXMgKiBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyLCBNYXRoLm1heChiYXNlRWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uVGltZU1zKSkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UaW1lIDwgbmV3IERhdGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnVW5lamVjdGluZyAnICsgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5lamVjdChtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZywgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIShsYkNvbmZpZyBpbnN0YW5jZW9mIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWxBZGRyZXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBhZGRyZXNzTGlzdCkge1xuICAgICAgICAgICAgc3ViY2hhbm5lbEFkZHJlc3Nlcy5hZGQoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2Ygc3ViY2hhbm5lbEFkZHJlc3Nlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkZHJlc3NNYXAuaGFzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ0FkZGluZyBtYXAgZW50cnkgZm9yICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZHJlc3NNYXAuc2V0KGFkZHJlc3MsIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcjogbmV3IENhbGxDb3VudGVyKCksXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFamVjdGlvblRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZWplY3Rpb25UaW1lTXVsdGlwbGllcjogMCxcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXJzOiBbXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmFkZHJlc3NNYXAua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAoIXN1YmNoYW5uZWxBZGRyZXNzZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUmVtb3ZpbmcgbWFwIGVudHJ5IGZvciAnICsga2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZHJlc3NNYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRQb2xpY3kgPSAoMCwgbG9hZF9iYWxhbmNlcl8xLmdldEZpcnN0VXNhYmxlQ29uZmlnKShsYkNvbmZpZy5nZXRDaGlsZFBvbGljeSgpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLnVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBjaGlsZFBvbGljeSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChsYkNvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCkgfHxcbiAgICAgICAgICAgIGxiQ29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUHJldmlvdXMgdGltZXIgZXhpc3RlZC4gUmVwbGFjaW5nIHRpbWVyJyk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGVsYXkgPSBsYkNvbmZpZy5nZXRJbnRlcnZhbE1zKCkgLVxuICAgICAgICAgICAgICAgICAgICAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnRpbWVyU3RhcnRUaW1lLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKHJlbWFpbmluZ0RlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdTdGFydGluZyBuZXcgdGltZXInKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZXIobGJDb25maWcuZ2V0SW50ZXJ2YWxNcygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaEFsbEJ1Y2tldHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYWNlKCdDb3VudGluZyBkaXNhYmxlZC4gQ2FuY2VsbGluZyB0aW1lci4nKTtcbiAgICAgICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5lamVjdChtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBsYkNvbmZpZztcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5yZXNldEJhY2tvZmYoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciA9IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBpZiAoT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCkge1xuICAgICAgICAoMCwgZXhwZXJpbWVudGFsXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUsIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIsIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJfYSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2V0dXAiLCJPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyIiwiT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWciLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsImR1cmF0aW9uXzEiLCJleHBlcmltZW50YWxfMSIsImxvYWRfYmFsYW5jZXJfMSIsImxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xIiwicGlja2VyXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsInN1YmNoYW5uZWxfaW50ZXJmYWNlXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIk9VVExJRVJfREVURUNUSU9OX0VOQUJMRUQiLCJwcm9jZXNzIiwiZW52IiwiR1JQQ19FWFBFUklNRU5UQUxfRU5BQkxFX09VVExJRVJfREVURUNUSU9OIiwiZGVmYXVsdFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWciLCJzdGRldl9mYWN0b3IiLCJlbmZvcmNlbWVudF9wZXJjZW50YWdlIiwibWluaW11bV9ob3N0cyIsInJlcXVlc3Rfdm9sdW1lIiwiZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWciLCJ0aHJlc2hvbGQiLCJ2YWxpZGF0ZUZpZWxkVHlwZSIsIm9iaiIsImZpZWxkTmFtZSIsImV4cGVjdGVkVHlwZSIsIm9iamVjdE5hbWUiLCJmdWxsRmllbGROYW1lIiwiRXJyb3IiLCJ2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24iLCJpc0R1cmF0aW9uIiwic2Vjb25kcyIsIm5hbm9zIiwidmFsaWRhdGVQZXJjZW50YWdlIiwiY29uc3RydWN0b3IiLCJpbnRlcnZhbE1zIiwiYmFzZUVqZWN0aW9uVGltZU1zIiwibWF4RWplY3Rpb25UaW1lTXMiLCJtYXhFamVjdGlvblBlcmNlbnQiLCJzdWNjZXNzUmF0ZUVqZWN0aW9uIiwiZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiIsImNoaWxkUG9saWN5IiwibGVuZ3RoIiwiZ2V0TG9hZEJhbGFuY2VyTmFtZSIsImFzc2lnbiIsInRvSnNvbk9iamVjdCIsImludGVydmFsIiwibXNUb0R1cmF0aW9uIiwiYmFzZV9lamVjdGlvbl90aW1lIiwibWF4X2VqZWN0aW9uX3RpbWUiLCJtYXhfZWplY3Rpb25fcGVyY2VudCIsInN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiIsImZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiIsImNoaWxkX3BvbGljeSIsIm1hcCIsInBvbGljeSIsImdldEludGVydmFsTXMiLCJnZXRCYXNlRWplY3Rpb25UaW1lTXMiLCJnZXRNYXhFamVjdGlvblRpbWVNcyIsImdldE1heEVqZWN0aW9uUGVyY2VudCIsImdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWciLCJnZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnIiwiZ2V0Q2hpbGRQb2xpY3kiLCJjb3B5V2l0aENoaWxkUG9saWN5IiwiY3JlYXRlRnJvbUpzb24iLCJkdXJhdGlvblRvTXMiLCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWciLCJPdXRsaWVyRGV0ZWN0aW9uU3ViY2hhbm5lbFdyYXBwZXIiLCJCYXNlU3ViY2hhbm5lbFdyYXBwZXIiLCJjaGlsZFN1YmNoYW5uZWwiLCJtYXBFbnRyeSIsInN0YXRlTGlzdGVuZXJzIiwiZWplY3RlZCIsInJlZkNvdW50IiwiY2hpbGRTdWJjaGFubmVsU3RhdGUiLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsImFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJzdWJjaGFubmVsIiwicHJldmlvdXNTdGF0ZSIsIm5ld1N0YXRlIiwia2VlcGFsaXZlVGltZSIsImxpc3RlbmVyIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJUUkFOU0lFTlRfRkFJTFVSRSIsInB1c2giLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwibGlzdGVuZXJJbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJyZWYiLCJjaGlsZCIsInVucmVmIiwiaW5kZXgiLCJzdWJjaGFubmVsV3JhcHBlcnMiLCJlamVjdCIsInVuZWplY3QiLCJnZXRNYXBFbnRyeSIsImdldFdyYXBwZWRTdWJjaGFubmVsIiwiY3JlYXRlRW1wdHlCdWNrZXQiLCJzdWNjZXNzIiwiZmFpbHVyZSIsIkNhbGxDb3VudGVyIiwiYWN0aXZlQnVja2V0IiwiaW5hY3RpdmVCdWNrZXQiLCJhZGRTdWNjZXNzIiwiYWRkRmFpbHVyZSIsInN3aXRjaEJ1Y2tldHMiLCJnZXRMYXN0U3VjY2Vzc2VzIiwiZ2V0TGFzdEZhaWx1cmVzIiwiT3V0bGllckRldGVjdGlvblBpY2tlciIsIndyYXBwZWRQaWNrZXIiLCJjb3VudENhbGxzIiwicGljayIsInBpY2tBcmdzIiwid3JhcHBlZFBpY2siLCJwaWNrUmVzdWx0VHlwZSIsIlBpY2tSZXN1bHRUeXBlIiwiQ09NUExFVEUiLCJzdWJjaGFubmVsV3JhcHBlciIsIm9uQ2FsbEVuZGVkIiwic3RhdHVzQ29kZSIsIlN0YXR1cyIsIk9LIiwiY291bnRlciIsImNhbGwiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImFkZHJlc3NNYXAiLCJNYXAiLCJsYXRlc3RDb25maWciLCJ0aW1lclN0YXJ0VGltZSIsImNoaWxkQmFsYW5jZXIiLCJDaGlsZExvYWRCYWxhbmNlckhhbmRsZXIiLCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyIiwiY3JlYXRlU3ViY2hhbm5lbCIsInN1YmNoYW5uZWxBZGRyZXNzIiwic3ViY2hhbm5lbEFyZ3MiLCJvcmlnaW5hbFN1YmNoYW5uZWwiLCJnZXQiLCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nIiwiY3VycmVudEVqZWN0aW9uVGltZXN0YW1wIiwidXBkYXRlU3RhdGUiLCJjb25uZWN0aXZpdHlTdGF0ZSIsInBpY2tlciIsIlJFQURZIiwiaXNDb3VudGluZ0VuYWJsZWQiLCJlamVjdGlvblRpbWVyIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCIsImVqZWN0aW9uQ291bnQiLCJ2YWx1ZXMiLCJzaXplIiwicnVuU3VjY2Vzc1JhdGVDaGVjayIsImVqZWN0aW9uVGltZXN0YW1wIiwic3VjY2Vzc1JhdGVDb25maWciLCJ0YXJnZXRSZXF1ZXN0Vm9sdW1lIiwiYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lIiwic3VjY2Vzc1JhdGVzIiwiYWRkcmVzcyIsInN1Y2Nlc3NlcyIsImZhaWx1cmVzIiwic3VjY2Vzc1JhdGVNZWFuIiwicmVkdWNlIiwiYSIsImIiLCJzdWNjZXNzUmF0ZURldmlhdGlvblN1bSIsInJhdGUiLCJkZXZpYXRpb24iLCJzdWNjZXNzUmF0ZVZhcmlhbmNlIiwic3VjY2Vzc1JhdGVTdGRldiIsIk1hdGgiLCJzcXJ0IiwiZWplY3Rpb25UaHJlc2hvbGQiLCJlbnRyaWVzIiwic3VjY2Vzc1JhdGUiLCJyYW5kb21OdW1iZXIiLCJyYW5kb20iLCJydW5GYWlsdXJlUGVyY2VudGFnZUNoZWNrIiwiZmFpbHVyZVBlcmNlbnRhZ2VDb25maWciLCJhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lIiwiZmFpbHVyZVBlcmNlbnRhZ2UiLCJEYXRlIiwiZWplY3Rpb25UaW1lTXVsdGlwbGllciIsInN3aXRjaEFsbEJ1Y2tldHMiLCJzdGFydFRpbWVyIiwiZGVsYXlNcyIsIl9iIiwic2V0VGltZW91dCIsInJ1bkNoZWNrcyIsInJldHVyblRpbWUiLCJnZXRUaW1lIiwic2V0TWlsbGlzZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwibWluIiwibWF4IiwidXBkYXRlQWRkcmVzc0xpc3QiLCJhZGRyZXNzTGlzdCIsImxiQ29uZmlnIiwiYXR0cmlidXRlcyIsInN1YmNoYW5uZWxBZGRyZXNzZXMiLCJTZXQiLCJhZGQiLCJoYXMiLCJzZXQiLCJrZXkiLCJrZXlzIiwiZGVsZXRlIiwiZ2V0Rmlyc3RVc2FibGVDb25maWciLCJjbGVhclRpbWVvdXQiLCJyZW1haW5pbmdEZWxheSIsImV4aXRJZGxlIiwicmVzZXRCYWNrb2ZmIiwiZGVzdHJveSIsImdldFR5cGVOYW1lIiwicmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.PickFirstLoadBalancer = exports.shuffled = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"pick_first\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"pick_first\";\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */ const CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n    constructor(shuffleAddressList){\n        this.shuffleAddressList = shuffleAddressList;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {\n                shuffleAddressList: this.shuffleAddressList\n            }\n        };\n    }\n    getShuffleAddressList() {\n        return this.shuffleAddressList;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        if (\"shuffleAddressList\" in obj && !(typeof obj.shuffleAddressList === \"boolean\")) {\n            throw new Error(\"pick_first config field shuffleAddressList must be a boolean if provided\");\n        }\n        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n    }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */ class PickFirstPicker {\n    constructor(subchannel){\n        this.subchannel = subchannel;\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: this.subchannel,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n}\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */ function shuffled(list) {\n    const result = list.slice();\n    for(let i = result.length - 1; i > 1; i--){\n        const j = Math.floor(Math.random() * (i + 1));\n        const temp = result[i];\n        result[i] = result[j];\n        result[j] = temp;\n    }\n    return result;\n}\nexports.shuffled = shuffled;\nclass PickFirstLoadBalancer {\n    /**\n     * Load balancer that attempts to connect to each backend in the address list\n     * in order, and picks the first one that connects, using it for every\n     * request.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     */ constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        /**\n         * The list of subchannels this load balancer is currently attempting to\n         * connect to.\n         */ this.children = [];\n        /**\n         * The current connectivity state of the load balancer.\n         */ this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The index within the `subchannels` array of the subchannel with the most\n         * recently started connection attempt.\n         */ this.currentSubchannelIndex = 0;\n        /**\n         * The currently picked subchannel used for making calls. Populated if\n         * and only if the load balancer's current state is READY. In that case,\n         * the subchannel's current state is also READY.\n         */ this.currentPick = null;\n        /**\n         * Listener callback attached to each subchannel in the `subchannels` list\n         * while establishing a connection.\n         */ this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage)=>{\n            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\n        };\n        this.triedAllSubchannels = false;\n        /**\n         * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n         * subchannels have failed to connect at least once, and it stays in that\n         * mode until a connection attempt is successful. While in sticky TF mode,\n         * the LB policy continuously attempts to connect to all of its subchannels.\n         */ this.stickyTransientFailureMode = false;\n        /**\n         * Indicates whether we called channelControlHelper.requestReresolution since\n         * the last call to updateAddressList\n         */ this.requestedResolutionSinceLastUpdate = false;\n        /**\n         * The most recent error reported by any subchannel as it transitioned to\n         * TRANSIENT_FAILURE.\n         */ this.lastError = null;\n        this.latestAddressList = null;\n        this.connectionDelayTimeout = setTimeout(()=>{}, 0);\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    allChildrenHaveReportedTF() {\n        return this.children.every((child)=>child.hasReportedTransientFailure);\n    }\n    calculateAndReportNewState() {\n        if (this.currentPick) {\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));\n        } else if (this.children.length === 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        } else {\n            if (this.stickyTransientFailureMode) {\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                    details: `No connection established. Last error: ${this.lastError}`\n                }));\n            } else {\n                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n            }\n        }\n    }\n    requestReresolution() {\n        this.requestedResolutionSinceLastUpdate = true;\n        this.channelControlHelper.requestReresolution();\n    }\n    maybeEnterStickyTransientFailureMode() {\n        if (!this.allChildrenHaveReportedTF()) {\n            return;\n        }\n        if (!this.requestedResolutionSinceLastUpdate) {\n            /* Each time we get an update we reset each subchannel's\n             * hasReportedTransientFailure flag, so the next time we get to this\n             * point after that, each subchannel has reported TRANSIENT_FAILURE\n             * at least once since then. That is the trigger for requesting\n             * reresolution, whether or not the LB policy is already in sticky TF\n             * mode. */ this.requestReresolution();\n        }\n        if (this.stickyTransientFailureMode) {\n            return;\n        }\n        this.stickyTransientFailureMode = true;\n        for (const { subchannel } of this.children){\n            subchannel.startConnecting();\n        }\n        this.calculateAndReportNewState();\n    }\n    removeCurrentPick() {\n        if (this.currentPick !== null) {\n            /* Unref can cause a state change, which can cause a change in the value\n             * of this.currentPick, so we hold a local reference to make sure that\n             * does not impact this function. */ const currentPick = this.currentPick;\n            this.currentPick = null;\n            currentPick.unref();\n            currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n        }\n    }\n    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {\n        var _a;\n        if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\n                this.removeCurrentPick();\n                this.calculateAndReportNewState();\n                this.requestReresolution();\n            }\n            return;\n        }\n        for (const [index, child] of this.children.entries()){\n            if (subchannel.realSubchannelEquals(child.subchannel)) {\n                if (newState === connectivity_state_1.ConnectivityState.READY) {\n                    this.pickSubchannel(child.subchannel);\n                }\n                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    child.hasReportedTransientFailure = true;\n                    if (errorMessage) {\n                        this.lastError = errorMessage;\n                    }\n                    this.maybeEnterStickyTransientFailureMode();\n                    if (index === this.currentSubchannelIndex) {\n                        this.startNextSubchannelConnecting(index + 1);\n                    }\n                }\n                child.subchannel.startConnecting();\n                return;\n            }\n        }\n    }\n    startNextSubchannelConnecting(startIndex) {\n        clearTimeout(this.connectionDelayTimeout);\n        if (this.triedAllSubchannels) {\n            return;\n        }\n        for (const [index, child] of this.children.entries()){\n            if (index >= startIndex) {\n                const subchannelState = child.subchannel.getConnectivityState();\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                    this.startConnecting(index);\n                    return;\n                }\n            }\n        }\n        this.triedAllSubchannels = true;\n        this.maybeEnterStickyTransientFailureMode();\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */ startConnecting(subchannelIndex) {\n        var _a, _b;\n        clearTimeout(this.connectionDelayTimeout);\n        this.currentSubchannelIndex = subchannelIndex;\n        if (this.children[subchannelIndex].subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n            trace(\"Start connecting to subchannel with address \" + this.children[subchannelIndex].subchannel.getAddress());\n            process.nextTick(()=>{\n                var _a;\n                (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();\n            });\n        }\n        this.connectionDelayTimeout = (_b = (_a = setTimeout(()=>{\n            this.startNextSubchannelConnecting(subchannelIndex + 1);\n        }, CONNECTION_DELAY_INTERVAL_MS)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    pickSubchannel(subchannel) {\n        if (this.currentPick && subchannel.realSubchannelEquals(this.currentPick)) {\n            return;\n        }\n        trace(\"Pick subchannel with address \" + subchannel.getAddress());\n        this.stickyTransientFailureMode = false;\n        if (this.currentPick !== null) {\n            this.currentPick.unref();\n            this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\n            this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n        }\n        this.currentPick = subchannel;\n        subchannel.ref();\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        this.resetSubchannelList();\n        clearTimeout(this.connectionDelayTimeout);\n        this.calculateAndReportNewState();\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const child of this.children){\n            if (child.subchannel !== this.currentPick) {\n                /* The connectivity state listener is the same whether the subchannel\n                 * is in the list of children or it is the currentPick, so if it is in\n                 * both, removing it here would cause problems. In particular, that\n                 * always happens immediately after the subchannel is picked. */ child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            }\n            /* Refs are counted independently for the children list and the\n             * currentPick, so we call unref whether or not the child is the\n             * currentPick. Channelz child references are also refcounted, so\n             * removeChannelzChild can be handled the same way. */ child.subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\n        }\n        this.currentSubchannelIndex = 0;\n        this.children = [];\n        this.triedAllSubchannels = false;\n        this.requestedResolutionSinceLastUpdate = false;\n    }\n    connectToAddressList(addressList) {\n        const newChildrenList = addressList.map((address)=>({\n                subchannel: this.channelControlHelper.createSubchannel(address, {}),\n                hasReportedTransientFailure: false\n            }));\n        /* Ref each subchannel before resetting the list, to ensure that\n         * subchannels shared between the list don't drop to 0 refs during the\n         * transition. */ for (const { subchannel } of newChildrenList){\n            subchannel.ref();\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        }\n        this.resetSubchannelList();\n        this.children = newChildrenList;\n        for (const { subchannel } of this.children){\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                return;\n            }\n        }\n        for (const child of this.children){\n            if (child.subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                child.hasReportedTransientFailure = true;\n            }\n        }\n        this.startNextSubchannelConnecting(0);\n        this.calculateAndReportNewState();\n    }\n    updateAddressList(addressList, lbConfig) {\n        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n            return;\n        }\n        /* Previously, an update would be discarded if it was identical to the\n         * previous update, to minimize churn. Now the DNS resolver is\n         * rate-limited, so that is less of a concern. */ if (lbConfig.getShuffleAddressList()) {\n            addressList = shuffled(addressList);\n        }\n        this.latestAddressList = addressList;\n        this.connectToAddressList(addressList);\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {\n            this.connectToAddressList(this.latestAddressList);\n        }\n    }\n    resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */ }\n    destroy() {\n        this.resetSubchannelList();\n        this.removeCurrentPick();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-pick-first.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSw2QkFBNkIsR0FBR0EsZ0JBQWdCLEdBQUdBLG9DQUFvQyxHQUFHLEtBQUs7QUFDL0csTUFBTU0sa0JBQWtCQyxtQkFBT0EsQ0FBQyxzRkFBaUI7QUFDakQsTUFBTUMsdUJBQXVCRCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTUksY0FBY0osbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUssY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZKLFFBQVFHLEtBQUssQ0FBQ0YsWUFBWUksWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0EsTUFBTUcsWUFBWTtBQUNsQjs7O0NBR0MsR0FDRCxNQUFNQywrQkFBK0I7QUFDckMsTUFBTWI7SUFDRmMsWUFBWUMsa0JBQWtCLENBQUU7UUFDNUIsSUFBSSxDQUFDQSxrQkFBa0IsR0FBR0E7SUFDOUI7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU9KO0lBQ1g7SUFDQUssZUFBZTtRQUNYLE9BQU87WUFDSCxDQUFDTCxVQUFVLEVBQUU7Z0JBQ1RHLG9CQUFvQixJQUFJLENBQUNBLGtCQUFrQjtZQUMvQztRQUNKO0lBQ0o7SUFDQUcsd0JBQXdCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDSCxrQkFBa0I7SUFDbEM7SUFDQSw4REFBOEQ7SUFDOUQsT0FBT0ksZUFBZUMsR0FBRyxFQUFFO1FBQ3ZCLElBQUksd0JBQXdCQSxPQUN4QixDQUFFLFFBQU9BLElBQUlMLGtCQUFr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T0FBT3RHO0lBQ1g7QUFDSjtBQUNBakIsNkJBQTZCLEdBQUdHO0FBQ2hDLFNBQVNEO0lBQ0osSUFBR0ksZ0JBQWdCa0gsd0JBQXdCLEVBQUV2RyxXQUFXZCx1QkFBdUJFO0lBQy9FLElBQUdDLGdCQUFnQm1ILCtCQUErQixFQUFFeEc7QUFDekQ7QUFDQWpCLGFBQWEsR0FBR0UsT0FDaEIsb0RBQW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzPzUzODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNlciA9IGV4cG9ydHMuc2h1ZmZsZWQgPSBleHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcgPSB2b2lkIDA7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdwaWNrX2ZpcnN0JztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgVFlQRV9OQU1FID0gJ3BpY2tfZmlyc3QnO1xuLyoqXG4gKiBEZWxheSBhZnRlciBzdGFydGluZyBhIGNvbm5lY3Rpb24gb24gYSBzdWJjaGFubmVsIGJlZm9yZSBzdGFydGluZyBhXG4gKiBjb25uZWN0aW9uIG9uIHRoZSBuZXh0IHN1YmNoYW5uZWwgaW4gdGhlIGxpc3QsIGZvciBIYXBweSBFeWViYWxscyBhbGdvcml0aG0uXG4gKi9cbmNvbnN0IENPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMgPSAyNTA7XG5jbGFzcyBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihzaHVmZmxlQWRkcmVzc0xpc3QpIHtcbiAgICAgICAgdGhpcy5zaHVmZmxlQWRkcmVzc0xpc3QgPSBzaHVmZmxlQWRkcmVzc0xpc3Q7XG4gICAgfVxuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIHRvSnNvbk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtUWVBFX05BTUVdOiB7XG4gICAgICAgICAgICAgICAgc2h1ZmZsZUFkZHJlc3NMaXN0OiB0aGlzLnNodWZmbGVBZGRyZXNzTGlzdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFNodWZmbGVBZGRyZXNzTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2h1ZmZsZUFkZHJlc3NMaXN0O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcbiAgICAgICAgaWYgKCdzaHVmZmxlQWRkcmVzc0xpc3QnIGluIG9iaiAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqLnNodWZmbGVBZGRyZXNzTGlzdCA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwaWNrX2ZpcnN0IGNvbmZpZyBmaWVsZCBzaHVmZmxlQWRkcmVzc0xpc3QgbXVzdCBiZSBhIGJvb2xlYW4gaWYgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcob2JqLnNodWZmbGVBZGRyZXNzTGlzdCA9PT0gdHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnID0gUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZztcbi8qKlxuICogUGlja2VyIGZvciBhIGBQaWNrRmlyc3RMb2FkQmFsYW5jZXJgIGluIHRoZSBSRUFEWSBzdGF0ZS4gQWx3YXlzIHJldHVybnMgdGhlXG4gKiBwaWNrZWQgc3ViY2hhbm5lbC5cbiAqL1xuY2xhc3MgUGlja0ZpcnN0UGlja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzdWJjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbCA9IHN1YmNoYW5uZWw7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IHRoaXMuc3ViY2hhbm5lbCxcbiAgICAgICAgICAgIHN0YXR1czogbnVsbCxcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxFbmRlZDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybiBhIG5ldyBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyBvZiB0aGUgaW5wdXQgYXJyYXkgaW4gYSByYW5kb20gb3JkZXJcbiAqIEBwYXJhbSBsaXN0IFRoZSBpbnB1dCBhcnJheVxuICogQHJldHVybnMgQSBzaHVmZmxlZCBhcnJheSBvZiB0aGUgZWxlbWVudHMgb2YgbGlzdFxuICovXG5mdW5jdGlvbiBzaHVmZmxlZChsaXN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbGlzdC5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+IDE7IGktLSkge1xuICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgIGNvbnN0IHRlbXAgPSByZXN1bHRbaV07XG4gICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtqXTtcbiAgICAgICAgcmVzdWx0W2pdID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuc2h1ZmZsZWQgPSBzaHVmZmxlZDtcbmNsYXNzIFBpY2tGaXJzdExvYWRCYWxhbmNlciB7XG4gICAgLyoqXG4gICAgICogTG9hZCBiYWxhbmNlciB0aGF0IGF0dGVtcHRzIHRvIGNvbm5lY3QgdG8gZWFjaCBiYWNrZW5kIGluIHRoZSBhZGRyZXNzIGxpc3RcbiAgICAgKiBpbiBvcmRlciwgYW5kIHBpY2tzIHRoZSBmaXJzdCBvbmUgdGhhdCBjb25uZWN0cywgdXNpbmcgaXQgZm9yIGV2ZXJ5XG4gICAgICogcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbENvbnRyb2xIZWxwZXIgYENoYW5uZWxDb250cm9sSGVscGVyYCBpbnN0YW5jZSBwcm92aWRlZCBieVxuICAgICAqICAgICB0aGlzIGxvYWQgYmFsYW5jZXIncyBvd25lci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBzdWJjaGFubmVscyB0aGlzIGxvYWQgYmFsYW5jZXIgaXMgY3VycmVudGx5IGF0dGVtcHRpbmcgdG9cbiAgICAgICAgICogY29ubmVjdCB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZSBvZiB0aGUgbG9hZCBiYWxhbmNlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCB3aXRoaW4gdGhlIGBzdWJjaGFubmVsc2AgYXJyYXkgb2YgdGhlIHN1YmNoYW5uZWwgd2l0aCB0aGUgbW9zdFxuICAgICAgICAgKiByZWNlbnRseSBzdGFydGVkIGNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IHBpY2tlZCBzdWJjaGFubmVsIHVzZWQgZm9yIG1ha2luZyBjYWxscy4gUG9wdWxhdGVkIGlmXG4gICAgICAgICAqIGFuZCBvbmx5IGlmIHRoZSBsb2FkIGJhbGFuY2VyJ3MgY3VycmVudCBzdGF0ZSBpcyBSRUFEWS4gSW4gdGhhdCBjYXNlLFxuICAgICAgICAgKiB0aGUgc3ViY2hhbm5lbCdzIGN1cnJlbnQgc3RhdGUgaXMgYWxzbyBSRUFEWS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdGVuZXIgY2FsbGJhY2sgYXR0YWNoZWQgdG8gZWFjaCBzdWJjaGFubmVsIGluIHRoZSBgc3ViY2hhbm5lbHNgIGxpc3RcbiAgICAgICAgICogd2hpbGUgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIgPSAoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGtlZXBhbGl2ZVRpbWUsIGVycm9yTWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZShzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmllZEFsbFN1YmNoYW5uZWxzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgTEIgcG9saWN5IGVudGVycyBzdGlja3kgVFJBTlNJRU5UX0ZBSUxVUkUgbW9kZSB3aGVuIGFsbFxuICAgICAgICAgKiBzdWJjaGFubmVscyBoYXZlIGZhaWxlZCB0byBjb25uZWN0IGF0IGxlYXN0IG9uY2UsIGFuZCBpdCBzdGF5cyBpbiB0aGF0XG4gICAgICAgICAqIG1vZGUgdW50aWwgYSBjb25uZWN0aW9uIGF0dGVtcHQgaXMgc3VjY2Vzc2Z1bC4gV2hpbGUgaW4gc3RpY2t5IFRGIG1vZGUsXG4gICAgICAgICAqIHRoZSBMQiBwb2xpY3kgY29udGludW91c2x5IGF0dGVtcHRzIHRvIGNvbm5lY3QgdG8gYWxsIG9mIGl0cyBzdWJjaGFubmVscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHdlIGNhbGxlZCBjaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uIHNpbmNlXG4gICAgICAgICAqIHRoZSBsYXN0IGNhbGwgdG8gdXBkYXRlQWRkcmVzc0xpc3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVxdWVzdGVkUmVzb2x1dGlvblNpbmNlTGFzdFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vc3QgcmVjZW50IGVycm9yIHJlcG9ydGVkIGJ5IGFueSBzdWJjaGFubmVsIGFzIGl0IHRyYW5zaXRpb25lZCB0b1xuICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XG4gICAgfVxuICAgIGFsbENoaWxkcmVuSGF2ZVJlcG9ydGVkVEYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IGNoaWxkLmhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGljaykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSwgbmV3IFBpY2tGaXJzdFBpY2tlcih0aGlzLmN1cnJlbnRQaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHsgZGV0YWlsczogYE5vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuIExhc3QgZXJyb3I6ICR7dGhpcy5sYXN0RXJyb3J9YCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdFJlcmVzb2x1dGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWRSZXNvbHV0aW9uU2luY2VMYXN0VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgfVxuICAgIG1heWJlRW50ZXJTdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbENoaWxkcmVuSGF2ZVJlcG9ydGVkVEYoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0ZWRSZXNvbHV0aW9uU2luY2VMYXN0VXBkYXRlKSB7XG4gICAgICAgICAgICAvKiBFYWNoIHRpbWUgd2UgZ2V0IGFuIHVwZGF0ZSB3ZSByZXNldCBlYWNoIHN1YmNoYW5uZWwnc1xuICAgICAgICAgICAgICogaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlIGZsYWcsIHNvIHRoZSBuZXh0IHRpbWUgd2UgZ2V0IHRvIHRoaXNcbiAgICAgICAgICAgICAqIHBvaW50IGFmdGVyIHRoYXQsIGVhY2ggc3ViY2hhbm5lbCBoYXMgcmVwb3J0ZWQgVFJBTlNJRU5UX0ZBSUxVUkVcbiAgICAgICAgICAgICAqIGF0IGxlYXN0IG9uY2Ugc2luY2UgdGhlbi4gVGhhdCBpcyB0aGUgdHJpZ2dlciBmb3IgcmVxdWVzdGluZ1xuICAgICAgICAgICAgICogcmVyZXNvbHV0aW9uLCB3aGV0aGVyIG9yIG5vdCB0aGUgTEIgcG9saWN5IGlzIGFscmVhZHkgaW4gc3RpY2t5IFRGXG4gICAgICAgICAgICAgKiBtb2RlLiAqL1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKTtcbiAgICB9XG4gICAgcmVtb3ZlQ3VycmVudFBpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvKiBVbnJlZiBjYW4gY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIHdoaWNoIGNhbiBjYXVzZSBhIGNoYW5nZSBpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgICAqIG9mIHRoaXMuY3VycmVudFBpY2ssIHNvIHdlIGhvbGQgYSBsb2NhbCByZWZlcmVuY2UgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICAgICAgICAgICAqIGRvZXMgbm90IGltcGFjdCB0aGlzIGZ1bmN0aW9uLiAqL1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFBpY2sgPSB0aGlzLmN1cnJlbnRQaWNrO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGljayA9IG51bGw7XG4gICAgICAgICAgICBjdXJyZW50UGljay51bnJlZigpO1xuICAgICAgICAgICAgY3VycmVudFBpY2sucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChjdXJyZW50UGljay5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZShzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuY3VycmVudFBpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFsU3ViY2hhbm5lbEVxdWFscyhzdWJjaGFubmVsKSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ3VycmVudFBpY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkXSBvZiB0aGlzLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWwucmVhbFN1YmNoYW5uZWxFcXVhbHMoY2hpbGQuc3ViY2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGlja1N1YmNoYW5uZWwoY2hpbGQuc3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmcoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZC5zdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZyhzdGFydEluZGV4KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xuICAgICAgICBpZiAodGhpcy50cmllZEFsbFN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkXSBvZiB0aGlzLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RhdGUgPSBjaGlsZC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWxTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSB8fFxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydENvbm5lY3RpbmcoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZWRBbGxTdWJjaGFubmVscyA9IHRydWU7XG4gICAgICAgIHRoaXMubWF5YmVFbnRlclN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhdmUgYSBzaW5nbGUgc3ViY2hhbm5lbCBpbiB0aGUgYHN1YmNoYW5uZWxzYCBsaXN0IHN0YXJ0IGNvbm5lY3RpbmcuXG4gICAgICogQHBhcmFtIHN1YmNoYW5uZWxJbmRleCBUaGUgaW5kZXggaW50byB0aGUgYHN1YmNoYW5uZWxzYCBsaXN0LlxuICAgICAqL1xuICAgIHN0YXJ0Q29ubmVjdGluZyhzdWJjaGFubmVsSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IHN1YmNoYW5uZWxJbmRleDtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bc3ViY2hhbm5lbEluZGV4XS5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09XG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0cmFjZSgnU3RhcnQgY29ubmVjdGluZyB0byBzdWJjaGFubmVsIHdpdGggYWRkcmVzcyAnICtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW3N1YmNoYW5uZWxJbmRleF0uc3ViY2hhbm5lbC5nZXRBZGRyZXNzKCkpO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY2hpbGRyZW5bc3ViY2hhbm5lbEluZGV4XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQgPSAoX2IgPSAoX2EgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3Rpbmcoc3ViY2hhbm5lbEluZGV4ICsgMSk7XG4gICAgICAgIH0sIENPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMpKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH1cbiAgICBwaWNrU3ViY2hhbm5lbChzdWJjaGFubmVsKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrICYmIHN1YmNoYW5uZWwucmVhbFN1YmNoYW5uZWxFcXVhbHModGhpcy5jdXJyZW50UGljaykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUGljayBzdWJjaGFubmVsIHdpdGggYWRkcmVzcyAnICsgc3ViY2hhbm5lbC5nZXRBZGRyZXNzKCkpO1xuICAgICAgICB0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrLnVucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQodGhpcy5jdXJyZW50UGljay5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrID0gc3ViY2hhbm5lbDtcbiAgICAgICAgc3ViY2hhbm5lbC5yZWYoKTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKSB7XG4gICAgICAgIHRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY3VycmVudFN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKTtcbiAgICB9XG4gICAgcmVzZXRTdWJjaGFubmVsTGlzdCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuc3ViY2hhbm5lbCAhPT0gdGhpcy5jdXJyZW50UGljaykge1xuICAgICAgICAgICAgICAgIC8qIFRoZSBjb25uZWN0aXZpdHkgc3RhdGUgbGlzdGVuZXIgaXMgdGhlIHNhbWUgd2hldGhlciB0aGUgc3ViY2hhbm5lbFxuICAgICAgICAgICAgICAgICAqIGlzIGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuIG9yIGl0IGlzIHRoZSBjdXJyZW50UGljaywgc28gaWYgaXQgaXMgaW5cbiAgICAgICAgICAgICAgICAgKiBib3RoLCByZW1vdmluZyBpdCBoZXJlIHdvdWxkIGNhdXNlIHByb2JsZW1zLiBJbiBwYXJ0aWN1bGFyLCB0aGF0XG4gICAgICAgICAgICAgICAgICogYWx3YXlzIGhhcHBlbnMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHN1YmNoYW5uZWwgaXMgcGlja2VkLiAqL1xuICAgICAgICAgICAgICAgIGNoaWxkLnN1YmNoYW5uZWwucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFJlZnMgYXJlIGNvdW50ZWQgaW5kZXBlbmRlbnRseSBmb3IgdGhlIGNoaWxkcmVuIGxpc3QgYW5kIHRoZVxuICAgICAgICAgICAgICogY3VycmVudFBpY2ssIHNvIHdlIGNhbGwgdW5yZWYgd2hldGhlciBvciBub3QgdGhlIGNoaWxkIGlzIHRoZVxuICAgICAgICAgICAgICogY3VycmVudFBpY2suIENoYW5uZWx6IGNoaWxkIHJlZmVyZW5jZXMgYXJlIGFsc28gcmVmY291bnRlZCwgc29cbiAgICAgICAgICAgICAqIHJlbW92ZUNoYW5uZWx6Q2hpbGQgY2FuIGJlIGhhbmRsZWQgdGhlIHNhbWUgd2F5LiAqL1xuICAgICAgICAgICAgY2hpbGQuc3ViY2hhbm5lbC51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWRSZXNvbHV0aW9uU2luY2VMYXN0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbm5lY3RUb0FkZHJlc3NMaXN0KGFkZHJlc3NMaXN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuTGlzdCA9IGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICh7XG4gICAgICAgICAgICBzdWJjaGFubmVsOiB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoYWRkcmVzcywge30pLFxuICAgICAgICAgICAgaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlOiBmYWxzZSxcbiAgICAgICAgfSkpO1xuICAgICAgICAvKiBSZWYgZWFjaCBzdWJjaGFubmVsIGJlZm9yZSByZXNldHRpbmcgdGhlIGxpc3QsIHRvIGVuc3VyZSB0aGF0XG4gICAgICAgICAqIHN1YmNoYW5uZWxzIHNoYXJlZCBiZXR3ZWVuIHRoZSBsaXN0IGRvbid0IGRyb3AgdG8gMCByZWZzIGR1cmluZyB0aGVcbiAgICAgICAgICogdHJhbnNpdGlvbi4gKi9cbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiBuZXdDaGlsZHJlbkxpc3QpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuTGlzdDtcbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGlja1N1YmNoYW5uZWwoc3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT1cbiAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZygwKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgaWYgKCEobGJDb25maWcgaW5zdGFuY2VvZiBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIFByZXZpb3VzbHksIGFuIHVwZGF0ZSB3b3VsZCBiZSBkaXNjYXJkZWQgaWYgaXQgd2FzIGlkZW50aWNhbCB0byB0aGVcbiAgICAgICAgICogcHJldmlvdXMgdXBkYXRlLCB0byBtaW5pbWl6ZSBjaHVybi4gTm93IHRoZSBETlMgcmVzb2x2ZXIgaXNcbiAgICAgICAgICogcmF0ZS1saW1pdGVkLCBzbyB0aGF0IGlzIGxlc3Mgb2YgYSBjb25jZXJuLiAqL1xuICAgICAgICBpZiAobGJDb25maWcuZ2V0U2h1ZmZsZUFkZHJlc3NMaXN0KCkpIHtcbiAgICAgICAgICAgIGFkZHJlc3NMaXN0ID0gc2h1ZmZsZWQoYWRkcmVzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QgPSBhZGRyZXNzTGlzdDtcbiAgICAgICAgdGhpcy5jb25uZWN0VG9BZGRyZXNzTGlzdChhZGRyZXNzTGlzdCk7XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgJiYgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VG9BZGRyZXNzTGlzdCh0aGlzLmxhdGVzdEFkZHJlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIC8qIFRoZSBwaWNrIGZpcnN0IGxvYWQgYmFsYW5jZXIgZG9lcyBub3QgaGF2ZSBhIGNvbm5lY3Rpb24gYmFja29mZiwgc28gdGhpc1xuICAgICAgICAgKiBkb2VzIG5vdGhpbmcgKi9cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ3VycmVudFBpY2soKTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jZXIgPSBQaWNrRmlyc3RMb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAoMCwgbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSkoVFlQRV9OQU1FLCBQaWNrRmlyc3RMb2FkQmFsYW5jZXIsIFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcpO1xuICAgICgwLCBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSkoVFlQRV9OQU1FKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItcGljay1maXJzdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIlBpY2tGaXJzdExvYWRCYWxhbmNlciIsInNodWZmbGVkIiwiUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyIsImxvYWRfYmFsYW5jZXJfMSIsInJlcXVpcmUiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsInBpY2tlcl8xIiwibG9nZ2luZyIsImNvbnN0YW50c18xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIkNPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMiLCJjb25zdHJ1Y3RvciIsInNodWZmbGVBZGRyZXNzTGlzdCIsImdldExvYWRCYWxhbmNlck5hbWUiLCJ0b0pzb25PYmplY3QiLCJnZXRTaHVmZmxlQWRkcmVzc0xpc3QiLCJjcmVhdGVGcm9tSnNvbiIsIm9iaiIsIkVycm9yIiwiUGlja0ZpcnN0UGlja2VyIiwic3ViY2hhbm5lbCIsInBpY2siLCJwaWNrQXJncyIsInBpY2tSZXN1bHRUeXBlIiwiUGlja1Jlc3VsdFR5cGUiLCJDT01QTEVURSIsInN0YXR1cyIsIm9uQ2FsbFN0YXJ0ZWQiLCJvbkNhbGxFbmRlZCIsImxpc3QiLCJyZXN1bHQiLCJzbGljZSIsImkiLCJsZW5ndGgiLCJqIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwidGVtcCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwiY2hpbGRyZW4iLCJjdXJyZW50U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJjdXJyZW50U3ViY2hhbm5lbEluZGV4IiwiY3VycmVudFBpY2siLCJzdWJjaGFubmVsU3RhdGVMaXN0ZW5lciIsInByZXZpb3VzU3RhdGUiLCJuZXdTdGF0ZSIsImtlZXBhbGl2ZVRpbWUiLCJlcnJvck1lc3NhZ2UiLCJvblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZSIsInRyaWVkQWxsU3ViY2hhbm5lbHMiLCJzdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSIsInJlcXVlc3RlZFJlc29sdXRpb25TaW5jZUxhc3RVcGRhdGUiLCJsYXN0RXJyb3IiLCJsYXRlc3RBZGRyZXNzTGlzdCIsImNvbm5lY3Rpb25EZWxheVRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiYWxsQ2hpbGRyZW5IYXZlUmVwb3J0ZWRURiIsImV2ZXJ5IiwiY2hpbGQiLCJoYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUiLCJjYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSIsInVwZGF0ZVN0YXRlIiwiUkVBRFkiLCJRdWV1ZVBpY2tlciIsIlRSQU5TSUVOVF9GQUlMVVJFIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJkZXRhaWxzIiwiQ09OTkVDVElORyIsInJlcXVlc3RSZXJlc29sdXRpb24iLCJtYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUiLCJzdGFydENvbm5lY3RpbmciLCJyZW1vdmVDdXJyZW50UGljayIsInVucmVmIiwicmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInJlbW92ZUNoYW5uZWx6Q2hpbGQiLCJnZXRDaGFubmVselJlZiIsIl9hIiwicmVhbFN1YmNoYW5uZWxFcXVhbHMiLCJpbmRleCIsImVudHJpZXMiLCJwaWNrU3ViY2hhbm5lbCIsInN0YXJ0TmV4dFN1YmNoYW5uZWxDb25uZWN0aW5nIiwic3RhcnRJbmRleCIsInN1YmNoYW5uZWxTdGF0ZSIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwic3ViY2hhbm5lbEluZGV4IiwiX2IiLCJnZXRBZGRyZXNzIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2FsbCIsInJlZiIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZXNldFN1YmNoYW5uZWxMaXN0IiwicGlja2VyIiwiY29ubmVjdFRvQWRkcmVzc0xpc3QiLCJhZGRyZXNzTGlzdCIsIm5ld0NoaWxkcmVuTGlzdCIsIm1hcCIsImFkZHJlc3MiLCJjcmVhdGVTdWJjaGFubmVsIiwiYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInVwZGF0ZUFkZHJlc3NMaXN0IiwibGJDb25maWciLCJleGl0SWRsZSIsInJlc2V0QmFja29mZiIsImRlc3Ryb3kiLCJnZXRUeXBlTmFtZSIsInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSIsInJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"round_robin\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"round_robin\";\nclass RoundRobinLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor(){}\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {}\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new RoundRobinLoadBalancingConfig();\n    }\n}\nclass RoundRobinPicker {\n    constructor(subchannelList, nextIndex = 0){\n        this.subchannelList = subchannelList;\n        this.nextIndex = nextIndex;\n    }\n    pick(pickArgs) {\n        const pickedSubchannel = this.subchannelList[this.nextIndex];\n        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: pickedSubchannel,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */ peekNextSubchannel() {\n        return this.subchannelList[this.nextIndex];\n    }\n}\nclass RoundRobinLoadBalancer {\n    constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        this.subchannels = [];\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentReadyPicker = null;\n        this.lastError = null;\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage)=>{\n            this.calculateAndUpdateState();\n            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE || newState === connectivity_state_1.ConnectivityState.IDLE) {\n                if (errorMessage) {\n                    this.lastError = errorMessage;\n                }\n                this.channelControlHelper.requestReresolution();\n                subchannel.startConnecting();\n            }\n        };\n    }\n    countSubchannelsWithState(state) {\n        return this.subchannels.filter((subchannel)=>subchannel.getConnectivityState() === state).length;\n    }\n    calculateAndUpdateState() {\n        if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.READY) > 0) {\n            const readySubchannels = this.subchannels.filter((subchannel)=>subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n            let index = 0;\n            if (this.currentReadyPicker !== null) {\n                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n        } else if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        } else if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                details: `No connection established. Last error: ${this.lastError}`\n            }));\n        } else {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n            this.currentReadyPicker = picker;\n        } else {\n            this.currentReadyPicker = null;\n        }\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const subchannel of this.subchannels){\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.subchannels = [];\n    }\n    updateAddressList(addressList, lbConfig) {\n        this.resetSubchannelList();\n        trace(\"Connect to address list \" + addressList.map((address)=>(0, subchannel_address_1.subchannelAddressToString)(address)));\n        this.subchannels = addressList.map((address)=>this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels){\n            subchannel.ref();\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n            const subchannelState = subchannel.getConnectivityState();\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                subchannel.startConnecting();\n            }\n        }\n        this.calculateAndUpdateState();\n    }\n    exitIdle() {\n        for (const subchannel of this.subchannels){\n            subchannel.startConnecting();\n        }\n    }\n    resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */ }\n    destroy() {\n        this.resetSubchannelList();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-round-robin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQ3RELE1BQU1JLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1NLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmSixRQUFRRyxLQUFLLENBQUNGLFlBQVlJLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBLE1BQU1HLFlBQVk7QUFDbEIsTUFBTUM7SUFDRkMsc0JBQXNCO1FBQ2xCLE9BQU9GO0lBQ1g7SUFDQUcsYUFBYyxDQUFFO0lBQ2hCQyxlQUFlO1FBQ1gsT0FBTztZQUNILENBQUNKLFVBQVUsRUFBRSxDQUFDO1FBQ2xCO0lBQ0o7SUFDQSw4REFBOEQ7SUFDOUQsT0FBT0ssZUFBZUMsR0FBRyxFQUFFO1FBQ3ZCLE9BQU8sSUFBSUw7SUFDZjtBQUNKO0FBQ0EsTUFBTU07SUFDRkosWUFBWUssY0FBYyxFQUFFQyxZQUFZLENBQUMsQ0FBRTtRQUN2QyxJQUFJLENBQUNELGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0FDLEtBQUtDLFFBQVEsRUFBRTtRQUNYLE1BQU1DLG1CQUFtQixJQUFJLENBQUNK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b0IsQ0FBQ3lDLGdCQUFnQixDQUFDRixTQUFTLENBQUM7UUFDbkcsS0FBSyxNQUFNNUMsY0FBYyxJQUFJLENBQUNNLFdBQVcsQ0FBRTtZQUN2Q04sV0FBVytDLEdBQUc7WUFDZC9DLFdBQVdnRCw0QkFBNEIsQ0FBQyxJQUFJLENBQUNwQyx1QkFBdUI7WUFDcEUsSUFBSSxDQUFDUCxvQkFBb0IsQ0FBQzRDLGdCQUFnQixDQUFDakQsV0FBV3VDLGNBQWM7WUFDcEUsTUFBTVcsa0JBQWtCbEQsV0FBV3dCLG9CQUFvQjtZQUN2RCxJQUFJMEIsb0JBQW9CN0UscUJBQXFCbUMsaUJBQWlCLENBQUNDLElBQUksSUFDL0R5QyxvQkFBb0I3RSxxQkFBcUJtQyxpQkFBaUIsQ0FBQ1UsaUJBQWlCLEVBQUU7Z0JBQzlFbEIsV0FBV29CLGVBQWU7WUFDOUI7UUFDSjtRQUNBLElBQUksQ0FBQ0gsdUJBQXVCO0lBQ2hDO0lBQ0FrQyxXQUFXO1FBQ1AsS0FBSyxNQUFNbkQsY0FBYyxJQUFJLENBQUNNLFdBQVcsQ0FBRTtZQUN2Q04sV0FBV29CLGVBQWU7UUFDOUI7SUFDSjtJQUNBZ0MsZUFBZTtJQUNYO3dCQUNnQixHQUNwQjtJQUNBQyxVQUFVO1FBQ04sSUFBSSxDQUFDbEIsbUJBQW1CO0lBQzVCO0lBQ0FtQixjQUFjO1FBQ1YsT0FBT3ZFO0lBQ1g7QUFDSjtBQUNBaEIsOEJBQThCLEdBQUdHO0FBQ2pDLFNBQVNEO0lBQ0osSUFBR0UsZ0JBQWdCb0Ysd0JBQXdCLEVBQUV4RSxXQUFXYix3QkFBd0JjO0FBQ3JGO0FBQ0FqQixhQUFhLEdBQUdFLE9BQ2hCLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItcm91bmQtcm9iaW4uanM/OWVkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuUm91bmRSb2JpbkxvYWRCYWxhbmNlciA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncm91bmRfcm9iaW4nO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBUWVBFX05BTUUgPSAncm91bmRfcm9iaW4nO1xuY2xhc3MgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcge1xuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgdG9Kc29uT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW1RZUEVfTkFNRV06IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xuICAgIH1cbn1cbmNsYXNzIFJvdW5kUm9iaW5QaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHN1YmNoYW5uZWxMaXN0LCBuZXh0SW5kZXggPSAwKSB7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbExpc3QgPSBzdWJjaGFubmVsTGlzdDtcbiAgICAgICAgdGhpcy5uZXh0SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgY29uc3QgcGlja2VkU3ViY2hhbm5lbCA9IHRoaXMuc3ViY2hhbm5lbExpc3RbdGhpcy5uZXh0SW5kZXhdO1xuICAgICAgICB0aGlzLm5leHRJbmRleCA9ICh0aGlzLm5leHRJbmRleCArIDEpICUgdGhpcy5zdWJjaGFubmVsTGlzdC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaWNrUmVzdWx0VHlwZTogcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUsXG4gICAgICAgICAgICBzdWJjaGFubmVsOiBwaWNrZWRTdWJjaGFubmVsLFxuICAgICAgICAgICAgc3RhdHVzOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsU3RhcnRlZDogbnVsbCxcbiAgICAgICAgICAgIG9uQ2FsbEVuZGVkOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGF0IHRoZSBuZXh0IHN1YmNoYW5uZWwgcmV0dXJuZWQgd291bGQgYmUuIFVzZWQgYnkgdGhlIGxvYWRcbiAgICAgKiBiYWxhbmNlciBpbXBsZW1lbnRhdGlvbiB0byBwcmVzZXJ2ZSB0aGlzIHBhcnQgb2YgdGhlIHBpY2tlciBzdGF0ZSBpZlxuICAgICAqIHBvc3NpYmxlIHdoZW4gYSBzdWJjaGFubmVsIGNvbm5lY3RzIG9yIGRpc2Nvbm5lY3RzLlxuICAgICAqL1xuICAgIHBlZWtOZXh0U3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbExpc3RbdGhpcy5uZXh0SW5kZXhdO1xuICAgIH1cbn1cbmNsYXNzIFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBrZWVwYWxpdmVUaW1lLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUgfHxcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvdW50U3ViY2hhbm5lbHNXaXRoU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbHMuZmlsdGVyKHN1YmNoYW5uZWwgPT4gc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBzdGF0ZSkubGVuZ3RoO1xuICAgIH1cbiAgICBjYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY291bnRTdWJjaGFubmVsc1dpdGhTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkeVN1YmNoYW5uZWxzID0gdGhpcy5zdWJjaGFubmVscy5maWx0ZXIoc3ViY2hhbm5lbCA9PiBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVhZHlQaWNrZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHJlYWR5U3ViY2hhbm5lbHMuaW5kZXhPZih0aGlzLmN1cnJlbnRSZWFkeVBpY2tlci5wZWVrTmV4dFN1YmNoYW5uZWwoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSwgbmV3IFJvdW5kUm9iaW5QaWNrZXIocmVhZHlTdWJjaGFubmVscywgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvdW50U3ViY2hhbm5lbHNXaXRoU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb3VudFN1YmNoYW5uZWxzV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcih7IGRldGFpbHM6IGBObyBjb25uZWN0aW9uIGVzdGFibGlzaGVkLiBMYXN0IGVycm9yOiAke3RoaXMubGFzdEVycm9yfWAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpIHtcbiAgICAgICAgdHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpO1xuICAgIH1cbiAgICByZXNldFN1YmNoYW5uZWxMaXN0KCkge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgc3ViY2hhbm5lbC51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRyYWNlKCdDb25uZWN0IHRvIGFkZHJlc3MgbGlzdCAnICtcbiAgICAgICAgICAgIGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSkpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxzID0gYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4gdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKGFkZHJlc3MsIHt9KSk7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RhdGUgPSBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsIG9mIHRoaXMuc3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICAvKiBUaGUgcGljayBmaXJzdCBsb2FkIGJhbGFuY2VyIGRvZXMgbm90IGhhdmUgYSBjb25uZWN0aW9uIGJhY2tvZmYsIHNvIHRoaXNcbiAgICAgICAgICogZG9lcyBub3RoaW5nICovXG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgIH1cbiAgICBnZXRUeXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG59XG5leHBvcnRzLlJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIgPSBSb3VuZFJvYmluTG9hZEJhbGFuY2VyO1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIGxvYWRfYmFsYW5jZXJfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSwgUm91bmRSb2JpbkxvYWRCYWxhbmNlciwgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIlJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIiLCJsb2FkX2JhbGFuY2VyXzEiLCJyZXF1aXJlIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJwaWNrZXJfMSIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwibG9nZ2luZyIsImNvbnN0YW50c18xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIlJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnIiwiZ2V0TG9hZEJhbGFuY2VyTmFtZSIsImNvbnN0cnVjdG9yIiwidG9Kc29uT2JqZWN0IiwiY3JlYXRlRnJvbUpzb24iLCJvYmoiLCJSb3VuZFJvYmluUGlja2VyIiwic3ViY2hhbm5lbExpc3QiLCJuZXh0SW5kZXgiLCJwaWNrIiwicGlja0FyZ3MiLCJwaWNrZWRTdWJjaGFubmVsIiwibGVuZ3RoIiwicGlja1Jlc3VsdFR5cGUiLCJQaWNrUmVzdWx0VHlwZSIsIkNPTVBMRVRFIiwic3ViY2hhbm5lbCIsInN0YXR1cyIsIm9uQ2FsbFN0YXJ0ZWQiLCJvbkNhbGxFbmRlZCIsInBlZWtOZXh0U3ViY2hhbm5lbCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwic3ViY2hhbm5lbHMiLCJjdXJyZW50U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJjdXJyZW50UmVhZHlQaWNrZXIiLCJsYXN0RXJyb3IiLCJzdWJjaGFubmVsU3RhdGVMaXN0ZW5lciIsInByZXZpb3VzU3RhdGUiLCJuZXdTdGF0ZSIsImtlZXBhbGl2ZVRpbWUiLCJlcnJvck1lc3NhZ2UiLCJjYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSIsIlRSQU5TSUVOVF9GQUlMVVJFIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsInN0YXJ0Q29ubmVjdGluZyIsImNvdW50U3ViY2hhbm5lbHNXaXRoU3RhdGUiLCJzdGF0ZSIsImZpbHRlciIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwiUkVBRFkiLCJyZWFkeVN1YmNoYW5uZWxzIiwiaW5kZXgiLCJpbmRleE9mIiwidXBkYXRlU3RhdGUiLCJDT05ORUNUSU5HIiwiUXVldWVQaWNrZXIiLCJVbmF2YWlsYWJsZVBpY2tlciIsImRldGFpbHMiLCJwaWNrZXIiLCJyZXNldFN1YmNoYW5uZWxMaXN0IiwicmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInVucmVmIiwicmVtb3ZlQ2hhbm5lbHpDaGlsZCIsImdldENoYW5uZWx6UmVmIiwidXBkYXRlQWRkcmVzc0xpc3QiLCJhZGRyZXNzTGlzdCIsImxiQ29uZmlnIiwibWFwIiwiYWRkcmVzcyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJjcmVhdGVTdWJjaGFubmVsIiwicmVmIiwiYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsImFkZENoYW5uZWx6Q2hpbGQiLCJzdWJjaGFubmVsU3RhdGUiLCJleGl0SWRsZSIsInJlc2V0QmFja29mZiIsImRlc3Ryb3kiLCJnZXRUeXBlTmFtZSIsInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.isLoadBalancerNameRegistered = exports.createLoadBalancer = exports.registerDefaultLoadBalancerType = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = void 0;\n/**\n * Create a child ChannelControlHelper that overrides some methods of the\n * parent while letting others pass through to the parent unmodified. This\n * allows other code to create these children without needing to know about\n * all of the methods to be passed through.\n * @param parent\n * @param overrides\n */ function createChildChannelControlHelper(parent, overrides) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    return {\n        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),\n        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),\n        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),\n        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),\n        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent)\n    };\n}\nexports.createChildChannelControlHelper = createChildChannelControlHelper;\nconst registeredLoadBalancerTypes = {};\nlet defaultLoadBalancerType = null;\nfunction registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {\n    registeredLoadBalancerTypes[typeName] = {\n        LoadBalancer: loadBalancerType,\n        LoadBalancingConfig: loadBalancingConfigType\n    };\n}\nexports.registerLoadBalancerType = registerLoadBalancerType;\nfunction registerDefaultLoadBalancerType(typeName) {\n    defaultLoadBalancerType = typeName;\n}\nexports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;\nfunction createLoadBalancer(config, channelControlHelper) {\n    const typeName = config.getLoadBalancerName();\n    if (typeName in registeredLoadBalancerTypes) {\n        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);\n    } else {\n        return null;\n    }\n}\nexports.createLoadBalancer = createLoadBalancer;\nfunction isLoadBalancerNameRegistered(typeName) {\n    return typeName in registeredLoadBalancerTypes;\n}\nexports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;\nfunction getFirstUsableConfig(configs, fallbackTodefault = false) {\n    for (const config of configs){\n        if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {\n            return config;\n        }\n    }\n    if (fallbackTodefault) {\n        if (defaultLoadBalancerType) {\n            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\n        } else {\n            return null;\n        }\n    } else {\n        return null;\n    }\n}\nexports.getFirstUsableConfig = getFirstUsableConfig;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validateLoadBalancingConfig(obj) {\n    if (!(obj !== null && typeof obj === \"object\")) {\n        throw new Error(\"Load balancing config must be an object\");\n    }\n    const keys = Object.keys(obj);\n    if (keys.length !== 1) {\n        throw new Error(\"Provided load balancing config has multiple conflicting entries\");\n    }\n    const typeName = keys[0];\n    if (typeName in registeredLoadBalancerTypes) {\n        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);\n    } else {\n        throw new Error(`Unrecognized load balancing config name ${typeName}`);\n    }\n}\nexports.validateLoadBalancingConfig = validateLoadBalancingConfig; //# sourceMappingURL=load-balancer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUNBQW1DLEdBQUdBLDRCQUE0QixHQUFHQSxvQ0FBb0MsR0FBR0EsMEJBQTBCLEdBQUdBLHVDQUF1QyxHQUFHQSxnQ0FBZ0MsR0FBR0EsdUNBQXVDLEdBQUcsS0FBSztBQUNyUTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1EsZ0NBQWdDQyxNQUFNLEVBQUVDLFNBQVM7SUFDdEQsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7SUFDeEMsT0FBTztRQUNIQyxrQkFBa0IsQ0FBQ1QsS0FBSyxDQUFDRCxLQUFLRCxVQUFVVyxnQkFBZ0IsTUFBTSxRQUFRVixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdXLElBQUksQ0FBQ1osVUFBUyxNQUFPLFFBQVFFLE9BQU8sS0FBSyxJQUFJQSxLQUFLSCxPQUFPWSxnQkFBZ0IsQ0FBQ0MsSUFBSSxDQUFDYjtRQUNqTGMsYUFBYSxDQUFDVCxLQUFLLENBQUNELEtBQUtILFVBQVVhLFdBQVcsTUFBTSxRQUFRVixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdTLElBQUksQ0FBQ1osVUFBUyxNQUFPLFFBQVFJLE9BQU8sS0FBSyxJQUFJQSxLQUFLTCxPQUFPYyxXQUFXLENBQUNELElBQUksQ0FBQ2I7UUFDbEtlLHFCQUFxQixDQUFDUixLQUFLLENBQUNELEtBQUtMLFVBQVVjLG1CQUFtQixNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR08sSUFBSSxDQUFDWixVQUFTLE1BQU8sUUFBUU0sT0FBTyxLQUFLLElBQUlBLEtBQUtQLE9BQU9lLG1CQUFtQixDQUFDRixJQUFJLENBQUNiO1FBQzFMZ0Isa0JBQWtCLENBQUNQLEtBQUssQ0FBQ0QsS0FBS1AsVUFBVWUsZ0JBQWdCLE1BQU0sUUFBUVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSyxJQUFJLENBQUNaLFVBQVMsTUFBTyxRQUFRUSxPQUFPLEtBQUssSUFBSUEsS0FBS1QsT0FBT2dCLGdCQUFnQixDQUFDSCxJQUFJLENBQUNiO1FBQ2pMaUIscUJBQXFCLENBQUNOLEtBQUssQ0FBQ0QsS0FBS1QsVUFBVWdCLG1CQUFtQixNQUFNLFFBQVFQLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0csSUFBSSxDQUFDWixVQUFTLE1BQU8sUUFBUVUsT0FBTyxLQUFLLElBQUlBLEtBQUtYLE9BQU9pQixtQkFBbUIsQ0FBQ0osSUFBSSxDQUFDYjtJQUM5TDtBQUNKO0FBQ0FULHVDQUF1QyxHQUFHUTtBQUMxQyxNQUFNbUIsOEJBQThCLENBQUM7QUFDckMsSUFBSUMsMEJBQTBCO0FBQzlCLFNBQVNyQix5QkFBeUJzQixRQUFRLEVBQUVDLGdCQUFnQixFQUFFQyx1QkFBdUI7SUFDakZKLDJCQUEyQixDQUFDRSxTQUFTLEdBQUc7UUFDcENHLGNBQWNGO1FBQ2RHLHFCQUFxQkY7SUFDekI7QUFDSjtBQUNBL0IsZ0NBQWdDLEdBQUdPO0FBQ25DLFNBQVNELGdDQUFnQ3VCLFFBQVE7SUFDN0NELDBCQUEwQkM7QUFDOUI7QUFDQTdCLHVDQUF1QyxHQUFHTTtBQUMxQyxTQUFTRCxtQkFBbUI2QixNQUFNLEVBQUVDLG9CQUFvQjtJQUNwRCxNQUFNTixXQUFXSyxPQUFPRSxtQkFBbUI7SUFDM0MsSUFBSVAsWUFBWUYsNkJBQTZCO1FBQ3pDLE9BQU8sSUFBSUEsMkJBQTJCLENBQUNFLFNBQVMsQ0FBQ0csWUFBWSxDQUFDRztJQUNsRSxPQUNLO1FBQ0QsT0FBTztJQUNYO0FBQ0o7QUFDQW5DLDBCQUEwQixHQUFHSztBQUM3QixTQUFTRCw2QkFBNkJ5QixRQUFRO0lBQzFDLE9BQU9BLFlBQVlGO0FBQ3ZCO0FBQ0EzQixvQ0FBb0MsR0FBR0k7QUFDdkMsU0FBU0QscUJBQXFCa0MsT0FBTyxFQUFFQyxvQkFBb0IsS0FBSztJQUM1RCxLQUFLLE1BQU1KLFVBQVVHLFFBQVM7UUFDMUIsSUFBSUgsT0FBT0UsbUJBQW1CLE1BQU1ULDZCQUE2QjtZQUM3RCxPQUFPTztRQUNYO0lBQ0o7SUFDQSxJQUFJSSxtQkFBbUI7UUFDbkIsSUFBSVYseUJBQXlCO1lBQ3pCLE9BQU8sSUFBSUQsMkJBQTJCLENBQUNDLHdCQUF3QixDQUFDSyxtQkFBbUI7UUFDdkYsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKLE9BQ0s7UUFDRCxPQUFPO0lBQ1g7QUFDSjtBQUNBakMsNEJBQTRCLEdBQUdHO0FBQy9CLDhEQUE4RDtBQUM5RCxTQUFTRCw0QkFBNEJxQyxHQUFHO0lBQ3BDLElBQUksQ0FBRUEsQ0FBQUEsUUFBUSxRQUFRLE9BQU9BLFFBQVEsUUFBTyxHQUFJO1FBQzVDLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBLE1BQU1DLE9BQU8zQyxPQUFPMkMsSUFBSSxDQUFDRjtJQUN6QixJQUFJRSxLQUFLQyxNQUFNLEtBQUssR0FBRztRQUNuQixNQUFNLElBQUlGLE1BQU07SUFDcEI7SUFDQSxNQUFNWCxXQUFXWSxJQUFJLENBQUMsRUFBRTtJQUN4QixJQUFJWixZQUFZRiw2QkFBNkI7UUFDekMsT0FBT0EsMkJBQTJCLENBQUNFLFNBQVMsQ0FBQ0ksbUJBQW1CLENBQUNVLGNBQWMsQ0FBQ0osR0FBRyxDQUFDVixTQUFTO0lBQ2pHLE9BQ0s7UUFDRCxNQUFNLElBQUlXLE1BQU0sQ0FBQyx3Q0FBd0MsRUFBRVgsU0FBUyxDQUFDO0lBQ3pFO0FBQ0o7QUFDQTdCLG1DQUFtQyxHQUFHRSw2QkFDdEMseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcz8yN2NhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyA9IGV4cG9ydHMuZ2V0Rmlyc3RVc2FibGVDb25maWcgPSBleHBvcnRzLmlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQgPSBleHBvcnRzLmNyZWF0ZUxvYWRCYWxhbmNlciA9IGV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IGV4cG9ydHMucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlID0gZXhwb3J0cy5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyID0gdm9pZCAwO1xuLyoqXG4gKiBDcmVhdGUgYSBjaGlsZCBDaGFubmVsQ29udHJvbEhlbHBlciB0aGF0IG92ZXJyaWRlcyBzb21lIG1ldGhvZHMgb2YgdGhlXG4gKiBwYXJlbnQgd2hpbGUgbGV0dGluZyBvdGhlcnMgcGFzcyB0aHJvdWdoIHRvIHRoZSBwYXJlbnQgdW5tb2RpZmllZC4gVGhpc1xuICogYWxsb3dzIG90aGVyIGNvZGUgdG8gY3JlYXRlIHRoZXNlIGNoaWxkcmVuIHdpdGhvdXQgbmVlZGluZyB0byBrbm93IGFib3V0XG4gKiBhbGwgb2YgdGhlIG1ldGhvZHMgdG8gYmUgcGFzc2VkIHRocm91Z2guXG4gKiBAcGFyYW0gcGFyZW50XG4gKiBAcGFyYW0gb3ZlcnJpZGVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIocGFyZW50LCBvdmVycmlkZXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKF9iID0gKF9hID0gb3ZlcnJpZGVzLmNyZWF0ZVN1YmNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHBhcmVudC5jcmVhdGVTdWJjaGFubmVsLmJpbmQocGFyZW50KSxcbiAgICAgICAgdXBkYXRlU3RhdGU6IChfZCA9IChfYyA9IG92ZXJyaWRlcy51cGRhdGVTdGF0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogcGFyZW50LnVwZGF0ZVN0YXRlLmJpbmQocGFyZW50KSxcbiAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKF9mID0gKF9lID0gb3ZlcnJpZGVzLnJlcXVlc3RSZXJlc29sdXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHBhcmVudC5yZXF1ZXN0UmVyZXNvbHV0aW9uLmJpbmQocGFyZW50KSxcbiAgICAgICAgYWRkQ2hhbm5lbHpDaGlsZDogKF9oID0gKF9nID0gb3ZlcnJpZGVzLmFkZENoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHBhcmVudC5hZGRDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KSxcbiAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogKF9rID0gKF9qID0gb3ZlcnJpZGVzLnJlbW92ZUNoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHBhcmVudC5yZW1vdmVDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KSxcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyID0gY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcjtcbmNvbnN0IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcyA9IHt9O1xubGV0IGRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlID0gbnVsbDtcbmZ1bmN0aW9uIHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSh0eXBlTmFtZSwgbG9hZEJhbGFuY2VyVHlwZSwgbG9hZEJhbGFuY2luZ0NvbmZpZ1R5cGUpIHtcbiAgICByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbdHlwZU5hbWVdID0ge1xuICAgICAgICBMb2FkQmFsYW5jZXI6IGxvYWRCYWxhbmNlclR5cGUsXG4gICAgICAgIExvYWRCYWxhbmNpbmdDb25maWc6IGxvYWRCYWxhbmNpbmdDb25maWdUeXBlLFxuICAgIH07XG59XG5leHBvcnRzLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSA9IHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTtcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUodHlwZU5hbWUpIHtcbiAgICBkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IHR5cGVOYW1lO1xufVxuZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlID0gcmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZTtcbmZ1bmN0aW9uIGNyZWF0ZUxvYWRCYWxhbmNlcihjb25maWcsIGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgY29uc3QgdHlwZU5hbWUgPSBjb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpO1xuICAgIGlmICh0eXBlTmFtZSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbdHlwZU5hbWVdLkxvYWRCYWxhbmNlcihjaGFubmVsQ29udHJvbEhlbHBlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUxvYWRCYWxhbmNlciA9IGNyZWF0ZUxvYWRCYWxhbmNlcjtcbmZ1bmN0aW9uIGlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQodHlwZU5hbWUpIHtcbiAgICByZXR1cm4gdHlwZU5hbWUgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzO1xufVxuZXhwb3J0cy5pc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkID0gaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZDtcbmZ1bmN0aW9uIGdldEZpcnN0VXNhYmxlQ29uZmlnKGNvbmZpZ3MsIGZhbGxiYWNrVG9kZWZhdWx0ID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBjb25maWdzKSB7XG4gICAgICAgIGlmIChjb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmFsbGJhY2tUb2RlZmF1bHQpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1tkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZV0uTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Rmlyc3RVc2FibGVDb25maWcgPSBnZXRGaXJzdFVzYWJsZUNvbmZpZztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcob2JqKSB7XG4gICAgaWYgKCEob2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWQgYmFsYW5jaW5nIGNvbmZpZyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBsb2FkIGJhbGFuY2luZyBjb25maWcgaGFzIG11bHRpcGxlIGNvbmZsaWN0aW5nIGVudHJpZXMnKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZU5hbWUgPSBrZXlzWzBdO1xuICAgIGlmICh0eXBlTmFtZSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0uTG9hZEJhbGFuY2luZ0NvbmZpZy5jcmVhdGVGcm9tSnNvbihvYmpbdHlwZU5hbWVdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGxvYWQgYmFsYW5jaW5nIGNvbmZpZyBuYW1lICR7dHlwZU5hbWV9YCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcgPSB2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyIsImdldEZpcnN0VXNhYmxlQ29uZmlnIiwiaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCIsImNyZWF0ZUxvYWRCYWxhbmNlciIsInJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUiLCJyZWdpc3RlckxvYWRCYWxhbmNlclR5cGUiLCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyIiwicGFyZW50Iiwib3ZlcnJpZGVzIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9qIiwiX2siLCJjcmVhdGVTdWJjaGFubmVsIiwiYmluZCIsInVwZGF0ZVN0YXRlIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZW1vdmVDaGFubmVsekNoaWxkIiwicmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzIiwiZGVmYXVsdExvYWRCYWxhbmNlclR5cGUiLCJ0eXBlTmFtZSIsImxvYWRCYWxhbmNlclR5cGUiLCJsb2FkQmFsYW5jaW5nQ29uZmlnVHlwZSIsIkxvYWRCYWxhbmNlciIsIkxvYWRCYWxhbmNpbmdDb25maWciLCJjb25maWciLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImdldExvYWRCYWxhbmNlck5hbWUiLCJjb25maWdzIiwiZmFsbGJhY2tUb2RlZmF1bHQiLCJvYmoiLCJFcnJvciIsImtleXMiLCJsZW5ndGgiLCJjcmVhdGVGcm9tSnNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LoadBalancingCall = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst TRACER_NAME = \"load_balancing_call\";\nclass LoadBalancingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber){\n        var _a, _b;\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.metadata = null;\n        this.listener = null;\n        this.onCallEnded = null;\n        const splitPath = this.methodName.split(\"/\");\n        let serviceName = \"\";\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */ if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : \"localhost\";\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */ this.serviceUrl = `https://${hostname}/${serviceName}`;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callNumber + \"] \" + text);\n    }\n    outputStatus(status, progress) {\n        var _a, _b;\n        if (!this.ended) {\n            this.ended = true;\n            this.trace(\"ended with status: code=\" + status.code + ' details=\"' + status.details + '\"');\n            const finalStatus = Object.assign(Object.assign({}, status), {\n                progress\n            });\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);\n            (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);\n        }\n    }\n    doPick() {\n        var _a, _b;\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata) {\n            throw new Error(\"doPick called before start\");\n        }\n        this.trace(\"Pick called\");\n        const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);\n        const subchannelString = pickResult.subchannel ? \"(\" + pickResult.subchannel.getChannelzRef().id + \") \" + pickResult.subchannel.getAddress() : \"\" + pickResult.subchannel;\n        this.trace(\"Pick result: \" + picker_1.PickResultType[pickResult.pickResultType] + \" subchannel: \" + subchannelString + \" status: \" + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + \" \" + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n        switch(pickResult.pickResultType){\n            case picker_1.PickResultType.COMPLETE:\n                this.credentials.generateMetadata({\n                    service_url: this.serviceUrl\n                }).then((credsMetadata)=>{\n                    var _a, _b, _c;\n                    /* If this call was cancelled (e.g. by the deadline) before\n                     * metadata generation finished, we shouldn't do anything with\n                     * it. */ if (this.ended) {\n                        this.trace(\"Credentials metadata generation finished after call ended\");\n                        return;\n                    }\n                    const finalMetadata = this.metadata.clone();\n                    finalMetadata.merge(credsMetadata);\n                    if (finalMetadata.get(\"authorization\").length > 1) {\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: '\"authorization\" metadata cannot have multiple values',\n                            metadata: new metadata_1.Metadata()\n                        }, \"PROCESSED\");\n                    }\n                    if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n                        this.trace(\"Picked subchannel \" + subchannelString + \" has state \" + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] + \" after getting credentials metadata. Retrying pick\");\n                        this.doPick();\n                        return;\n                    }\n                    if (this.deadline !== Infinity) {\n                        finalMetadata.set(\"grpc-timeout\", (0, deadline_1.getDeadlineTimeoutString)(this.deadline));\n                    }\n                    try {\n                        this.child = pickResult.subchannel.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {\n                            onReceiveMetadata: (metadata)=>{\n                                this.trace(\"Received metadata\");\n                                this.listener.onReceiveMetadata(metadata);\n                            },\n                            onReceiveMessage: (message)=>{\n                                this.trace(\"Received message\");\n                                this.listener.onReceiveMessage(message);\n                            },\n                            onReceiveStatus: (status)=>{\n                                this.trace(\"Received status\");\n                                if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {\n                                    this.outputStatus(status, \"REFUSED\");\n                                } else {\n                                    this.outputStatus(status, \"PROCESSED\");\n                                }\n                            }\n                        });\n                    } catch (error) {\n                        this.trace(\"Failed to start call on picked subchannel \" + subchannelString + \" with error \" + error.message);\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: \"Failed to start HTTP/2 stream with error \" + error.message,\n                            metadata: new metadata_1.Metadata()\n                        }, \"NOT_STARTED\");\n                        return;\n                    }\n                    (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n                    this.onCallEnded = pickResult.onCallEnded;\n                    this.trace(\"Created child call [\" + this.child.getCallNumber() + \"]\");\n                    if (this.readPending) {\n                        this.child.startRead();\n                    }\n                    if (this.pendingMessage) {\n                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n                    }\n                    if (this.pendingHalfClose) {\n                        this.child.halfClose();\n                    }\n                }, (error)=>{\n                    // We assume the error code isn't 0 (Status.OK)\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === \"number\" ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                    this.outputStatus({\n                        code: code,\n                        details: details,\n                        metadata: new metadata_1.Metadata()\n                    }, \"PROCESSED\");\n                });\n                break;\n            case picker_1.PickResultType.DROP:\n                const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                setImmediate(()=>{\n                    this.outputStatus({\n                        code,\n                        details,\n                        metadata: pickResult.status.metadata\n                    }, \"DROP\");\n                });\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (this.metadata.getOptions().waitForReady) {\n                    this.channel.queueCallForPick(this);\n                } else {\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                    setImmediate(()=>{\n                        this.outputStatus({\n                            code,\n                            details,\n                            metadata: pickResult.status.metadata\n                        }, \"PROCESSED\");\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.channel.queueCallForPick(this);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({\n            code: status,\n            details: details,\n            metadata: new metadata_1.Metadata()\n        }, \"PROCESSED\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace(\"start called\");\n        this.listener = listener;\n        this.metadata = metadata;\n        this.doPick();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace(\"write() called with message of length \" + message.length);\n        if (this.child) {\n            this.child.sendMessageWithContext(context, message);\n        } else {\n            this.pendingMessage = {\n                context,\n                message\n            };\n        }\n    }\n    startRead() {\n        this.trace(\"startRead called\");\n        if (this.child) {\n            this.child.startRead();\n        } else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace(\"halfClose called\");\n        if (this.child) {\n            this.child.halfClose();\n        } else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        throw new Error(\"Method not implemented.\");\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n}\nexports.LoadBalancingCall = LoadBalancingCall; //# sourceMappingURL=load-balancing-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUcsS0FBSztBQUNqQyxNQUFNRyx1QkFBdUJDLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSSxXQUFXSixtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNSyxlQUFlTCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTyx5QkFBeUJQLG1CQUFPQSxDQUFDLG9HQUF3QjtBQUMvRCxNQUFNUSxRQUFRUixtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNUyxjQUFjO0FBQ3BCLE1BQU1YO0lBQ0ZZLFlBQVlDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLElBQUksRUFBRUMsV0FBVyxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsQ0FBRTtRQUNsRixJQUFJQyxJQUFJQztRQUNSLElBQUksQ0FBQ1IsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDRyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLFdBQVcs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QUFFO1lBQ1osSUFBSSxDQUFDQSxLQUFLLENBQUN5RSxTQUFTO1FBQ3hCLE9BQ0s7WUFDRCxJQUFJLENBQUN0RSxnQkFBZ0IsR0FBRztRQUM1QjtJQUNKO0lBQ0FvRixlQUFlNUYsV0FBVyxFQUFFO1FBQ3hCLE1BQU0sSUFBSWtDLE1BQU07SUFDcEI7SUFDQXdDLGdCQUFnQjtRQUNaLE9BQU8sSUFBSSxDQUFDeEUsVUFBVTtJQUMxQjtBQUNKO0FBQ0FyQix5QkFBeUIsR0FBR0UsbUJBQzVCLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jaW5nLWNhbGwuanM/MjhmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2FkQmFsYW5jaW5nQ2FsbCA9IHZvaWQgMDtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBkZWFkbGluZV8xID0gcmVxdWlyZShcIi4vZGVhZGxpbmVcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEgPSByZXF1aXJlKFwiLi9jb250cm9sLXBsYW5lLXN0YXR1c1wiKTtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnbG9hZF9iYWxhbmNpbmdfY2FsbCc7XG5jbGFzcyBMb2FkQmFsYW5jaW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgY2FsbENvbmZpZywgbWV0aG9kTmFtZSwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuY2FsbENvbmZpZyA9IGNhbGxDb25maWc7XG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWU7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IGRlYWRsaW5lO1xuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xuICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm9uQ2FsbEVuZGVkID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc3BsaXRQYXRoID0gdGhpcy5tZXRob2ROYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgIGxldCBzZXJ2aWNlTmFtZSA9ICcnO1xuICAgICAgICAvKiBUaGUgc3RhbmRhcmQgcGF0aCBmb3JtYXQgaXMgXCIve3NlcnZpY2VOYW1lfS97bWV0aG9kTmFtZX1cIiwgc28gaWYgd2Ugc3BsaXRcbiAgICAgICAgICogYnkgJy8nLCB0aGUgZmlyc3QgaXRlbSBzaG91bGQgYmUgZW1wdHkgYW5kIHRoZSBzZWNvbmQgc2hvdWxkIGJlIHRoZVxuICAgICAgICAgKiBzZXJ2aWNlIG5hbWUgKi9cbiAgICAgICAgaWYgKHNwbGl0UGF0aC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgc2VydmljZU5hbWUgPSBzcGxpdFBhdGhbMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSAoX2IgPSAoX2EgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRoaXMuaG9zdCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ob3N0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnbG9jYWxob3N0JztcbiAgICAgICAgLyogQ3VycmVudGx5LCBjYWxsIGNyZWRlbnRpYWxzIGFyZSBvbmx5IGFsbG93ZWQgb24gSFRUUFMgY29ubmVjdGlvbnMsIHNvIHdlXG4gICAgICAgICAqIGNhbiBhc3N1bWUgdGhhdCB0aGUgc2NoZW1lIGlzIFwiaHR0cHNcIiAqL1xuICAgICAgICB0aGlzLnNlcnZpY2VVcmwgPSBgaHR0cHM6Ly8ke2hvc3RuYW1lfS8ke3NlcnZpY2VOYW1lfWA7XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxOdW1iZXIgKyAnXSAnICsgdGV4dCk7XG4gICAgfVxuICAgIG91dHB1dFN0YXR1cyhzdGF0dXMsIHByb2dyZXNzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICBzdGF0dXMuY29kZSArXG4gICAgICAgICAgICAgICAgJyBkZXRhaWxzPVwiJyArXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgK1xuICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgICAgY29uc3QgZmluYWxTdGF0dXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXR1cyksIHsgcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlU3RhdHVzKGZpbmFsU3RhdHVzKTtcbiAgICAgICAgICAgIChfYiA9IHRoaXMub25DYWxsRW5kZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIGZpbmFsU3RhdHVzLmNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvUGljaygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9QaWNrIGNhbGxlZCBiZWZvcmUgc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdQaWNrIGNhbGxlZCcpO1xuICAgICAgICBjb25zdCBwaWNrUmVzdWx0ID0gdGhpcy5jaGFubmVsLmRvUGljayh0aGlzLm1ldGFkYXRhLCB0aGlzLmNhbGxDb25maWcucGlja0luZm9ybWF0aW9uKTtcbiAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFN0cmluZyA9IHBpY2tSZXN1bHQuc3ViY2hhbm5lbFxuICAgICAgICAgICAgPyAnKCcgK1xuICAgICAgICAgICAgICAgIHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpLmlkICtcbiAgICAgICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgICAgICBwaWNrUmVzdWx0LnN1YmNoYW5uZWwuZ2V0QWRkcmVzcygpXG4gICAgICAgICAgICA6ICcnICsgcGlja1Jlc3VsdC5zdWJjaGFubmVsO1xuICAgICAgICB0aGlzLnRyYWNlKCdQaWNrIHJlc3VsdDogJyArXG4gICAgICAgICAgICBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZVtwaWNrUmVzdWx0LnBpY2tSZXN1bHRUeXBlXSArXG4gICAgICAgICAgICAnIHN1YmNoYW5uZWw6ICcgK1xuICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAnIHN0YXR1czogJyArXG4gICAgICAgICAgICAoKF9hID0gcGlja1Jlc3VsdC5zdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgKChfYiA9IHBpY2tSZXN1bHQuc3RhdHVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGV0YWlscykpO1xuICAgICAgICBzd2l0Y2ggKHBpY2tSZXN1bHQucGlja1Jlc3VsdFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEU6XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFsc1xuICAgICAgICAgICAgICAgICAgICAuZ2VuZXJhdGVNZXRhZGF0YSh7IHNlcnZpY2VfdXJsOiB0aGlzLnNlcnZpY2VVcmwgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oY3JlZHNNZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGlzIGNhbGwgd2FzIGNhbmNlbGxlZCAoZS5nLiBieSB0aGUgZGVhZGxpbmUpIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgKiBtZXRhZGF0YSBnZW5lcmF0aW9uIGZpbmlzaGVkLCB3ZSBzaG91bGRuJ3QgZG8gYW55dGhpbmcgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgKiBpdC4gKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0NyZWRlbnRpYWxzIG1ldGFkYXRhIGdlbmVyYXRpb24gZmluaXNoZWQgYWZ0ZXIgY2FsbCBlbmRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsTWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWV0YWRhdGEubWVyZ2UoY3JlZHNNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE1ldGFkYXRhLmdldCgnYXV0aG9yaXphdGlvbicpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ1wiYXV0aG9yaXphdGlvblwiIG1ldGFkYXRhIGNhbm5vdCBoYXZlIG11bHRpcGxlIHZhbHVlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1BpY2tlZCBzdWJjaGFubmVsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaGFzIHN0YXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3BpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBhZnRlciBnZXR0aW5nIGNyZWRlbnRpYWxzIG1ldGFkYXRhLiBSZXRyeWluZyBwaWNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvUGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYWRsaW5lICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxNZXRhZGF0YS5zZXQoJ2dycGMtdGltZW91dCcsICgwLCBkZWFkbGluZV8xLmdldERlYWRsaW5lVGltZW91dFN0cmluZykodGhpcy5kZWFkbGluZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkID0gcGlja1Jlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJjaGFubmVsLmdldFJlYWxTdWJjaGFubmVsKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3JlYXRlQ2FsbChmaW5hbE1ldGFkYXRhLCB0aGlzLmhvc3QsIHRoaXMubWV0aG9kTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1ldGFkYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzdGF0dXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5yc3RDb2RlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfUkVGVVNFRF9TVFJFQU0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cywgJ1JFRlVTRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cywgJ1BST0NFU1NFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIHN0YXJ0IGNhbGwgb24gcGlja2VkIHN1YmNoYW5uZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnRmFpbGVkIHRvIHN0YXJ0IEhUVFAvMiBzdHJlYW0gd2l0aCBlcnJvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICdOT1RfU1RBUlRFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbENvbmZpZykub25Db21taXR0ZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgICAgICAgICAgKF9jID0gcGlja1Jlc3VsdC5vbkNhbGxTdGFydGVkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChwaWNrUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNhbGxFbmRlZCA9IHBpY2tSZXN1bHQub25DYWxsRW5kZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0NyZWF0ZWQgY2hpbGQgY2FsbCBbJyArIHRoaXMuY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZFBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh0aGlzLnBlbmRpbmdNZXNzYWdlLmNvbnRleHQsIHRoaXMucGVuZGluZ01lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhlIGVycm9yIGNvZGUgaXNuJ3QgMCAoU3RhdHVzLk9LKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkodHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInID8gZXJyb3IuY29kZSA6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLCBgR2V0dGluZyBtZXRhZGF0YSBmcm9tIHBsdWdpbiBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICB9LCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkRST1A6XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKHBpY2tSZXN1bHQuc3RhdHVzLmNvZGUsIHBpY2tSZXN1bHQuc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHsgY29kZSwgZGV0YWlscywgbWV0YWRhdGE6IHBpY2tSZXN1bHQuc3RhdHVzLm1ldGFkYXRhIH0sICdEUk9QJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLlRSQU5TSUVOVF9GQUlMVVJFOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvclBpY2sodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkocGlja1Jlc3VsdC5zdGF0dXMuY29kZSwgcGlja1Jlc3VsdC5zdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7IGNvZGUsIGRldGFpbHMsIG1ldGFkYXRhOiBwaWNrUmVzdWx0LnN0YXR1cy5tZXRhZGF0YSB9LCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuUVVFVUU6XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvclBpY2sodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoeyBjb2RlOiBzdGF0dXMsIGRldGFpbHM6IGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0sICdQUk9DRVNTRUQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY2hhbm5lbC5nZXRUYXJnZXQoKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5kb1BpY2soKTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3dyaXRlKCkgY2FsbGVkIHdpdGggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSB7IGNvbnRleHQsIG1lc3NhZ2UgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0UmVhZCBjYWxsZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2hhbGZDbG9zZSBjYWxsZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcbiAgICB9XG59XG5leHBvcnRzLkxvYWRCYWxhbmNpbmdDYWxsID0gTG9hZEJhbGFuY2luZ0NhbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2luZy1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxvYWRCYWxhbmNpbmdDYWxsIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJkZWFkbGluZV8xIiwibWV0YWRhdGFfMSIsInBpY2tlcl8xIiwidXJpX3BhcnNlcl8xIiwibG9nZ2luZyIsImNvbnRyb2xfcGxhbmVfc3RhdHVzXzEiLCJodHRwMiIsIlRSQUNFUl9OQU1FIiwiY29uc3RydWN0b3IiLCJjaGFubmVsIiwiY2FsbENvbmZpZyIsIm1ldGhvZE5hbWUiLCJob3N0IiwiY3JlZGVudGlhbHMiLCJkZWFkbGluZSIsImNhbGxOdW1iZXIiLCJfYSIsIl9iIiwiY2hpbGQiLCJyZWFkUGVuZGluZyIsInBlbmRpbmdNZXNzYWdlIiwicGVuZGluZ0hhbGZDbG9zZSIsImVuZGVkIiwibWV0YWRhdGEiLCJsaXN0ZW5lciIsIm9uQ2FsbEVuZGVkIiwic3BsaXRQYXRoIiwic3BsaXQiLCJzZXJ2aWNlTmFtZSIsImxlbmd0aCIsImhvc3RuYW1lIiwic3BsaXRIb3N0UG9ydCIsInNlcnZpY2VVcmwiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIm91dHB1dFN0YXR1cyIsInN0YXR1cyIsInByb2dyZXNzIiwiY29kZSIsImRldGFpbHMiLCJmaW5hbFN0YXR1cyIsImFzc2lnbiIsIm9uUmVjZWl2ZVN0YXR1cyIsImNhbGwiLCJkb1BpY2siLCJFcnJvciIsInBpY2tSZXN1bHQiLCJwaWNrSW5mb3JtYXRpb24iLCJzdWJjaGFubmVsU3RyaW5nIiwic3ViY2hhbm5lbCIsImdldENoYW5uZWx6UmVmIiwiaWQiLCJnZXRBZGRyZXNzIiwiUGlja1Jlc3VsdFR5cGUiLCJwaWNrUmVzdWx0VHlwZSIsIkNPTVBMRVRFIiwiZ2VuZXJhdGVNZXRhZGF0YSIsInNlcnZpY2VfdXJsIiwidGhlbiIsImNyZWRzTWV0YWRhdGEiLCJfYyIsImZpbmFsTWV0YWRhdGEiLCJjbG9uZSIsIm1lcmdlIiwiZ2V0IiwiU3RhdHVzIiwiSU5URVJOQUwiLCJNZXRhZGF0YSIsImdldENvbm5lY3Rpdml0eVN0YXRlIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJSRUFEWSIsIkluZmluaXR5Iiwic2V0IiwiZ2V0RGVhZGxpbmVUaW1lb3V0U3RyaW5nIiwiZ2V0UmVhbFN1YmNoYW5uZWwiLCJjcmVhdGVDYWxsIiwib25SZWNlaXZlTWV0YWRhdGEiLCJvblJlY2VpdmVNZXNzYWdlIiwibWVzc2FnZSIsInJzdENvZGUiLCJjb25zdGFudHMiLCJOR0hUVFAyX1JFRlVTRURfU1RSRUFNIiwiZXJyb3IiLCJvbkNvbW1pdHRlZCIsIm9uQ2FsbFN0YXJ0ZWQiLCJnZXRDYWxsTnVtYmVyIiwic3RhcnRSZWFkIiwic2VuZE1lc3NhZ2VXaXRoQ29udGV4dCIsImNvbnRleHQiLCJoYWxmQ2xvc2UiLCJyZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUiLCJVTktOT1dOIiwiRFJPUCIsInNldEltbWVkaWF0ZSIsIlRSQU5TSUVOVF9GQUlMVVJFIiwiZ2V0T3B0aW9ucyIsIndhaXRGb3JSZWFkeSIsInF1ZXVlQ2FsbEZvclBpY2siLCJRVUVVRSIsImNhbmNlbFdpdGhTdGF0dXMiLCJnZXRQZWVyIiwiZ2V0VGFyZ2V0Iiwic3RhcnQiLCJzZXRDcmVkZW50aWFscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var _a, _b, _c, _d;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst process_1 = __webpack_require__(/*! process */ \"process\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst DEFAULT_LOGGER = {\n    error: (message, ...optionalParams)=>{\n        console.error(\"E \" + message, ...optionalParams);\n    },\n    info: (message, ...optionalParams)=>{\n        console.error(\"I \" + message, ...optionalParams);\n    },\n    debug: (message, ...optionalParams)=>{\n        console.error(\"D \" + message, ...optionalParams);\n    }\n};\nlet _logger = DEFAULT_LOGGER;\nlet _logVerbosity = constants_1.LogVerbosity.ERROR;\nconst verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : \"\";\nswitch(verbosityString.toUpperCase()){\n    case \"DEBUG\":\n        _logVerbosity = constants_1.LogVerbosity.DEBUG;\n        break;\n    case \"INFO\":\n        _logVerbosity = constants_1.LogVerbosity.INFO;\n        break;\n    case \"ERROR\":\n        _logVerbosity = constants_1.LogVerbosity.ERROR;\n        break;\n    case \"NONE\":\n        _logVerbosity = constants_1.LogVerbosity.NONE;\n        break;\n    default:\n}\nconst getLogger = ()=>{\n    return _logger;\n};\nexports.getLogger = getLogger;\nconst setLogger = (logger)=>{\n    _logger = logger;\n};\nexports.setLogger = setLogger;\nconst setLoggerVerbosity = (verbosity)=>{\n    _logVerbosity = verbosity;\n};\nexports.setLoggerVerbosity = setLoggerVerbosity;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst log = (severity, ...args)=>{\n    let logFunction;\n    if (severity >= _logVerbosity) {\n        switch(severity){\n            case constants_1.LogVerbosity.DEBUG:\n                logFunction = _logger.debug;\n                break;\n            case constants_1.LogVerbosity.INFO:\n                logFunction = _logger.info;\n                break;\n            case constants_1.LogVerbosity.ERROR:\n                logFunction = _logger.error;\n                break;\n        }\n        /* Fall back to _logger.error when other methods are not available for\n         * compatiblity with older behavior that always logged to _logger.error */ if (!logFunction) {\n            logFunction = _logger.error;\n        }\n        if (logFunction) {\n            logFunction.bind(_logger)(...args);\n        }\n    }\n};\nexports.log = log;\nconst tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : \"\";\nconst enabledTracers = new Set();\nconst disabledTracers = new Set();\nfor (const tracerName of tracersString.split(\",\")){\n    if (tracerName.startsWith(\"-\")) {\n        disabledTracers.add(tracerName.substring(1));\n    } else {\n        enabledTracers.add(tracerName);\n    }\n}\nconst allEnabled = enabledTracers.has(\"all\");\nfunction trace(severity, tracer, text) {\n    if (isTracerEnabled(tracer)) {\n        (0, exports.log)(severity, new Date().toISOString() + \" | v\" + clientVersion + \" \" + process_1.pid + \" | \" + tracer + \" | \" + text);\n    }\n}\nexports.trace = trace;\nfunction isTracerEnabled(tracer) {\n    return !disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer));\n}\nexports.isTracerEnabled = isTracerEnabled; //# sourceMappingURL=logging.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxJQUFJQSxJQUFJQyxJQUFJQyxJQUFJQztBQUNoQkMsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSxhQUFhLEdBQUdBLFdBQVcsR0FBR0EsMEJBQTBCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQ2xJLE1BQU1RLGNBQWNDLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1DLFlBQVlELG1CQUFPQSxDQUFDLHdCQUFTO0FBQ25DLE1BQU1FLGdCQUFnQkYsMEdBQXFDO0FBQzNELE1BQU1JLGlCQUFpQjtJQUNuQkMsT0FBTyxDQUFDQyxTQUFTLEdBQUdDO1FBQ2hCQyxRQUFRSCxLQUFLLENBQUMsT0FBT0MsWUFBWUM7SUFDckM7SUFDQUUsTUFBTSxDQUFDSCxTQUFTLEdBQUdDO1FBQ2ZDLFFBQVFILEtBQUssQ0FBQyxPQUFPQyxZQUFZQztJQUNyQztJQUNBRyxPQUFPLENBQUNKLFNBQVMsR0FBR0M7UUFDaEJDLFFBQVFILEtBQUssQ0FBQyxPQUFPQyxZQUFZQztJQUNyQztBQUNKO0FBQ0EsSUFBSUksVUFBVVA7QUFDZCxJQUFJUSxnQkFBZ0JiLFlBQVljLFlBQVksQ0FBQ0MsS0FBSztBQUNsRCxNQUFNQyxrQkFBa0IsQ0FBQzdCLEtBQUssQ0FBQ0QsS0FBSytCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLE1BQU0sUUFBUWpDLE9BQU8sS0FBSyxJQUFJQSxLQUFLK0IsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRSxjQUFjLE1BQU0sUUFBUWpDLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0FBQ25LLE9BQVE2QixnQkFBZ0JLLFdBQVc7SUFDL0IsS0FBSztRQUNEUixnQkFBZ0JiLFlBQVljLFlBQVksQ0FBQ1EsS0FBSztRQUM5QztJQUNKLEtBQUs7UUFDRFQsZ0JBQWdCYixZQUFZYyxZQUFZLENBQUNTLElBQUk7UUFDN0M7SUFDSixLQUFLO1FBQ0RWLGdCQUFnQmIsWUFBWWMsWUFBWSxDQUFDQyxLQUFLO1FBQzlDO0lBQ0osS0FBSztRQUNERixnQkFBZ0JiLFlBQVljLFlBQVksQ0FBQ1UsSUFBSTtRQUM3QztJQUNKO0FBRUo7QUFDQSxNQUFNekIsWUFBWTtJQUNkLE9BQU9hO0FBQ1g7QUFDQXBCLGlCQUFpQixHQUFHTztBQUNwQixNQUFNRCxZQUFZLENBQUMyQjtJQUNmYixVQUFVYTtBQUNkO0FBQ0FqQyxpQkFBaUIsR0FBR007QUFDcEIsTUFBTUQscUJBQXFCLENBQUM2QjtJQUN4QmIsZ0JBQWdCYTtBQUNwQjtBQUNBbEMsMEJBQTBCLEdBQUdLO0FBQzdCLDhEQUE4RDtBQUM5RCxNQUFNRCxNQUFNLENBQUMrQixVQUFVLEdBQUdDO0lBQ3RCLElBQUlDO0lBQ0osSUFBSUYsWUFBWWQsZUFBZTtRQUMzQixPQUFRYztZQUNKLEtBQUszQixZQUFZYyxZQUFZLENBQUNRLEtBQUs7Z0JBQy9CTyxjQUFjakIsUUFBUUQsS0FBSztnQkFDM0I7WUFDSixLQUFLWCxZQUFZYyxZQUFZLENBQUNTLElBQUk7Z0JBQzlCTSxjQUFjakIsUUFBUUYsSUFBSTtnQkFDMUI7WUFDSixLQUFLVixZQUFZYyxZQUFZLENBQUNDLEtBQUs7Z0JBQy9CYyxjQUFjakIsUUFBUU4sS0FBSztnQkFDM0I7UUFDUjtRQUNBO2dGQUN3RSxHQUN4RSxJQUFJLENBQUN1QixhQUFhO1lBQ2RBLGNBQWNqQixRQUFRTixLQUFLO1FBQy9CO1FBQ0EsSUFBSXVCLGFBQWE7WUFDYkEsWUFBWUMsSUFBSSxDQUFDbEIsWUFBWWdCO1FBQ2pDO0lBQ0o7QUFDSjtBQUNBcEMsV0FBVyxHQUFHSTtBQUNkLE1BQU1tQyxnQkFBZ0IsQ0FBQzFDLEtBQUssQ0FBQ0QsS0FBSzZCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ2MsZUFBZSxNQUFNLFFBQVE1QyxPQUFPLEtBQUssSUFBSUEsS0FBSzZCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ2UsVUFBVSxNQUFNLFFBQVE1QyxPQUFPLEtBQUssSUFBSUEsS0FBSztBQUN6SixNQUFNNkMsaUJBQWlCLElBQUlDO0FBQzNCLE1BQU1DLGtCQUFrQixJQUFJRDtBQUM1QixLQUFLLE1BQU1FLGNBQWNOLGNBQWNPLEtBQUssQ0FBQyxLQUFNO0lBQy9DLElBQUlELFdBQVdFLFVBQVUsQ0FBQyxNQUFNO1FBQzVCSCxnQkFBZ0JJLEdBQUcsQ0FBQ0gsV0FBV0ksU0FBUyxDQUFDO0lBQzdDLE9BQ0s7UUFDRFAsZUFBZU0sR0FBRyxDQUFDSDtJQUN2QjtBQUNKO0FBQ0EsTUFBTUssYUFBYVIsZUFBZVMsR0FBRyxDQUFDO0FBQ3RDLFNBQVNoRCxNQUFNZ0MsUUFBUSxFQUFFaUIsTUFBTSxFQUFFQyxJQUFJO0lBQ2pDLElBQUluRCxnQkFBZ0JrRCxTQUFTO1FBQ3hCLElBQUdwRCxRQUFRSSxHQUFHLEVBQUUrQixVQUFVLElBQUltQixPQUFPQyxXQUFXLEtBQUssU0FBUzVDLGdCQUFnQixNQUFNRCxVQUFVOEMsR0FBRyxHQUFHLFFBQVFKLFNBQVMsUUFBUUM7SUFDbEk7QUFDSjtBQUNBckQsYUFBYSxHQUFHRztBQUNoQixTQUFTRCxnQkFBZ0JrRCxNQUFNO0lBQzNCLE9BQVEsQ0FBQ1IsZ0JBQWdCTyxHQUFHLENBQUNDLFdBQVlGLENBQUFBLGNBQWNSLGVBQWVTLEdBQUcsQ0FBQ0MsT0FBTTtBQUNwRjtBQUNBcEQsdUJBQXVCLEdBQUdFLGlCQUMxQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2dnaW5nLmpzPzQ1M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbnZhciBfYSwgX2IsIF9jLCBfZDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNUcmFjZXJFbmFibGVkID0gZXhwb3J0cy50cmFjZSA9IGV4cG9ydHMubG9nID0gZXhwb3J0cy5zZXRMb2dnZXJWZXJib3NpdHkgPSBleHBvcnRzLnNldExvZ2dlciA9IGV4cG9ydHMuZ2V0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBwcm9jZXNzXzEgPSByZXF1aXJlKFwicHJvY2Vzc1wiKTtcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuY29uc3QgREVGQVVMVF9MT0dHRVIgPSB7XG4gICAgZXJyb3I6IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfSxcbiAgICBpbmZvOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSSAnICsgbWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgIH0sXG4gICAgZGVidWc6IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdEICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfSxcbn07XG5sZXQgX2xvZ2dlciA9IERFRkFVTFRfTE9HR0VSO1xubGV0IF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1I7XG5jb25zdCB2ZXJib3NpdHlTdHJpbmcgPSAoX2IgPSAoX2EgPSBwcm9jZXNzLmVudi5HUlBDX05PREVfVkVSQk9TSVRZKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwcm9jZXNzLmVudi5HUlBDX1ZFUkJPU0lUWSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG5zd2l0Y2ggKHZlcmJvc2l0eVN0cmluZy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgY2FzZSAnREVCVUcnOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdJTkZPJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdFUlJPUic6XG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1I7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ05PTkUnOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5Lk5PTkU7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgLy8gSWdub3JlIGFueSBvdGhlciB2YWx1ZXNcbn1cbmNvbnN0IGdldExvZ2dlciA9ICgpID0+IHtcbiAgICByZXR1cm4gX2xvZ2dlcjtcbn07XG5leHBvcnRzLmdldExvZ2dlciA9IGdldExvZ2dlcjtcbmNvbnN0IHNldExvZ2dlciA9IChsb2dnZXIpID0+IHtcbiAgICBfbG9nZ2VyID0gbG9nZ2VyO1xufTtcbmV4cG9ydHMuc2V0TG9nZ2VyID0gc2V0TG9nZ2VyO1xuY29uc3Qgc2V0TG9nZ2VyVmVyYm9zaXR5ID0gKHZlcmJvc2l0eSkgPT4ge1xuICAgIF9sb2dWZXJib3NpdHkgPSB2ZXJib3NpdHk7XG59O1xuZXhwb3J0cy5zZXRMb2dnZXJWZXJib3NpdHkgPSBzZXRMb2dnZXJWZXJib3NpdHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgbG9nID0gKHNldmVyaXR5LCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IGxvZ0Z1bmN0aW9uO1xuICAgIGlmIChzZXZlcml0eSA+PSBfbG9nVmVyYm9zaXR5KSB7XG4gICAgICAgIHN3aXRjaCAoc2V2ZXJpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHOlxuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5kZWJ1ZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk86XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmluZm87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUjpcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuZXJyb3I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyogRmFsbCBiYWNrIHRvIF9sb2dnZXIuZXJyb3Igd2hlbiBvdGhlciBtZXRob2RzIGFyZSBub3QgYXZhaWxhYmxlIGZvclxuICAgICAgICAgKiBjb21wYXRpYmxpdHkgd2l0aCBvbGRlciBiZWhhdmlvciB0aGF0IGFsd2F5cyBsb2dnZWQgdG8gX2xvZ2dlci5lcnJvciAqL1xuICAgICAgICBpZiAoIWxvZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICBsb2dGdW5jdGlvbi5iaW5kKF9sb2dnZXIpKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMubG9nID0gbG9nO1xuY29uc3QgdHJhY2Vyc1N0cmluZyA9IChfZCA9IChfYyA9IHByb2Nlc3MuZW52LkdSUENfTk9ERV9UUkFDRSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogcHJvY2Vzcy5lbnYuR1JQQ19UUkFDRSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJyc7XG5jb25zdCBlbmFibGVkVHJhY2VycyA9IG5ldyBTZXQoKTtcbmNvbnN0IGRpc2FibGVkVHJhY2VycyA9IG5ldyBTZXQoKTtcbmZvciAoY29uc3QgdHJhY2VyTmFtZSBvZiB0cmFjZXJzU3RyaW5nLnNwbGl0KCcsJykpIHtcbiAgICBpZiAodHJhY2VyTmFtZS5zdGFydHNXaXRoKCctJykpIHtcbiAgICAgICAgZGlzYWJsZWRUcmFjZXJzLmFkZCh0cmFjZXJOYW1lLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbmFibGVkVHJhY2Vycy5hZGQodHJhY2VyTmFtZSk7XG4gICAgfVxufVxuY29uc3QgYWxsRW5hYmxlZCA9IGVuYWJsZWRUcmFjZXJzLmhhcygnYWxsJyk7XG5mdW5jdGlvbiB0cmFjZShzZXZlcml0eSwgdHJhY2VyLCB0ZXh0KSB7XG4gICAgaWYgKGlzVHJhY2VyRW5hYmxlZCh0cmFjZXIpKSB7XG4gICAgICAgICgwLCBleHBvcnRzLmxvZykoc2V2ZXJpdHksIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArICcgfCB2JyArIGNsaWVudFZlcnNpb24gKyAnICcgKyBwcm9jZXNzXzEucGlkICsgJyB8ICcgKyB0cmFjZXIgKyAnIHwgJyArIHRleHQpO1xuICAgIH1cbn1cbmV4cG9ydHMudHJhY2UgPSB0cmFjZTtcbmZ1bmN0aW9uIGlzVHJhY2VyRW5hYmxlZCh0cmFjZXIpIHtcbiAgICByZXR1cm4gKCFkaXNhYmxlZFRyYWNlcnMuaGFzKHRyYWNlcikgJiYgKGFsbEVuYWJsZWQgfHwgZW5hYmxlZFRyYWNlcnMuaGFzKHRyYWNlcikpKTtcbn1cbmV4cG9ydHMuaXNUcmFjZXJFbmFibGVkID0gaXNUcmFjZXJFbmFibGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5qcy5tYXAiXSwibmFtZXMiOlsiX2EiLCJfYiIsIl9jIiwiX2QiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzVHJhY2VyRW5hYmxlZCIsInRyYWNlIiwibG9nIiwic2V0TG9nZ2VyVmVyYm9zaXR5Iiwic2V0TG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiY29uc3RhbnRzXzEiLCJyZXF1aXJlIiwicHJvY2Vzc18xIiwiY2xpZW50VmVyc2lvbiIsInZlcnNpb24iLCJERUZBVUxUX0xPR0dFUiIsImVycm9yIiwibWVzc2FnZSIsIm9wdGlvbmFsUGFyYW1zIiwiY29uc29sZSIsImluZm8iLCJkZWJ1ZyIsIl9sb2dnZXIiLCJfbG9nVmVyYm9zaXR5IiwiTG9nVmVyYm9zaXR5IiwiRVJST1IiLCJ2ZXJib3NpdHlTdHJpbmciLCJwcm9jZXNzIiwiZW52IiwiR1JQQ19OT0RFX1ZFUkJPU0lUWSIsIkdSUENfVkVSQk9TSVRZIiwidG9VcHBlckNhc2UiLCJERUJVRyIsIklORk8iLCJOT05FIiwibG9nZ2VyIiwidmVyYm9zaXR5Iiwic2V2ZXJpdHkiLCJhcmdzIiwibG9nRnVuY3Rpb24iLCJiaW5kIiwidHJhY2Vyc1N0cmluZyIsIkdSUENfTk9ERV9UUkFDRSIsIkdSUENfVFJBQ0UiLCJlbmFibGVkVHJhY2VycyIsIlNldCIsImRpc2FibGVkVHJhY2VycyIsInRyYWNlck5hbWUiLCJzcGxpdCIsInN0YXJ0c1dpdGgiLCJhZGQiLCJzdWJzdHJpbmciLCJhbGxFbmFibGVkIiwiaGFzIiwidHJhY2VyIiwidGV4dCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInBpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/make-client.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.loadPackageDefinition = exports.makeClientConstructor = void 0;\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */ const requesterFuncs = {\n    unary: client_1.Client.prototype.makeUnaryRequest,\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\n    bidi: client_1.Client.prototype.makeBidiStreamRequest\n};\n/**\n * Returns true, if given key is included in the blacklisted\n * keys.\n * @param key key for check, string.\n */ function isPrototypePolluted(key) {\n    return [\n        \"__proto__\",\n        \"prototype\",\n        \"constructor\"\n    ].includes(key);\n}\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */ function makeClientConstructor(methods, serviceName, classOptions) {\n    if (!classOptions) {\n        classOptions = {};\n    }\n    class ServiceClientImpl extends client_1.Client {\n    }\n    Object.keys(methods).forEach((name)=>{\n        if (isPrototypePolluted(name)) {\n            return;\n        }\n        const attrs = methods[name];\n        let methodType;\n        // TODO(murgatroid99): Verify that we don't need this anymore\n        if (typeof name === \"string\" && name.charAt(0) === \"$\") {\n            throw new Error(\"Method names cannot start with $\");\n        }\n        if (attrs.requestStream) {\n            if (attrs.responseStream) {\n                methodType = \"bidi\";\n            } else {\n                methodType = \"client_stream\";\n            }\n        } else {\n            if (attrs.responseStream) {\n                methodType = \"server_stream\";\n            } else {\n                methodType = \"unary\";\n            }\n        }\n        const serialize = attrs.requestSerialize;\n        const deserialize = attrs.responseDeserialize;\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n        ServiceClientImpl.prototype[name] = methodFunc;\n        // Associate all provided attributes with the method\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\n        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\n            ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];\n        }\n    });\n    ServiceClientImpl.service = methods;\n    ServiceClientImpl.serviceName = serviceName;\n    return ServiceClientImpl;\n}\nexports.makeClientConstructor = makeClientConstructor;\nfunction partial(fn, path, serialize, deserialize) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function(...args) {\n        return fn.call(this, path, serialize, deserialize, ...args);\n    };\n}\nfunction isProtobufTypeDefinition(obj) {\n    return \"format\" in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */ function loadPackageDefinition(packageDef) {\n    const result = {};\n    for(const serviceFqn in packageDef){\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\n            const service = packageDef[serviceFqn];\n            const nameComponents = serviceFqn.split(\".\");\n            if (nameComponents.some((comp)=>isPrototypePolluted(comp))) {\n                continue;\n            }\n            const serviceName = nameComponents[nameComponents.length - 1];\n            let current = result;\n            for (const packageName of nameComponents.slice(0, -1)){\n                if (!current[packageName]) {\n                    current[packageName] = {};\n                }\n                current = current[packageName];\n            }\n            if (isProtobufTypeDefinition(service)) {\n                current[serviceName] = service;\n            } else {\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\n            }\n        }\n    }\n    return result;\n}\nexports.loadPackageDefinition = loadPackageDefinition; //# sourceMappingURL=make-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWFrZS1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSw2QkFBNkIsR0FBRyxLQUFLO0FBQ3JFLE1BQU1JLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DOzs7O0NBSUMsR0FDRCxNQUFNQyxpQkFBaUI7SUFDbkJDLE9BQU9ILFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDQyxnQkFBZ0I7SUFDakRDLGVBQWVQLFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDRyx1QkFBdUI7SUFDaEVDLGVBQWVULFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDSyx1QkFBdUI7SUFDaEVDLE1BQU1YLFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDTyxxQkFBcUI7QUFDekQ7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0Msb0JBQW9CQyxHQUFHO0lBQzVCLE9BQU87UUFBQztRQUFhO1FBQWE7S0FBYyxDQUFDQyxRQUFRLENBQUNEO0FBQzlEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNmLHNCQUFzQmlCLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxZQUFZO0lBQzdELElBQUksQ0FBQ0EsY0FBYztRQUNmQSxlQUFlLENBQUM7SUFDcEI7SUFDQSxNQUFNQywwQkFBMEJuQixTQUFTSSxNQUFNO0lBQy9DO0lBQ0FWLE9BQU8wQixJQUFJLENBQUNKLFNBQVNLLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDekIsSUFBSVQsb0JBQW9CUyxPQUFPO1lBQzNCO1FBQ0o7UUFDQSxNQUFNQyxRQUFRUCxPQUFPLENBQUNNLEtBQUs7UUFDM0IsSUFBSUU7UUFDSiw2REFBNkQ7UUFDN0QsSUFBSSxPQUFPRixTQUFTLFlBQVlBLEtBQUtHLE1BQU0sQ0FBQyxPQUFPLEtBQUs7WUFDcEQsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSUgsTUFBTUksYUFBYSxFQUFFO1lBQ3JCLElBQUlKLE1BQU1LLGNBQWMsRUFBRTtnQkFDdEJKLGFBQWE7WUFDakIsT0FDSztnQkFDREEsYUFBYTtZQUNqQjtRQUNKLE9BQ0s7WUFDRCxJQUFJRCxNQUFNSyxjQUFjLEVBQUU7Z0JBQ3RCSixhQUFhO1lBQ2pCLE9BQ0s7Z0JBQ0RBLGFBQWE7WUFDakI7UUFDSjtRQUNBLE1BQU1LLFlBQVlOLE1BQU1PLGdCQUFnQjtRQUN4QyxNQUFNQyxjQUFjUixNQUFNUyxtQkFBbUI7UUFDN0MsTUFBTUMsYUFBYUMsUUFBUWhDLGNBQWMsQ0FBQ3NCLFdBQVcsRUFBRUQsTUFBTVksSUFBSSxFQUFFTixXQUFXRTtRQUM5RVosa0JBQWtCZCxTQUFTLENBQUNpQixLQUFLLEdBQUdXO1FBQ3BDLG9EQUFvRDtRQUNwRHZDLE9BQU8wQyxNQUFNLENBQUNqQixrQkFBa0JkLFNBQVMsQ0FBQ2lCLEtBQUssRUFBRUM7UUFDakQsSUFBSUEsTUFBTWMsWUFBWSxJQUFJLENBQUN4QixvQkFBb0JVLE1BQU1jLFlBQVksR0FBRztZQUNoRWxCLGtCQUFrQmQsU0FBUyxDQUFDa0IsTUFBTWMsWUFBWSxDQUFDLEdBQzNDbEIsa0JBQWtCZCxTQUFTLENBQUNpQixLQUFLO1FBQ3pDO0lBQ0o7SUFDQUgsa0JBQWtCbUIsT0FBTyxHQUFHdEI7SUFDNUJHLGtCQUFrQkYsV0FBVyxHQUFHQTtJQUNoQyxPQUFPRTtBQUNYO0FBQ0F2Qiw2QkFBNkIsR0FBR0c7QUFDaEMsU0FBU21DLFFBQVFLLEVBQUUsRUFBRUosSUFBSSxFQUFFTixTQUFTLEVBQUVFLFdBQVc7SUFDN0MsOERBQThEO0lBQzlELE9BQU8sU0FBVSxHQUFHUyxJQUFJO1FBQ3BCLE9BQU9ELEdBQUdFLElBQUksQ0FBQyxJQUFJLEVBQUVOLE1BQU1OLFdBQVdFLGdCQUFnQlM7SUFDMUQ7QUFDSjtBQUNBLFNBQVNFLHlCQUF5QkMsR0FBRztJQUNqQyxPQUFPLFlBQVlBO0FBQ3ZCO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVM3QyxzQkFBc0I4QyxVQUFVO0lBQ3JDLE1BQU1DLFNBQVMsQ0FBQztJQUNoQixJQUFLLE1BQU1DLGNBQWNGLFdBQVk7UUFDakMsSUFBSWxELE9BQU9XLFNBQVMsQ0FBQzBDLGNBQWMsQ0FBQ04sSUFBSSxDQUFDRyxZQUFZRSxhQUFhO1lBQzlELE1BQU1SLFVBQVVNLFVBQVUsQ0FBQ0UsV0FBVztZQUN0QyxNQUFNRSxpQkFBaUJGLFdBQVdHLEtBQUssQ0FBQztZQUN4QyxJQUFJRCxlQUFlRSxJQUFJLENBQUMsQ0FBQ0MsT0FBU3RDLG9CQUFvQnNDLFFBQVE7Z0JBQzFEO1lBQ0o7WUFDQSxNQUFNbEMsY0FBYytCLGNBQWMsQ0FBQ0EsZUFBZUksTUFBTSxHQUFHLEVBQUU7WUFDN0QsSUFBSUMsVUFBVVI7WUFDZCxLQUFLLE1BQU1TLGVBQWVOLGVBQWVPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBSTtnQkFDbkQsSUFBSSxDQUFDRixPQUFPLENBQUNDLFlBQVksRUFBRTtvQkFDdkJELE9BQU8sQ0FBQ0MsWUFBWSxHQUFHLENBQUM7Z0JBQzVCO2dCQUNBRCxVQUFVQSxPQUFPLENBQUNDLFlBQVk7WUFDbEM7WUFDQSxJQUFJWix5QkFBeUJKLFVBQVU7Z0JBQ25DZSxPQUFPLENBQUNwQyxZQUFZLEdBQUdxQjtZQUMzQixPQUNLO2dCQUNEZSxPQUFPLENBQUNwQyxZQUFZLEdBQUdsQixzQkFBc0J1QyxTQUFTckIsYUFBYSxDQUFDO1lBQ3hFO1FBQ0o7SUFDSjtJQUNBLE9BQU80QjtBQUNYO0FBQ0FqRCw2QkFBNkIsR0FBR0UsdUJBQ2hDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21ha2UtY2xpZW50LmpzPzZiYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSB2b2lkIDA7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbi8qKlxuICogTWFwIHdpdGggc2hvcnQgbmFtZXMgZm9yIGVhY2ggb2YgdGhlIHJlcXVlc3RlciBtYWtlciBmdW5jdGlvbnMuIFVzZWQgaW5cbiAqIG1ha2VDbGllbnRDb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcmVxdWVzdGVyRnVuY3MgPSB7XG4gICAgdW5hcnk6IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZVVuYXJ5UmVxdWVzdCxcbiAgICBzZXJ2ZXJfc3RyZWFtOiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0LFxuICAgIGNsaWVudF9zdHJlYW06IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZUNsaWVudFN0cmVhbVJlcXVlc3QsXG4gICAgYmlkaTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlQmlkaVN0cmVhbVJlcXVlc3QsXG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUsIGlmIGdpdmVuIGtleSBpcyBpbmNsdWRlZCBpbiB0aGUgYmxhY2tsaXN0ZWRcbiAqIGtleXMuXG4gKiBAcGFyYW0ga2V5IGtleSBmb3IgY2hlY2ssIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGVQb2xsdXRlZChrZXkpIHtcbiAgICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5jbHVkZXMoa2V5KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGNvbnN0cnVjdG9yIGZvciBhIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBtZXRob2RzLCBhcyBzcGVjaWZpZWQgaW5cbiAqIHRoZSBtZXRob2RzIGFyZ3VtZW50LiBUaGUgcmVzdWx0aW5nIGNsYXNzIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBtZXRob2QgZm9yXG4gKiBlYWNoIG1ldGhvZCBpbiB0aGUgc2VydmljZSwgd2hpY2ggaXMgYSBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIG9uZSBvZiB0aGVcbiAqIFtDbGllbnRde0BsaW5rIGdycGMuQ2xpZW50fSByZXF1ZXN0IG1ldGhvZHMsIGRlcGVuZGluZyBvbiBgcmVxdWVzdFNlcmlhbGl6ZWBcbiAqIGFuZCBgcmVzcG9uc2VTZXJpYWxpemVgLCB3aXRoIHRoZSBgbWV0aG9kYCwgYHNlcmlhbGl6ZWAsIGFuZCBgZGVzZXJpYWxpemVgXG4gKiBhcmd1bWVudHMgcHJlZGVmaW5lZC5cbiAqIEBwYXJhbSBtZXRob2RzIEFuIG9iamVjdCBtYXBwaW5nIG1ldGhvZCBuYW1lcyB0b1xuICogICAgIG1ldGhvZCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gc2VydmljZU5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoZSBzZXJ2aWNlXG4gKiBAcGFyYW0gY2xhc3NPcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybiBOZXcgY2xpZW50IGNvbnN0cnVjdG9yLCB3aGljaCBpcyBhIHN1YmNsYXNzIG9mXG4gKiAgICAge0BsaW5rIGdycGMuQ2xpZW50fSwgYW5kIGhhcyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhhdCBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gbWFrZUNsaWVudENvbnN0cnVjdG9yKG1ldGhvZHMsIHNlcnZpY2VOYW1lLCBjbGFzc09wdGlvbnMpIHtcbiAgICBpZiAoIWNsYXNzT3B0aW9ucykge1xuICAgICAgICBjbGFzc09wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY2xhc3MgU2VydmljZUNsaWVudEltcGwgZXh0ZW5kcyBjbGllbnRfMS5DbGllbnQge1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBpZiAoaXNQcm90b3R5cGVQb2xsdXRlZChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJzID0gbWV0aG9kc1tuYW1lXTtcbiAgICAgICAgbGV0IG1ldGhvZFR5cGU7XG4gICAgICAgIC8vIFRPRE8obXVyZ2F0cm9pZDk5KTogVmVyaWZ5IHRoYXQgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiBuYW1lLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCAkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzLnJlcXVlc3RTdHJlYW0pIHtcbiAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnYmlkaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ2NsaWVudF9zdHJlYW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGF0dHJzLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdzZXJ2ZXJfc3RyZWFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAndW5hcnknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZSA9IGF0dHJzLnJlcXVlc3RTZXJpYWxpemU7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplID0gYXR0cnMucmVzcG9uc2VEZXNlcmlhbGl6ZTtcbiAgICAgICAgY29uc3QgbWV0aG9kRnVuYyA9IHBhcnRpYWwocmVxdWVzdGVyRnVuY3NbbWV0aG9kVHlwZV0sIGF0dHJzLnBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpO1xuICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2RGdW5jO1xuICAgICAgICAvLyBBc3NvY2lhdGUgYWxsIHByb3ZpZGVkIGF0dHJpYnV0ZXMgd2l0aCB0aGUgbWV0aG9kXG4gICAgICAgIE9iamVjdC5hc3NpZ24oU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW25hbWVdLCBhdHRycyk7XG4gICAgICAgIGlmIChhdHRycy5vcmlnaW5hbE5hbWUgJiYgIWlzUHJvdG90eXBlUG9sbHV0ZWQoYXR0cnMub3JpZ2luYWxOYW1lKSkge1xuICAgICAgICAgICAgU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW2F0dHJzLm9yaWdpbmFsTmFtZV0gPVxuICAgICAgICAgICAgICAgIFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFNlcnZpY2VDbGllbnRJbXBsLnNlcnZpY2UgPSBtZXRob2RzO1xuICAgIFNlcnZpY2VDbGllbnRJbXBsLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgcmV0dXJuIFNlcnZpY2VDbGllbnRJbXBsO1xufVxuZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSBtYWtlQ2xpZW50Q29uc3RydWN0b3I7XG5mdW5jdGlvbiBwYXJ0aWFsKGZuLCBwYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgcGF0aCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgLi4uYXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzUHJvdG9idWZUeXBlRGVmaW5pdGlvbihvYmopIHtcbiAgICByZXR1cm4gJ2Zvcm1hdCcgaW4gb2JqO1xufVxuLyoqXG4gKiBMb2FkIGEgZ1JQQyBwYWNrYWdlIGRlZmluaXRpb24gYXMgYSBnUlBDIG9iamVjdCBoaWVyYXJjaHkuXG4gKiBAcGFyYW0gcGFja2FnZURlZiBUaGUgcGFja2FnZSBkZWZpbml0aW9uIG9iamVjdC5cbiAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBnUlBDIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gbG9hZFBhY2thZ2VEZWZpbml0aW9uKHBhY2thZ2VEZWYpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHNlcnZpY2VGcW4gaW4gcGFja2FnZURlZikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhY2thZ2VEZWYsIHNlcnZpY2VGcW4pKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gcGFja2FnZURlZltzZXJ2aWNlRnFuXTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVDb21wb25lbnRzID0gc2VydmljZUZxbi5zcGxpdCgnLicpO1xuICAgICAgICAgICAgaWYgKG5hbWVDb21wb25lbnRzLnNvbWUoKGNvbXApID0+IGlzUHJvdG90eXBlUG9sbHV0ZWQoY29tcCkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlTmFtZSA9IG5hbWVDb21wb25lbnRzW25hbWVDb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSByZXN1bHQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhY2thZ2VOYW1lIG9mIG5hbWVDb21wb25lbnRzLnNsaWNlKDAsIC0xKSkge1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFtwYWNrYWdlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFtwYWNrYWdlTmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFja2FnZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJvdG9idWZUeXBlRGVmaW5pdGlvbihzZXJ2aWNlKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbc2VydmljZU5hbWVdID0gc2VydmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbc2VydmljZU5hbWVdID0gbWFrZUNsaWVudENvbnN0cnVjdG9yKHNlcnZpY2UsIHNlcnZpY2VOYW1lLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gbG9hZFBhY2thZ2VEZWZpbml0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibG9hZFBhY2thZ2VEZWZpbml0aW9uIiwibWFrZUNsaWVudENvbnN0cnVjdG9yIiwiY2xpZW50XzEiLCJyZXF1aXJlIiwicmVxdWVzdGVyRnVuY3MiLCJ1bmFyeSIsIkNsaWVudCIsInByb3RvdHlwZSIsIm1ha2VVbmFyeVJlcXVlc3QiLCJzZXJ2ZXJfc3RyZWFtIiwibWFrZVNlcnZlclN0cmVhbVJlcXVlc3QiLCJjbGllbnRfc3RyZWFtIiwibWFrZUNsaWVudFN0cmVhbVJlcXVlc3QiLCJiaWRpIiwibWFrZUJpZGlTdHJlYW1SZXF1ZXN0IiwiaXNQcm90b3R5cGVQb2xsdXRlZCIsImtleSIsImluY2x1ZGVzIiwibWV0aG9kcyIsInNlcnZpY2VOYW1lIiwiY2xhc3NPcHRpb25zIiwiU2VydmljZUNsaWVudEltcGwiLCJrZXlzIiwiZm9yRWFjaCIsIm5hbWUiLCJhdHRycyIsIm1ldGhvZFR5cGUiLCJjaGFyQXQiLCJFcnJvciIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsInNlcmlhbGl6ZSIsInJlcXVlc3RTZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJtZXRob2RGdW5jIiwicGFydGlhbCIsInBhdGgiLCJhc3NpZ24iLCJvcmlnaW5hbE5hbWUiLCJzZXJ2aWNlIiwiZm4iLCJhcmdzIiwiY2FsbCIsImlzUHJvdG9idWZUeXBlRGVmaW5pdGlvbiIsIm9iaiIsInBhY2thZ2VEZWYiLCJyZXN1bHQiLCJzZXJ2aWNlRnFuIiwiaGFzT3duUHJvcGVydHkiLCJuYW1lQ29tcG9uZW50cyIsInNwbGl0Iiwic29tZSIsImNvbXAiLCJsZW5ndGgiLCJjdXJyZW50IiwicGFja2FnZU5hbWUiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MaxMessageSizeFilterFactory = exports.MaxMessageSizeFilter = void 0;\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nclass MaxMessageSizeFilter extends filter_1.BaseFilter {\n    constructor(options){\n        super();\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        if (\"grpc.max_send_message_length\" in options) {\n            this.maxSendMessageSize = options[\"grpc.max_send_message_length\"];\n        }\n        if (\"grpc.max_receive_message_length\" in options) {\n            this.maxReceiveMessageSize = options[\"grpc.max_receive_message_length\"];\n        }\n    }\n    async sendMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */ if (this.maxSendMessageSize === -1) {\n            return message;\n        } else {\n            const concreteMessage = await message;\n            if (concreteMessage.message.length > this.maxSendMessageSize) {\n                throw {\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\n                    details: `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`,\n                    metadata: new metadata_1.Metadata()\n                };\n            } else {\n                return concreteMessage;\n            }\n        }\n    }\n    async receiveMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */ if (this.maxReceiveMessageSize === -1) {\n            return message;\n        } else {\n            const concreteMessage = await message;\n            if (concreteMessage.length > this.maxReceiveMessageSize) {\n                throw {\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\n                    details: `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`,\n                    metadata: new metadata_1.Metadata()\n                };\n            } else {\n                return concreteMessage;\n            }\n        }\n    }\n}\nexports.MaxMessageSizeFilter = MaxMessageSizeFilter;\nclass MaxMessageSizeFilterFactory {\n    constructor(options){\n        this.options = options;\n    }\n    createFilter() {\n        return new MaxMessageSizeFilter(this.options);\n    }\n}\nexports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory; //# sourceMappingURL=max-message-size-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWF4LW1lc3NhZ2Utc2l6ZS1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1DQUFtQyxHQUFHQSw0QkFBNEIsR0FBRyxLQUFLO0FBQzFFLE1BQU1JLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1GLDZCQUE2QkMsU0FBU0ksVUFBVTtJQUNsREMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUs7UUFDTCxJQUFJLENBQUNDLGtCQUFrQixHQUFHTCxZQUFZTSwrQkFBK0I7UUFDckUsSUFBSSxDQUFDQyxxQkFBcUIsR0FBR1AsWUFBWVEsa0NBQWtDO1FBQzNFLElBQUksa0NBQWtDSixTQUFTO1lBQzNDLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUdELE9BQU8sQ0FBQywrQkFBK0I7UUFDckU7UUFDQSxJQUFJLHFDQUFxQ0EsU0FBUztZQUM5QyxJQUFJLENBQUNHLHFCQUFxQixHQUFHSCxPQUFPLENBQUMsa0NBQWtDO1FBQzNFO0lBQ0o7SUFDQSxNQUFNSyxZQUFZQyxPQUFPLEVBQUU7UUFDdkI7b0JBQ1ksR0FDWixJQUFJLElBQUksQ0FBQ0wsa0JBQWtCLEtBQUssQ0FBQyxHQUFHO1lBQ2hDLE9BQU9LO1FBQ1gsT0FDSztZQUNELE1BQU1DLGtCQUFrQixNQUFNRDtZQUM5QixJQUFJQyxnQkFBZ0JELE9BQU8sQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ1Asa0JBQWtCLEVBQUU7Z0JBQzFELE1BQU07b0JBQ0ZRLE1BQU1iLFlBQVljLE1BQU0sQ0FBQ0Msa0JBQWtCO29CQUMzQ0MsU0FBUyxDQUFDLDhCQUE4QixFQUFFTCxnQkFBZ0JELE9BQU8sQ0FBQ0UsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUNQLGtCQUFrQixDQUFDLENBQUMsQ0FBQztvQkFDMUdZLFVBQVUsSUFBSWhCLFdBQVdpQixRQUFRO2dCQUNyQztZQUNKLE9BQ0s7Z0JBQ0QsT0FBT1A7WUFDWDtRQUNKO0lBQ0o7SUFDQSxNQUFNUSxlQUFlVCxPQUFPLEVBQUU7UUFDMUI7b0JBQ1ksR0FDWixJQUFJLElBQUksQ0FBQ0gscUJBQXFCLEtBQUssQ0FBQyxHQUFHO1lBQ25DLE9BQU9HO1FBQ1gsT0FDSztZQUNELE1BQU1DLGtCQUFrQixNQUFNRDtZQUM5QixJQUFJQyxnQkFBZ0JDLE1BQU0sR0FBRyxJQUFJLENBQUNMLHFCQUFxQixFQUFFO2dCQUNyRCxNQUFNO29CQUNGTSxNQUFNYixZQUFZYyxNQUFNLENBQUNDLGtCQUFrQjtvQkFDM0NDLFNBQVMsQ0FBQyxrQ0FBa0MsRUFBRUwsZ0JBQWdCQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQ0wscUJBQXFCLENBQUMsQ0FBQyxDQUFDO29CQUN6R1UsVUFBVSxJQUFJaEIsV0FBV2lCLFFBQVE7Z0JBQ3JDO1lBQ0osT0FDSztnQkFDRCxPQUFPUDtZQUNYO1FBQ0o7SUFDSjtBQUNKO0FBQ0FqQiw0QkFBNEIsR0FBR0c7QUFDL0IsTUFBTUQ7SUFDRk8sWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNuQjtJQUNBZ0IsZUFBZTtRQUNYLE9BQU8sSUFBSXZCLHFCQUFxQixJQUFJLENBQUNPLE9BQU87SUFDaEQ7QUFDSjtBQUNBVixtQ0FBbUMsR0FBR0UsNkJBQ3RDLG1EQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21heC1tZXNzYWdlLXNpemUtZmlsdGVyLmpzP2FjNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5NYXhNZXNzYWdlU2l6ZUZpbHRlciA9IHZvaWQgMDtcbmNvbnN0IGZpbHRlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jbGFzcyBNYXhNZXNzYWdlU2l6ZUZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPSBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSA9IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSA9IG9wdGlvbnNbJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIC8qIEEgY29uZmlndXJlZCBzaXplIG9mIC0xIG1lYW5zIHRoYXQgdGhlcmUgaXMgbm8gbGltaXQsIHNvIHNraXAgdGhlIGNoZWNrXG4gICAgICAgICAqIGVudGlyZWx5ICovXG4gICAgICAgIGlmICh0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29uY3JldGVNZXNzYWdlID0gYXdhaXQgbWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChjb25jcmV0ZU1lc3NhZ2UubWVzc2FnZS5sZW5ndGggPiB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFNlbnQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7Y29uY3JldGVNZXNzYWdlLm1lc3NhZ2UubGVuZ3RofSB2cy4gJHt0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZX0pYCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jcmV0ZU1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBBIGNvbmZpZ3VyZWQgc2l6ZSBvZiAtMSBtZWFucyB0aGF0IHRoZXJlIGlzIG5vIGxpbWl0LCBzbyBza2lwIHRoZSBjaGVja1xuICAgICAgICAgKiBlbnRpcmVseSAqL1xuICAgICAgICBpZiAodGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmNyZXRlTWVzc2FnZSA9IGF3YWl0IG1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoY29uY3JldGVNZXNzYWdlLmxlbmd0aCA+IHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7Y29uY3JldGVNZXNzYWdlLmxlbmd0aH0gdnMuICR7dGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemV9KWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY3JldGVNZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5NYXhNZXNzYWdlU2l6ZUZpbHRlciA9IE1heE1lc3NhZ2VTaXplRmlsdGVyO1xuY2xhc3MgTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGNyZWF0ZUZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXhNZXNzYWdlU2l6ZUZpbHRlcih0aGlzLm9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5ID0gTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF4LW1lc3NhZ2Utc2l6ZS1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5IiwiTWF4TWVzc2FnZVNpemVGaWx0ZXIiLCJmaWx0ZXJfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsIm1ldGFkYXRhXzEiLCJCYXNlRmlsdGVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwibWF4U2VuZE1lc3NhZ2VTaXplIiwiREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCIsIm1heFJlY2VpdmVNZXNzYWdlU2l6ZSIsIkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEgiLCJzZW5kTWVzc2FnZSIsIm1lc3NhZ2UiLCJjb25jcmV0ZU1lc3NhZ2UiLCJsZW5ndGgiLCJjb2RlIiwiU3RhdHVzIiwiUkVTT1VSQ0VfRVhIQVVTVEVEIiwiZGV0YWlscyIsIm1ldGFkYXRhIiwiTWV0YWRhdGEiLCJyZWNlaXZlTWVzc2FnZSIsImNyZWF0ZUZpbHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Metadata = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith(\"-bin\");\n}\nfunction isCustomMetadata(key) {\n    return !key.startsWith(\"grpc-\");\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value !== null && value !== undefined) {\n        if (isBinaryKey(key)) {\n            if (!Buffer.isBuffer(value)) {\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\n            }\n        } else {\n            if (Buffer.isBuffer(value)) {\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */ class Metadata {\n    constructor(options = {}){\n        this.internalRepr = new Map();\n        this.options = options;\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */ set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [\n            value\n        ]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */ add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [\n                value\n            ]);\n        } else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */ remove(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */ get(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */ getMap() {\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n            }\n        }\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */ clone() {\n        const newMetadata = new Metadata(this.options);\n        const newInternalRepr = newMetadata.internalRepr;\n        for (const [key, value] of this.internalRepr){\n            const clonedValue = value.map((v)=>{\n                if (Buffer.isBuffer(v)) {\n                    return Buffer.from(v);\n                } else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        }\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */ merge(other) {\n        for (const [key, values] of other.internalRepr){\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        }\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */ toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map(bufToString);\n        }\n        return result;\n    }\n    /**\n     * This modifies the behavior of JSON.stringify to show an object\n     * representation of the metadata map.\n     */ toJSON() {\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            result[key] = values;\n        }\n        return result;\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */ static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        for (const key of Object.keys(headers)){\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === \":\") {\n                continue;\n            }\n            const values = headers[key];\n            try {\n                if (isBinaryKey(key)) {\n                    if (Array.isArray(values)) {\n                        values.forEach((value)=>{\n                            result.add(key, Buffer.from(value, \"base64\"));\n                        });\n                    } else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(\",\").forEach((v)=>{\n                                result.add(key, Buffer.from(v.trim(), \"base64\"));\n                            });\n                        } else {\n                            result.add(key, Buffer.from(values, \"base64\"));\n                        }\n                    }\n                } else {\n                    if (Array.isArray(values)) {\n                        values.forEach((value)=>{\n                            result.add(key, value);\n                        });\n                    } else if (values !== undefined) {\n                        result.add(key, values);\n                    }\n                }\n            } catch (error) {\n                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);\n            }\n        }\n        return result;\n    }\n}\nexports.Metadata = Metadata;\nconst bufToString = (val)=>{\n    return Buffer.isBuffer(val) ? val.toString(\"base64\") : val;\n}; //# sourceMappingURL=metadata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3hCLE1BQU1HLFlBQVlDLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ3JDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLHNFQUFTO0FBQ2pDLE1BQU1HLGtCQUFrQjtBQUN4QixNQUFNQywrQkFBK0I7QUFDckMsU0FBU0MsV0FBV0MsR0FBRztJQUNuQixPQUFPSCxnQkFBZ0JJLElBQUksQ0FBQ0Q7QUFDaEM7QUFDQSxTQUFTRSxzQkFBc0JYLEtBQUs7SUFDaEMsT0FBT08sNkJBQTZCRyxJQUFJLENBQUNWO0FBQzdDO0FBQ0EsU0FBU1ksWUFBWUgsR0FBRztJQUNwQixPQUFPQSxJQUFJSSxRQUFRLENBQUM7QUFDeEI7QUFDQSxTQUFTQyxpQkFBaUJMLEdBQUc7SUFDekIsT0FBTyxDQUFDQSxJQUFJTSxVQUFVLENBQUM7QUFDM0I7QUFDQSxTQUFTQyxhQUFhUCxHQUFHO0lBQ3JCLE9BQU9BLElBQUlRLFdBQVc7QUFDMUI7QUFDQSxTQUFTQyxTQUFTVCxHQUFHLEVBQUVULEtBQUs7SUFDeEIsSUFBSSxDQUFDUSxXQUFXQyxNQUFNO1FBQ2xCLE1BQU0sSUFBSVUsTUFBTSxtQkFBbUJWLE1BQU07SUFDN0M7SUFDQSxJQUFJVCxVQUFVLFFBQVFBLFVBQVVvQixXQUFXO1FBQ3ZDLElBQUlSLFlBQVlILE1BQU07WUFDbEIsSUFBSSxDQUFDWSxNQUFNQSxDQUFDQyxRQUFRLENBQUN0QixRQUFRO2dCQUN6QixNQUFNLElBQUltQixNQUFNO1lBQ3BCO1FBQ0osT0FDSztZQUNELElBQUlFLE1BQU1BLENBQUNDLFFBQVEsQ0FBQ3RC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QyxXQUFXaEIsV0FBVzt3QkFDM0IsSUFBSU4saUJBQWlCTCxNQUFNOzRCQUN2QjJCLE9BQU95QixLQUFLLENBQUMsS0FBS0QsT0FBTyxDQUFDdEIsQ0FBQUE7Z0NBQ3RCSCxPQUFPUCxHQUFHLENBQUNuQixLQUFLWSxNQUFNQSxDQUFDa0IsSUFBSSxDQUFDRCxFQUFFd0IsSUFBSSxJQUFJOzRCQUMxQzt3QkFDSixPQUNLOzRCQUNEM0IsT0FBT1AsR0FBRyxDQUFDbkIsS0FBS1ksTUFBTUEsQ0FBQ2tCLElBQUksQ0FBQ0gsUUFBUTt3QkFDeEM7b0JBQ0o7Z0JBQ0osT0FDSztvQkFDRCxJQUFJc0IsTUFBTUMsT0FBTyxDQUFDdkIsU0FBUzt3QkFDdkJBLE9BQU93QixPQUFPLENBQUM1RCxDQUFBQTs0QkFDWG1DLE9BQU9QLEdBQUcsQ0FBQ25CLEtBQUtUO3dCQUNwQjtvQkFDSixPQUNLLElBQUlvQyxXQUFXaEIsV0FBVzt3QkFDM0JlLE9BQU9QLEdBQUcsQ0FBQ25CLEtBQUsyQjtvQkFDcEI7Z0JBQ0o7WUFDSixFQUNBLE9BQU8yQixPQUFPO2dCQUNWLE1BQU1DLFVBQVUsQ0FBQyw2QkFBNkIsRUFBRXZELElBQUksRUFBRSxFQUFFMkIsT0FBTyxFQUFFLEVBQUUsQ0FBQyxHQUFHL0IsUUFBUTRELGVBQWUsRUFBRUYsT0FBTyx3RUFBd0UsQ0FBQztnQkFDL0ssSUFBRzdELFVBQVVnRSxHQUFHLEVBQUU5RCxZQUFZK0QsWUFBWSxDQUFDQyxLQUFLLEVBQUVKO1lBQ3ZEO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtBQUNKO0FBQ0FwQyxnQkFBZ0IsR0FBR0U7QUFDbkIsTUFBTW1ELGNBQWMsQ0FBQ2lCO0lBQ2pCLE9BQU9oRCxNQUFNQSxDQUFDQyxRQUFRLENBQUMrQyxPQUFPQSxJQUFJQyxRQUFRLENBQUMsWUFBWUQ7QUFDM0QsR0FDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tZXRhZGF0YS5qcz8xYzVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1ldGFkYXRhID0gdm9pZCAwO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuY29uc3QgTEVHQUxfS0VZX1JFR0VYID0gL15bMC05YS16Xy4tXSskLztcbmNvbnN0IExFR0FMX05PTl9CSU5BUllfVkFMVUVfUkVHRVggPSAvXlsgLX5dKiQvO1xuZnVuY3Rpb24gaXNMZWdhbEtleShrZXkpIHtcbiAgICByZXR1cm4gTEVHQUxfS0VZX1JFR0VYLnRlc3Qoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzTGVnYWxOb25CaW5hcnlWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBMRUdBTF9OT05fQklOQVJZX1ZBTFVFX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNCaW5hcnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5lbmRzV2l0aCgnLWJpbicpO1xufVxuZnVuY3Rpb24gaXNDdXN0b21NZXRhZGF0YShrZXkpIHtcbiAgICByZXR1cm4gIWtleS5zdGFydHNXaXRoKCdncnBjLScpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzTGVnYWxLZXkoa2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIGtleSBcIicgKyBrZXkgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc0JpbmFyeUtleShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBCdWZmZXIgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZG9uJ3QgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBTdHJpbmcgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0xlZ2FsTm9uQmluYXJ5VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhZGF0YSBzdHJpbmcgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgZm9yIHN0b3JpbmcgbWV0YWRhdGEuIEtleXMgYXJlIG5vcm1hbGl6ZWQgdG8gbG93ZXJjYXNlIEFTQ0lJLlxuICovXG5jbGFzcyBNZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSByZXBsYWNpbmcgYW55IG90aGVyIHZhbHVlc1xuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgc2V0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLnNldChrZXksIFt2YWx1ZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSBhcHBlbmRpbmcgdG8gYSBsaXN0IG9mIHByZXZpb3VzXG4gICAgICogdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBmb3Igd2hpY2ggYSBuZXcgdmFsdWUgc2hvdWxkIGJlIGFwcGVuZGVkLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cbiAgICAgKi9cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSB0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGlzdGluZ1ZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGtleSBhbmQgYW55IGFzc29jaWF0ZWQgdmFsdWVzLiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHdob3NlIHZhbHVlcyBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICAvLyB2YWxpZGF0ZShrZXkpO1xuICAgICAgICB0aGlzLmludGVybmFsUmVwci5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgYWxsIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4gQSBsaXN0IG9mIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICAvLyB2YWxpZGF0ZShrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSkgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBwbGFpbiBvYmplY3QgbWFwcGluZyBlYWNoIGtleSB0byB0aGUgZmlyc3QgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICAqIFRoaXMgcmVmbGVjdHMgdGhlIG1vc3QgY29tbW9uIHdheSB0aGF0IHBlb3BsZSB3aWxsIHdhbnQgdG8gc2VlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm4gQSBrZXkvdmFsdWUgbWFwcGluZyBvZiB0aGUgbWV0YWRhdGEuXG4gICAgICovXG4gICAgZ2V0TWFwKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVzWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gQnVmZmVyLmlzQnVmZmVyKHYpID8gQnVmZmVyLmZyb20odikgOiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgbWV0YWRhdGEgb2JqZWN0LlxuICAgICAqIEByZXR1cm4gVGhlIG5ld2x5IGNsb25lZCBvYmplY3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IG5ld01ldGFkYXRhID0gbmV3IE1ldGFkYXRhKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG5ld0ludGVybmFsUmVwciA9IG5ld01ldGFkYXRhLmludGVybmFsUmVwcjtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZFZhbHVlID0gdmFsdWUubWFwKHYgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdJbnRlcm5hbFJlcHIuc2V0KGtleSwgY2xvbmVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdNZXRhZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFsbCBrZXktdmFsdWUgcGFpcnMgZnJvbSBhIGdpdmVuIE1ldGFkYXRhIG9iamVjdCBpbnRvIHRoaXMgb25lLlxuICAgICAqIElmIGJvdGggdGhpcyBvYmplY3QgYW5kIHRoZSBnaXZlbiBvYmplY3QgaGF2ZSB2YWx1ZXMgaW4gdGhlIHNhbWUga2V5LFxuICAgICAqIHZhbHVlcyBmcm9tIHRoZSBvdGhlciBNZXRhZGF0YSBvYmplY3Qgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzIG9iamVjdCdzXG4gICAgICogdmFsdWVzLlxuICAgICAqIEBwYXJhbSBvdGhlciBBIE1ldGFkYXRhIG9iamVjdC5cbiAgICAgKi9cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2Ygb3RoZXIuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRWYWx1ZSA9ICh0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KSB8fCBbXSkuY29uY2F0KHZhbHVlcyk7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVwci5zZXQoa2V5LCBtZXJnZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT3V0Z29pbmdIdHRwSGVhZGVycyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoZSBodHRwMiBBUEkuXG4gICAgICovXG4gICAgdG9IdHRwMkhlYWRlcnMoKSB7XG4gICAgICAgIC8vIE5PVEU6IE5vZGUgPDguOSBmb3JtYXRzIGh0dHAyIGhlYWRlcnMgaW5jb3JyZWN0bHkuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGlzIG9iamVjdCBpcyBsaW1pdGVkIHRvXG4gICAgICAgICAgICAvLyB0aHJvdWdoIGl0cyBwdWJsaWMgQVBJIChpLmUuIGtleXMgYW5kIHZhbHVlcyBhcmUgYWxyZWFkeSB2YWxpZGF0ZWQpLlxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXMubWFwKGJ1ZlRvU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGlmaWVzIHRoZSBiZWhhdmlvciBvZiBKU09OLnN0cmluZ2lmeSB0byBzaG93IGFuIG9iamVjdFxuICAgICAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXRhZGF0YSBtYXAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IE1ldGFkYXRhIG9iamVjdCBiYXNlZCBmaWVsZHMgaW4gYSBnaXZlbiBJbmNvbWluZ0h0dHBIZWFkZXJzXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSBoZWFkZXJzIEFuIEluY29taW5nSHR0cEhlYWRlcnMgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1ldGFkYXRhKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAvLyBSZXNlcnZlZCBoZWFkZXJzIChiZWdpbm5pbmcgd2l0aCBgOmApIGFyZSBub3QgdmFsaWQga2V5cy5cbiAgICAgICAgICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmluYXJ5S2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2YWx1ZSwgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXN0b21NZXRhZGF0YShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNwbGl0KCcsJykuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHYudHJpbSgpLCAnYmFzZTY0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHZhbHVlcywgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZhaWxlZCB0byBhZGQgbWV0YWRhdGEgZW50cnkgJHtrZXl9OiAke3ZhbHVlc30uICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnJvcil9LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL2lzc3Vlcy8xMTczYDtcbiAgICAgICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuTWV0YWRhdGEgPSBNZXRhZGF0YTtcbmNvbnN0IGJ1ZlRvU3RyaW5nID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsKSA/IHZhbC50b1N0cmluZygnYmFzZTY0JykgOiB2YWw7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTWV0YWRhdGEiLCJsb2dnaW5nXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJlcnJvcl8xIiwiTEVHQUxfS0VZX1JFR0VYIiwiTEVHQUxfTk9OX0JJTkFSWV9WQUxVRV9SRUdFWCIsImlzTGVnYWxLZXkiLCJrZXkiLCJ0ZXN0IiwiaXNMZWdhbE5vbkJpbmFyeVZhbHVlIiwiaXNCaW5hcnlLZXkiLCJlbmRzV2l0aCIsImlzQ3VzdG9tTWV0YWRhdGEiLCJzdGFydHNXaXRoIiwibm9ybWFsaXplS2V5IiwidG9Mb3dlckNhc2UiLCJ2YWxpZGF0ZSIsIkVycm9yIiwidW5kZWZpbmVkIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJpbnRlcm5hbFJlcHIiLCJNYXAiLCJzZXQiLCJhZGQiLCJleGlzdGluZ1ZhbHVlIiwiZ2V0IiwicHVzaCIsInJlbW92ZSIsImRlbGV0ZSIsImdldE1hcCIsInJlc3VsdCIsInZhbHVlcyIsImxlbmd0aCIsInYiLCJmcm9tIiwiY2xvbmUiLCJuZXdNZXRhZGF0YSIsIm5ld0ludGVybmFsUmVwciIsImNsb25lZFZhbHVlIiwibWFwIiwibWVyZ2UiLCJvdGhlciIsIm1lcmdlZFZhbHVlIiwiY29uY2F0Iiwic2V0T3B0aW9ucyIsImdldE9wdGlvbnMiLCJ0b0h0dHAySGVhZGVycyIsImJ1ZlRvU3RyaW5nIiwidG9KU09OIiwiZnJvbUh0dHAySGVhZGVycyIsImhlYWRlcnMiLCJrZXlzIiwiY2hhckF0IiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInNwbGl0IiwidHJpbSIsImVycm9yIiwibWVzc2FnZSIsImdldEVycm9yTWVzc2FnZSIsImxvZyIsIkxvZ1ZlcmJvc2l0eSIsIkVSUk9SIiwidmFsIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/picker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nvar PickResultType;\n(function(PickResultType) {\n    PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\n    PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\n    PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n    PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\n})(PickResultType || (exports.PickResultType = PickResultType = {}));\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */ class UnavailablePicker {\n    constructor(status){\n        this.status = Object.assign({\n            code: constants_1.Status.UNAVAILABLE,\n            details: \"No connection established\",\n            metadata: new metadata_1.Metadata()\n        }, status);\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: PickResultType.TRANSIENT_FAILURE,\n            subchannel: null,\n            status: this.status,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n}\nexports.UnavailablePicker = UnavailablePicker;\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n */ class QueuePicker {\n    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n    constructor(loadBalancer){\n        this.loadBalancer = loadBalancer;\n        this.calledExitIdle = false;\n    }\n    pick(pickArgs) {\n        if (!this.calledExitIdle) {\n            process.nextTick(()=>{\n                this.loadBalancer.exitIdle();\n            });\n            this.calledExitIdle = true;\n        }\n        return {\n            pickResultType: PickResultType.QUEUE,\n            subchannel: null,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n}\nexports.QueuePicker = QueuePicker; //# sourceMappingURL=picker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLHlCQUF5QixHQUFHQSxzQkFBc0IsR0FBRyxLQUFLO0FBQ2hGLE1BQU1LLGFBQWFDLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLElBQUlGO0FBQ0gsVUFBVUEsY0FBYztJQUNyQkEsY0FBYyxDQUFDQSxjQUFjLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztJQUNqREEsY0FBYyxDQUFDQSxjQUFjLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQzFEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0FBQ2pELEdBQUdBLGtCQUFtQkosQ0FBQUEsc0JBQXNCLEdBQUdJLGlCQUFpQixDQUFDO0FBQ2pFOzs7Q0FHQyxHQUNELE1BQU1EO0lBQ0ZLLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQixJQUFJLENBQUNBLE1BQU0sR0FBR1gsT0FBT1ksTUFBTSxDQUFDO1lBQUVDLE1BQU1KLFlBQVlLLE1BQU0sQ0FBQ0MsV0FBVztZQUFFQyxTQUFTO1lBQTZCQyxVQUFVLElBQUlWLFdBQVdXLFFBQVE7UUFBRyxHQUFHUDtJQUNySjtJQUNBUSxLQUFLQyxRQUFRLEVBQUU7UUFDWCxPQUFPO1lBQ0hDLGdCQUFnQmYsZUFBZWdCLGlCQUFpQjtZQUNoREMsWUFBWTtZQUNaWixRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQmEsZUFBZTtZQUNmQyxhQUFhO1FBQ2pCO0lBQ0o7QUFDSjtBQUNBdkIseUJBQXlCLEdBQUdHO0FBQzVCOzs7Ozs7Q0FNQyxHQUNELE1BQU1EO0lBQ0YsdUZBQXVGO0lBQ3ZGTSxZQUFZZ0IsWUFBWSxDQUFFO1FBQ3RCLElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNDLGNBQWMsR0FBRztJQUMxQjtJQUNBUixLQUFLQyxRQUFRLEVBQUU7UUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDTyxjQUFjLEVBQUU7WUFDdEJDLE9BQU9BLENBQUNDLFFBQVEsQ0FBQztnQkFDYixJQUFJLENBQUNILFlBQVksQ0FBQ0ksUUFBUTtZQUM5QjtZQUNBLElBQUksQ0FBQ0gsY0FBYyxHQUFHO1FBQzFCO1FBQ0EsT0FBTztZQUNITixnQkFBZ0JmLGVBQWV5QixLQUFLO1lBQ3BDUixZQUFZO1lBQ1paLFFBQVE7WUFDUmEsZUFBZTtZQUNmQyxhQUFhO1FBQ2pCO0lBQ0o7QUFDSjtBQUNBdkIsbUJBQW1CLEdBQUdFLGFBQ3RCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3BpY2tlci5qcz81N2U2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1ZXVlUGlja2VyID0gZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSB2b2lkIDA7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBQaWNrUmVzdWx0VHlwZTtcbihmdW5jdGlvbiAoUGlja1Jlc3VsdFR5cGUpIHtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkNPTVBMRVRFXCJdID0gMF0gPSBcIkNPTVBMRVRFXCI7XG4gICAgUGlja1Jlc3VsdFR5cGVbUGlja1Jlc3VsdFR5cGVbXCJRVUVVRVwiXSA9IDFdID0gXCJRVUVVRVwiO1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiVFJBTlNJRU5UX0ZBSUxVUkVcIl0gPSAyXSA9IFwiVFJBTlNJRU5UX0ZBSUxVUkVcIjtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkRST1BcIl0gPSAzXSA9IFwiRFJPUFwiO1xufSkoUGlja1Jlc3VsdFR5cGUgfHwgKGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSBQaWNrUmVzdWx0VHlwZSA9IHt9KSk7XG4vKipcbiAqIEEgc3RhbmRhcmQgcGlja2VyIHJlcHJlc2VudGluZyBhIGxvYWQgYmFsYW5jZXIgaW4gdGhlIFRSQU5TSUVOVF9GQUlMVVJFXG4gKiBzdGF0ZS4gQWx3YXlzIHJlc3BvbmRzIHRvIGV2ZXJ5IHBpY2sgcmVxdWVzdCB3aXRoIGFuIFVOQVZBSUxBQkxFIHN0YXR1cy5cbiAqL1xuY2xhc3MgVW5hdmFpbGFibGVQaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IE9iamVjdC5hc3NpZ24oeyBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsIGRldGFpbHM6ICdObyBjb25uZWN0aW9uIGVzdGFibGlzaGVkJywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSwgc3RhdHVzKTtcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IFBpY2tSZXN1bHRUeXBlLlRSQU5TSUVOVF9GQUlMVVJFLFxuICAgICAgICAgICAgc3ViY2hhbm5lbDogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IFVuYXZhaWxhYmxlUGlja2VyO1xuLyoqXG4gKiBBIHN0YW5kYXJkIHBpY2tlciByZXByZXNlbnRpbmcgYSBsb2FkIGJhbGFuY2VyIGluIHRoZSBJRExFIG9yIENPTk5FQ1RJTkdcbiAqIHN0YXRlLiBBbHdheXMgcmVzcG9uZHMgdG8gZXZlcnkgcGljayByZXF1ZXN0IHdpdGggYSBRVUVVRSBwaWNrIHJlc3VsdFxuICogaW5kaWNhdGluZyB0aGF0IHRoZSBwaWNrIHNob3VsZCBiZSB0cmllZCBhZ2FpbiB3aXRoIHRoZSBuZXh0IGBQaWNrZXJgLiBBbHNvXG4gKiByZXBvcnRzIGJhY2sgdG8gdGhlIGxvYWQgYmFsYW5jZXIgdGhhdCBhIGNvbm5lY3Rpb24gc2hvdWxkIGJlIGVzdGFibGlzaGVkXG4gKiBvbmNlIGFueSBwaWNrIGlzIGF0dGVtcHRlZC5cbiAqL1xuY2xhc3MgUXVldWVQaWNrZXIge1xuICAgIC8vIENvbnN0cnVjdGVkIHdpdGggYSBsb2FkIGJhbGFuY2VyLiBDYWxscyBleGl0SWRsZSBvbiBpdCB0aGUgZmlyc3QgdGltZSBwaWNrIGlzIGNhbGxlZFxuICAgIGNvbnN0cnVjdG9yKGxvYWRCYWxhbmNlcikge1xuICAgICAgICB0aGlzLmxvYWRCYWxhbmNlciA9IGxvYWRCYWxhbmNlcjtcbiAgICAgICAgdGhpcy5jYWxsZWRFeGl0SWRsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsZWRFeGl0SWRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWRFeGl0SWRsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBQaWNrUmVzdWx0VHlwZS5RVUVVRSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5RdWV1ZVBpY2tlciA9IFF1ZXVlUGlja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlja2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlF1ZXVlUGlja2VyIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJQaWNrUmVzdWx0VHlwZSIsIm1ldGFkYXRhXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJjb25zdHJ1Y3RvciIsInN0YXR1cyIsImFzc2lnbiIsImNvZGUiLCJTdGF0dXMiLCJVTkFWQUlMQUJMRSIsImRldGFpbHMiLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwicGljayIsInBpY2tBcmdzIiwicGlja1Jlc3VsdFR5cGUiLCJUUkFOU0lFTlRfRkFJTFVSRSIsInN1YmNoYW5uZWwiLCJvbkNhbGxTdGFydGVkIiwib25DYWxsRW5kZWQiLCJsb2FkQmFsYW5jZXIiLCJjYWxsZWRFeGl0SWRsZSIsInByb2Nlc3MiLCJuZXh0VGljayIsImV4aXRJZGxlIiwiUVVFVUUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-dns.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.DEFAULT_PORT = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst dns = __webpack_require__(/*! dns */ \"dns\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst TRACER_NAME = \"dns_resolver\";\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */ exports.DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */ function mergeArrays(...arrays) {\n    const result = [];\n    for(let i = 0; i < Math.max.apply(null, arrays.map((array)=>array.length)); i++){\n        for (const array of arrays){\n            if (i < array.length) {\n                result.push(array[i]);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */ class DnsResolver {\n    constructor(target, listener, channelOptions){\n        var _a, _b, _c;\n        this.target = target;\n        this.listener = listener;\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.continueResolving = false;\n        this.isNextResolutionTimerRunning = false;\n        this.isServiceConfigEnabled = true;\n        this.returnedIpResult = false;\n        trace(\"Resolver constructed for target \" + (0, uri_parser_1.uriToString)(target));\n        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n        if (hostPort === null) {\n            this.ipResult = null;\n            this.dnsHostname = null;\n            this.port = null;\n        } else {\n            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {\n                this.ipResult = [\n                    {\n                        host: hostPort.host,\n                        port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : exports.DEFAULT_PORT\n                    }\n                ];\n                this.dnsHostname = null;\n                this.port = null;\n            } else {\n                this.ipResult = null;\n                this.dnsHostname = hostPort.host;\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : exports.DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        if (channelOptions[\"grpc.service_config_disable_resolution\"] === 1) {\n            this.isServiceConfigEnabled = false;\n        }\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,\n            metadata: new metadata_1.Metadata()\n        };\n        const backoffOptions = {\n            initialDelay: channelOptions[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: channelOptions[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoff = new backoff_timeout_1.BackoffTimeout(()=>{\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, backoffOptions);\n        this.backoff.unref();\n        this.minTimeBetweenResolutionsMs = (_c = channelOptions[\"grpc.dns_min_time_between_resolutions_ms\"]) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n        this.nextResolutionTimer = setTimeout(()=>{}, 0);\n        clearTimeout(this.nextResolutionTimer);\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT lookups\n     */ startResolution() {\n        if (this.ipResult !== null) {\n            if (!this.returnedIpResult) {\n                trace(\"Returning IP address for target \" + (0, uri_parser_1.uriToString)(this.target));\n                setImmediate(()=>{\n                    this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n                });\n                this.returnedIpResult = true;\n            }\n            this.backoff.stop();\n            this.backoff.reset();\n            this.stopNextResolutionTimer();\n            return;\n        }\n        if (this.dnsHostname === null) {\n            trace(\"Failed to parse DNS address \" + (0, uri_parser_1.uriToString)(this.target));\n            setImmediate(()=>{\n                this.listener.onError({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,\n                    metadata: new metadata_1.Metadata()\n                });\n            });\n            this.stopNextResolutionTimer();\n        } else {\n            if (this.pendingLookupPromise !== null) {\n                return;\n            }\n            trace(\"Looking up DNS hostname \" + this.dnsHostname);\n            /* We clear out latestLookupResult here to ensure that it contains the\n             * latest result since the last time we started resolving. That way, the\n             * TXT resolution handler can use it, but only if it finishes second. We\n             * don't clear out any previous service config results because it's\n             * better to use a service config that's slightly out of date than to\n             * revert to an effectively blank one. */ this.latestLookupResult = null;\n            const hostname = this.dnsHostname;\n            /* We lookup both address families here and then split them up later\n             * because when looking up a single family, dns.lookup outputs an error\n             * if the name exists but there are no records for that family, and that\n             * error is indistinguishable from other kinds of errors */ this.pendingLookupPromise = dnsLookupPromise(hostname, {\n                all: true\n            });\n            this.pendingLookupPromise.then((addressList)=>{\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                this.pendingLookupPromise = null;\n                this.backoff.reset();\n                this.backoff.stop();\n                const ip4Addresses = addressList.filter((addr)=>addr.family === 4);\n                const ip6Addresses = addressList.filter((addr)=>addr.family === 6);\n                this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr)=>({\n                        host: addr.address,\n                        port: +this.port\n                    }));\n                const allAddressesString = \"[\" + this.latestLookupResult.map((addr)=>addr.host + \":\" + addr.port).join(\",\") + \"]\";\n                trace(\"Resolved addresses for target \" + (0, uri_parser_1.uriToString)(this.target) + \": \" + allAddressesString);\n                if (this.latestLookupResult.length === 0) {\n                    this.listener.onError(this.defaultResolutionError);\n                    return;\n                }\n                /* If the TXT lookup has not yet finished, both of the last two\n                 * arguments will be null, which is the equivalent of getting an\n                 * empty TXT response. When the TXT lookup does finish, its handler\n                 * can update the service config by using the same address list */ this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n            }, (err)=>{\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                trace(\"Resolution error for target \" + (0, uri_parser_1.uriToString)(this.target) + \": \" + err.message);\n                this.pendingLookupPromise = null;\n                this.stopNextResolutionTimer();\n                this.listener.onError(this.defaultResolutionError);\n            });\n            /* If there already is a still-pending TXT resolution, we can just use\n             * that result when it comes in */ if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {\n                /* We handle the TXT query promise differently than the others because\n                 * the name resolution attempt as a whole is a success even if the TXT\n                 * lookup fails */ this.pendingTxtPromise = resolveTxtPromise(hostname);\n                this.pendingTxtPromise.then((txtRecord)=>{\n                    if (this.pendingTxtPromise === null) {\n                        return;\n                    }\n                    this.pendingTxtPromise = null;\n                    try {\n                        this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);\n                    } catch (err) {\n                        this.latestServiceConfigError = {\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: `Parsing service config failed with error ${err.message}`,\n                            metadata: new metadata_1.Metadata()\n                        };\n                    }\n                    if (this.latestLookupResult !== null) {\n                        /* We rely here on the assumption that calling this function with\n                         * identical parameters will be essentialy idempotent, and calling\n                         * it with the same address list and a different service config\n                         * should result in a fast and seamless switchover. */ this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n                    }\n                }, (err)=>{\n                /* If TXT lookup fails we should do nothing, which means that we\n                     * continue to use the result of the most recent successful lookup,\n                     * or the default null config object if there has never been a\n                     * successful lookup. We do not set the latestServiceConfigError\n                     * here because that is specifically used for response validation\n                     * errors. We still need to handle this error so that it does not\n                     * bubble up as an unhandled promise rejection. */ });\n            }\n        }\n    }\n    startNextResolutionTimer() {\n        var _a, _b;\n        clearTimeout(this.nextResolutionTimer);\n        this.nextResolutionTimer = (_b = (_a = setTimeout(()=>{\n            this.stopNextResolutionTimer();\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.isNextResolutionTimerRunning = true;\n    }\n    stopNextResolutionTimer() {\n        clearTimeout(this.nextResolutionTimer);\n        this.isNextResolutionTimerRunning = false;\n    }\n    startResolutionWithBackoff() {\n        if (this.pendingLookupPromise === null) {\n            this.continueResolving = false;\n            this.backoff.runOnce();\n            this.startNextResolutionTimer();\n            this.startResolution();\n        }\n    }\n    updateResolution() {\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\n         * nextResolutionTimer or backoff timer is running, set the\n         * continueResolving flag to resolve when whichever of those timers\n         * fires. Otherwise, start resolving immediately. */ if (this.pendingLookupPromise === null) {\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n                if (this.isNextResolutionTimerRunning) {\n                    trace('resolution update delayed by \"min time between resolutions\" rate limit');\n                } else {\n                    trace(\"resolution update delayed by backoff timer until \" + this.backoff.getEndTime().toISOString());\n                }\n                this.continueResolving = true;\n            } else {\n                this.startResolutionWithBackoff();\n            }\n        }\n    }\n    /**\n     * Reset the resolver to the same state it had when it was created. In-flight\n     * DNS requests cannot be cancelled, but they are discarded and their results\n     * will be ignored.\n     */ destroy() {\n        this.continueResolving = false;\n        this.backoff.reset();\n        this.backoff.stop();\n        this.stopNextResolutionTimer();\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.returnedIpResult = false;\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */ static getDefaultAuthority(target) {\n        return target.path;\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */ function setup() {\n    (0, resolver_1.registerResolver)(\"dns\", DnsResolver);\n    (0, resolver_1.registerDefaultScheme)(\"dns\");\n}\nexports.setup = setup; //# sourceMappingURL=resolver-dns.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUM1QyxNQUFNSSxhQUFhQyxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNQyxNQUFNRCxtQkFBT0EsQ0FBQyxnQkFBSztBQUN6QixNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNRyxtQkFBbUJILG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNuRCxNQUFNSSxjQUFjSixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNSyxhQUFhTCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTyxjQUFjUCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNUSxlQUFlUixtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNUyxRQUFRVCxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNVSxvQkFBb0JWLG1CQUFPQSxDQUFDLDBGQUFtQjtBQUNyRCxNQUFNVyxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZlAsUUFBUU0sS0FBSyxDQUFDTCxZQUFZTyxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQTs7Q0FFQyxHQUNEbEIsb0JBQW9CLEdBQUc7QUFDdkIsTUFBTXFCLDBDQUEwQztBQUNoRCxNQUFNQyxvQkFBb0JmLEtBQUtnQixTQUFTLENBQUNqQixJQUFJa0IsVUFBVTtBQUN2RCxNQUFNQyxtQkFBbUJsQixLQUFLZ0IsU0FBUyxDQUFDakIsSUFBSW9CLE1BQU07QUFDbEQ7OztDQUdDLEdBQ0QsU0FBU0MsWUFBWSxHQUFHQyxNQUFNO0lBQzFC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QixHQUFHO1FBQ3pCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztRQUMzQixJQUFJLENBQUNDLHdCQUF3QixHQUFHO1FBQ2hDLElBQUksQ0FBQ0ksZ0JBQWdCLEdBQUc7SUFDNUI7SUFDQTs7OztLQUlDLEdBQ0QsT0FBTzhELG9CQUFvQjVFLE1BQU0sRUFBRTtRQUMvQixPQUFPQSxPQUFPa0IsSUFBSTtJQUN0QjtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU3hEO0lBQ0osSUFBR0UsV0FBV2lILGdCQUFnQixFQUFFLE9BQU8vRTtJQUN2QyxJQUFHbEMsV0FBV2tILHFCQUFxQixFQUFFO0FBQzFDO0FBQ0F0SCxhQUFhLEdBQUdFLE9BQ2hCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLWRucy5qcz83MWU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLkRFRkFVTFRfUE9SVCA9IHZvaWQgMDtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGRucyA9IHJlcXVpcmUoXCJkbnNcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBzZXJ2aWNlX2NvbmZpZ18xID0gcmVxdWlyZShcIi4vc2VydmljZS1jb25maWdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdkbnNfcmVzb2x2ZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IFRDUCBwb3J0IHRvIGNvbm5lY3QgdG8gaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZSB0YXJnZXQuXG4gKi9cbmV4cG9ydHMuREVGQVVMVF9QT1JUID0gNDQzO1xuY29uc3QgREVGQVVMVF9NSU5fVElNRV9CRVRXRUVOX1JFU09MVVRJT05TX01TID0gMzAwMDA7XG5jb25zdCByZXNvbHZlVHh0UHJvbWlzZSA9IHV0aWwucHJvbWlzaWZ5KGRucy5yZXNvbHZlVHh0KTtcbmNvbnN0IGRuc0xvb2t1cFByb21pc2UgPSB1dGlsLnByb21pc2lmeShkbnMubG9va3VwKTtcbi8qKlxuICogTWVyZ2UgYW55IG51bWJlciBvZiBhcnJheXMgaW50byBhIHNpbmdsZSBhbHRlcm5hdGluZyBhcnJheVxuICogQHBhcmFtIGFycmF5c1xuICovXG5mdW5jdGlvbiBtZXJnZUFycmF5cyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8XG4gICAgICAgIE1hdGgubWF4LmFwcGx5KG51bGwsIGFycmF5cy5tYXAoYXJyYXkgPT4gYXJyYXkubGVuZ3RoKSk7IGkrKykge1xuICAgICAgICBmb3IgKGNvbnN0IGFycmF5IG9mIGFycmF5cykge1xuICAgICAgICAgICAgaWYgKGkgPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmVzb2x2ZXIgaW1wbGVtZW50YXRpb24gdGhhdCBoYW5kbGVzIEROUyBuYW1lcyBhbmQgSVAgYWRkcmVzc2VzLlxuICovXG5jbGFzcyBEbnNSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTZXJ2aWNlQ29uZmlnRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucmV0dXJuZWRJcFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB0cmFjZSgnUmVzb2x2ZXIgY29uc3RydWN0ZWQgZm9yIHRhcmdldCAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSk7XG4gICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXQucGF0aCk7XG4gICAgICAgIGlmIChob3N0UG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKDAsIG5ldF8xLmlzSVB2NCkoaG9zdFBvcnQuaG9zdCkgfHwgKDAsIG5ldF8xLmlzSVB2NikoaG9zdFBvcnQuaG9zdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlwUmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogKF9hID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhwb3J0cy5ERUZBVUxUX1BPUlQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IGhvc3RQb3J0Lmhvc3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gKF9iID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXhwb3J0cy5ERUZBVUxUX1BPUlQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZXJjZW50YWdlID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgICAgaWYgKGNoYW5uZWxPcHRpb25zWydncnBjLnNlcnZpY2VfY29uZmlnX2Rpc2FibGVfcmVzb2x1dGlvbiddID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmlzU2VydmljZUNvbmZpZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IgPSB7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICBkZXRhaWxzOiBgTmFtZSByZXNvbHV0aW9uIGZhaWxlZCBmb3IgdGFyZ2V0ICR7KDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpfWAsXG4gICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYmFja29mZk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlc29sdXRpb25XaXRoQmFja29mZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFja29mZi51bnJlZigpO1xuICAgICAgICB0aGlzLm1pblRpbWVCZXR3ZWVuUmVzb2x1dGlvbnNNcyA9XG4gICAgICAgICAgICAoX2MgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5kbnNfbWluX3RpbWVfYmV0d2Vlbl9yZXNvbHV0aW9uc19tcyddKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01JTl9USU1FX0JFVFdFRU5fUkVTT0xVVElPTlNfTVM7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB0YXJnZXQgaXMgYW4gSVAgYWRkcmVzcywganVzdCBwcm92aWRlIHRoYXQgYWRkcmVzcyBhcyBhIHJlc3VsdC5cbiAgICAgKiBPdGhlcndpc2UsIGluaXRpYXRlIEEsIEFBQUEsIGFuZCBUWFQgbG9va3Vwc1xuICAgICAqL1xuICAgIHN0YXJ0UmVzb2x1dGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXBSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXR1cm5lZElwUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1JldHVybmluZyBJUCBhZGRyZXNzIGZvciB0YXJnZXQgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMuaXBSZXN1bHQsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybmVkSXBSZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRuc0hvc3RuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFjZSgnRmFpbGVkIHRvIHBhcnNlIEROUyBhZGRyZXNzICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkpO1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgRE5TIGFkZHJlc3MgJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCl9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2UoJ0xvb2tpbmcgdXAgRE5TIGhvc3RuYW1lICcgKyB0aGlzLmRuc0hvc3RuYW1lKTtcbiAgICAgICAgICAgIC8qIFdlIGNsZWFyIG91dCBsYXRlc3RMb29rdXBSZXN1bHQgaGVyZSB0byBlbnN1cmUgdGhhdCBpdCBjb250YWlucyB0aGVcbiAgICAgICAgICAgICAqIGxhdGVzdCByZXN1bHQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzdGFydGVkIHJlc29sdmluZy4gVGhhdCB3YXksIHRoZVxuICAgICAgICAgICAgICogVFhUIHJlc29sdXRpb24gaGFuZGxlciBjYW4gdXNlIGl0LCBidXQgb25seSBpZiBpdCBmaW5pc2hlcyBzZWNvbmQuIFdlXG4gICAgICAgICAgICAgKiBkb24ndCBjbGVhciBvdXQgYW55IHByZXZpb3VzIHNlcnZpY2UgY29uZmlnIHJlc3VsdHMgYmVjYXVzZSBpdCdzXG4gICAgICAgICAgICAgKiBiZXR0ZXIgdG8gdXNlIGEgc2VydmljZSBjb25maWcgdGhhdCdzIHNsaWdodGx5IG91dCBvZiBkYXRlIHRoYW4gdG9cbiAgICAgICAgICAgICAqIHJldmVydCB0byBhbiBlZmZlY3RpdmVseSBibGFuayBvbmUuICovXG4gICAgICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBob3N0bmFtZSA9IHRoaXMuZG5zSG9zdG5hbWU7XG4gICAgICAgICAgICAvKiBXZSBsb29rdXAgYm90aCBhZGRyZXNzIGZhbWlsaWVzIGhlcmUgYW5kIHRoZW4gc3BsaXQgdGhlbSB1cCBsYXRlclxuICAgICAgICAgICAgICogYmVjYXVzZSB3aGVuIGxvb2tpbmcgdXAgYSBzaW5nbGUgZmFtaWx5LCBkbnMubG9va3VwIG91dHB1dHMgYW4gZXJyb3JcbiAgICAgICAgICAgICAqIGlmIHRoZSBuYW1lIGV4aXN0cyBidXQgdGhlcmUgYXJlIG5vIHJlY29yZHMgZm9yIHRoYXQgZmFtaWx5LCBhbmQgdGhhdFxuICAgICAgICAgICAgICogZXJyb3IgaXMgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBvdGhlciBraW5kcyBvZiBlcnJvcnMgKi9cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBkbnNMb29rdXBQcm9taXNlKGhvc3RuYW1lLCB7IGFsbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UudGhlbihhZGRyZXNzTGlzdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYuc3RvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlwNEFkZHJlc3NlcyA9IGFkZHJlc3NMaXN0LmZpbHRlcihhZGRyID0+IGFkZHIuZmFtaWx5ID09PSA0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpcDZBZGRyZXNzZXMgPSBhZGRyZXNzTGlzdC5maWx0ZXIoYWRkciA9PiBhZGRyLmZhbWlseSA9PT0gNik7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBtZXJnZUFycmF5cyhpcDZBZGRyZXNzZXMsIGlwNEFkZHJlc3NlcykubWFwKGFkZHIgPT4gKHsgaG9zdDogYWRkci5hZGRyZXNzLCBwb3J0OiArdGhpcy5wb3J0IH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxBZGRyZXNzZXNTdHJpbmcgPSAnWycgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChhZGRyID0+IGFkZHIuaG9zdCArICc6JyArIGFkZHIucG9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsJykgK1xuICAgICAgICAgICAgICAgICAgICAnXSc7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1Jlc29sdmVkIGFkZHJlc3NlcyBmb3IgdGFyZ2V0ICcgK1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgYWxsQWRkcmVzc2VzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXRlc3RMb29rdXBSZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBUWFQgbG9va3VwIGhhcyBub3QgeWV0IGZpbmlzaGVkLCBib3RoIG9mIHRoZSBsYXN0IHR3b1xuICAgICAgICAgICAgICAgICAqIGFyZ3VtZW50cyB3aWxsIGJlIG51bGwsIHdoaWNoIGlzIHRoZSBlcXVpdmFsZW50IG9mIGdldHRpbmcgYW5cbiAgICAgICAgICAgICAgICAgKiBlbXB0eSBUWFQgcmVzcG9uc2UuIFdoZW4gdGhlIFRYVCBsb29rdXAgZG9lcyBmaW5pc2gsIGl0cyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICogY2FuIHVwZGF0ZSB0aGUgc2VydmljZSBjb25maWcgYnkgdXNpbmcgdGhlIHNhbWUgYWRkcmVzcyBsaXN0ICovXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0LCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yLCBudWxsLCB7fSk7XG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1Jlc29sdXRpb24gZXJyb3IgZm9yIHRhcmdldCAnICtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHRoaXMuZGVmYXVsdFJlc29sdXRpb25FcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qIElmIHRoZXJlIGFscmVhZHkgaXMgYSBzdGlsbC1wZW5kaW5nIFRYVCByZXNvbHV0aW9uLCB3ZSBjYW4ganVzdCB1c2VcbiAgICAgICAgICAgICAqIHRoYXQgcmVzdWx0IHdoZW4gaXQgY29tZXMgaW4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2VydmljZUNvbmZpZ0VuYWJsZWQgJiYgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8qIFdlIGhhbmRsZSB0aGUgVFhUIHF1ZXJ5IHByb21pc2UgZGlmZmVyZW50bHkgdGhhbiB0aGUgb3RoZXJzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgKiB0aGUgbmFtZSByZXNvbHV0aW9uIGF0dGVtcHQgYXMgYSB3aG9sZSBpcyBhIHN1Y2Nlc3MgZXZlbiBpZiB0aGUgVFhUXG4gICAgICAgICAgICAgICAgICogbG9va3VwIGZhaWxzICovXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9IHJlc29sdmVUeHRQcm9taXNlKGhvc3RuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlLnRoZW4odHh0UmVjb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1R4dFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZyA9ICgwLCBzZXJ2aWNlX2NvbmZpZ18xLmV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnKSh0eHRSZWNvcmQsIHRoaXMucGVyY2VudGFnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBQYXJzaW5nIHNlcnZpY2UgY29uZmlnIGZhaWxlZCB3aXRoIGVycm9yICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBXZSByZWx5IGhlcmUgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICogaWRlbnRpY2FsIHBhcmFtZXRlcnMgd2lsbCBiZSBlc3NlbnRpYWx5IGlkZW1wb3RlbnQsIGFuZCBjYWxsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCB3aXRoIHRoZSBzYW1lIGFkZHJlc3MgbGlzdCBhbmQgYSBkaWZmZXJlbnQgc2VydmljZSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNob3VsZCByZXN1bHQgaW4gYSBmYXN0IGFuZCBzZWFtbGVzcyBzd2l0Y2hvdmVyLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0LCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yLCBudWxsLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiBUWFQgbG9va3VwIGZhaWxzIHdlIHNob3VsZCBkbyBub3RoaW5nLCB3aGljaCBtZWFucyB0aGF0IHdlXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnRpbnVlIHRvIHVzZSB0aGUgcmVzdWx0IG9mIHRoZSBtb3N0IHJlY2VudCBzdWNjZXNzZnVsIGxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICogb3IgdGhlIGRlZmF1bHQgbnVsbCBjb25maWcgb2JqZWN0IGlmIHRoZXJlIGhhcyBuZXZlciBiZWVuIGFcbiAgICAgICAgICAgICAgICAgICAgICogc3VjY2Vzc2Z1bCBsb29rdXAuIFdlIGRvIG5vdCBzZXQgdGhlIGxhdGVzdFNlcnZpY2VDb25maWdFcnJvclxuICAgICAgICAgICAgICAgICAgICAgKiBoZXJlIGJlY2F1c2UgdGhhdCBpcyBzcGVjaWZpY2FsbHkgdXNlZCBmb3IgcmVzcG9uc2UgdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiBlcnJvcnMuIFdlIHN0aWxsIG5lZWQgdG8gaGFuZGxlIHRoaXMgZXJyb3Igc28gdGhhdCBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgICAgKiBidWJibGUgdXAgYXMgYW4gdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uLiAqL1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0TmV4dFJlc29sdXRpb25UaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IChfYiA9IChfYSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMubWluVGltZUJldHdlZW5SZXNvbHV0aW9uc01zKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xuICAgICAgICB0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucnVuT25jZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFydE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgLyogSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGxvb2t1cCwganVzdCBsZXQgaXQgZmluaXNoLiBPdGhlcndpc2UsIGlmIHRoZVxuICAgICAgICAgKiBuZXh0UmVzb2x1dGlvblRpbWVyIG9yIGJhY2tvZmYgdGltZXIgaXMgcnVubmluZywgc2V0IHRoZVxuICAgICAgICAgKiBjb250aW51ZVJlc29sdmluZyBmbGFnIHRvIHJlc29sdmUgd2hlbiB3aGljaGV2ZXIgb2YgdGhvc2UgdGltZXJzXG4gICAgICAgICAqIGZpcmVzLiBPdGhlcndpc2UsIHN0YXJ0IHJlc29sdmluZyBpbW1lZGlhdGVseS4gKi9cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgfHwgdGhpcy5iYWNrb2ZmLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgncmVzb2x1dGlvbiB1cGRhdGUgZGVsYXllZCBieSBcIm1pbiB0aW1lIGJldHdlZW4gcmVzb2x1dGlvbnNcIiByYXRlIGxpbWl0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgncmVzb2x1dGlvbiB1cGRhdGUgZGVsYXllZCBieSBiYWNrb2ZmIHRpbWVyIHVudGlsICcgKyB0aGlzLmJhY2tvZmYuZ2V0RW5kVGltZSgpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcmVzb2x2ZXIgdG8gdGhlIHNhbWUgc3RhdGUgaXQgaGFkIHdoZW4gaXQgd2FzIGNyZWF0ZWQuIEluLWZsaWdodFxuICAgICAqIEROUyByZXF1ZXN0cyBjYW5ub3QgYmUgY2FuY2VsbGVkLCBidXQgdGhleSBhcmUgZGlzY2FyZGVkIGFuZCB0aGVpciByZXN1bHRzXG4gICAgICogd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XG4gICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXR1cm5lZElwUmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCBhdXRob3JpdHkgZm9yIHRoZSBnaXZlbiB0YXJnZXQuIEZvciBJUCB0YXJnZXRzLCB0aGF0IGlzXG4gICAgICogdGhlIElQIGFkZHJlc3MuIEZvciBETlMgdGFyZ2V0cywgaXQgaXMgdGhlIGhvc3RuYW1lLlxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoO1xuICAgIH1cbn1cbi8qKlxuICogU2V0IHVwIHRoZSBETlMgcmVzb2x2ZXIgY2xhc3MgYnkgcmVnaXN0ZXJpbmcgaXQgYXMgdGhlIGhhbmRsZXIgZm9yIHRoZVxuICogXCJkbnM6XCIgcHJlZml4IGFuZCBhcyB0aGUgZGVmYXVsdCByZXNvbHZlci5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoJ2RucycsIERuc1Jlc29sdmVyKTtcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlckRlZmF1bHRTY2hlbWUpKCdkbnMnKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLWRucy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIkRFRkFVTFRfUE9SVCIsInJlc29sdmVyXzEiLCJyZXF1aXJlIiwiZG5zIiwidXRpbCIsInNlcnZpY2VfY29uZmlnXzEiLCJjb25zdGFudHNfMSIsIm1ldGFkYXRhXzEiLCJsb2dnaW5nIiwiY29uc3RhbnRzXzIiLCJ1cmlfcGFyc2VyXzEiLCJuZXRfMSIsImJhY2tvZmZfdGltZW91dF8xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIkRFRkFVTFRfTUlOX1RJTUVfQkVUV0VFTl9SRVNPTFVUSU9OU19NUyIsInJlc29sdmVUeHRQcm9taXNlIiwicHJvbWlzaWZ5IiwicmVzb2x2ZVR4dCIsImRuc0xvb2t1cFByb21pc2UiLCJsb29rdXAiLCJtZXJnZUFycmF5cyIsImFycmF5cyIsInJlc3VsdCIsImkiLCJNYXRoIiwibWF4IiwiYXBwbHkiLCJtYXAiLCJhcnJheSIsImxlbmd0aCIsInB1c2giLCJEbnNSZXNvbHZlciIsImNvbnN0cnVjdG9yIiwidGFyZ2V0IiwibGlzdGVuZXIiLCJjaGFubmVsT3B0aW9ucyIsIl9hIiwiX2IiLCJfYyIsInBlbmRpbmdMb29rdXBQcm9taXNlIiwicGVuZGluZ1R4dFByb21pc2UiLCJsYXRlc3RMb29rdXBSZXN1bHQiLCJsYXRlc3RTZXJ2aWNlQ29uZmlnIiwibGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yIiwiY29udGludWVSZXNvbHZpbmciLCJpc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nIiwiaXNTZXJ2aWNlQ29uZmlnRW5hYmxlZCIsInJldHVybmVkSXBSZXN1bHQiLCJ1cmlUb1N0cmluZyIsImhvc3RQb3J0Iiwic3BsaXRIb3N0UG9ydCIsInBhdGgiLCJpcFJlc3VsdCIsImRuc0hvc3RuYW1lIiwicG9ydCIsImlzSVB2NCIsImhvc3QiLCJpc0lQdjYiLCJwZXJjZW50YWdlIiwicmFuZG9tIiwiZGVmYXVsdFJlc29sdXRpb25FcnJvciIsImNvZGUiLCJTdGF0dXMiLCJVTkFWQUlMQUJMRSIsImRldGFpbHMiLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwiYmFja29mZk9wdGlvbnMiLCJpbml0aWFsRGVsYXkiLCJtYXhEZWxheSIsImJhY2tvZmYiLCJCYWNrb2ZmVGltZW91dCIsInN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmIiwidW5yZWYiLCJtaW5UaW1lQmV0d2VlblJlc29sdXRpb25zTXMiLCJuZXh0UmVzb2x1dGlvblRpbWVyIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInN0YXJ0UmVzb2x1dGlvbiIsInNldEltbWVkaWF0ZSIsIm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24iLCJzdG9wIiwicmVzZXQiLCJzdG9wTmV4dFJlc29sdXRpb25UaW1lciIsIm9uRXJyb3IiLCJob3N0bmFtZSIsImFsbCIsInRoZW4iLCJhZGRyZXNzTGlzdCIsImlwNEFkZHJlc3NlcyIsImZpbHRlciIsImFkZHIiLCJmYW1pbHkiLCJpcDZBZGRyZXNzZXMiLCJhZGRyZXNzIiwiYWxsQWRkcmVzc2VzU3RyaW5nIiwiam9pbiIsImVyciIsIm1lc3NhZ2UiLCJ0eHRSZWNvcmQiLCJleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyIsInN0YXJ0TmV4dFJlc29sdXRpb25UaW1lciIsImNhbGwiLCJydW5PbmNlIiwidXBkYXRlUmVzb2x1dGlvbiIsImlzUnVubmluZyIsImdldEVuZFRpbWUiLCJ0b0lTT1N0cmluZyIsImRlc3Ryb3kiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicmVnaXN0ZXJSZXNvbHZlciIsInJlZ2lzdGVyRGVmYXVsdFNjaGVtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"ip_resolver\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst IPV4_SCHEME = \"ipv4\";\nconst IPV6_SCHEME = \"ipv6\";\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */ const DEFAULT_PORT = 443;\nclass IpResolver {\n    constructor(target, listener, channelOptions){\n        var _a;\n        this.listener = listener;\n        this.addresses = [];\n        this.error = null;\n        this.hasReturnedResult = false;\n        trace(\"Resolver constructed for target \" + (0, uri_parser_1.uriToString)(target));\n        const addresses = [];\n        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\n            this.error = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Unrecognized scheme ${target.scheme} in IP resolver`,\n                metadata: new metadata_1.Metadata()\n            };\n            return;\n        }\n        const pathList = target.path.split(\",\");\n        for (const path of pathList){\n            const hostPort = (0, uri_parser_1.splitHostPort)(path);\n            if (hostPort === null) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata()\n                };\n                return;\n            }\n            if (target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host) || target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host)) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata()\n                };\n                return;\n            }\n            addresses.push({\n                host: hostPort.host,\n                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT\n            });\n        }\n        this.addresses = addresses;\n        trace(\"Parsed \" + target.scheme + \" address list \" + this.addresses);\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(()=>{\n                if (this.error) {\n                    this.listener.onError(this.error);\n                } else {\n                    this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});\n                }\n            });\n        }\n    }\n    destroy() {\n        this.hasReturnedResult = false;\n    }\n    static getDefaultAuthority(target) {\n        return target.path.split(\",\")[0];\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);\n    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);\n}\nexports.setup = setup; //# sourceMappingURL=resolver-ip.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBRyxLQUFLO0FBQ3JCLE1BQU1HLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1JLGVBQWVKLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1NLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmSCxRQUFRRSxLQUFLLENBQUNOLFlBQVlRLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBLE1BQU1HLGNBQWM7QUFDcEIsTUFBTUMsY0FBYztBQUNwQjs7Q0FFQyxHQUNELE1BQU1DLGVBQWU7QUFDckIsTUFBTUM7SUFDRkMsWUFBWUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLGNBQWMsQ0FBRTtRQUMxQyxJQUFJQztRQUNKLElBQUksQ0FBQ0YsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNHLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QmYsTUFBTSxxQ0FBcUMsQ0FBQyxHQUFHSCxhQUFhbUIsV0FBVyxFQUFFUDtRQUN6RSxNQUFNSSxZQUFZLEVBQUU7UUFDcEIsSUFBSSxDQUFFSixDQUFBQSxPQUFPUSxNQUFNLEtBQUtiLGVBQWVLLE9BQU9RLE1BQU0sS0FBS1osV0FBVSxHQUFJO1lBQ25FLElBQUksQ0FBQ1MsS0FBSyxHQUFHO2dCQUNUSSxNQUFNeEIsWUFBWXlCLE1BQU0sQ0FBQ0MsV0FBVztnQkFDcENDLFNBQVMsQ0FBQyxvQkFBb0IsRUFBRVosT0FBT1EsTUFBTSxDQUFDLGVBQWUsQ0FBQztnQkFDOURLLFVBQVUsSUFBSTNCLFdBQVc0QixRQUFRO1lBQ3JDO1lBQ0E7UUFDSjtRQUNBLE1BQU1DLFdBQVdmLE9BQU9nQixJQUFJLENBQUNDLEtBQUssQ0FBQztRQUNuQyxLQUFLLE1BQU1ELFFBQVFELFNBQVU7WUFDekIsTUFBTUcsV0FBVyxDQUFDLEdBQUc5QixhQUFhK0IsYUFBYSxFQUFFSDtZQUNqRCxJQUFJRSxhQUFhLE1BQU07Z0JBQ25CLElBQUksQ0FBQ2IsS0FBSyxHQUFHO29CQUNUSSxNQUFNeEIsWUFBWXlCLE1BQU0sQ0FBQ0MsV0FBVztvQkFDcENDLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRVosT0FBT1EsTUFBTSxDQUFDLFNBQVMsRUFBRVEsS0FBSyxDQUFDO29CQUMzREgsVUFBVSxJQUFJM0IsV0FBVzRCLFFBQVE7Z0JBQ3JDO2dCQUNBO1lBQ0o7WUFDQSxJQUFJLE9BQVFOLE1BQU0sS0FBS2IsZUFBZSxDQUFDLENBQUMsR0FBR1osTUFBTXFDLE1BQU0sRUFBRUYsU0FBU0csSUFBSSxLQUNqRXJCLE9BQU9RLE1BQU0sS0FBS1osZUFBZSxDQUFDLENBQUMsR0FBR2IsTUFBTXVDLE1BQU0sRUFBRUosU0FBU0csSUFBSSxHQUFJO2dCQUN0RSxJQUFJLENBQUNoQixLQUFLLEdBQUc7b0JBQ1RJLE1BQU14QixZQUFZeUIsTUFBTSxDQUFDQyxXQUFXO29CQUNwQ0MsU0FBUyxDQUFDLGdCQUFnQixFQUFFWixPQUFPUSxNQUFNLENBQUMsU0FBUyxFQUFFUSxLQUFLLENBQUM7b0JBQzNESCxVQUFVLElBQUkzQixXQUFXNEIsUUFBUTtnQkFDckM7Z0JBQ0E7WUFDSjtZQUNBVixVQUFVbUIsSUFBSSxDQUFDO2dCQUNYRixNQUFNSCxTQUFTRyxJQUFJO2dCQUNuQkcsTUFBTSxDQUFDckIsS0FBS2UsU0FBU00sSUFBSSxNQUFNLFFBQVFyQixPQUFPLEtBQUssSUFBSUEsS0FBS047WUFDaEU7UUFDSjtRQUNBLElBQUksQ0FBQ08sU0FBUyxHQUFHQTtRQUNqQmIsTUFBTSxZQUFZUyxPQUFPUSxNQUFNLEdBQUcsbUJBQW1CLElBQUksQ0FBQ0osU0FBUztJQUN2RTtJQUNBcUIsbUJBQW1CO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQ25CLGlCQUFpQixFQUFFO1lBQ3pCLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUc7WUFDekJvQixPQUFPQSxDQUFDQyxRQUFRLENBQUM7Z0JBQ2IsSUFBSSxJQUFJLENBQUN0QixLQUFLLEVBQUU7b0JBQ1osSUFBSSxDQUFDSixRQUFRLENBQUMyQixPQUFPLENBQUMsSUFBSSxDQUFDdkIsS0FBSztnQkFDcEMsT0FDSztvQkFDRCxJQUFJLENBQUNKLFFBQVEsQ0FBQzRCLHNCQUFzQixDQUFDLElBQUksQ0FBQ3pCLFNBQVMsRUFBRSxNQUFNLE1BQU0sTUFBTSxDQUFDO2dCQUM1RTtZQUNKO1FBQ0o7SUFDSjtJQUNBMEIsVUFBVTtRQUNOLElBQUksQ0FBQ3hCLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0EsT0FBT3lCLG9CQUFvQi9CLE1BQU0sRUFBRTtRQUMvQixPQUFPQSxPQUFPZ0IsSUFBSSxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDcEM7QUFDSjtBQUNBLFNBQVNuQztJQUNKLElBQUdLLFdBQVc2QyxnQkFBZ0IsRUFBRXJDLGFBQWFHO0lBQzdDLElBQUdYLFdBQVc2QyxnQkFBZ0IsRUFBRXBDLGFBQWFFO0FBQ2xEO0FBQ0FsQixhQUFhLEdBQUdFLE9BQ2hCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLWlwLmpzPzdkMjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IHZvaWQgMDtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnaXBfcmVzb2x2ZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBJUFY0X1NDSEVNRSA9ICdpcHY0JztcbmNvbnN0IElQVjZfU0NIRU1FID0gJ2lwdjYnO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGUgdGFyZ2V0LlxuICovXG5jb25zdCBERUZBVUxUX1BPUlQgPSA0NDM7XG5jbGFzcyBJcFJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxpc3RlbmVyLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdHJhY2UoJ1Jlc29sdmVyIGNvbnN0cnVjdGVkIGZvciB0YXJnZXQgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCkpO1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNF9TQ0hFTUUgfHwgdGFyZ2V0LnNjaGVtZSA9PT0gSVBWNl9TQ0hFTUUpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgVW5yZWNvZ25pemVkIHNjaGVtZSAke3RhcmdldC5zY2hlbWV9IGluIElQIHJlc29sdmVyYCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aExpc3QgPSB0YXJnZXQucGF0aC5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aExpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KShwYXRoKTtcbiAgICAgICAgICAgIGlmIChob3N0UG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYEZhaWxlZCB0byBwYXJzZSAke3RhcmdldC5zY2hlbWV9IGFkZHJlc3MgJHtwYXRofWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YXJnZXQuc2NoZW1lID09PSBJUFY0X1NDSEVNRSAmJiAhKDAsIG5ldF8xLmlzSVB2NCkoaG9zdFBvcnQuaG9zdCkpIHx8XG4gICAgICAgICAgICAgICAgKHRhcmdldC5zY2hlbWUgPT09IElQVjZfU0NIRU1FICYmICEoMCwgbmV0XzEuaXNJUHY2KShob3N0UG9ydC5ob3N0KSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgJHt0YXJnZXQuc2NoZW1lfSBhZGRyZXNzICR7cGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxuICAgICAgICAgICAgICAgIHBvcnQ6IChfYSA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRfUE9SVCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gYWRkcmVzc2VzO1xuICAgICAgICB0cmFjZSgnUGFyc2VkICcgKyB0YXJnZXQuc2NoZW1lICsgJyBhZGRyZXNzIGxpc3QgJyArIHRoaXMuYWRkcmVzc2VzKTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JldHVybmVkUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmFkZHJlc3NlcywgbnVsbCwgbnVsbCwgbnVsbCwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQucGF0aC5zcGxpdCgnLCcpWzBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKElQVjRfU0NIRU1FLCBJcFJlc29sdmVyKTtcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyKShJUFY2X1NDSEVNRSwgSXBSZXNvbHZlcik7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci1pcC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIm5ldF8xIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwibWV0YWRhdGFfMSIsInJlc29sdmVyXzEiLCJ1cmlfcGFyc2VyXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIklQVjRfU0NIRU1FIiwiSVBWNl9TQ0hFTUUiLCJERUZBVUxUX1BPUlQiLCJJcFJlc29sdmVyIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJsaXN0ZW5lciIsImNoYW5uZWxPcHRpb25zIiwiX2EiLCJhZGRyZXNzZXMiLCJlcnJvciIsImhhc1JldHVybmVkUmVzdWx0IiwidXJpVG9TdHJpbmciLCJzY2hlbWUiLCJjb2RlIiwiU3RhdHVzIiwiVU5BVkFJTEFCTEUiLCJkZXRhaWxzIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsInBhdGhMaXN0IiwicGF0aCIsInNwbGl0IiwiaG9zdFBvcnQiLCJzcGxpdEhvc3RQb3J0IiwiaXNJUHY0IiwiaG9zdCIsImlzSVB2NiIsInB1c2giLCJwb3J0IiwidXBkYXRlUmVzb2x1dGlvbiIsInByb2Nlc3MiLCJuZXh0VGljayIsIm9uRXJyb3IiLCJvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uIiwiZGVzdHJveSIsImdldERlZmF1bHRBdXRob3JpdHkiLCJyZWdpc3RlclJlc29sdmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-uds.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nclass UdsResolver {\n    constructor(target, listener, channelOptions){\n        this.listener = listener;\n        this.addresses = [];\n        this.hasReturnedResult = false;\n        let path;\n        if (target.authority === \"\") {\n            path = \"/\" + target.path;\n        } else {\n            path = target.path;\n        }\n        this.addresses = [\n            {\n                path\n            }\n        ];\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});\n        }\n    }\n    destroy() {\n    // This resolver owns no resources, so we do nothing here.\n    }\n    static getDefaultAuthority(target) {\n        return \"localhost\";\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)(\"unix\", UdsResolver);\n}\nexports.setup = setup; //# sourceMappingURL=resolver-uds.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxhQUFhLEdBQUcsS0FBSztBQUNyQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNQztJQUNGQyxZQUFZQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsY0FBYyxDQUFFO1FBQzFDLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNFLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSUM7UUFDSixJQUFJTCxPQUFPTSxTQUFTLEtBQUssSUFBSTtZQUN6QkQsT0FBTyxNQUFNTCxPQUFPSyxJQUFJO1FBQzVCLE9BQ0s7WUFDREEsT0FBT0wsT0FBT0ssSUFBSTtRQUN0QjtRQUNBLElBQUksQ0FBQ0YsU0FBUyxHQUFHO1lBQUM7Z0JBQUVFO1lBQUs7U0FBRTtJQUMvQjtJQUNBRSxtQkFBbUI7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDSCxpQkFBaUIsRUFBRTtZQUN6QixJQUFJLENBQUNBLGlCQUFpQixHQUFHO1lBQ3pCSSxPQUFPQSxDQUFDQyxRQUFRLENBQUMsSUFBSSxDQUFDUixRQUFRLENBQUNTLHNCQUFzQixFQUFFLElBQUksQ0FBQ1AsU0FBUyxFQUFFLE1BQU0sTUFBTSxNQUFNLENBQUM7UUFDOUY7SUFDSjtJQUNBUSxVQUFVO0lBQ04sMERBQTBEO0lBQzlEO0lBQ0EsT0FBT0Msb0JBQW9CWixNQUFNLEVBQUU7UUFDL0IsT0FBTztJQUNYO0FBQ0o7QUFDQSxTQUFTTDtJQUNKLElBQUdDLFdBQVdpQixnQkFBZ0IsRUFBRSxRQUFRZjtBQUM3QztBQUNBTCxhQUFhLEdBQUdFLE9BQ2hCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLXVkcy5qcz82OTU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSB2b2lkIDA7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jbGFzcyBVZHNSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IFtdO1xuICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGxldCBwYXRoO1xuICAgICAgICBpZiAodGFyZ2V0LmF1dGhvcml0eSA9PT0gJycpIHtcbiAgICAgICAgICAgIHBhdGggPSAnLycgKyB0YXJnZXQucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSB0YXJnZXQucGF0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IFt7IHBhdGggfV07XG4gICAgfVxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgdGhpcy5hZGRyZXNzZXMsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBUaGlzIHJlc29sdmVyIG93bnMgbm8gcmVzb3VyY2VzLCBzbyB3ZSBkbyBub3RoaW5nIGhlcmUuXG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCkge1xuICAgICAgICByZXR1cm4gJ2xvY2FsaG9zdCc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoJ3VuaXgnLCBVZHNSZXNvbHZlcik7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci11ZHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2V0dXAiLCJyZXNvbHZlcl8xIiwicmVxdWlyZSIsIlVkc1Jlc29sdmVyIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJsaXN0ZW5lciIsImNoYW5uZWxPcHRpb25zIiwiYWRkcmVzc2VzIiwiaGFzUmV0dXJuZWRSZXN1bHQiLCJwYXRoIiwiYXV0aG9yaXR5IiwidXBkYXRlUmVzb2x1dGlvbiIsInByb2Nlc3MiLCJuZXh0VGljayIsIm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24iLCJkZXN0cm95IiwiZ2V0RGVmYXVsdEF1dGhvcml0eSIsInJlZ2lzdGVyUmVzb2x2ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */ function registerResolver(scheme, resolverClass) {\n    registeredResolvers[scheme] = resolverClass;\n}\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */ function registerDefaultScheme(scheme) {\n    defaultScheme = scheme;\n}\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */ function createResolver(target, listener, options) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return new registeredResolvers[target.scheme](target, listener, options);\n    } else {\n        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */ function getDefaultAuthority(target) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\n    } else {\n        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\nexports.getDefaultAuthority = getDefaultAuthority;\nfunction mapUriDefaultScheme(target) {\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n        if (defaultScheme !== null) {\n            return {\n                scheme: defaultScheme,\n                authority: undefined,\n                path: (0, uri_parser_1.uriToString)(target)\n            };\n        } else {\n            return null;\n        }\n    }\n    return target;\n}\nexports.mapUriDefaultScheme = mapUriDefaultScheme; //# sourceMappingURL=resolver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSwyQkFBMkIsR0FBR0Esc0JBQXNCLEdBQUdBLDZCQUE2QixHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQ3JKLE1BQU1PLGVBQWVDLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1DLHNCQUFzQixDQUFDO0FBQzdCLElBQUlDLGdCQUFnQjtBQUNwQjs7Ozs7O0NBTUMsR0FDRCxTQUFTSixpQkFBaUJLLE1BQU0sRUFBRUMsYUFBYTtJQUMzQ0gsbUJBQW1CLENBQUNFLE9BQU8sR0FBR0M7QUFDbEM7QUFDQVosd0JBQXdCLEdBQUdNO0FBQzNCOzs7O0NBSUMsR0FDRCxTQUFTRCxzQkFBc0JNLE1BQU07SUFDakNELGdCQUFnQkM7QUFDcEI7QUFDQVgsNkJBQTZCLEdBQUdLO0FBQ2hDOzs7OztDQUtDLEdBQ0QsU0FBU0QsZUFBZVMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLE9BQU87SUFDN0MsSUFBSUYsT0FBT0YsTUFBTSxLQUFLSyxhQUFhSCxPQUFPRixNQUFNLElBQUlGLHFCQUFxQjtRQUNyRSxPQUFPLElBQUlBLG1CQUFtQixDQUFDSSxPQUFPRixNQUFNLENBQUMsQ0FBQ0UsUUFBUUMsVUFBVUM7SUFDcEUsT0FDSztRQUNELE1BQU0sSUFBSUUsTUFBTSxDQUFDLHdDQUF3QyxFQUFFLENBQUMsR0FBR1YsYUFBYVcsV0FBVyxFQUFFTCxRQUFRLENBQUM7SUFDdEc7QUFDSjtBQUNBYixzQkFBc0IsR0FBR0k7QUFDekI7Ozs7Q0FJQyxHQUNELFNBQVNELG9CQUFvQlUsTUFBTTtJQUMvQixJQUFJQSxPQUFPRixNQUFNLEtBQUtLLGFBQWFILE9BQU9GLE1BQU0sSUFBSUYscUJBQXFCO1FBQ3JFLE9BQU9BLG1CQUFtQixDQUFDSSxPQUFPRixNQUFNLENBQUMsQ0FBQ1IsbUJBQW1CLENBQUNVO0lBQ2xFLE9BQ0s7UUFDRCxNQUFNLElBQUlJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxHQUFHVixhQUFhVyxXQUFXLEVBQUVMLFFBQVEsQ0FBQztJQUM3RTtBQUNKO0FBQ0FiLDJCQUEyQixHQUFHRztBQUM5QixTQUFTRCxvQkFBb0JXLE1BQU07SUFDL0IsSUFBSUEsT0FBT0YsTUFBTSxLQUFLSyxhQUFhLENBQUVILENBQUFBLE9BQU9GLE1BQU0sSUFBSUYsbUJBQWtCLEdBQUk7UUFDeEUsSUFBSUMsa0JBQWtCLE1BQU07WUFDeEIsT0FBTztnQkFDSEMsUUFBUUQ7Z0JBQ1JTLFdBQVdIO2dCQUNYSSxNQUFNLENBQUMsR0FBR2IsYUFBYVcsV0FBVyxFQUFFTDtZQUN4QztRQUNKLE9BQ0s7WUFDRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU9BO0FBQ1g7QUFDQWIsMkJBQTJCLEdBQUdFLHFCQUM5QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci5qcz8xZDk3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hcFVyaURlZmF1bHRTY2hlbWUgPSBleHBvcnRzLmdldERlZmF1bHRBdXRob3JpdHkgPSBleHBvcnRzLmNyZWF0ZVJlc29sdmVyID0gZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRTY2hlbWUgPSBleHBvcnRzLnJlZ2lzdGVyUmVzb2x2ZXIgPSB2b2lkIDA7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgcmVnaXN0ZXJlZFJlc29sdmVycyA9IHt9O1xubGV0IGRlZmF1bHRTY2hlbWUgPSBudWxsO1xuLyoqXG4gKiBSZWdpc3RlciBhIHJlc29sdmVyIGNsYXNzIHRvIGhhbmRsZSB0YXJnZXQgbmFtZXMgcHJlZml4ZWQgd2l0aCB0aGUgYHByZWZpeGBcbiAqIHN0cmluZy4gVGhpcyBwcmVmaXggc2hvdWxkIGNvcnJlc3BvbmQgdG8gYSBVUkkgc2NoZW1lIG5hbWUgbGlzdGVkIGluIHRoZVxuICogW2dSUEMgTmFtZSBSZXNvbHV0aW9uIGRvY3VtZW50XShodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2RvYy9uYW1pbmcubWQpXG4gKiBAcGFyYW0gcHJlZml4XG4gKiBAcGFyYW0gcmVzb2x2ZXJDbGFzc1xuICovXG5mdW5jdGlvbiByZWdpc3RlclJlc29sdmVyKHNjaGVtZSwgcmVzb2x2ZXJDbGFzcykge1xuICAgIHJlZ2lzdGVyZWRSZXNvbHZlcnNbc2NoZW1lXSA9IHJlc29sdmVyQ2xhc3M7XG59XG5leHBvcnRzLnJlZ2lzdGVyUmVzb2x2ZXIgPSByZWdpc3RlclJlc29sdmVyO1xuLyoqXG4gKiBSZWdpc3RlciBhIGRlZmF1bHQgcmVzb2x2ZXIgdG8gaGFuZGxlIHRhcmdldCBuYW1lcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoXG4gKiBhbnkgcmVnaXN0ZXJlZCBwcmVmaXguXG4gKiBAcGFyYW0gcmVzb2x2ZXJDbGFzc1xuICovXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRTY2hlbWUoc2NoZW1lKSB7XG4gICAgZGVmYXVsdFNjaGVtZSA9IHNjaGVtZTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0U2NoZW1lID0gcmVnaXN0ZXJEZWZhdWx0U2NoZW1lO1xuLyoqXG4gKiBDcmVhdGUgYSBuYW1lIHJlc29sdmVyIGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCwgaWYgcG9zc2libGUuIFRocm93cyBhblxuICogZXJyb3IgaWYgbm8gc3VjaCBuYW1lIHJlc29sdmVyIGNhbiBiZSBjcmVhdGVkLlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIGxpc3RlbmVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKHRhcmdldCwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykge1xuICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRSZXNvbHZlcnNbdGFyZ2V0LnNjaGVtZV0odGFyZ2V0LCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlc29sdmVyIGNvdWxkIGJlIGNyZWF0ZWQgZm9yIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGNyZWF0ZVJlc29sdmVyO1xuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgYXV0aG9yaXR5IGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCwgaWYgcG9zc2libGUuIFRocm93cyBhblxuICogZXJyb3IgaWYgbm8gcmVnaXN0ZXJlZCBuYW1lIHJlc29sdmVyIGNhbiBwYXJzZSB0aGF0IHRhcmdldCBzdHJpbmcuXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQuc2NoZW1lIGluIHJlZ2lzdGVyZWRSZXNvbHZlcnMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRSZXNvbHZlcnNbdGFyZ2V0LnNjaGVtZV0uZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREZWZhdWx0QXV0aG9yaXR5ID0gZ2V0RGVmYXVsdEF1dGhvcml0eTtcbmZ1bmN0aW9uIG1hcFVyaURlZmF1bHRTY2hlbWUodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgPT09IHVuZGVmaW5lZCB8fCAhKHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRTY2hlbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NoZW1lOiBkZWZhdWx0U2NoZW1lLFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBhdGg6ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmV4cG9ydHMubWFwVXJpRGVmYXVsdFNjaGVtZSA9IG1hcFVyaURlZmF1bHRTY2hlbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtYXBVcmlEZWZhdWx0U2NoZW1lIiwiZ2V0RGVmYXVsdEF1dGhvcml0eSIsImNyZWF0ZVJlc29sdmVyIiwicmVnaXN0ZXJEZWZhdWx0U2NoZW1lIiwicmVnaXN0ZXJSZXNvbHZlciIsInVyaV9wYXJzZXJfMSIsInJlcXVpcmUiLCJyZWdpc3RlcmVkUmVzb2x2ZXJzIiwiZGVmYXVsdFNjaGVtZSIsInNjaGVtZSIsInJlc29sdmVyQ2xhc3MiLCJ0YXJnZXQiLCJsaXN0ZW5lciIsIm9wdGlvbnMiLCJ1bmRlZmluZWQiLCJFcnJvciIsInVyaVRvU3RyaW5nIiwiYXV0aG9yaXR5IiwicGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-call.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ResolvingCall = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst TRACER_NAME = \"resolving_call\";\nclass ResolvingCall {\n    constructor(channel, method, options, filterStackFactory, credentials, callNumber){\n        this.channel = channel;\n        this.method = method;\n        this.filterStackFactory = filterStackFactory;\n        this.credentials = credentials;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.readFilterPending = false;\n        this.writeFilterPending = false;\n        this.pendingChildStatus = null;\n        this.metadata = null;\n        this.listener = null;\n        this.statusWatchers = [];\n        this.deadlineTimer = setTimeout(()=>{}, 0);\n        this.filterStack = null;\n        this.deadline = options.deadline;\n        this.host = options.host;\n        if (options.parentCall) {\n            if (options.flags & constants_1.Propagate.CANCELLATION) {\n                options.parentCall.on(\"cancelled\", ()=>{\n                    this.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled by parent call\");\n                });\n            }\n            if (options.flags & constants_1.Propagate.DEADLINE) {\n                this.trace(\"Propagating deadline from parent: \" + options.parentCall.getDeadline());\n                this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());\n            }\n        }\n        this.trace(\"Created\");\n        this.runDeadlineTimer();\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callNumber + \"] \" + text);\n    }\n    runDeadlineTimer() {\n        clearTimeout(this.deadlineTimer);\n        this.trace(\"Deadline: \" + (0, deadline_1.deadlineToString)(this.deadline));\n        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);\n        if (timeout !== Infinity) {\n            this.trace(\"Deadline will be reached in \" + timeout + \"ms\");\n            const handleDeadline = ()=>{\n                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, \"Deadline exceeded\");\n            };\n            if (timeout <= 0) {\n                process.nextTick(handleDeadline);\n            } else {\n                this.deadlineTimer = setTimeout(handleDeadline, timeout);\n            }\n        }\n    }\n    outputStatus(status) {\n        if (!this.ended) {\n            this.ended = true;\n            if (!this.filterStack) {\n                this.filterStack = this.filterStackFactory.createFilter();\n            }\n            clearTimeout(this.deadlineTimer);\n            const filteredStatus = this.filterStack.receiveTrailers(status);\n            this.trace(\"ended with status: code=\" + filteredStatus.code + ' details=\"' + filteredStatus.details + '\"');\n            this.statusWatchers.forEach((watcher)=>watcher(filteredStatus));\n            process.nextTick(()=>{\n                var _a;\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n            });\n        }\n    }\n    sendMessageOnChild(context, message) {\n        if (!this.child) {\n            throw new Error(\"sendMessageonChild called with child not populated\");\n        }\n        const child = this.child;\n        this.writeFilterPending = true;\n        this.filterStack.sendMessage(Promise.resolve({\n            message: message,\n            flags: context.flags\n        })).then((filteredMessage)=>{\n            this.writeFilterPending = false;\n            child.sendMessageWithContext(context, filteredMessage.message);\n            if (this.pendingHalfClose) {\n                child.halfClose();\n            }\n        }, (status)=>{\n            this.cancelWithStatus(status.code, status.details);\n        });\n    }\n    getConfig() {\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata || !this.listener) {\n            throw new Error(\"getConfig called before start\");\n        }\n        const configResult = this.channel.getConfig(this.method, this.metadata);\n        if (configResult.type === \"NONE\") {\n            this.channel.queueCallForConfig(this);\n            return;\n        } else if (configResult.type === \"ERROR\") {\n            if (this.metadata.getOptions().waitForReady) {\n                this.channel.queueCallForConfig(this);\n            } else {\n                this.outputStatus(configResult.error);\n            }\n            return;\n        }\n        // configResult.type === 'SUCCESS'\n        const config = configResult.config;\n        if (config.status !== constants_1.Status.OK) {\n            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, \"Failed to route call to method \" + this.method);\n            this.outputStatus({\n                code: code,\n                details: details,\n                metadata: new metadata_1.Metadata()\n            });\n            return;\n        }\n        if (config.methodConfig.timeout) {\n            const configDeadline = new Date();\n            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);\n            configDeadline.setMilliseconds(configDeadline.getMilliseconds() + config.methodConfig.timeout.nanos / 1000000);\n            this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);\n            this.runDeadlineTimer();\n        }\n        this.filterStackFactory.push(config.dynamicFilterFactories);\n        this.filterStack = this.filterStackFactory.createFilter();\n        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then((filteredMetadata)=>{\n            this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);\n            this.trace(\"Created child [\" + this.child.getCallNumber() + \"]\");\n            this.child.start(filteredMetadata, {\n                onReceiveMetadata: (metadata)=>{\n                    this.trace(\"Received metadata\");\n                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));\n                },\n                onReceiveMessage: (message)=>{\n                    this.trace(\"Received message\");\n                    this.readFilterPending = true;\n                    this.filterStack.receiveMessage(message).then((filteredMesssage)=>{\n                        this.trace(\"Finished filtering received message\");\n                        this.readFilterPending = false;\n                        this.listener.onReceiveMessage(filteredMesssage);\n                        if (this.pendingChildStatus) {\n                            this.outputStatus(this.pendingChildStatus);\n                        }\n                    }, (status)=>{\n                        this.cancelWithStatus(status.code, status.details);\n                    });\n                },\n                onReceiveStatus: (status)=>{\n                    this.trace(\"Received status\");\n                    if (this.readFilterPending) {\n                        this.pendingChildStatus = status;\n                    } else {\n                        this.outputStatus(status);\n                    }\n                }\n            });\n            if (this.readPending) {\n                this.child.startRead();\n            }\n            if (this.pendingMessage) {\n                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);\n            } else if (this.pendingHalfClose) {\n                this.child.halfClose();\n            }\n        }, (status)=>{\n            this.outputStatus(status);\n        });\n    }\n    reportResolverError(status) {\n        var _a;\n        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\n            this.channel.queueCallForConfig(this);\n        } else {\n            this.outputStatus(status);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({\n            code: status,\n            details: details,\n            metadata: new metadata_1.Metadata()\n        });\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace(\"start called\");\n        this.metadata = metadata.clone();\n        this.listener = listener;\n        this.getConfig();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace(\"write() called with message of length \" + message.length);\n        if (this.child) {\n            this.sendMessageOnChild(context, message);\n        } else {\n            this.pendingMessage = {\n                context,\n                message\n            };\n        }\n    }\n    startRead() {\n        this.trace(\"startRead called\");\n        if (this.child) {\n            this.child.startRead();\n        } else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace(\"halfClose called\");\n        if (this.child && !this.writeFilterPending) {\n            this.child.halfClose();\n        } else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        this.credentials = this.credentials.compose(credentials);\n    }\n    addStatusWatcher(watcher) {\n        this.statusWatchers.push(watcher);\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n}\nexports.ResolvingCall = ResolvingCall; //# sourceMappingURL=resolving-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWNhbGwuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBRyxLQUFLO0FBQzdCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1JLHlCQUF5QkosbUJBQU9BLENBQUMsb0dBQXdCO0FBQy9ELE1BQU1LLGNBQWM7QUFDcEIsTUFBTVA7SUFDRlEsWUFBWUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsa0JBQWtCLEVBQUVDLFdBQVcsRUFBRUMsVUFBVSxDQUFFO1FBQy9FLElBQUksQ0FBQ0wsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0Usa0JBQWtCLEdBQUdBO1FBQzFCLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxjQUFjLEdBQUcsRUFBRTtRQUN4QixJQUFJLENBQUNDLGFBQWEsR0FBR0MsV0FBVyxLQUFRLEdBQUc7UUFDM0MsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxRQUFRLEdBQUdsQixRQUFRa0IsUUFBUTtRQUNoQyxJQUFJLENBQUNDLElBQUksR0FBR25CLFFBQVFtQixJQUFJO1FBQ3hCLElBQUluQixRQUFRb0IsVUFBVSxFQUFFO1lBQ3BCLElBQUlwQixRQUFRcUIsS0FBSyxHQUFHL0IsWUFBWWdDLFNBQVMsQ0FBQ0MsWUFBWSxFQUFFO2dCQUNwRHZCLFFBQVFvQixVQUFVLENBQUNJLEVBQUUsQ0FBQyxhQUFhO29CQUMvQixJQUFJLENBQUNDLGdCQUFnQixDQUFDbkMsWUFBWW9DLE1BQU0sQ0FBQ0MsU0FBUyxFQUFFO2dCQUN4RDtZQUNKO1lBQ0EsSUFBSTNCLFFBQVFxQixLQUFLLEdBQUcvQixZQUFZZ0MsU0FBUyxDQUFDTSxRQUFRLEVBQUU7Z0JBQ2hELElBQUksQ0FBQ0MsS0FBSyxDQUFDLHVDQUNQN0IsUUFBUW9CLFVBQVUsQ0FBQ1UsV0FBVztnQkFDbEMsSUFBSSxDQUFDWixRQUFRLEdBQUcsQ0FBQyxHQUFHMUIsV0FBV3VDLFdBQVcsRUFBRSxJQUFJLENBQUNiLFFBQVEsRUFBRWxCLFFBQVFvQixVQUFVLENBQUNVLFdBQVc7WUFDN0Y7UUFDSjtRQUNBLElBQUksQ0FBQ0QsS0FBSyxDQUFDO1FBQ1gsSUFBSSxDQUFDRyxnQkFBZ0I7SUFDekI7SUFDQUgsTUFBTUksSUFBSSxFQUFFO1FBQ1J2QyxRQUFRbUMsS0FBSyxDQUFDdkMsWUFBWTRDLFlBQVksQ0FBQ0MsS0FBSyxFQUFFdkMsYUFBYSxNQUFNLElBQUksQ0FBQ08sVUFBVSxHQUFHLE9BQU84QjtJQUM5RjtJQUNBRCxtQkFBbUI7UUFDZkksYUFBYSxJQUFJLENBQUNyQixhQUFhO1FBQy9CLElBQUksQ0FBQ2MsS0FBSyxDQUFDLGVBQWUsQ0FBQyxHQUFHckMsV0FBVzZDLGdCQUFnQixFQUFFLElBQUksQ0FBQ25CLFFBQVE7UUFDeEUsTUFBTW9CLFVBQVUsQ0FBQyxHQUFHOUMsV0FBVytDLGtCQUFrQixFQUFFLElBQUksQ0FBQ3JCLFFBQVE7UUFDaEUsSUFBSW9CLFlBQVlFLFVBQVU7WUFDdEIsSUFBSSxDQUFDWCxLQUFLLENBQUMsaUNBQWlDUyxVQUFVO1lBQ3RELE1BQU1HLGlCQUFpQjtnQkFDbkIsSUFBSSxDQUFDaEIsZ0JBQWdCLENBQUNuQyxZQUFZb0MsTUFBTSxDQUFDZ0IsaUJBQWlCLEVBQUU7WUFDaEU7WUFDQSxJQUFJSixXQUFXLEdBQUc7Z0JBQ2RLLE9BQU9BLENBQUNDLFFBQVEsQ0FBQ0g7WUFDckIsT0FDSztnQkFDRCxJQUFJLENBQUMxQixhQUFhLEdBQUdDLFdBQVd5QixnQkFBZ0JIO1lBQ3BEO1FBQ0o7SUFDSjtJQUNBTyxhQUFhQyxNQUFNLEVBQUU7UUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQ3RDLEtBQUssRUFBRTtZQUNiLElBQUksQ0FBQ0EsS0FBSyxHQUFHO1lBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQ1MsV0FBVyxFQUFFO2dCQUNuQixJQUFJLENBQUNBLFdBQVcsR0FBRyxJQUFJLENBQUNoQixrQkFBa0IsQ0FBQzhDLFlBQVk7WUFDM0Q7WUFDQVgsYUFBYSxJQUFJLENBQUNyQixhQUFhO1lBQy9CLE1BQU1pQyxpQkFBaUIsSUFBSSxDQUFDL0IsV0FBVyxDQUFDZ0MsZUFBZSxDQUFDSDtZQUN4RCxJQUFJLENBQUNqQixLQUFLLENBQUMsNkJBQ1BtQixlQUFlRSxJQUFJLEdBQ25CLGVBQ0FGLGVBQWVHLE9BQU8sR0FDdEI7WUFDSixJQUFJLENBQUNyQyxjQUFjLENBQUNzQyxPQUFPLENBQUNDLENBQUFBLFVBQVdBLFFBQVFMO1lBQy9DTCxPQUFPQSxDQUFDQyxRQUFRLENBQUM7Z0JBQ2IsSUFBSVU7Z0JBQ0hBLENBQUFBLEtBQUssSUFBSSxDQUFDekMsUUFBUSxNQUFNLFFBQVF5QyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdDLGVBQWUsQ0FBQ1A7WUFDakY7UUFDSjtJQUNKO0lBQ0FRLG1CQUFtQkMsT0FBTyxFQUFFQyxPQUFPLEVBQUU7UUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQ3RELEtBQUssRUFBRTtZQUNiLE1BQU0sSUFBSXVELE1BQU07UUFDcEI7UUFDQSxNQUFNdkQsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDeEIsSUFBSSxDQUFDTSxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNPLFdBQVcsQ0FBQzJDLFdBQVcsQ0FBQ0MsUUFBUUMsT0FBTyxDQUFDO1lBQUVKLFNBQVNBO1lBQVNyQyxPQUFPb0MsUUFBUXBDLEtBQUs7UUFBQyxJQUFJMEMsSUFBSSxDQUFDQyxDQUFBQTtZQUMzRixJQUFJLENBQUN0RCxrQkFBa0IsR0FBRztZQUMxQk4sTUFBTTZELHNCQUFzQixDQUFDUixTQUFTTyxnQkFBZ0JOLE9BQU87WUFDN0QsSUFBSSxJQUFJLENBQUNuRCxnQkFBZ0IsRUFBRTtnQkFDdkJILE1BQU04RCxTQUFTO1lBQ25CO1FBQ0osR0FBRyxDQUFDcEI7WUFDQSxJQUFJLENBQUNyQixnQkFBZ0IsQ0FBQ3FCLE9BQU9JLElBQUksRUFBRUosT0FBT0ssT0FBTztRQUNyRDtJQUNKO0lBQ0FnQixZQUFZO1FBQ1IsSUFBSSxJQUFJLENBQUMzRCxLQUFLLEVBQUU7WUFDWjtRQUNKO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ0ksUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDQyxRQUFRLEVBQUU7WUFDbEMsTUFBTSxJQUFJOEMsTUFBTTtRQUNwQjtRQUNBLE1BQU1TLGVBQWUsSUFBSSxDQUFDdEUsT0FBTyxDQUFDcUUsU0FBUyxDQUFDLElBQUksQ0FBQ3BFLE1BQU0sRUFBRSxJQUFJLENBQUNhLFFBQVE7UUFDdEUsSUFBSXdELGFBQWFDLElBQUksS0FBSyxRQUFRO1lBQzlCLElBQUksQ0FBQ3ZFLE9BQU8sQ0FBQ3dFLGtCQUFrQixDQUFDLElBQUk7WUFDcEM7UUFDSixPQUNLLElBQUlGLGFBQWFDLElBQUksS0FBSyxTQUFTO1lBQ3BDLElBQUksSUFBSSxDQUFDekQsUUFBUSxDQUFDMkQsVUFBVSxHQUFHQyxZQUFZLEVBQUU7Z0JBQ3pDLElBQUksQ0FBQzFFLE9BQU8sQ0FBQ3dFLGtCQUFrQixDQUFDLElBQUk7WUFDeEMsT0FDSztnQkFDRCxJQUFJLENBQUN6QixZQUFZLENBQUN1QixhQUFhSyxLQUFLO1lBQ3hDO1lBQ0E7UUFDSjtRQUNBLGtDQUFrQztRQUNsQyxNQUFNQyxTQUFTTixhQUFhTSxNQUFNO1FBQ2xDLElBQUlBLE9BQU81QixNQUFNLEtBQUt4RCxZQUFZb0MsTUFBTSxDQUFDaUQsRUFBRSxFQUFFO1lBQ3pDLE1BQU0sRUFBRXpCLElBQUksRUFBRUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxHQUFHeEQsdUJBQXVCaUYsOEJBQThCLEVBQUVGLE9BQU81QixNQUFNLEVBQUUsb0NBQW9DLElBQUksQ0FBQy9DLE1BQU07WUFDbkosSUFBSSxDQUFDOEMsWUFBWSxDQUFDO2dCQUNkSyxNQUFNQTtnQkFDTkMsU0FBU0E7Z0JBQ1R2QyxVQUFVLElBQUluQixXQUFXb0YsUUFBUTtZQUNyQztZQUNBO1FBQ0o7UUFDQSxJQUFJSCxPQUFPSSxZQUFZLENBQUN4QyxPQUFPLEVBQUU7WUFDN0IsTUFBTXlDLGlCQUFpQixJQUFJQztZQUMzQkQsZUFBZUUsVUFBVSxDQUFDRixlQUFlRyxVQUFVLEtBQUtSLE9BQU9JLFlBQVksQ0FBQ3hDLE9BQU8sQ0FBQzZDLE9BQU87WUFDM0ZKLGVBQWVLLGVBQWUsQ0FBQ0wsZUFBZU0sZUFBZSxLQUN6RFgsT0FBT0ksWUFBWSxDQUFDeEMsT0FBTyxDQUFDZ0QsS0FBSyxHQUFHO1lBQ3hDLElBQUksQ0FBQ3BFLFFBQVEsR0FBRyxDQUFDLEdBQUcxQixXQUFXdUMsV0FBVyxFQUFFLElBQUksQ0FBQ2IsUUFBUSxFQUFFNkQ7WUFDM0QsSUFBSSxDQUFDL0MsZ0JBQWdCO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDL0Isa0JBQWtCLENBQUNzRixJQUFJLENBQUNiLE9BQU9jLHNCQUFzQjtRQUMxRCxJQUFJLENBQUN2RSxXQUFXLEdBQUcsSUFBSSxDQUFDaEIsa0JBQWtCLENBQUM4QyxZQUFZO1FBQ3ZELElBQUksQ0FBQzlCLFdBQVcsQ0FBQ3dFLFlBQVksQ0FBQzVCLFFBQVFDLE9BQU8sQ0FBQyxJQUFJLENBQUNsRCxRQUFRLEdBQUdtRCxJQUFJLENBQUMyQixDQUFBQTtZQUMvRCxJQUFJLENBQUN0RixLQUFLLEdBQUcsSUFBSSxDQUFDTixPQUFPLENBQUM2RixlQUFlLENBQUNqQixRQUFRLElBQUksQ0FBQzNFLE1BQU0sRUFBRSxJQUFJLENBQUNvQixJQUFJLEVBQUUsSUFBSSxDQUFDakIsV0FBVyxFQUFFLElBQUksQ0FBQ2dCLFFBQVE7WUFDekcsSUFBSSxDQUFDVyxLQUFLLENBQUMsb0JBQW9CLElBQUksQ0FBQ3pCLEtBQUssQ0FBQ3dGLGFBQWEsS0FBSztZQUM1RCxJQUFJLENBQUN4RixLQUFLLENBQUN5RixLQUFLLENBQUNILGtCQUFrQjtnQkFDL0JJLG1CQUFtQmxGLENBQUFBO29CQUNmLElBQUksQ0FBQ2lCLEtBQUssQ0FBQztvQkFDWCxJQUFJLENBQUNoQixRQUFRLENBQUNpRixpQkFBaUIsQ0FBQyxJQUFJLENBQUM3RSxXQUFXLENBQUM4RSxlQUFlLENBQUNuRjtnQkFDckU7Z0JBQ0FvRixrQkFBa0J0QyxDQUFBQTtvQkFDZCxJQUFJLENBQUM3QixLQUFLLENBQUM7b0JBQ1gsSUFBSSxDQUFDcEIsaUJBQWlCLEdBQUc7b0JBQ3pCLElBQUksQ0FBQ1EsV0FBVyxDQUFDZ0YsY0FBYyxDQUFDdkMsU0FBU0ssSUFBSSxDQUFDbUMsQ0FBQUE7d0JBQzFDLElBQUksQ0FBQ3JFLEtBQUssQ0FBQzt3QkFDWCxJQUFJLENBQUNwQixpQkFBaUIsR0FBRzt3QkFDekIsSUFBSSxDQUFDSSxRQUFRLENBQUNtRixnQkFBZ0IsQ0FBQ0U7d0JBQy9CLElBQUksSUFBSSxDQUFDdkYsa0JBQWtCLEVBQUU7NEJBQ3pCLElBQUksQ0FBQ2tDLFlBQVksQ0FBQyxJQUFJLENBQUNsQyxrQkFBa0I7d0JBQzdDO29CQUNKLEdBQUcsQ0FBQ21DO3dCQUNBLElBQUksQ0FBQ3JCLGdCQUFnQixDQUFDcUIsT0FBT0ksSUFBSSxFQUFFSixPQUFPSyxPQUFPO29CQUNyRDtnQkFDSjtnQkFDQUksaUJBQWlCVCxDQUFBQTtvQkFDYixJQUFJLENBQUNqQixLQUFLLENBQUM7b0JBQ1gsSUFBSSxJQUFJLENBQUNwQixpQkFBaUIsRUFBRTt3QkFDeEIsSUFBSSxDQUFDRSxrQkFBa0IsR0FBR21DO29CQUM5QixPQUNLO3dCQUNELElBQUksQ0FBQ0QsWUFBWSxDQUFDQztvQkFDdEI7Z0JBQ0o7WUFDSjtZQUNBLElBQUksSUFBSSxDQUFDekMsV0FBVyxFQUFFO2dCQUNsQixJQUFJLENBQUNELEtBQUssQ0FBQytGLFNBQVM7WUFDeEI7WUFDQSxJQUFJLElBQUksQ0FBQzdGLGNBQWMsRUFBRTtnQkFDckIsSUFBSSxDQUFDa0Qsa0JBQWtCLENBQUMsSUFBSSxDQUFDbEQsY0FBYyxDQUFDbUQsT0FBTyxFQUFFLElBQUksQ0FBQ25ELGNBQWMsQ0FBQ29ELE9BQU87WUFDcEYsT0FDSyxJQUFJLElBQUksQ0FBQ25ELGdCQUFnQixFQUFFO2dCQUM1QixJQUFJLENBQUNILEtBQUssQ0FBQzhELFNBQVM7WUFDeEI7UUFDSixHQUFHLENBQUNwQjtZQUNBLElBQUksQ0FBQ0QsWUFBWSxDQUFDQztRQUN0QjtJQUNKO0lBQ0FzRCxvQkFBb0J0RCxNQUFNLEVBQUU7UUFDeEIsSUFBSVE7UUFDSixJQUFJLENBQUNBLEtBQUssSUFBSSxDQUFDMUMsUUFBUSxNQUFNLFFBQVEwQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpQixVQUFVLEdBQUdDLFlBQVksRUFBRTtZQUN4RixJQUFJLENBQUMxRSxPQUFPLENBQUN3RSxrQkFBa0IsQ0FBQyxJQUFJO1FBQ3hDLE9BQ0s7WUFDRCxJQUFJLENBQUN6QixZQUFZLENBQUNDO1FBQ3RCO0lBQ0o7SUFDQXJCLGlCQUFpQnFCLE1BQU0sRUFBRUssT0FBTyxFQUFFO1FBQzlCLElBQUlHO1FBQ0osSUFBSSxDQUFDekIsS0FBSyxDQUFDLDRCQUE0QmlCLFNBQVMsZ0JBQWdCSyxVQUFVO1FBQ3pFRyxDQUFBQSxLQUFLLElBQUksQ0FBQ2xELEtBQUssTUFBTSxRQUFRa0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHN0IsZ0JBQWdCLENBQUNxQixRQUFRSztRQUNuRixJQUFJLENBQUNOLFlBQVksQ0FBQztZQUNkSyxNQUFNSjtZQUNOSyxTQUFTQTtZQUNUdkMsVUFBVSxJQUFJbkIsV0FBV29GLFFBQVE7UUFDckM7SUFDSjtJQUNBd0IsVUFBVTtRQUNOLElBQUkvQyxJQUFJZ0Q7UUFDUixPQUFPLENBQUNBLEtBQUssQ0FBQ2hELEtBQUssSUFBSSxDQUFDbEQsS0FBSyxNQUFNLFFBQVFrRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcrQyxPQUFPLEVBQUMsTUFBTyxRQUFRQyxPQUFPLEtBQUssSUFBSUEsS0FBSyxJQUFJLENBQUN4RyxPQUFPLENBQUN5RyxTQUFTO0lBQzdJO0lBQ0FWLE1BQU1qRixRQUFRLEVBQUVDLFFBQVEsRUFBRTtRQUN0QixJQUFJLENBQUNnQixLQUFLLENBQUM7UUFDWCxJQUFJLENBQUNqQixRQUFRLEdBQUdBLFNBQVM0RixLQUFLO1FBQzlCLElBQUksQ0FBQzNGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDc0QsU0FBUztJQUNsQjtJQUNBRix1QkFBdUJSLE9BQU8sRUFBRUMsT0FBTyxFQUFFO1FBQ3JDLElBQUksQ0FBQzdCLEtBQUssQ0FBQywyQ0FBMkM2QixRQUFRK0MsTUFBTTtRQUNwRSxJQUFJLElBQUksQ0FBQ3JHLEtBQUssRUFBRTtZQUNaLElBQUksQ0FBQ29ELGtCQUFrQixDQUFDQyxTQUFTQztRQUNyQyxPQUNLO1lBQ0QsSUFBSSxDQUFDcEQsY0FBYyxHQUFHO2dCQUFFbUQ7Z0JBQVNDO1lBQVE7UUFDN0M7SUFDSjtJQUNBeUMsWUFBWTtRQUNSLElBQUksQ0FBQ3RFLEtBQUssQ0FBQztRQUNYLElBQUksSUFBSSxDQUFDekIsS0FBSyxFQUFFO1lBQ1osSUFBSSxDQUFDQSxLQUFLLENBQUMrRixTQUFTO1FBQ3hCLE9BQ0s7WUFDRCxJQUFJLENBQUM5RixXQUFXLEdBQUc7UUFDdkI7SUFDSjtJQUNBNkQsWUFBWTtRQUNSLElBQUksQ0FBQ3JDLEtBQUssQ0FBQztRQUNYLElBQUksSUFBSSxDQUFDekIsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDTSxrQkFBa0IsRUFBRTtZQUN4QyxJQUFJLENBQUNOLEtBQUssQ0FBQzhELFNBQVM7UUFDeEIsT0FDSztZQUNELElBQUksQ0FBQzNELGdCQUFnQixHQUFHO1FBQzVCO0lBQ0o7SUFDQW1HLGVBQWV4RyxXQUFXLEVBQUU7UUFDeEIsSUFBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLENBQUN5RyxPQUFPLENBQUN6RztJQUNoRDtJQUNBMEcsaUJBQWlCdkQsT0FBTyxFQUFFO1FBQ3RCLElBQUksQ0FBQ3ZDLGNBQWMsQ0FBQ3lFLElBQUksQ0FBQ2xDO0lBQzdCO0lBQ0F1QyxnQkFBZ0I7UUFDWixPQUFPLElBQUksQ0FBQ3pGLFVBQVU7SUFDMUI7QUFDSjtBQUNBaEIscUJBQXFCLEdBQUdFLGVBQ3hCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmluZy1jYWxsLmpzPzYxYWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb2x2aW5nQ2FsbCA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZGVhZGxpbmVfMSA9IHJlcXVpcmUoXCIuL2RlYWRsaW5lXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb250cm9sX3BsYW5lX3N0YXR1c18xID0gcmVxdWlyZShcIi4vY29udHJvbC1wbGFuZS1zdGF0dXNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyZXNvbHZpbmdfY2FsbCc7XG5jbGFzcyBSZXNvbHZpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBtZXRob2QsIG9wdGlvbnMsIGZpbHRlclN0YWNrRmFjdG9yeSwgY3JlZGVudGlhbHMsIGNhbGxOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5ID0gZmlsdGVyU3RhY2tGYWN0b3J5O1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuY2FsbE51bWJlciA9IGNhbGxOdW1iZXI7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkU3RhdHVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzID0gW107XG4gICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBvcHRpb25zLmRlYWRsaW5lO1xuICAgICAgICB0aGlzLmhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gICAgICAgIGlmIChvcHRpb25zLnBhcmVudENhbGwpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZsYWdzICYgY29uc3RhbnRzXzEuUHJvcGFnYXRlLkNBTkNFTExBVElPTikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyZW50Q2FsbC5vbignY2FuY2VsbGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBieSBwYXJlbnQgY2FsbCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmxhZ3MgJiBjb25zdGFudHNfMS5Qcm9wYWdhdGUuREVBRExJTkUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdQcm9wYWdhdGluZyBkZWFkbGluZSBmcm9tIHBhcmVudDogJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyZW50Q2FsbC5nZXREZWFkbGluZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gKDAsIGRlYWRsaW5lXzEubWluRGVhZGxpbmUpKHRoaXMuZGVhZGxpbmUsIG9wdGlvbnMucGFyZW50Q2FsbC5nZXREZWFkbGluZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkJyk7XG4gICAgICAgIHRoaXMucnVuRGVhZGxpbmVUaW1lcigpO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJ1snICsgdGhpcy5jYWxsTnVtYmVyICsgJ10gJyArIHRleHQpO1xuICAgIH1cbiAgICBydW5EZWFkbGluZVRpbWVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWFkbGluZVRpbWVyKTtcbiAgICAgICAgdGhpcy50cmFjZSgnRGVhZGxpbmU6ICcgKyAoMCwgZGVhZGxpbmVfMS5kZWFkbGluZVRvU3RyaW5nKSh0aGlzLmRlYWRsaW5lKSk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoMCwgZGVhZGxpbmVfMS5nZXRSZWxhdGl2ZVRpbWVvdXQpKHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICBpZiAodGltZW91dCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ0RlYWRsaW5lIHdpbGwgYmUgcmVhY2hlZCBpbiAnICsgdGltZW91dCArICdtcycpO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRGVhZGxpbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRCwgJ0RlYWRsaW5lIGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soaGFuZGxlRGVhZGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gc2V0VGltZW91dChoYW5kbGVEZWFkbGluZSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0U3RhdHVzKHN0YXR1cykge1xuICAgICAgICBpZiAoIXRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbHRlclN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5LmNyZWF0ZUZpbHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFN0YXR1cyA9IHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZVRyYWlsZXJzKHN0YXR1cyk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFN0YXR1cy5jb2RlICtcbiAgICAgICAgICAgICAgICAnIGRldGFpbHM9XCInICtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFN0YXR1cy5kZXRhaWxzICtcbiAgICAgICAgICAgICAgICAnXCInKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzV2F0Y2hlcnMuZm9yRWFjaCh3YXRjaGVyID0+IHdhdGNoZXIoZmlsdGVyZWRTdGF0dXMpKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlU3RhdHVzKGZpbHRlcmVkU3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlT25DaGlsZChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZW5kTWVzc2FnZW9uQ2hpbGQgY2FsbGVkIHdpdGggY2hpbGQgbm90IHBvcHVsYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZDtcbiAgICAgICAgdGhpcy53cml0ZUZpbHRlclBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnNlbmRNZXNzYWdlKFByb21pc2UucmVzb2x2ZSh7IG1lc3NhZ2U6IG1lc3NhZ2UsIGZsYWdzOiBjb250ZXh0LmZsYWdzIH0pKS50aGVuKGZpbHRlcmVkTWVzc2FnZSA9PiB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY2hpbGQuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBmaWx0ZXJlZE1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tZXRhZGF0YSB8fCAhdGhpcy5saXN0ZW5lcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRDb25maWcgY2FsbGVkIGJlZm9yZSBzdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IHRoaXMuY2hhbm5lbC5nZXRDb25maWcodGhpcy5tZXRob2QsIHRoaXMubWV0YWRhdGEpO1xuICAgICAgICBpZiAoY29uZmlnUmVzdWx0LnR5cGUgPT09ICdOT05FJykge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvckNvbmZpZyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWdSZXN1bHQudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5xdWV1ZUNhbGxGb3JDb25maWcodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyhjb25maWdSZXN1bHQuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbmZpZ1Jlc3VsdC50eXBlID09PSAnU1VDQ0VTUydcbiAgICAgICAgY29uc3QgY29uZmlnID0gY29uZmlnUmVzdWx0LmNvbmZpZztcbiAgICAgICAgaWYgKGNvbmZpZy5zdGF0dXMgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKGNvbmZpZy5zdGF0dXMsICdGYWlsZWQgdG8gcm91dGUgY2FsbCB0byBtZXRob2QgJyArIHRoaXMubWV0aG9kKTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0KSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWdEZWFkbGluZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBjb25maWdEZWFkbGluZS5zZXRTZWNvbmRzKGNvbmZpZ0RlYWRsaW5lLmdldFNlY29uZHMoKSArIGNvbmZpZy5tZXRob2RDb25maWcudGltZW91dC5zZWNvbmRzKTtcbiAgICAgICAgICAgIGNvbmZpZ0RlYWRsaW5lLnNldE1pbGxpc2Vjb25kcyhjb25maWdEZWFkbGluZS5nZXRNaWxsaXNlY29uZHMoKSArXG4gICAgICAgICAgICAgICAgY29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0Lm5hbm9zIC8gMTAwMDAwMCk7XG4gICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gKDAsIGRlYWRsaW5lXzEubWluRGVhZGxpbmUpKHRoaXMuZGVhZGxpbmUsIGNvbmZpZ0RlYWRsaW5lKTtcbiAgICAgICAgICAgIHRoaXMucnVuRGVhZGxpbmVUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5LnB1c2goY29uZmlnLmR5bmFtaWNGaWx0ZXJGYWN0b3JpZXMpO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrID0gdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkuY3JlYXRlRmlsdGVyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2suc2VuZE1ldGFkYXRhKFByb21pc2UucmVzb2x2ZSh0aGlzLm1ldGFkYXRhKSkudGhlbihmaWx0ZXJlZE1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQgPSB0aGlzLmNoYW5uZWwuY3JlYXRlSW5uZXJDYWxsKGNvbmZpZywgdGhpcy5tZXRob2QsIHRoaXMuaG9zdCwgdGhpcy5jcmVkZW50aWFscywgdGhpcy5kZWFkbGluZSk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkIGNoaWxkIFsnICsgdGhpcy5jaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydChmaWx0ZXJlZE1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWV0YWRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSh0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkRmlsdGVyUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkudGhlbihmaWx0ZXJlZE1lc3NzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZpbmlzaGVkIGZpbHRlcmluZyByZWNlaXZlZCBtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UoZmlsdGVyZWRNZXNzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh0aGlzLnBlbmRpbmdDaGlsZFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc3RhdHVzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZFN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkUGVuZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VPbkNoaWxkKHRoaXMucGVuZGluZ01lc3NhZ2UuY29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXBvcnRSZXNvbHZlckVycm9yKHN0YXR1cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvckNvbmZpZyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY2hhbm5lbC5nZXRUYXJnZXQoKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmdldENvbmZpZygpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZU9uQ2hpbGQoY29udGV4dCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0geyBjb250ZXh0LCBtZXNzYWdlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdzdGFydFJlYWQgY2FsbGVkJyk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0UmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdoYWxmQ2xvc2UgY2FsbGVkJyk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkICYmICF0aGlzLndyaXRlRmlsdGVyUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHRoaXMuY3JlZGVudGlhbHMuY29tcG9zZShjcmVkZW50aWFscyk7XG4gICAgfVxuICAgIGFkZFN0YXR1c1dhdGNoZXIod2F0Y2hlcikge1xuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgfVxuICAgIGdldENhbGxOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxOdW1iZXI7XG4gICAgfVxufVxuZXhwb3J0cy5SZXNvbHZpbmdDYWxsID0gUmVzb2x2aW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmluZy1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJlc29sdmluZ0NhbGwiLCJjb25zdGFudHNfMSIsInJlcXVpcmUiLCJkZWFkbGluZV8xIiwibWV0YWRhdGFfMSIsImxvZ2dpbmciLCJjb250cm9sX3BsYW5lX3N0YXR1c18xIiwiVFJBQ0VSX05BTUUiLCJjb25zdHJ1Y3RvciIsImNoYW5uZWwiLCJtZXRob2QiLCJvcHRpb25zIiwiZmlsdGVyU3RhY2tGYWN0b3J5IiwiY3JlZGVudGlhbHMiLCJjYWxsTnVtYmVyIiwiY2hpbGQiLCJyZWFkUGVuZGluZyIsInBlbmRpbmdNZXNzYWdlIiwicGVuZGluZ0hhbGZDbG9zZSIsImVuZGVkIiwicmVhZEZpbHRlclBlbmRpbmciLCJ3cml0ZUZpbHRlclBlbmRpbmciLCJwZW5kaW5nQ2hpbGRTdGF0dXMiLCJtZXRhZGF0YSIsImxpc3RlbmVyIiwic3RhdHVzV2F0Y2hlcnMiLCJkZWFkbGluZVRpbWVyIiwic2V0VGltZW91dCIsImZpbHRlclN0YWNrIiwiZGVhZGxpbmUiLCJob3N0IiwicGFyZW50Q2FsbCIsImZsYWdzIiwiUHJvcGFnYXRlIiwiQ0FOQ0VMTEFUSU9OIiwib24iLCJjYW5jZWxXaXRoU3RhdHVzIiwiU3RhdHVzIiwiQ0FOQ0VMTEVEIiwiREVBRExJTkUiLCJ0cmFjZSIsImdldERlYWRsaW5lIiwibWluRGVhZGxpbmUiLCJydW5EZWFkbGluZVRpbWVyIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiY2xlYXJUaW1lb3V0IiwiZGVhZGxpbmVUb1N0cmluZyIsInRpbWVvdXQiLCJnZXRSZWxhdGl2ZVRpbWVvdXQiLCJJbmZpbml0eSIsImhhbmRsZURlYWRsaW5lIiwiREVBRExJTkVfRVhDRUVERUQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJvdXRwdXRTdGF0dXMiLCJzdGF0dXMiLCJjcmVhdGVGaWx0ZXIiLCJmaWx0ZXJlZFN0YXR1cyIsInJlY2VpdmVUcmFpbGVycyIsImNvZGUiLCJkZXRhaWxzIiwiZm9yRWFjaCIsIndhdGNoZXIiLCJfYSIsIm9uUmVjZWl2ZVN0YXR1cyIsInNlbmRNZXNzYWdlT25DaGlsZCIsImNvbnRleHQiLCJtZXNzYWdlIiwiRXJyb3IiLCJzZW5kTWVzc2FnZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImZpbHRlcmVkTWVzc2FnZSIsInNlbmRNZXNzYWdlV2l0aENvbnRleHQiLCJoYWxmQ2xvc2UiLCJnZXRDb25maWciLCJjb25maWdSZXN1bHQiLCJ0eXBlIiwicXVldWVDYWxsRm9yQ29uZmlnIiwiZ2V0T3B0aW9ucyIsIndhaXRGb3JSZWFkeSIsImVycm9yIiwiY29uZmlnIiwiT0siLCJyZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUiLCJNZXRhZGF0YSIsIm1ldGhvZENvbmZpZyIsImNvbmZpZ0RlYWRsaW5lIiwiRGF0ZSIsInNldFNlY29uZHMiLCJnZXRTZWNvbmRzIiwic2Vjb25kcyIsInNldE1pbGxpc2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsIm5hbm9zIiwicHVzaCIsImR5bmFtaWNGaWx0ZXJGYWN0b3JpZXMiLCJzZW5kTWV0YWRhdGEiLCJmaWx0ZXJlZE1ldGFkYXRhIiwiY3JlYXRlSW5uZXJDYWxsIiwiZ2V0Q2FsbE51bWJlciIsInN0YXJ0Iiwib25SZWNlaXZlTWV0YWRhdGEiLCJyZWNlaXZlTWV0YWRhdGEiLCJvblJlY2VpdmVNZXNzYWdlIiwicmVjZWl2ZU1lc3NhZ2UiLCJmaWx0ZXJlZE1lc3NzYWdlIiwic3RhcnRSZWFkIiwicmVwb3J0UmVzb2x2ZXJFcnJvciIsImdldFBlZXIiLCJfYiIsImdldFRhcmdldCIsImNsb25lIiwibGVuZ3RoIiwic2V0Q3JlZGVudGlhbHMiLCJjb21wb3NlIiwiYWRkU3RhdHVzV2F0Y2hlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst TRACER_NAME = \"resolving_load_balancer\";\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * Name match levels in order from most to least specific. This is the order in\n * which searches will be performed.\n */ const NAME_MATCH_LEVEL_ORDER = [\n    \"SERVICE_AND_METHOD\",\n    \"SERVICE\",\n    \"EMPTY\"\n];\nfunction hasMatchingName(service, method, methodConfig, matchLevel) {\n    for (const name of methodConfig.name){\n        switch(matchLevel){\n            case \"EMPTY\":\n                if (!name.service && !name.method) {\n                    return true;\n                }\n                break;\n            case \"SERVICE\":\n                if (name.service === service && !name.method) {\n                    return true;\n                }\n                break;\n            case \"SERVICE_AND_METHOD\":\n                if (name.service === service && name.method === method) {\n                    return true;\n                }\n        }\n    }\n    return false;\n}\nfunction findMatchingConfig(service, method, methodConfigs, matchLevel) {\n    for (const config of methodConfigs){\n        if (hasMatchingName(service, method, config, matchLevel)) {\n            return config;\n        }\n    }\n    return null;\n}\nfunction getDefaultConfigSelector(serviceConfig) {\n    return function defaultConfigSelector(methodName, metadata) {\n        var _a, _b;\n        const splitName = methodName.split(\"/\").filter((x)=>x.length > 0);\n        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : \"\";\n        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : \"\";\n        if (serviceConfig && serviceConfig.methodConfig) {\n            /* Check for the following in order, and return the first method\n             * config that matches:\n             * 1. A name that exactly matches the service and method\n             * 2. A name with no method set that matches the service\n             * 3. An empty name\n             */ for (const matchLevel of NAME_MATCH_LEVEL_ORDER){\n                const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);\n                if (matchingConfig) {\n                    return {\n                        methodConfig: matchingConfig,\n                        pickInformation: {},\n                        status: constants_1.Status.OK,\n                        dynamicFilterFactories: []\n                    };\n                }\n            }\n        }\n        return {\n            methodConfig: {\n                name: []\n            },\n            pickInformation: {},\n            status: constants_1.Status.OK,\n            dynamicFilterFactories: []\n        };\n    };\n}\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */ constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution){\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.onSuccessfulResolution = onSuccessfulResolution;\n        this.onFailedResolution = onFailedResolution;\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        /**\n         * This resolving load balancer's current connectivity state.\n         */ this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of null indicates that we have not yet received a valid\n         * service config from the resolver.\n         */ this.previousServiceConfig = null;\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */ this.continueResolving = false;\n        if (channelOptions[\"grpc.service_config\"]) {\n            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions[\"grpc.service_config\"]));\n        } else {\n            this.defaultServiceConfig = {\n                loadBalancingConfig: [],\n                methodConfig: []\n            };\n        }\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n            requestReresolution: ()=>{\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */ if (this.backoffTimeout.isRunning()) {\n                    trace(\"requestReresolution delayed by backoff timer until \" + this.backoffTimeout.getEndTime().toISOString());\n                    this.continueResolving = true;\n                } else {\n                    this.updateResolution();\n                }\n            },\n            updateState: (newState, picker)=>{\n                this.latestChildState = newState;\n                this.latestChildPicker = picker;\n                this.updateState(newState, picker);\n            },\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)\n        });\n        this.innerResolver = (0, resolver_1.createResolver)(target, {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes)=>{\n                var _a;\n                this.backoffTimeout.stop();\n                this.backoffTimeout.reset();\n                let workingServiceConfig = null;\n                /* This first group of conditionals implements the algorithm described\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\n                 */ if (serviceConfig === null) {\n                    // Step 4 and 5\n                    if (serviceConfigError === null) {\n                        // Step 5\n                        this.previousServiceConfig = null;\n                        workingServiceConfig = this.defaultServiceConfig;\n                    } else {\n                        // Step 4\n                        if (this.previousServiceConfig === null) {\n                            // Step 4.ii\n                            this.handleResolutionFailure(serviceConfigError);\n                        } else {\n                            // Step 4.i\n                            workingServiceConfig = this.previousServiceConfig;\n                        }\n                    }\n                } else {\n                    // Step 3\n                    workingServiceConfig = serviceConfig;\n                    this.previousServiceConfig = serviceConfig;\n                }\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n                const loadBalancingConfig = (0, load_balancer_1.getFirstUsableConfig)(workingConfigList, true);\n                if (loadBalancingConfig === null) {\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\n                    this.handleResolutionFailure({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: \"All load balancer options in service config are not compatible\",\n                        metadata: new metadata_1.Metadata()\n                    });\n                    return;\n                }\n                this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n                this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n            },\n            onError: (error)=>{\n                this.handleResolutionFailure(error);\n            }\n        }, channelOptions);\n        const backoffOptions = {\n            initialDelay: channelOptions[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: channelOptions[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(()=>{\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            } else {\n                this.updateState(this.latestChildState, this.latestChildPicker);\n            }\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        this.backoffTimeout.runOnce();\n    }\n    updateState(connectivityState, picker) {\n        trace((0, uri_parser_1.uriToString)(this.target) + \" \" + connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[connectivityState]);\n        // Ensure that this.exitIdle() is called by the picker\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n            picker = new picker_1.QueuePicker(this);\n        }\n        this.currentState = connectivityState;\n        this.channelControlHelper.updateState(connectivityState, picker);\n    }\n    handleResolutionFailure(error) {\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n            this.onFailedResolution(error);\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            } else {\n                this.updateResolution();\n            }\n        }\n        this.childLoadBalancer.exitIdle();\n    }\n    updateAddressList(addressList, lbConfig) {\n        throw new Error(\"updateAddressList not supported on ResolvingLoadBalancer\");\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.childLoadBalancer.resetBackoff();\n    }\n    destroy() {\n        this.childLoadBalancer.destroy();\n        this.innerResolver.destroy();\n        this.backoffTimeout.reset();\n        this.backoffTimeout.stop();\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.previousServiceConfig = null;\n        this.continueResolving = false;\n    }\n    getTypeName() {\n        return \"resolving_load_balancer\";\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer; //# sourceMappingURL=resolving-load-balancer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUcsa0JBQWtCQyxtQkFBT0EsQ0FBQyxzRkFBaUI7QUFDakQsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDbkQsTUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUksV0FBV0osbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUssb0JBQW9CTCxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTU0sY0FBY04sbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTVEsVUFBVVIsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTVMsY0FBY1QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTVUsZUFBZVYsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVcsZ0NBQWdDWCxtQkFBT0EsQ0FBQyxrSEFBK0I7QUFDN0UsTUFBTVksY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZOLFFBQVFLLEtBQUssQ0FBQ0osWUFBWU0sWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUcseUJBQXlCO0lBQzNCO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsU0FBU0MsZ0JBQWdCQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsWUFBWSxFQUFFQyxVQUFVO0lBQzlELEtBQUssTUFBTUMsUUFBUUYsYUFBYUUsSUFBSSxDQUFFO1FBQ2xD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QUFFOEIsUUFBUSxFQUFFO1FBQ3JDLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBQyxlQUFlO1FBQ1gsSUFBSSxDQUFDM0MsY0FBYyxDQUFDZ0IsS0FBSztRQUN6QixJQUFJLENBQUNyQixpQkFBaUIsQ0FBQ2dELFlBQVk7SUFDdkM7SUFDQUMsVUFBVTtRQUNOLElBQUksQ0FBQ2pELGlCQUFpQixDQUFDaUQsT0FBTztRQUM5QixJQUFJLENBQUNuQyxhQUFhLENBQUNtQyxPQUFPO1FBQzFCLElBQUksQ0FBQzVDLGNBQWMsQ0FBQ2dCLEtBQUs7UUFDekIsSUFBSSxDQUFDaEIsY0FBYyxDQUFDZSxJQUFJO1FBQ3hCLElBQUksQ0FBQ2xDLGdCQUFnQixHQUFHakQscUJBQXFCa0QsaUJBQWlCLENBQUNDLElBQUk7UUFDbkUsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxJQUFJbEQsU0FBU21ELFdBQVcsQ0FBQyxJQUFJO1FBQ3RELElBQUksQ0FBQ0MsWUFBWSxHQUFHdEQscUJBQXFCa0QsaUJBQWlCLENBQUNDLElBQUk7UUFDL0QsSUFBSSxDQUFDSSxxQkFBcUIsR0FBRztRQUM3QixJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0F5RCxjQUFjO1FBQ1YsT0FBTztJQUNYO0FBQ0o7QUFDQXZILDZCQUE2QixHQUFHRSx1QkFDaEMsbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanM/NDk3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXNvbHZpbmdMb2FkQmFsYW5jZXIgPSB2b2lkIDA7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3Qgc2VydmljZV9jb25maWdfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2UtY29uZmlnXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncmVzb2x2aW5nX2xvYWRfYmFsYW5jZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG4vKipcbiAqIE5hbWUgbWF0Y2ggbGV2ZWxzIGluIG9yZGVyIGZyb20gbW9zdCB0byBsZWFzdCBzcGVjaWZpYy4gVGhpcyBpcyB0aGUgb3JkZXIgaW5cbiAqIHdoaWNoIHNlYXJjaGVzIHdpbGwgYmUgcGVyZm9ybWVkLlxuICovXG5jb25zdCBOQU1FX01BVENIX0xFVkVMX09SREVSID0gW1xuICAgICdTRVJWSUNFX0FORF9NRVRIT0QnLFxuICAgICdTRVJWSUNFJyxcbiAgICAnRU1QVFknLFxuXTtcbmZ1bmN0aW9uIGhhc01hdGNoaW5nTmFtZShzZXJ2aWNlLCBtZXRob2QsIG1ldGhvZENvbmZpZywgbWF0Y2hMZXZlbCkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXRob2RDb25maWcubmFtZSkge1xuICAgICAgICBzd2l0Y2ggKG1hdGNoTGV2ZWwpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VNUFRZJzpcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUuc2VydmljZSAmJiAhbmFtZS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU0VSVklDRSc6XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc2VydmljZSA9PT0gc2VydmljZSAmJiAhbmFtZS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU0VSVklDRV9BTkRfTUVUSE9EJzpcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zZXJ2aWNlID09PSBzZXJ2aWNlICYmIG5hbWUubWV0aG9kID09PSBtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmRNYXRjaGluZ0NvbmZpZyhzZXJ2aWNlLCBtZXRob2QsIG1ldGhvZENvbmZpZ3MsIG1hdGNoTGV2ZWwpIHtcbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBtZXRob2RDb25maWdzKSB7XG4gICAgICAgIGlmIChoYXNNYXRjaGluZ05hbWUoc2VydmljZSwgbWV0aG9kLCBjb25maWcsIG1hdGNoTGV2ZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdENvbmZpZ1NlbGVjdG9yKHNlcnZpY2VDb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVmYXVsdENvbmZpZ1NlbGVjdG9yKG1ldGhvZE5hbWUsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHNwbGl0TmFtZSA9IG1ldGhvZE5hbWUuc3BsaXQoJy8nKS5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDApO1xuICAgICAgICBjb25zdCBzZXJ2aWNlID0gKF9hID0gc3BsaXROYW1lWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgY29uc3QgbWV0aG9kID0gKF9iID0gc3BsaXROYW1lWzFdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgICAgICAgaWYgKHNlcnZpY2VDb25maWcgJiYgc2VydmljZUNvbmZpZy5tZXRob2RDb25maWcpIHtcbiAgICAgICAgICAgIC8qIENoZWNrIGZvciB0aGUgZm9sbG93aW5nIGluIG9yZGVyLCBhbmQgcmV0dXJuIHRoZSBmaXJzdCBtZXRob2RcbiAgICAgICAgICAgICAqIGNvbmZpZyB0aGF0IG1hdGNoZXM6XG4gICAgICAgICAgICAgKiAxLiBBIG5hbWUgdGhhdCBleGFjdGx5IG1hdGNoZXMgdGhlIHNlcnZpY2UgYW5kIG1ldGhvZFxuICAgICAgICAgICAgICogMi4gQSBuYW1lIHdpdGggbm8gbWV0aG9kIHNldCB0aGF0IG1hdGNoZXMgdGhlIHNlcnZpY2VcbiAgICAgICAgICAgICAqIDMuIEFuIGVtcHR5IG5hbWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaExldmVsIG9mIE5BTUVfTUFUQ0hfTEVWRUxfT1JERVIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ0NvbmZpZyA9IGZpbmRNYXRjaGluZ0NvbmZpZyhzZXJ2aWNlLCBtZXRob2QsIHNlcnZpY2VDb25maWcubWV0aG9kQ29uZmlnLCBtYXRjaExldmVsKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogbWF0Y2hpbmdDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrSW5mb3JtYXRpb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljRmlsdGVyRmFjdG9yaWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGhvZENvbmZpZzogeyBuYW1lOiBbXSB9LFxuICAgICAgICAgICAgcGlja0luZm9ybWF0aW9uOiB7fSxcbiAgICAgICAgICAgIHN0YXR1czogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxuICAgICAgICAgICAgZHluYW1pY0ZpbHRlckZhY3RvcmllczogW10sXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmNsYXNzIFJlc29sdmluZ0xvYWRCYWxhbmNlciB7XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBjbGFzcyB0aGF0IGJlaGF2ZXMgbGlrZSBhIGBMb2FkQmFsYW5jZXJgIGFuZCBhbHNvIGhhbmRsZXMgbmFtZVxuICAgICAqIHJlc29sdXRpb24gaW50ZXJuYWxseS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSBhZGRyZXNzIG9mIHRoZSBiYWNrZW5kIHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHBhcmFtIGNoYW5uZWxDb250cm9sSGVscGVyIGBDaGFubmVsQ29udHJvbEhlbHBlcmAgaW5zdGFuY2UgcHJvdmlkZWQgYnlcbiAgICAgKiAgICAgdGhpcyBsb2FkIGJhbGFuY2VyJ3Mgb3duZXIuXG4gICAgICogQHBhcmFtIGRlZmF1bHRTZXJ2aWNlQ29uZmlnIFRoZSBkZWZhdWx0IHNlcnZpY2UgY29uZmlndXJhdGlvbiB0byBiZSB1c2VkXG4gICAgICogICAgIGlmIG5vbmUgaXMgcHJvdmlkZWQgYnkgdGhlIG5hbWUgcmVzb2x2ZXIuIEEgYG51bGxgIHZhbHVlIGluZGljYXRlc1xuICAgICAqICAgICB0aGF0IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHNob3VsZCBiZSB0aGUgZGVmYXVsdCB1bmNvbmZpZ3VyZWQgYmVoYXZpb3IuXG4gICAgICogICAgIEluIHByYWN0aWNlLCB0aGF0IG1lYW5zIHVzaW5nIHRoZSBcInBpY2sgZmlyc3RcIiBsb2FkIGJhbGFuY2VyXG4gICAgICogICAgIGltcGxtZW50YXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNoYW5uZWxDb250cm9sSGVscGVyLCBjaGFubmVsT3B0aW9ucywgb25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgb25GYWlsZWRSZXNvbHV0aW9uKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIHRoaXMub25TdWNjZXNzZnVsUmVzb2x1dGlvbiA9IG9uU3VjY2Vzc2Z1bFJlc29sdXRpb247XG4gICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uID0gb25GYWlsZWRSZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkUGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyByZXNvbHZpbmcgbG9hZCBiYWxhbmNlcidzIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlcnZpY2UgY29uZmlnIG9iamVjdCBmcm9tIHRoZSBsYXN0IHN1Y2Nlc3NmdWwgcmVzb2x1dGlvbiwgaWZcbiAgICAgICAgICogYXZhaWxhYmxlLiBBIHZhbHVlIG9mIG51bGwgaW5kaWNhdGVzIHRoYXQgd2UgaGF2ZSBub3QgeWV0IHJlY2VpdmVkIGEgdmFsaWRcbiAgICAgICAgICogc2VydmljZSBjb25maWcgZnJvbSB0aGUgcmVzb2x2ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB3ZSBzaG91bGQgYXR0ZW1wdCB0byByZXNvbHZlIGFnYWluIGFmdGVyIHRoZSBiYWNrb2ZmXG4gICAgICAgICAqIHRpbWVyIHJ1bnMgb3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoY2hhbm5lbE9wdGlvbnNbJ2dycGMuc2VydmljZV9jb25maWcnXSkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2VydmljZUNvbmZpZyA9ICgwLCBzZXJ2aWNlX2NvbmZpZ18xLnZhbGlkYXRlU2VydmljZUNvbmZpZykoSlNPTi5wYXJzZShjaGFubmVsT3B0aW9uc1snZ3JwYy5zZXJ2aWNlX2NvbmZpZyddKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGxvYWRCYWxhbmNpbmdDb25maWc6IFtdLFxuICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlciA9IG5ldyBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIoe1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbC5iaW5kKGNoYW5uZWxDb250cm9sSGVscGVyKSxcbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgYmFja29mZlRpbWVvdXQgaXMgcnVubmluZywgd2UncmUgc3RpbGwgYmFja2luZyBvZmYgZnJvbVxuICAgICAgICAgICAgICAgICAqIG1ha2luZyByZXNvbHZlIHJlcXVlc3RzLCBzbyB3ZSBzaG91bGRuJ3QgbWFrZSBhbm90aGVyIG9uZSBoZXJlLlxuICAgICAgICAgICAgICAgICAqIEluIHRoYXQgY2FzZSwgdGhlIGJhY2tvZmYgdGltZXIgY2FsbGJhY2sgd2lsbCBjYWxsXG4gICAgICAgICAgICAgICAgICogdXBkYXRlUmVzb2x1dGlvbiAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdyZXF1ZXN0UmVyZXNvbHV0aW9uIGRlbGF5ZWQgYnkgYmFja29mZiB0aW1lciB1bnRpbCAnICsgdGhpcy5iYWNrb2ZmVGltZW91dC5nZXRFbmRUaW1lKCkudG9JU09TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAobmV3U3RhdGUsIHBpY2tlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBwaWNrZXI7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiBjaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkLmJpbmQoY2hhbm5lbENvbnRyb2xIZWxwZXIpLFxuICAgICAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZC5iaW5kKGNoYW5uZWxDb250cm9sSGVscGVyKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlciA9ICgwLCByZXNvbHZlcl8xLmNyZWF0ZVJlc29sdmVyKSh0YXJnZXQsIHtcbiAgICAgICAgICAgIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb246IChhZGRyZXNzTGlzdCwgc2VydmljZUNvbmZpZywgc2VydmljZUNvbmZpZ0Vycm9yLCBjb25maWdTZWxlY3RvciwgYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvKiBUaGlzIGZpcnN0IGdyb3VwIG9mIGNvbmRpdGlvbmFscyBpbXBsZW1lbnRzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkXG4gICAgICAgICAgICAgICAgICogaW4gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvcHJvcG9zYWwvYmxvYi9tYXN0ZXIvQTIxLXNlcnZpY2UtY29uZmlnLWVycm9yLWhhbmRsaW5nLm1kXG4gICAgICAgICAgICAgICAgICogaW4gdGhlIHNlY3Rpb24gY2FsbGVkIFwiQmVoYXZpb3Igb24gcmVjZWl2aW5nIGEgbmV3IGdSUEMgQ29uZmlnXCIuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VDb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0IGFuZCA1XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnRXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQuaWlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKHNlcnZpY2VDb25maWdFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQuaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgM1xuICAgICAgICAgICAgICAgICAgICB3b3JraW5nU2VydmljZUNvbmZpZyA9IHNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID0gc2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd29ya2luZ0NvbmZpZ0xpc3QgPSAoX2EgPSB3b3JraW5nU2VydmljZUNvbmZpZyA9PT0gbnVsbCB8fCB3b3JraW5nU2VydmljZUNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd29ya2luZ1NlcnZpY2VDb25maWcubG9hZEJhbGFuY2luZ0NvbmZpZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZEJhbGFuY2luZ0NvbmZpZyA9ICgwLCBsb2FkX2JhbGFuY2VyXzEuZ2V0Rmlyc3RVc2FibGVDb25maWcpKHdvcmtpbmdDb25maWdMaXN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobG9hZEJhbGFuY2luZ0NvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSB3ZXJlIGxvYWQgYmFsYW5jaW5nIGNvbmZpZ3MgYnV0IG5vbmUgYXJlIHN1cHBvcnRlZC4gVGhpcyBjb3VudHMgYXMgYSByZXNvbHV0aW9uIGZhaWx1cmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHV0aW9uRmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnQWxsIGxvYWQgYmFsYW5jZXIgb3B0aW9ucyBpbiBzZXJ2aWNlIGNvbmZpZyBhcmUgbm90IGNvbXBhdGlibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxvYWRCYWxhbmNpbmdDb25maWcsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsU2VydmljZUNvbmZpZyA9IHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSBudWxsICYmIHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSB2b2lkIDAgPyB3b3JraW5nU2VydmljZUNvbmZpZyA6IHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKGZpbmFsU2VydmljZUNvbmZpZywgY29uZmlnU2VsZWN0b3IgIT09IG51bGwgJiYgY29uZmlnU2VsZWN0b3IgIT09IHZvaWQgMCA/IGNvbmZpZ1NlbGVjdG9yIDogZ2V0RGVmYXVsdENvbmZpZ1NlbGVjdG9yKGZpbmFsU2VydmljZUNvbmZpZykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzb2x1dGlvbkZhaWx1cmUoZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBiYWNrb2ZmT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGluaXRpYWxEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMuaW5pdGlhbF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICAgICAgbWF4RGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0ID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLmxhdGVzdENoaWxkU3RhdGUsIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQudW5yZWYoKTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5ydW5PbmNlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpIHtcbiAgICAgICAgdHJhY2UoKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW2Nvbm5lY3Rpdml0eVN0YXRlXSk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoaXMuZXhpdElkbGUoKSBpcyBjYWxsZWQgYnkgdGhlIHBpY2tlclxuICAgICAgICBpZiAoY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIHBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eVN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpO1xuICAgIH1cbiAgICBoYW5kbGVSZXNvbHV0aW9uRmFpbHVyZShlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5sYXRlc3RDaGlsZFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoZXJyb3IpKTtcbiAgICAgICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VwZGF0ZUFkZHJlc3NMaXN0IG5vdCBzdXBwb3J0ZWQgb24gUmVzb2x2aW5nTG9hZEJhbGFuY2VyJyk7XG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLnJlc2V0QmFja29mZigpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAncmVzb2x2aW5nX2xvYWRfYmFsYW5jZXInO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gUmVzb2x2aW5nTG9hZEJhbGFuY2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmVzb2x2aW5nTG9hZEJhbGFuY2VyIiwibG9hZF9iYWxhbmNlcl8xIiwicmVxdWlyZSIsInNlcnZpY2VfY29uZmlnXzEiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsInJlc29sdmVyXzEiLCJwaWNrZXJfMSIsImJhY2tvZmZfdGltZW91dF8xIiwiY29uc3RhbnRzXzEiLCJtZXRhZGF0YV8xIiwibG9nZ2luZyIsImNvbnN0YW50c18yIiwidXJpX3BhcnNlcl8xIiwibG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEiLCJUUkFDRVJfTkFNRSIsInRyYWNlIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiTkFNRV9NQVRDSF9MRVZFTF9PUkRFUiIsImhhc01hdGNoaW5nTmFtZSIsInNlcnZpY2UiLCJtZXRob2QiLCJtZXRob2RDb25maWciLCJtYXRjaExldmVsIiwibmFtZSIsImZpbmRNYXRjaGluZ0NvbmZpZyIsIm1ldGhvZENvbmZpZ3MiLCJjb25maWciLCJnZXREZWZhdWx0Q29uZmlnU2VsZWN0b3IiLCJzZXJ2aWNlQ29uZmlnIiwiZGVmYXVsdENvbmZpZ1NlbGVjdG9yIiwibWV0aG9kTmFtZSIsIm1ldGFkYXRhIiwiX2EiLCJfYiIsInNwbGl0TmFtZSIsInNwbGl0IiwiZmlsdGVyIiwieCIsImxlbmd0aCIsIm1hdGNoaW5nQ29uZmlnIiwicGlja0luZm9ybWF0aW9uIiwic3RhdHVzIiwiU3RhdHVzIiwiT0siLCJkeW5hbWljRmlsdGVyRmFjdG9yaWVzIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImNoYW5uZWxPcHRpb25zIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsIm9uRmFpbGVkUmVzb2x1dGlvbiIsImxhdGVzdENoaWxkU3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJsYXRlc3RDaGlsZFBpY2tlciIsIlF1ZXVlUGlja2VyIiwiY3VycmVudFN0YXRlIiwicHJldmlvdXNTZXJ2aWNlQ29uZmlnIiwiY29udGludWVSZXNvbHZpbmciLCJkZWZhdWx0U2VydmljZUNvbmZpZyIsInZhbGlkYXRlU2VydmljZUNvbmZpZyIsIkpTT04iLCJwYXJzZSIsImxvYWRCYWxhbmNpbmdDb25maWciLCJ1cGRhdGVTdGF0ZSIsImNoaWxkTG9hZEJhbGFuY2VyIiwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIiwiY3JlYXRlU3ViY2hhbm5lbCIsImJpbmQiLCJyZXF1ZXN0UmVyZXNvbHV0aW9uIiwiYmFja29mZlRpbWVvdXQiLCJpc1J1bm5pbmciLCJnZXRFbmRUaW1lIiwidG9JU09TdHJpbmciLCJ1cGRhdGVSZXNvbHV0aW9uIiwibmV3U3RhdGUiLCJwaWNrZXIiLCJhZGRDaGFubmVsekNoaWxkIiwicmVtb3ZlQ2hhbm5lbHpDaGlsZCIsImlubmVyUmVzb2x2ZXIiLCJjcmVhdGVSZXNvbHZlciIsImFkZHJlc3NMaXN0Iiwic2VydmljZUNvbmZpZ0Vycm9yIiwiY29uZmlnU2VsZWN0b3IiLCJhdHRyaWJ1dGVzIiwic3RvcCIsInJlc2V0Iiwid29ya2luZ1NlcnZpY2VDb25maWciLCJoYW5kbGVSZXNvbHV0aW9uRmFpbHVyZSIsIndvcmtpbmdDb25maWdMaXN0IiwiZ2V0Rmlyc3RVc2FibGVDb25maWciLCJjb2RlIiwiVU5BVkFJTEFCTEUiLCJkZXRhaWxzIiwiTWV0YWRhdGEiLCJ1cGRhdGVBZGRyZXNzTGlzdCIsImZpbmFsU2VydmljZUNvbmZpZyIsIm9uRXJyb3IiLCJlcnJvciIsImJhY2tvZmZPcHRpb25zIiwiaW5pdGlhbERlbGF5IiwibWF4RGVsYXkiLCJCYWNrb2ZmVGltZW91dCIsInVucmVmIiwiQ09OTkVDVElORyIsInJ1bk9uY2UiLCJjb25uZWN0aXZpdHlTdGF0ZSIsInVyaVRvU3RyaW5nIiwiVFJBTlNJRU5UX0ZBSUxVUkUiLCJVbmF2YWlsYWJsZVBpY2tlciIsImV4aXRJZGxlIiwibGJDb25maWciLCJFcnJvciIsInJlc2V0QmFja29mZiIsImRlc3Ryb3kiLCJnZXRUeXBlTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/retrying-call.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"retrying_call\";\nclass RetryThrottler {\n    constructor(maxTokens, tokenRatio, previousRetryThrottler){\n        this.maxTokens = maxTokens;\n        this.tokenRatio = tokenRatio;\n        if (previousRetryThrottler) {\n            /* When carrying over tokens from a previous config, rescale them to the\n             * new max value */ this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);\n        } else {\n            this.tokens = maxTokens;\n        }\n    }\n    addCallSucceeded() {\n        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n    }\n    addCallFailed() {\n        this.tokens = Math.min(this.tokens - 1, 0);\n    }\n    canRetryCall() {\n        return this.tokens > this.maxTokens / 2;\n    }\n}\nexports.RetryThrottler = RetryThrottler;\nclass MessageBufferTracker {\n    constructor(totalLimit, limitPerCall){\n        this.totalLimit = totalLimit;\n        this.limitPerCall = limitPerCall;\n        this.totalAllocated = 0;\n        this.allocatedPerCall = new Map();\n    }\n    allocate(size, callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {\n            return false;\n        }\n        this.allocatedPerCall.set(callId, currentPerCall + size);\n        this.totalAllocated += size;\n        return true;\n    }\n    free(size, callId) {\n        var _a;\n        if (this.totalAllocated < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= size;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (currentPerCall < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n        }\n        this.allocatedPerCall.set(callId, currentPerCall - size);\n    }\n    freeAll(callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.totalAllocated < currentPerCall) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= currentPerCall;\n        this.allocatedPerCall.delete(callId);\n    }\n}\nexports.MessageBufferTracker = MessageBufferTracker;\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = \"grpc-previous-rpc-attempts\";\nclass RetryingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler){\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.bufferTracker = bufferTracker;\n        this.retryThrottler = retryThrottler;\n        this.listener = null;\n        this.initialMetadata = null;\n        this.underlyingCalls = [];\n        this.writeBuffer = [];\n        /**\n         * The offset of message indices in the writeBuffer. For example, if\n         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n         * is in writeBuffer[5].\n         */ this.writeBufferOffset = 0;\n        /**\n         * Tracks whether a read has been started, so that we know whether to start\n         * reads on new child calls. This only matters for the first read, because\n         * once a message comes in the child call becomes committed and there will\n         * be no new child calls.\n         */ this.readStarted = false;\n        this.transparentRetryUsed = false;\n        /**\n         * Number of attempts so far\n         */ this.attempts = 0;\n        this.hedgingTimer = null;\n        this.committedCallIndex = null;\n        this.initialRetryBackoffSec = 0;\n        this.nextRetryBackoffSec = 0;\n        if (callConfig.methodConfig.retryPolicy) {\n            this.state = \"RETRY\";\n            const retryPolicy = callConfig.methodConfig.retryPolicy;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n        } else if (callConfig.methodConfig.hedgingPolicy) {\n            this.state = \"HEDGING\";\n        } else {\n            this.state = \"TRANSPARENT_ONLY\";\n        }\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callNumber + \"] \" + text);\n    }\n    reportStatus(statusObject) {\n        this.trace(\"ended with status: code=\" + statusObject.code + ' details=\"' + statusObject.details + '\"');\n        this.bufferTracker.freeAll(this.callNumber);\n        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n        this.writeBuffer = [];\n        process.nextTick(()=>{\n            var _a;\n            // Explicitly construct status object to remove progress field\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({\n                code: statusObject.code,\n                details: statusObject.details,\n                metadata: statusObject.metadata\n            });\n        });\n    }\n    cancelWithStatus(status, details) {\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        this.reportStatus({\n            code: status,\n            details,\n            metadata: new metadata_1.Metadata()\n        });\n        for (const { call } of this.underlyingCalls){\n            call.cancelWithStatus(status, details);\n        }\n    }\n    getPeer() {\n        if (this.committedCallIndex !== null) {\n            return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n        } else {\n            return \"unknown\";\n        }\n    }\n    getBufferEntry(messageIndex) {\n        var _a;\n        return (_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {\n            entryType: \"FREED\",\n            allocated: false\n        };\n    }\n    getNextBufferIndex() {\n        return this.writeBufferOffset + this.writeBuffer.length;\n    }\n    clearSentMessages() {\n        if (this.state !== \"COMMITTED\") {\n            return;\n        }\n        const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;\n        for(let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++){\n            const bufferEntry = this.getBufferEntry(messageIndex);\n            if (bufferEntry.allocated) {\n                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\n            }\n        }\n        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\n        this.writeBufferOffset = earliestNeededMessageIndex;\n    }\n    commitCall(index) {\n        if (this.state === \"COMMITTED\") {\n            return;\n        }\n        if (this.underlyingCalls[index].state === \"COMPLETED\") {\n            return;\n        }\n        this.trace(\"Committing call [\" + this.underlyingCalls[index].call.getCallNumber() + \"] at index \" + index);\n        this.state = \"COMMITTED\";\n        this.committedCallIndex = index;\n        for(let i = 0; i < this.underlyingCalls.length; i++){\n            if (i === index) {\n                continue;\n            }\n            if (this.underlyingCalls[i].state === \"COMPLETED\") {\n                continue;\n            }\n            this.underlyingCalls[i].state = \"COMPLETED\";\n            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, \"Discarded in favor of other hedged attempt\");\n        }\n        this.clearSentMessages();\n    }\n    commitCallWithMostMessages() {\n        if (this.state === \"COMMITTED\") {\n            return;\n        }\n        let mostMessages = -1;\n        let callWithMostMessages = -1;\n        for (const [index, childCall] of this.underlyingCalls.entries()){\n            if (childCall.state === \"ACTIVE\" && childCall.nextMessageToSend > mostMessages) {\n                mostMessages = childCall.nextMessageToSend;\n                callWithMostMessages = index;\n            }\n        }\n        if (callWithMostMessages === -1) {\n            /* There are no active calls, disable retries to force the next call that\n             * is started to be committed. */ this.state = \"TRANSPARENT_ONLY\";\n        } else {\n            this.commitCall(callWithMostMessages);\n        }\n    }\n    isStatusCodeInList(list, code) {\n        return list.some((value)=>value === code || value.toString().toLowerCase() === constants_1.Status[code].toLowerCase());\n    }\n    getNextRetryBackoffMs() {\n        var _a;\n        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\n        if (!retryPolicy) {\n            return 0;\n        }\n        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n        return nextBackoffMs;\n    }\n    maybeRetryCall(pushback, callback) {\n        if (this.state !== \"RETRY\") {\n            callback(false);\n            return;\n        }\n        const retryPolicy = this.callConfig.methodConfig.retryPolicy;\n        if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\n            callback(false);\n            return;\n        }\n        let retryDelayMs;\n        if (pushback === null) {\n            retryDelayMs = this.getNextRetryBackoffMs();\n        } else if (pushback < 0) {\n            this.state = \"TRANSPARENT_ONLY\";\n            callback(false);\n            return;\n        } else {\n            retryDelayMs = pushback;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n        }\n        setTimeout(()=>{\n            var _a, _b;\n            if (this.state !== \"RETRY\") {\n                callback(false);\n                return;\n            }\n            if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\n                callback(true);\n                this.attempts += 1;\n                this.startNewAttempt();\n            }\n        }, retryDelayMs);\n    }\n    countActiveCalls() {\n        let count = 0;\n        for (const call of this.underlyingCalls){\n            if ((call === null || call === void 0 ? void 0 : call.state) === \"ACTIVE\") {\n                count += 1;\n            }\n        }\n        return count;\n    }\n    handleProcessedStatus(status, callIndex, pushback) {\n        var _a, _b, _c;\n        switch(this.state){\n            case \"COMMITTED\":\n            case \"TRANSPARENT_ONLY\":\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case \"HEDGING\":\n                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\n                    (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\n                    let delayMs;\n                    if (pushback === null) {\n                        delayMs = 0;\n                    } else if (pushback < 0) {\n                        this.state = \"TRANSPARENT_ONLY\";\n                        this.commitCall(callIndex);\n                        this.reportStatus(status);\n                        return;\n                    } else {\n                        delayMs = pushback;\n                    }\n                    setTimeout(()=>{\n                        this.maybeStartHedgingAttempt();\n                        // If after trying to start a call there are no active calls, this was the last one\n                        if (this.countActiveCalls() === 0) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    }, delayMs);\n                } else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n            case \"RETRY\":\n                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\n                    (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\n                    this.maybeRetryCall(pushback, (retried)=>{\n                        if (!retried) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    });\n                } else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n        }\n    }\n    getPushback(metadata) {\n        const mdValue = metadata.get(\"grpc-retry-pushback-ms\");\n        if (mdValue.length === 0) {\n            return null;\n        }\n        try {\n            return parseInt(mdValue[0]);\n        } catch (e) {\n            return -1;\n        }\n    }\n    handleChildStatus(status, callIndex) {\n        var _a;\n        if (this.underlyingCalls[callIndex].state === \"COMPLETED\") {\n            return;\n        }\n        this.trace(\"state=\" + this.state + \" handling status with progress \" + status.progress + \" from child [\" + this.underlyingCalls[callIndex].call.getCallNumber() + \"] in state \" + this.underlyingCalls[callIndex].state);\n        this.underlyingCalls[callIndex].state = \"COMPLETED\";\n        if (status.code === constants_1.Status.OK) {\n            (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n        }\n        if (this.state === \"COMMITTED\") {\n            this.reportStatus(status);\n            return;\n        }\n        const pushback = this.getPushback(status.metadata);\n        switch(status.progress){\n            case \"NOT_STARTED\":\n                // RPC never leaves the client, always safe to retry\n                this.startNewAttempt();\n                break;\n            case \"REFUSED\":\n                // RPC reaches the server library, but not the server application logic\n                if (this.transparentRetryUsed) {\n                    this.handleProcessedStatus(status, callIndex, pushback);\n                } else {\n                    this.transparentRetryUsed = true;\n                    this.startNewAttempt();\n                }\n                break;\n            case \"DROP\":\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case \"PROCESSED\":\n                this.handleProcessedStatus(status, callIndex, pushback);\n                break;\n        }\n    }\n    maybeStartHedgingAttempt() {\n        if (this.state !== \"HEDGING\") {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n            return;\n        }\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    maybeStartHedgingTimer() {\n        var _a, _b, _c;\n        if (this.hedgingTimer) {\n            clearTimeout(this.hedgingTimer);\n        }\n        if (this.state !== \"HEDGING\") {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n            return;\n        }\n        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : \"0s\";\n        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n        this.hedgingTimer = setTimeout(()=>{\n            this.maybeStartHedgingAttempt();\n        }, hedgingDelaySec * 1000);\n        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n    }\n    startNewAttempt() {\n        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n        this.trace(\"Created child call [\" + child.getCallNumber() + \"] for attempt \" + this.attempts);\n        const index = this.underlyingCalls.length;\n        this.underlyingCalls.push({\n            state: \"ACTIVE\",\n            call: child,\n            nextMessageToSend: 0\n        });\n        const previousAttempts = this.attempts - 1;\n        const initialMetadata = this.initialMetadata.clone();\n        if (previousAttempts > 0) {\n            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        let receivedMetadata = false;\n        child.start(initialMetadata, {\n            onReceiveMetadata: (metadata)=>{\n                this.trace(\"Received metadata from child [\" + child.getCallNumber() + \"]\");\n                this.commitCall(index);\n                receivedMetadata = true;\n                if (previousAttempts > 0) {\n                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                if (this.underlyingCalls[index].state === \"ACTIVE\") {\n                    this.listener.onReceiveMetadata(metadata);\n                }\n            },\n            onReceiveMessage: (message)=>{\n                this.trace(\"Received message from child [\" + child.getCallNumber() + \"]\");\n                this.commitCall(index);\n                if (this.underlyingCalls[index].state === \"ACTIVE\") {\n                    this.listener.onReceiveMessage(message);\n                }\n            },\n            onReceiveStatus: (status)=>{\n                this.trace(\"Received status from child [\" + child.getCallNumber() + \"]\");\n                if (!receivedMetadata && previousAttempts > 0) {\n                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                this.handleChildStatus(status, index);\n            }\n        });\n        this.sendNextChildMessage(index);\n        if (this.readStarted) {\n            child.startRead();\n        }\n    }\n    start(metadata, listener) {\n        this.trace(\"start called\");\n        this.listener = listener;\n        this.initialMetadata = metadata;\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    handleChildWriteCompleted(childIndex) {\n        var _a, _b;\n        const childCall = this.underlyingCalls[childIndex];\n        const messageIndex = childCall.nextMessageToSend;\n        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.clearSentMessages();\n        childCall.nextMessageToSend += 1;\n        this.sendNextChildMessage(childIndex);\n    }\n    sendNextChildMessage(childIndex) {\n        const childCall = this.underlyingCalls[childIndex];\n        if (childCall.state === \"COMPLETED\") {\n            return;\n        }\n        if (this.getBufferEntry(childCall.nextMessageToSend)) {\n            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n            switch(bufferEntry.entryType){\n                case \"MESSAGE\":\n                    childCall.call.sendMessageWithContext({\n                        callback: (error)=>{\n                            // Ignore error\n                            this.handleChildWriteCompleted(childIndex);\n                        }\n                    }, bufferEntry.message.message);\n                    break;\n                case \"HALF_CLOSE\":\n                    childCall.nextMessageToSend += 1;\n                    childCall.call.halfClose();\n                    break;\n                case \"FREED\":\n                    break;\n            }\n        }\n    }\n    sendMessageWithContext(context, message) {\n        var _a;\n        this.trace(\"write() called with message of length \" + message.length);\n        const writeObj = {\n            message,\n            flags: context.flags\n        };\n        const messageIndex = this.getNextBufferIndex();\n        const bufferEntry = {\n            entryType: \"MESSAGE\",\n            message: writeObj,\n            allocated: this.bufferTracker.allocate(message.length, this.callNumber)\n        };\n        this.writeBuffer.push(bufferEntry);\n        if (bufferEntry.allocated) {\n            (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            for (const [callIndex, call] of this.underlyingCalls.entries()){\n                if (call.state === \"ACTIVE\" && call.nextMessageToSend === messageIndex) {\n                    call.call.sendMessageWithContext({\n                        callback: (error)=>{\n                            // Ignore error\n                            this.handleChildWriteCompleted(callIndex);\n                        }\n                    }, message);\n                }\n            }\n        } else {\n            this.commitCallWithMostMessages();\n            // commitCallWithMostMessages can fail if we are between ping attempts\n            if (this.committedCallIndex === null) {\n                return;\n            }\n            const call = this.underlyingCalls[this.committedCallIndex];\n            bufferEntry.callback = context.callback;\n            if (call.state === \"ACTIVE\" && call.nextMessageToSend === messageIndex) {\n                call.call.sendMessageWithContext({\n                    callback: (error)=>{\n                        // Ignore error\n                        this.handleChildWriteCompleted(this.committedCallIndex);\n                    }\n                }, message);\n            }\n        }\n    }\n    startRead() {\n        this.trace(\"startRead called\");\n        this.readStarted = true;\n        for (const underlyingCall of this.underlyingCalls){\n            if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === \"ACTIVE\") {\n                underlyingCall.call.startRead();\n            }\n        }\n    }\n    halfClose() {\n        this.trace(\"halfClose called\");\n        const halfCloseIndex = this.getNextBufferIndex();\n        this.writeBuffer.push({\n            entryType: \"HALF_CLOSE\",\n            allocated: false\n        });\n        for (const call of this.underlyingCalls){\n            if ((call === null || call === void 0 ? void 0 : call.state) === \"ACTIVE\" && call.nextMessageToSend === halfCloseIndex) {\n                call.nextMessageToSend += 1;\n                call.call.halfClose();\n            }\n        }\n    }\n    setCredentials(newCredentials) {\n        throw new Error(\"Method not implemented.\");\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.host;\n    }\n}\nexports.RetryingCall = RetryingCall; //# sourceMappingURL=retrying-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmV0cnlpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSw0QkFBNEIsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUNwRixNQUFNSyxjQUFjQyxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNRyxjQUFjO0FBQ3BCLE1BQU1MO0lBQ0ZNLFlBQVlDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxzQkFBc0IsQ0FBRTtRQUN2RCxJQUFJLENBQUNGLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO1FBQ2xCLElBQUlDLHdCQUF3QjtZQUN4Qjs2QkFDaUIsR0FDakIsSUFBSSxDQUFDQyxNQUFNLEdBQ1BELHVCQUF1QkMsTUFBTSxHQUN4QkgsQ0FBQUEsWUFBWUUsdUJBQXVCRixTQUFTO1FBQ3pELE9BQ0s7WUFDRCxJQUFJLENBQUNHLE1BQU0sR0FBR0g7UUFDbEI7SUFDSjtJQUNBSSxtQkFBbUI7UUFDZixJQUFJLENBQUNELE1BQU0sR0FBR0UsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ0gsTUFBTSxHQUFHLElBQUksQ0FBQ0YsVUFBVSxFQUFFLElBQUksQ0FBQ0QsU0FBUztJQUN4RTtJQUNBTyxnQkFBZ0I7UUFDWixJQUFJLENBQUNKLE1BQU0sR0FBR0UsS0FBS0csR0FBRyxDQUFDLElBQUksQ0FBQ0wsTUFBTSxHQUFHLEdBQUc7SUFDNUM7SUFDQU0sZUFBZTtRQUNYLE9BQU8sSUFBSSxDQUFDTixNQUFNLEdBQUcsSUFBSSxDQUFDSCxTQUFTLEdBQUc7SUFDMUM7QUFDSjtBQUNBWCxzQkFB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L25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXRyeWluZy1jYWxsLmpzPzdjNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmV0cnlpbmdDYWxsID0gZXhwb3J0cy5NZXNzYWdlQnVmZmVyVHJhY2tlciA9IGV4cG9ydHMuUmV0cnlUaHJvdHRsZXIgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncmV0cnlpbmdfY2FsbCc7XG5jbGFzcyBSZXRyeVRocm90dGxlciB7XG4gICAgY29uc3RydWN0b3IobWF4VG9rZW5zLCB0b2tlblJhdGlvLCBwcmV2aW91c1JldHJ5VGhyb3R0bGVyKSB7XG4gICAgICAgIHRoaXMubWF4VG9rZW5zID0gbWF4VG9rZW5zO1xuICAgICAgICB0aGlzLnRva2VuUmF0aW8gPSB0b2tlblJhdGlvO1xuICAgICAgICBpZiAocHJldmlvdXNSZXRyeVRocm90dGxlcikge1xuICAgICAgICAgICAgLyogV2hlbiBjYXJyeWluZyBvdmVyIHRva2VucyBmcm9tIGEgcHJldmlvdXMgY29uZmlnLCByZXNjYWxlIHRoZW0gdG8gdGhlXG4gICAgICAgICAgICAgKiBuZXcgbWF4IHZhbHVlICovXG4gICAgICAgICAgICB0aGlzLnRva2VucyA9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZXRyeVRocm90dGxlci50b2tlbnMgKlxuICAgICAgICAgICAgICAgICAgICAobWF4VG9rZW5zIC8gcHJldmlvdXNSZXRyeVRocm90dGxlci5tYXhUb2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2tlbnMgPSBtYXhUb2tlbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQ2FsbFN1Y2NlZWRlZCgpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBNYXRoLm1heCh0aGlzLnRva2VucyArIHRoaXMudG9rZW5SYXRpbywgdGhpcy5tYXhUb2tlbnMpO1xuICAgIH1cbiAgICBhZGRDYWxsRmFpbGVkKCkge1xuICAgICAgICB0aGlzLnRva2VucyA9IE1hdGgubWluKHRoaXMudG9rZW5zIC0gMSwgMCk7XG4gICAgfVxuICAgIGNhblJldHJ5Q2FsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zID4gdGhpcy5tYXhUb2tlbnMgLyAyO1xuICAgIH1cbn1cbmV4cG9ydHMuUmV0cnlUaHJvdHRsZXIgPSBSZXRyeVRocm90dGxlcjtcbmNsYXNzIE1lc3NhZ2VCdWZmZXJUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3RhbExpbWl0LCBsaW1pdFBlckNhbGwpIHtcbiAgICAgICAgdGhpcy50b3RhbExpbWl0ID0gdG90YWxMaW1pdDtcbiAgICAgICAgdGhpcy5saW1pdFBlckNhbGwgPSBsaW1pdFBlckNhbGw7XG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgPSAwO1xuICAgICAgICB0aGlzLmFsbG9jYXRlZFBlckNhbGwgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFsbG9jYXRlKHNpemUsIGNhbGxJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJDYWxsID0gKF9hID0gdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmdldChjYWxsSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBpZiAodGhpcy5saW1pdFBlckNhbGwgLSBjdXJyZW50UGVyQ2FsbCA8IHNpemUgfHxcbiAgICAgICAgICAgIHRoaXMudG90YWxMaW1pdCAtIHRoaXMudG90YWxBbGxvY2F0ZWQgPCBzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLnNldChjYWxsSWQsIGN1cnJlbnRQZXJDYWxsICsgc2l6ZSk7XG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZyZWUoc2l6ZSwgY2FsbElkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMudG90YWxBbGxvY2F0ZWQgPCBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVmZmVyIGFsbG9jYXRpb24gc3RhdGU6IGNhbGwgJHtjYWxsSWR9IGZyZWVkICR7c2l6ZX0gPiB0b3RhbCBhbGxvY2F0ZWQgJHt0aGlzLnRvdGFsQWxsb2NhdGVkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgLT0gc2l6ZTtcbiAgICAgICAgY29uc3QgY3VycmVudFBlckNhbGwgPSAoX2EgPSB0aGlzLmFsbG9jYXRlZFBlckNhbGwuZ2V0KGNhbGxJZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIGlmIChjdXJyZW50UGVyQ2FsbCA8IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidWZmZXIgYWxsb2NhdGlvbiBzdGF0ZTogY2FsbCAke2NhbGxJZH0gZnJlZWQgJHtzaXplfSA+IGFsbG9jYXRlZCBmb3IgY2FsbCAke2N1cnJlbnRQZXJDYWxsfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5zZXQoY2FsbElkLCBjdXJyZW50UGVyQ2FsbCAtIHNpemUpO1xuICAgIH1cbiAgICBmcmVlQWxsKGNhbGxJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJDYWxsID0gKF9hID0gdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmdldChjYWxsSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBpZiAodGhpcy50b3RhbEFsbG9jYXRlZCA8IGN1cnJlbnRQZXJDYWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVmZmVyIGFsbG9jYXRpb24gc3RhdGU6IGNhbGwgJHtjYWxsSWR9IGFsbG9jYXRlZCAke2N1cnJlbnRQZXJDYWxsfSA+IHRvdGFsIGFsbG9jYXRlZCAke3RoaXMudG90YWxBbGxvY2F0ZWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRlZCAtPSBjdXJyZW50UGVyQ2FsbDtcbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmRlbGV0ZShjYWxsSWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzc2FnZUJ1ZmZlclRyYWNrZXIgPSBNZXNzYWdlQnVmZmVyVHJhY2tlcjtcbmNvbnN0IFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVkgPSAnZ3JwYy1wcmV2aW91cy1ycGMtYXR0ZW1wdHMnO1xuY2xhc3MgUmV0cnlpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBjYWxsQ29uZmlnLCBtZXRob2ROYW1lLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIsIGJ1ZmZlclRyYWNrZXIsIHJldHJ5VGhyb3R0bGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuY2FsbENvbmZpZyA9IGNhbGxDb25maWc7XG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWU7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IGRlYWRsaW5lO1xuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlclRyYWNrZXIgPSBidWZmZXJUcmFja2VyO1xuICAgICAgICB0aGlzLnJldHJ5VGhyb3R0bGVyID0gcmV0cnlUaHJvdHRsZXI7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRpYWxNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzID0gW107XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvZmZzZXQgb2YgbWVzc2FnZSBpbmRpY2VzIGluIHRoZSB3cml0ZUJ1ZmZlci4gRm9yIGV4YW1wbGUsIGlmXG4gICAgICAgICAqIHdyaXRlQnVmZmVyT2Zmc2V0IGlzIDEwLCBtZXNzYWdlIDEwIGlzIGluIHdyaXRlQnVmZmVyWzBdIGFuZCBtZXNzYWdlIDE1XG4gICAgICAgICAqIGlzIGluIHdyaXRlQnVmZmVyWzVdLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3Mgd2hldGhlciBhIHJlYWQgaGFzIGJlZW4gc3RhcnRlZCwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgdG8gc3RhcnRcbiAgICAgICAgICogcmVhZHMgb24gbmV3IGNoaWxkIGNhbGxzLiBUaGlzIG9ubHkgbWF0dGVycyBmb3IgdGhlIGZpcnN0IHJlYWQsIGJlY2F1c2VcbiAgICAgICAgICogb25jZSBhIG1lc3NhZ2UgY29tZXMgaW4gdGhlIGNoaWxkIGNhbGwgYmVjb21lcyBjb21taXR0ZWQgYW5kIHRoZXJlIHdpbGxcbiAgICAgICAgICogYmUgbm8gbmV3IGNoaWxkIGNhbGxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW50UmV0cnlVc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgYXR0ZW1wdHMgc28gZmFyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5oZWRnaW5nVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbW1pdHRlZENhbGxJbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdGlhbFJldHJ5QmFja29mZlNlYyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IDA7XG4gICAgICAgIGlmIChjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdSRVRSWSc7XG4gICAgICAgICAgICBjb25zdCByZXRyeVBvbGljeSA9IGNhbGxDb25maWcubWV0aG9kQ29uZmlnLnJldHJ5UG9saWN5O1xuICAgICAgICAgICAgdGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjID0gdGhpcy5pbml0aWFsUmV0cnlCYWNrb2ZmU2VjID0gTnVtYmVyKHJldHJ5UG9saWN5LmluaXRpYWxCYWNrb2ZmLnN1YnN0cmluZygwLCByZXRyeVBvbGljeS5pbml0aWFsQmFja29mZi5sZW5ndGggLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdIRURHSU5HJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnVFJBTlNQQVJFTlRfT05MWSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbE51bWJlciArICddICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgcmVwb3J0U3RhdHVzKHN0YXR1c09iamVjdCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgIHN0YXR1c09iamVjdC5jb2RlICtcbiAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xuICAgICAgICAgICAgc3RhdHVzT2JqZWN0LmRldGFpbHMgK1xuICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgIHRoaXMuYnVmZmVyVHJhY2tlci5mcmVlQWxsKHRoaXMuY2FsbE51bWJlcik7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgPSB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ICsgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGNvbnN0cnVjdCBzdGF0dXMgb2JqZWN0IHRvIHJlbW92ZSBwcm9ncmVzcyBmaWVsZFxuICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogc3RhdHVzT2JqZWN0LmNvZGUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogc3RhdHVzT2JqZWN0LmRldGFpbHMsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHN0YXR1c09iamVjdC5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnY2FuY2VsV2l0aFN0YXR1cyBjb2RlOiAnICsgc3RhdHVzICsgJyBkZXRhaWxzOiBcIicgKyBkZXRhaWxzICsgJ1wiJyk7XG4gICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHsgY29kZTogc3RhdHVzLCBkZXRhaWxzLCBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSB9KTtcbiAgICAgICAgZm9yIChjb25zdCB7IGNhbGwgfSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tbWl0dGVkQ2FsbEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmRlcmx5aW5nQ2FsbHNbdGhpcy5jb21taXR0ZWRDYWxsSW5kZXhdLmNhbGwuZ2V0UGVlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMud3JpdGVCdWZmZXJbbWVzc2FnZUluZGV4IC0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHtcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ0ZSRUVEJyxcbiAgICAgICAgICAgIGFsbG9jYXRlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROZXh0QnVmZmVySW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ICsgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIGNsZWFyU2VudE1lc3NhZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0NPTU1JVFRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW3RoaXMuY29tbWl0dGVkQ2FsbEluZGV4XS5uZXh0TWVzc2FnZVRvU2VuZDtcbiAgICAgICAgZm9yIChsZXQgbWVzc2FnZUluZGV4ID0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldDsgbWVzc2FnZUluZGV4IDwgZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXg7IG1lc3NhZ2VJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJFbnRyeSA9IHRoaXMuZ2V0QnVmZmVyRW50cnkobWVzc2FnZUluZGV4KTtcbiAgICAgICAgICAgIGlmIChidWZmZXJFbnRyeS5hbGxvY2F0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclRyYWNrZXIuZnJlZShidWZmZXJFbnRyeS5tZXNzYWdlLm1lc3NhZ2UubGVuZ3RoLCB0aGlzLmNhbGxOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSB0aGlzLndyaXRlQnVmZmVyLnNsaWNlKGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4IC0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgPSBlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleDtcbiAgICB9XG4gICAgY29tbWl0Q2FsbChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0NPTU1JVFRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbaW5kZXhdLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ0NvbW1pdHRpbmcgY2FsbCBbJyArXG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tpbmRleF0uY2FsbC5nZXRDYWxsTnVtYmVyKCkgK1xuICAgICAgICAgICAgJ10gYXQgaW5kZXggJyArXG4gICAgICAgICAgICBpbmRleCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnQ09NTUlUVEVEJztcbiAgICAgICAgdGhpcy5jb21taXR0ZWRDYWxsSW5kZXggPSBpbmRleDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnVuZGVybHlpbmdDYWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbaV0uc3RhdGUgPT09ICdDT01QTEVURUQnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tpXS5zdGF0ZSA9ICdDT01QTEVURUQnO1xuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbaV0uY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdEaXNjYXJkZWQgaW4gZmF2b3Igb2Ygb3RoZXIgaGVkZ2VkIGF0dGVtcHQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyU2VudE1lc3NhZ2VzKCk7XG4gICAgfVxuICAgIGNvbW1pdENhbGxXaXRoTW9zdE1lc3NhZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0NPTU1JVFRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9zdE1lc3NhZ2VzID0gLTE7XG4gICAgICAgIGxldCBjYWxsV2l0aE1vc3RNZXNzYWdlcyA9IC0xO1xuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgY2hpbGRDYWxsXSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZENhbGwuc3RhdGUgPT09ICdBQ1RJVkUnICYmXG4gICAgICAgICAgICAgICAgY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kID4gbW9zdE1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgbW9zdE1lc3NhZ2VzID0gY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kO1xuICAgICAgICAgICAgICAgIGNhbGxXaXRoTW9zdE1lc3NhZ2VzID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxXaXRoTW9zdE1lc3NhZ2VzID09PSAtMSkge1xuICAgICAgICAgICAgLyogVGhlcmUgYXJlIG5vIGFjdGl2ZSBjYWxscywgZGlzYWJsZSByZXRyaWVzIHRvIGZvcmNlIHRoZSBuZXh0IGNhbGwgdGhhdFxuICAgICAgICAgICAgICogaXMgc3RhcnRlZCB0byBiZSBjb21taXR0ZWQuICovXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxXaXRoTW9zdE1lc3NhZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1N0YXR1c0NvZGVJbkxpc3QobGlzdCwgY29kZSkge1xuICAgICAgICByZXR1cm4gbGlzdC5zb21lKHZhbHVlID0+IHZhbHVlID09PSBjb2RlIHx8XG4gICAgICAgICAgICB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IGNvbnN0YW50c18xLlN0YXR1c1tjb2RlXS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgZ2V0TmV4dFJldHJ5QmFja29mZk1zKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJldHJ5UG9saWN5ID0gKF9hID0gdGhpcy5jYWxsQ29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWV0aG9kQ29uZmlnLnJldHJ5UG9saWN5O1xuICAgICAgICBpZiAoIXJldHJ5UG9saWN5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0QmFja29mZk1zID0gTWF0aC5yYW5kb20oKSAqIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyAqIDEwMDA7XG4gICAgICAgIGNvbnN0IG1heEJhY2tvZmZTZWMgPSBOdW1iZXIocmV0cnlQb2xpY3kubWF4QmFja29mZi5zdWJzdHJpbmcoMCwgcmV0cnlQb2xpY3kubWF4QmFja29mZi5sZW5ndGggLSAxKSk7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IE1hdGgubWluKHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyAqIHJldHJ5UG9saWN5LmJhY2tvZmZNdWx0aXBsaWVyLCBtYXhCYWNrb2ZmU2VjKTtcbiAgICAgICAgcmV0dXJuIG5leHRCYWNrb2ZmTXM7XG4gICAgfVxuICAgIG1heWJlUmV0cnlDYWxsKHB1c2hiYWNrLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ1JFVFJZJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHJ5UG9saWN5ID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeTtcbiAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdHMgPj0gTWF0aC5taW4ocmV0cnlQb2xpY3kubWF4QXR0ZW1wdHMsIDUpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldHJ5RGVsYXlNcztcbiAgICAgICAgaWYgKHB1c2hiYWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXRyeURlbGF5TXMgPSB0aGlzLmdldE5leHRSZXRyeUJhY2tvZmZNcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1c2hiYWNrIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcbiAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHJ5RGVsYXlNcyA9IHB1c2hiYWNrO1xuICAgICAgICAgICAgdGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjID0gdGhpcy5pbml0aWFsUmV0cnlCYWNrb2ZmU2VjO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnUkVUUlknKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoX2IgPSAoX2EgPSB0aGlzLnJldHJ5VGhyb3R0bGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuUmV0cnlDYWxsKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRzICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE5ld0F0dGVtcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmV0cnlEZWxheU1zKTtcbiAgICB9XG4gICAgY291bnRBY3RpdmVDYWxscygpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzKSB7XG4gICAgICAgICAgICBpZiAoKGNhbGwgPT09IG51bGwgfHwgY2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbC5zdGF0ZSkgPT09ICdBQ1RJVkUnKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIGhhbmRsZVByb2Nlc3NlZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCwgcHVzaGJhY2spIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnQ09NTUlUVEVEJzpcbiAgICAgICAgICAgIGNhc2UgJ1RSQU5TUEFSRU5UX09OTFknOlxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdIRURHSU5HJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXR1c0NvZGVJbkxpc3QoKF9hID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5Lm5vbkZhdGFsU3RhdHVzQ29kZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCBzdGF0dXMuY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gdGhpcy5yZXRyeVRocm90dGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGF5TXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwdXNoYmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlNcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHVzaGJhY2sgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlNcyA9IHB1c2hiYWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGFmdGVyIHRyeWluZyB0byBzdGFydCBhIGNhbGwgdGhlcmUgYXJlIG5vIGFjdGl2ZSBjYWxscywgdGhpcyB3YXMgdGhlIGxhc3Qgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudEFjdGl2ZUNhbGxzKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBkZWxheU1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JFVFJZJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXR1c0NvZGVJbkxpc3QodGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeS5yZXRyeWFibGVTdGF0dXNDb2Rlcywgc3RhdHVzLmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVSZXRyeUNhbGwocHVzaGJhY2ssIHJldHJpZWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXRyaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UHVzaGJhY2sobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgbWRWYWx1ZSA9IG1ldGFkYXRhLmdldCgnZ3JwYy1yZXRyeS1wdXNoYmFjay1tcycpO1xuICAgICAgICBpZiAobWRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobWRWYWx1ZVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGlsZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1tjYWxsSW5kZXhdLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXRlPScgK1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSArXG4gICAgICAgICAgICAnIGhhbmRsaW5nIHN0YXR1cyB3aXRoIHByb2dyZXNzICcgK1xuICAgICAgICAgICAgc3RhdHVzLnByb2dyZXNzICtcbiAgICAgICAgICAgICcgZnJvbSBjaGlsZCBbJyArXG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tjYWxsSW5kZXhdLmNhbGwuZ2V0Q2FsbE51bWJlcigpICtcbiAgICAgICAgICAgICddIGluIHN0YXRlICcgK1xuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2FsbEluZGV4XS5zdGF0ZSk7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2NhbGxJbmRleF0uc3RhdGUgPSAnQ09NUExFVEVEJztcbiAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdDT01NSVRURUQnKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1c2hiYWNrID0gdGhpcy5nZXRQdXNoYmFjayhzdGF0dXMubWV0YWRhdGEpO1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cy5wcm9ncmVzcykge1xuICAgICAgICAgICAgY2FzZSAnTk9UX1NUQVJURUQnOlxuICAgICAgICAgICAgICAgIC8vIFJQQyBuZXZlciBsZWF2ZXMgdGhlIGNsaWVudCwgYWx3YXlzIHNhZmUgdG8gcmV0cnlcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUkVGVVNFRCc6XG4gICAgICAgICAgICAgICAgLy8gUlBDIHJlYWNoZXMgdGhlIHNlcnZlciBsaWJyYXJ5LCBidXQgbm90IHRoZSBzZXJ2ZXIgYXBwbGljYXRpb24gbG9naWNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVByb2Nlc3NlZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCwgcHVzaGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRFJPUCc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BST0NFU1NFRCc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQcm9jZXNzZWRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgsIHB1c2hiYWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnSEVER0lORycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlZGdpbmdQb2xpY3kgPSB0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3k7XG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzID49IE1hdGgubWluKGhlZGdpbmdQb2xpY3kubWF4QXR0ZW1wdHMsIDUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRlbXB0cyArPSAxO1xuICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xuICAgICAgICB0aGlzLm1heWJlU3RhcnRIZWRnaW5nVGltZXIoKTtcbiAgICB9XG4gICAgbWF5YmVTdGFydEhlZGdpbmdUaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICh0aGlzLmhlZGdpbmdUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVkZ2luZ1RpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0hFREdJTkcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3kpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWRnaW5nUG9saWN5ID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5O1xuICAgICAgICBpZiAodGhpcy5hdHRlbXB0cyA+PSBNYXRoLm1pbihoZWRnaW5nUG9saWN5Lm1heEF0dGVtcHRzLCA1KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlZGdpbmdEZWxheVN0cmluZyA9IChfYSA9IGhlZGdpbmdQb2xpY3kuaGVkZ2luZ0RlbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnMHMnO1xuICAgICAgICBjb25zdCBoZWRnaW5nRGVsYXlTZWMgPSBOdW1iZXIoaGVkZ2luZ0RlbGF5U3RyaW5nLnN1YnN0cmluZygwLCBoZWRnaW5nRGVsYXlTdHJpbmcubGVuZ3RoIC0gMSkpO1xuICAgICAgICB0aGlzLmhlZGdpbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKTtcbiAgICAgICAgfSwgaGVkZ2luZ0RlbGF5U2VjICogMTAwMCk7XG4gICAgICAgIChfYyA9IChfYiA9IHRoaXMuaGVkZ2luZ1RpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xuICAgIH1cbiAgICBzdGFydE5ld0F0dGVtcHQoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGFubmVsLmNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsKHRoaXMuY2FsbENvbmZpZywgdGhpcy5tZXRob2ROYW1lLCB0aGlzLmhvc3QsIHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkIGNoaWxkIGNhbGwgWycgK1xuICAgICAgICAgICAgY2hpbGQuZ2V0Q2FsbE51bWJlcigpICtcbiAgICAgICAgICAgICddIGZvciBhdHRlbXB0ICcgK1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0cyk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy51bmRlcmx5aW5nQ2FsbHMubGVuZ3RoO1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxscy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXRlOiAnQUNUSVZFJyxcbiAgICAgICAgICAgIGNhbGw6IGNoaWxkLFxuICAgICAgICAgICAgbmV4dE1lc3NhZ2VUb1NlbmQ6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcmV2aW91c0F0dGVtcHRzID0gdGhpcy5hdHRlbXB0cyAtIDE7XG4gICAgICAgIGNvbnN0IGluaXRpYWxNZXRhZGF0YSA9IHRoaXMuaW5pdGlhbE1ldGFkYXRhLmNsb25lKCk7XG4gICAgICAgIGlmIChwcmV2aW91c0F0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgaW5pdGlhbE1ldGFkYXRhLnNldChQUkVWSU9OU19SUENfQVRURU1QVFNfTUVUQURBVEFfS0VZLCBgJHtwcmV2aW91c0F0dGVtcHRzfWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWNlaXZlZE1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIGNoaWxkLnN0YXJ0KGluaXRpYWxNZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBtZXRhZGF0YSBmcm9tIGNoaWxkIFsnICsgY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0F0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5zZXQoUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSwgYCR7cHJldmlvdXNBdHRlbXB0c31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2luZGV4XS5zdGF0ZSA9PT0gJ0FDVElWRScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSBjaGlsZCBbJyArIGNoaWxkLmdldENhbGxOdW1iZXIoKSArICddJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbaW5kZXhdLnN0YXRlID09PSAnQUNUSVZFJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzdGF0dXMgZnJvbSBjaGlsZCBbJyArIGNoaWxkLmdldENhbGxOdW1iZXIoKSArICddJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWNlaXZlZE1ldGFkYXRhICYmIHByZXZpb3VzQXR0ZW1wdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5tZXRhZGF0YS5zZXQoUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSwgYCR7cHJldmlvdXNBdHRlbXB0c31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlsZFN0YXR1cyhzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbmROZXh0Q2hpbGRNZXNzYWdlKGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMucmVhZFN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0UmVhZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnRyYWNlKCdzdGFydCBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmluaXRpYWxNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLmF0dGVtcHRzICs9IDE7XG4gICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XG4gICAgICAgIHRoaXMubWF5YmVTdGFydEhlZGdpbmdUaW1lcigpO1xuICAgIH1cbiAgICBoYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkKGNoaWxkSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2hpbGRDYWxsID0gdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2hpbGRJbmRleF07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJbmRleCA9IGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZDtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5nZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpKS5jYWxsYmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB0aGlzLmNsZWFyU2VudE1lc3NhZ2VzKCk7XG4gICAgICAgIGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCArPSAxO1xuICAgICAgICB0aGlzLnNlbmROZXh0Q2hpbGRNZXNzYWdlKGNoaWxkSW5kZXgpO1xuICAgIH1cbiAgICBzZW5kTmV4dENoaWxkTWVzc2FnZShjaGlsZEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkQ2FsbCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW2NoaWxkSW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGRDYWxsLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldEJ1ZmZlckVudHJ5KGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckVudHJ5ID0gdGhpcy5nZXRCdWZmZXJFbnRyeShjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQpO1xuICAgICAgICAgICAgc3dpdGNoIChidWZmZXJFbnRyeS5lbnRyeVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdNRVNTQUdFJzpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDYWxsLmNhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRXcml0ZUNvbXBsZXRlZChjaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sIGJ1ZmZlckVudHJ5Lm1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0hBTEZfQ0xPU0UnOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDYWxsLmNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0ZSRUVEJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBiZSBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRyYWNlKCd3cml0ZSgpIGNhbGxlZCB3aXRoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHdyaXRlT2JqID0ge1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGZsYWdzOiBjb250ZXh0LmZsYWdzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtZXNzYWdlSW5kZXggPSB0aGlzLmdldE5leHRCdWZmZXJJbmRleCgpO1xuICAgICAgICBjb25zdCBidWZmZXJFbnRyeSA9IHtcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ01FU1NBR0UnLFxuICAgICAgICAgICAgbWVzc2FnZTogd3JpdGVPYmosXG4gICAgICAgICAgICBhbGxvY2F0ZWQ6IHRoaXMuYnVmZmVyVHJhY2tlci5hbGxvY2F0ZShtZXNzYWdlLmxlbmd0aCwgdGhpcy5jYWxsTnVtYmVyKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKGJ1ZmZlckVudHJ5KTtcbiAgICAgICAgaWYgKGJ1ZmZlckVudHJ5LmFsbG9jYXRlZCkge1xuICAgICAgICAgICAgKF9hID0gY29udGV4dC5jYWxsYmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY29udGV4dCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjYWxsSW5kZXgsIGNhbGxdIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsLnN0YXRlID09PSAnQUNUSVZFJyAmJlxuICAgICAgICAgICAgICAgICAgICBjYWxsLm5leHRNZXNzYWdlVG9TZW5kID09PSBtZXNzYWdlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbFdpdGhNb3N0TWVzc2FnZXMoKTtcbiAgICAgICAgICAgIC8vIGNvbW1pdENhbGxXaXRoTW9zdE1lc3NhZ2VzIGNhbiBmYWlsIGlmIHdlIGFyZSBiZXR3ZWVuIHBpbmcgYXR0ZW1wdHNcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbW1pdHRlZENhbGxJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSB0aGlzLnVuZGVybHlpbmdDYWxsc1t0aGlzLmNvbW1pdHRlZENhbGxJbmRleF07XG4gICAgICAgICAgICBidWZmZXJFbnRyeS5jYWxsYmFjayA9IGNvbnRleHQuY2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAoY2FsbC5zdGF0ZSA9PT0gJ0FDVElWRScgJiYgY2FsbC5uZXh0TWVzc2FnZVRvU2VuZCA9PT0gbWVzc2FnZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FsbC5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQodGhpcy5jb21taXR0ZWRDYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnRSZWFkIGNhbGxlZCcpO1xuICAgICAgICB0aGlzLnJlYWRTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCB1bmRlcmx5aW5nQ2FsbCBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgaWYgKCh1bmRlcmx5aW5nQ2FsbCA9PT0gbnVsbCB8fCB1bmRlcmx5aW5nQ2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5kZXJseWluZ0NhbGwuc3RhdGUpID09PSAnQUNUSVZFJykge1xuICAgICAgICAgICAgICAgIHVuZGVybHlpbmdDYWxsLmNhbGwuc3RhcnRSZWFkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdoYWxmQ2xvc2UgY2FsbGVkJyk7XG4gICAgICAgIGNvbnN0IGhhbGZDbG9zZUluZGV4ID0gdGhpcy5nZXROZXh0QnVmZmVySW5kZXgoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHtcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ0hBTEZfQ0xPU0UnLFxuICAgICAgICAgICAgYWxsb2NhdGVkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgaWYgKChjYWxsID09PSBudWxsIHx8IGNhbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGwuc3RhdGUpID09PSAnQUNUSVZFJyAmJlxuICAgICAgICAgICAgICAgIGNhbGwubmV4dE1lc3NhZ2VUb1NlbmQgPT09IGhhbGZDbG9zZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FsbC5uZXh0TWVzc2FnZVRvU2VuZCArPSAxO1xuICAgICAgICAgICAgICAgIGNhbGwuY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDcmVkZW50aWFscyhuZXdDcmVkZW50aWFscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIGdldE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kTmFtZTtcbiAgICB9XG4gICAgZ2V0SG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdDtcbiAgICB9XG59XG5leHBvcnRzLlJldHJ5aW5nQ2FsbCA9IFJldHJ5aW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5aW5nLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmV0cnlpbmdDYWxsIiwiTWVzc2FnZUJ1ZmZlclRyYWNrZXIiLCJSZXRyeVRocm90dGxlciIsImNvbnN0YW50c18xIiwicmVxdWlyZSIsIm1ldGFkYXRhXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJjb25zdHJ1Y3RvciIsIm1heFRva2VucyIsInRva2VuUmF0aW8iLCJwcmV2aW91c1JldHJ5VGhyb3R0bGVyIiwidG9rZW5zIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsIk1hdGgiLCJtYXgiLCJhZGRDYWxsRmFpbGVkIiwibWluIiwiY2FuUmV0cnlDYWxsIiwidG90YWxMaW1pdCIsImxpbWl0UGVyQ2FsbCIsInRvdGFsQWxsb2NhdGVkIiwiYWxsb2NhdGVkUGVyQ2FsbCIsIk1hcCIsImFsbG9jYXRlIiwic2l6ZSIsImNhbGxJZCIsIl9hIiwiY3VycmVudFBlckNhbGwiLCJnZXQiLCJzZXQiLCJmcmVlIiwiRXJyb3IiLCJmcmVlQWxsIiwiZGVsZXRlIiwiUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSIsImNoYW5uZWwiLCJjYWxsQ29uZmlnIiwibWV0aG9kTmFtZSIsImhvc3QiLCJjcmVkZW50aWFscyIsImRlYWRsaW5lIiwiY2FsbE51bWJlciIsImJ1ZmZlclRyYWNrZXIiLCJyZXRyeVRocm90dGxlciIsImxpc3RlbmVyIiwiaW5pdGlhbE1ldGFkYXRhIiwidW5kZXJseWluZ0NhbGxzIiwid3JpdGVCdWZmZXIiLCJ3cml0ZUJ1ZmZlck9mZnNldCIsInJlYWRTdGFydGVkIiwidHJhbnNwYXJlbnRSZXRyeVVzZWQiLCJhdHRlbXB0cyIsImhlZGdpbmdUaW1lciIsImNvbW1pdHRlZENhbGxJbmRleCIsImluaXRpYWxSZXRyeUJhY2tvZmZTZWMiLCJuZXh0UmV0cnlCYWNrb2ZmU2VjIiwibWV0aG9kQ29uZmlnIiwicmV0cnlQb2xpY3kiLCJzdGF0ZSIsIk51bWJlciIsImluaXRpYWxCYWNrb2ZmIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiaGVkZ2luZ1BvbGljeSIsImdldENhbGxOdW1iZXIiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsInJlcG9ydFN0YXR1cyIsInN0YXR1c09iamVjdCIsImNvZGUiLCJkZXRhaWxzIiwicHJvY2VzcyIsIm5leHRUaWNrIiwib25SZWNlaXZlU3RhdHVzIiwibWV0YWRhdGEiLCJjYW5jZWxXaXRoU3RhdHVzIiwic3RhdHVzIiwiTWV0YWRhdGEiLCJjYWxsIiwiZ2V0UGVlciIsImdldEJ1ZmZlckVudHJ5IiwibWVzc2FnZUluZGV4IiwiZW50cnlUeXBlIiwiYWxsb2NhdGVkIiwiZ2V0TmV4dEJ1ZmZlckluZGV4IiwiY2xlYXJTZW50TWVzc2FnZXMiLCJlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleCIsIm5leHRNZXNzYWdlVG9TZW5kIiwiYnVmZmVyRW50cnkiLCJtZXNzYWdlIiwic2xpY2UiLCJjb21taXRDYWxsIiwiaW5kZXgiLCJpIiwiU3RhdHVzIiwiQ0FOQ0VMTEVEIiwiY29tbWl0Q2FsbFdpdGhNb3N0TWVzc2FnZXMiLCJtb3N0TWVzc2FnZXMiLCJjYWxsV2l0aE1vc3RNZXNzYWdlcyIsImNoaWxkQ2FsbCIsImVudHJpZXMiLCJpc1N0YXR1c0NvZGVJbkxpc3QiLCJsaXN0Iiwic29tZSIsInRvU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJnZXROZXh0UmV0cnlCYWNrb2ZmTXMiLCJuZXh0QmFja29mZk1zIiwicmFuZG9tIiwibWF4QmFja29mZlNlYyIsIm1heEJhY2tvZmYiLCJiYWNrb2ZmTXVsdGlwbGllciIsIm1heWJlUmV0cnlDYWxsIiwicHVzaGJhY2siLCJjYWxsYmFjayIsIm1heEF0dGVtcHRzIiwicmV0cnlEZWxheU1zIiwic2V0VGltZW91dCIsIl9iIiwic3RhcnROZXdBdHRlbXB0IiwiY291bnRBY3RpdmVDYWxscyIsImNvdW50IiwiaGFuZGxlUHJvY2Vzc2VkU3RhdHVzIiwiY2FsbEluZGV4IiwiX2MiLCJub25GYXRhbFN0YXR1c0NvZGVzIiwiZGVsYXlNcyIsIm1heWJlU3RhcnRIZWRnaW5nQXR0ZW1wdCIsInJldHJ5YWJsZVN0YXR1c0NvZGVzIiwicmV0cmllZCIsImdldFB1c2hiYWNrIiwibWRWYWx1ZSIsInBhcnNlSW50IiwiZSIsImhhbmRsZUNoaWxkU3RhdHVzIiwicHJvZ3Jlc3MiLCJPSyIsIm1heWJlU3RhcnRIZWRnaW5nVGltZXIiLCJjbGVhclRpbWVvdXQiLCJoZWRnaW5nRGVsYXlTdHJpbmciLCJoZWRnaW5nRGVsYXkiLCJoZWRnaW5nRGVsYXlTZWMiLCJ1bnJlZiIsImNoaWxkIiwiY3JlYXRlTG9hZEJhbGFuY2luZ0NhbGwiLCJwdXNoIiwicHJldmlvdXNBdHRlbXB0cyIsImNsb25lIiwicmVjZWl2ZWRNZXRhZGF0YSIsInN0YXJ0Iiwib25SZWNlaXZlTWV0YWRhdGEiLCJvblJlY2VpdmVNZXNzYWdlIiwic2VuZE5leHRDaGlsZE1lc3NhZ2UiLCJzdGFydFJlYWQiLCJoYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkIiwiY2hpbGRJbmRleCIsInNlbmRNZXNzYWdlV2l0aENvbnRleHQiLCJlcnJvciIsImhhbGZDbG9zZSIsImNvbnRleHQiLCJ3cml0ZU9iaiIsImZsYWdzIiwidW5kZXJseWluZ0NhbGwiLCJoYWxmQ2xvc2VJbmRleCIsInNldENyZWRlbnRpYWxzIiwibmV3Q3JlZGVudGlhbHMiLCJnZXRNZXRob2QiLCJnZXRIb3N0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-call.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst TRACER_NAME = \"server_call\";\nconst unzip = (0, util_1.promisify)(zlib.unzip);\nconst inflate = (0, util_1.promisify)(zlib.inflate);\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = \"grpc-accept-encoding\";\nconst GRPC_ENCODING_HEADER = \"grpc-encoding\";\nconst GRPC_MESSAGE_HEADER = \"grpc-message\";\nconst GRPC_STATUS_HEADER = \"grpc-status\";\nconst GRPC_TIMEOUT_HEADER = \"grpc-timeout\";\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001\n};\nconst defaultCompressionHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: \"identity,deflate,gzip\",\n    [GRPC_ENCODING_HEADER]: \"identity\"\n};\nconst defaultResponseHeaders = {\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: \"application/grpc+proto\"\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(call, metadata, request){\n        super();\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(call, metadata, deserialize, encoding){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n    }\n    _read(size) {\n        if (!this.call.consumeUnpushedMessages(this)) {\n            return;\n        }\n        this.call.resume();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(call, metadata, serialize, request){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.request = request;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.on(\"error\", (err)=>{\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    _write(chunk, encoding, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            const response = this.call.serializeMessage(chunk);\n            if (!this.call.write(response)) {\n                this.call.once(\"drain\", callback);\n                return;\n            }\n        } catch (err) {\n            this.emit(\"error\", {\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL\n            });\n        }\n        callback();\n    }\n    _final(callback) {\n        this.call.sendStatus({\n            code: constants_1.Status.OK,\n            details: \"OK\",\n            metadata: this.trailingMetadata\n        });\n        callback(null);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(call, metadata, serialize, deserialize, encoding){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n        this.on(\"error\", (err)=>{\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n    constructor(stream, handler, options){\n        super();\n        this.stream = stream;\n        this.handler = handler;\n        this.cancelled = false;\n        this.deadlineTimer = null;\n        this.statusSent = false;\n        this.deadline = Infinity;\n        this.wantTrailers = false;\n        this.metadataSent = false;\n        this.canPush = false;\n        this.isPushPending = false;\n        this.bufferedMessages = [];\n        this.messagesToPush = [];\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.stream.once(\"error\", (err)=>{\n        /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */ });\n        this.stream.once(\"close\", ()=>{\n            var _a;\n            trace(\"Request to method \" + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + \" stream closed with rstCode \" + this.stream.rstCode);\n            if (!this.statusSent) {\n                this.cancelled = true;\n                this.emit(\"cancelled\", \"cancelled\");\n                this.emit(\"streamEnd\", false);\n                this.sendStatus({\n                    code: constants_1.Status.CANCELLED,\n                    details: \"Cancelled by client\",\n                    metadata: null\n                });\n                if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n            }\n        });\n        this.stream.on(\"drain\", ()=>{\n            this.emit(\"drain\");\n        });\n        if (\"grpc.max_send_message_length\" in options) {\n            this.maxSendMessageSize = options[\"grpc.max_send_message_length\"];\n        }\n        if (\"grpc.max_receive_message_length\" in options) {\n            this.maxReceiveMessageSize = options[\"grpc.max_receive_message_length\"];\n        }\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */ if (this.stream.destroyed || this.stream.closed) {\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    getDecompressedMessage(message, encoding) {\n        if (encoding === \"deflate\") {\n            return inflate(message.subarray(5));\n        } else if (encoding === \"gzip\") {\n            return unzip(message.subarray(5));\n        } else if (encoding === \"identity\") {\n            return message.subarray(5);\n        }\n        return Promise.reject({\n            code: constants_1.Status.UNIMPLEMENTED,\n            details: `Received message compressed with unsupported encoding \"${encoding}\"`\n        });\n    }\n    sendMetadata(customMetadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n        // TODO(cjihrig): Include compression headers.\n        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    receiveMetadata(headers) {\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            trace(\"Request to \" + this.handler.path + \" received headers \" + JSON.stringify(metadata.toJSON()));\n        }\n        // TODO(cjihrig): Receive compression metadata.\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n            if (match === null) {\n                const err = new Error(\"Invalid deadline\");\n                err.code = constants_1.Status.OUT_OF_RANGE;\n                this.sendError(err);\n                return metadata;\n            }\n            const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n            const now = new Date();\n            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n            metadata.remove(GRPC_TIMEOUT_HEADER);\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        metadata.remove(\"grpc-accept-encoding\");\n        return metadata;\n    }\n    receiveUnaryMessage(encoding) {\n        return new Promise((resolve, reject)=>{\n            const { stream } = this;\n            let receivedLength = 0;\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const call = this;\n            const body = [];\n            const limit = this.maxReceiveMessageSize;\n            this.stream.on(\"data\", onData);\n            this.stream.on(\"end\", onEnd);\n            this.stream.on(\"error\", onEnd);\n            function onData(chunk) {\n                receivedLength += chunk.byteLength;\n                if (limit !== -1 && receivedLength > limit) {\n                    stream.removeListener(\"data\", onData);\n                    stream.removeListener(\"end\", onEnd);\n                    stream.removeListener(\"error\", onEnd);\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${receivedLength} vs. ${limit})`\n                    });\n                    return;\n                }\n                body.push(chunk);\n            }\n            function onEnd(err) {\n                stream.removeListener(\"data\", onData);\n                stream.removeListener(\"end\", onEnd);\n                stream.removeListener(\"error\", onEnd);\n                if (err !== undefined) {\n                    reject({\n                        code: constants_1.Status.INTERNAL,\n                        details: err.message\n                    });\n                    return;\n                }\n                if (receivedLength === 0) {\n                    reject({\n                        code: constants_1.Status.INTERNAL,\n                        details: \"received empty unary message\"\n                    });\n                    return;\n                }\n                call.emit(\"receiveMessage\");\n                const requestBytes = Buffer.concat(body, receivedLength);\n                const compressed = requestBytes.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : \"identity\";\n                const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n                if (Buffer.isBuffer(decompressedMessage)) {\n                    resolve(call.deserializeMessageWithInternalError(decompressedMessage));\n                    return;\n                }\n                decompressedMessage.then((decompressed)=>resolve(call.deserializeMessageWithInternalError(decompressed)), (err)=>reject(err.code ? err : {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`\n                    }));\n            }\n        });\n    }\n    async deserializeMessageWithInternalError(buffer) {\n        try {\n            return this.deserializeMessage(buffer);\n        } catch (err) {\n            throw {\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL\n            };\n        }\n    }\n    serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        // TODO(cjihrig): Call compression aware serializeMessage().\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    deserializeMessage(bytes) {\n        return this.handler.deserialize(bytes);\n    }\n    async sendUnaryMessage(err, value, metadata, flags) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (metadata === undefined) {\n            metadata = null;\n        }\n        if (err) {\n            if (!Object.prototype.hasOwnProperty.call(err, \"metadata\") && metadata) {\n                err.metadata = metadata;\n            }\n            this.sendError(err);\n            return;\n        }\n        try {\n            const response = this.serializeMessage(value);\n            this.write(response);\n            this.sendStatus({\n                code: constants_1.Status.OK,\n                details: \"OK\",\n                metadata\n            });\n        } catch (err) {\n            this.sendError({\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL\n            });\n        }\n    }\n    sendStatus(statusObj) {\n        var _a, _b;\n        this.emit(\"callEnd\", statusObj.code);\n        this.emit(\"streamEnd\", statusObj.code === constants_1.Status.OK);\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace(\"Request to method \" + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + \" ended with status code: \" + constants_1.Status[statusObj.code] + \" details: \" + statusObj.details);\n        if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n        if (this.stream.headersSent) {\n            if (!this.wantTrailers) {\n                this.wantTrailers = true;\n                this.stream.once(\"wantTrailers\", ()=>{\n                    var _a;\n                    const trailersToSend = Object.assign({\n                        [GRPC_STATUS_HEADER]: statusObj.code,\n                        [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n                    }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n                    this.stream.sendTrailers(trailersToSend);\n                    this.statusSent = true;\n                });\n                this.stream.end();\n            }\n        } else {\n            // Trailers-only response\n            const trailersToSend = Object.assign(Object.assign({\n                [GRPC_STATUS_HEADER]: statusObj.code,\n                [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n            }, defaultResponseHeaders), (_b = statusObj.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());\n            this.stream.respond(trailersToSend, {\n                endStream: true\n            });\n            this.statusSent = true;\n        }\n    }\n    sendError(error) {\n        const status = {\n            code: constants_1.Status.UNKNOWN,\n            details: \"message\" in error ? error.message : \"Unknown Error\",\n            metadata: \"metadata\" in error && error.metadata !== undefined ? error.metadata : null\n        };\n        if (\"code\" in error && typeof error.code === \"number\" && Number.isInteger(error.code)) {\n            status.code = error.code;\n            if (\"details\" in error && typeof error.details === \"string\") {\n                status.details = error.details;\n            }\n        }\n        this.sendStatus(status);\n    }\n    write(chunk) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n            this.sendError({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n            });\n            return;\n        }\n        this.sendMetadata();\n        this.emit(\"sendMessage\");\n        return this.stream.write(chunk);\n    }\n    resume() {\n        this.stream.resume();\n    }\n    setupSurfaceCall(call) {\n        this.once(\"cancelled\", (reason)=>{\n            call.cancelled = true;\n            call.emit(\"cancelled\", reason);\n        });\n        this.once(\"callEnd\", (status)=>call.emit(\"callEnd\", status));\n    }\n    setupReadable(readable, encoding) {\n        const decoder = new stream_decoder_1.StreamDecoder();\n        let readsDone = false;\n        let pendingMessageProcessing = false;\n        let pushedEnd = false;\n        const maybePushEnd = async ()=>{\n            if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n                pushedEnd = true;\n                await this.pushOrBufferMessage(readable, null);\n            }\n        };\n        this.stream.on(\"data\", async (data)=>{\n            const messages = decoder.write(data);\n            pendingMessageProcessing = true;\n            this.stream.pause();\n            for (const message of messages){\n                if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {\n                    this.sendError({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`\n                    });\n                    return;\n                }\n                this.emit(\"receiveMessage\");\n                const compressed = message.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : \"identity\";\n                const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n                // Encountered an error with decompression; it'll already have been propogated back\n                // Just return early\n                if (!decompressedMessage) return;\n                await this.pushOrBufferMessage(readable, decompressedMessage);\n            }\n            pendingMessageProcessing = false;\n            this.stream.resume();\n            await maybePushEnd();\n        });\n        this.stream.once(\"end\", async ()=>{\n            readsDone = true;\n            await maybePushEnd();\n        });\n    }\n    consumeUnpushedMessages(readable) {\n        this.canPush = true;\n        while(this.messagesToPush.length > 0){\n            const nextMessage = this.messagesToPush.shift();\n            const canPush = readable.push(nextMessage);\n            if (nextMessage === null || canPush === false) {\n                this.canPush = false;\n                break;\n            }\n        }\n        return this.canPush;\n    }\n    async pushOrBufferMessage(readable, messageBytes) {\n        if (this.isPushPending) {\n            this.bufferedMessages.push(messageBytes);\n        } else {\n            await this.pushMessage(readable, messageBytes);\n        }\n    }\n    async pushMessage(readable, messageBytes) {\n        if (messageBytes === null) {\n            trace(\"Received end of stream\");\n            if (this.canPush) {\n                readable.push(null);\n            } else {\n                this.messagesToPush.push(null);\n            }\n            return;\n        }\n        trace(\"Received message of length \" + messageBytes.length);\n        this.isPushPending = true;\n        try {\n            const deserialized = await this.deserializeMessage(messageBytes);\n            if (this.canPush) {\n                if (!readable.push(deserialized)) {\n                    this.canPush = false;\n                    this.stream.pause();\n                }\n            } else {\n                this.messagesToPush.push(deserialized);\n            }\n        } catch (error) {\n            // Ignore any remaining messages when errors occur.\n            this.bufferedMessages.length = 0;\n            let code = (0, error_1.getErrorCode)(error);\n            if (code === null || code < constants_1.Status.OK || code > constants_1.Status.UNAUTHENTICATED) {\n                code = constants_1.Status.INTERNAL;\n            }\n            readable.emit(\"error\", {\n                details: (0, error_1.getErrorMessage)(error),\n                code: code\n            });\n        }\n        this.isPushPending = false;\n        if (this.bufferedMessages.length > 0) {\n            await this.pushMessage(readable, this.bufferedMessages.shift());\n        }\n    }\n    getPeer() {\n        var _a;\n        const socket = (_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket;\n        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            } else {\n                return socket.remoteAddress;\n            }\n        } else {\n            return \"unknown\";\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n    getPath() {\n        return this.handler.path;\n    }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n    const err = new Error(\"Deadline exceeded\");\n    err.code = constants_1.Status.DEADLINE_EXCEEDED;\n    call.sendError(err);\n    call.cancelled = true;\n    call.emit(\"cancelled\", \"deadline\");\n} //# sourceMappingURL=server-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw2QkFBNkIsR0FBR0EsOEJBQThCLEdBQUdBLGdDQUFnQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsMkJBQTJCLEdBQUcsS0FBSztBQUMxSyxNQUFNTyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNSSxTQUFTSixtQkFBT0EsQ0FBQyxrQkFBTTtBQUM3QixNQUFNSyxjQUFjTCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNTSxhQUFhTixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNTyxtQkFBbUJQLG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNuRCxNQUFNUSxVQUFVUixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNUyxVQUFVVCxtQkFBT0EsQ0FBQyxzRUFBUztBQUNqQyxNQUFNVSxjQUFjO0FBQ3BCLE1BQU1DLFFBQVEsQ0FBQyxHQUFHUCxPQUFPUSxTQUFTLEVBQUVULEtBQUtRLEtBQUs7QUFDOUMsTUFBTUUsVUFBVSxDQUFDLEdBQUdULE9BQU9RLFNBQVMsRUFBRVQsS0FBS1UsT0FBTztBQUNsRCxTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZQLFFBQVFNLEtBQUssQ0FBQ1QsWUFBWVcsWUFBWSxDQUFDQyxLQUFLLEVBQUVQLGFBQWFLO0FBQy9EO0FBQ0EsTUFBTUcsOEJBQThCO0FBQ3BDLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMscUJBQXFCO0FBQzNCLE1B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QUFLLElBQUksS0FBSyxJQUFJQSxPQUFPRSxhQUFhLEVBQUU7WUFDdEUsSUFBSUYsT0FBT0csVUFBVSxFQUFFO2dCQUNuQixPQUFPLENBQUMsRUFBRUgsT0FBT0UsYUFBYSxDQUFDLENBQUMsRUFBRUYsT0FBT0csVUFBVSxDQUFDLENBQUM7WUFDekQsT0FDSztnQkFDRCxPQUFPSCxPQUFPRSxhQUFhO1lBQy9CO1FBQ0osT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0lBQ0FySyxjQUFjO1FBQ1YsT0FBTyxJQUFJLENBQUMwQyxRQUFRO0lBQ3hCO0lBQ0F6QyxVQUFVO1FBQ04sT0FBTyxJQUFJLENBQUNxQyxPQUFPLENBQUNpQixJQUFJO0lBQzVCO0FBQ0o7QUFDQWhILDZCQUE2QixHQUFHRTtBQUNoQyxTQUFTb0osc0JBQXNCckcsSUFBSTtJQUMvQixNQUFNd0IsTUFBTSxJQUFJcUUsTUFBTTtJQUN0QnJFLElBQUlhLElBQUksR0FBR3pFLFlBQVkwRSxNQUFNLENBQUN5SSxpQkFBaUI7SUFDL0MvSyxLQUFLeUIsU0FBUyxDQUFDRDtJQUNmeEIsS0FBS0csU0FBUyxHQUFHO0lBQ2pCSCxLQUFLa0MsSUFBSSxDQUFDLGFBQWE7QUFDM0IsRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY2FsbC5qcz83MjNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHAyU2VydmVyQ2FsbFN0cmVhbSA9IGV4cG9ydHMuU2VydmVyRHVwbGV4U3RyZWFtSW1wbCA9IGV4cG9ydHMuU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLlNlcnZlclVuYXJ5Q2FsbEltcGwgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBzdHJlYW1fZGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vc3RyZWFtLWRlY29kZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3NlcnZlcl9jYWxsJztcbmNvbnN0IHVuemlwID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHpsaWIudW56aXApO1xuY29uc3QgaW5mbGF0ZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh6bGliLmluZmxhdGUpO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVIgPSAnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnO1xuY29uc3QgR1JQQ19FTkNPRElOR19IRUFERVIgPSAnZ3JwYy1lbmNvZGluZyc7XG5jb25zdCBHUlBDX01FU1NBR0VfSEVBREVSID0gJ2dycGMtbWVzc2FnZSc7XG5jb25zdCBHUlBDX1NUQVRVU19IRUFERVIgPSAnZ3JwYy1zdGF0dXMnO1xuY29uc3QgR1JQQ19USU1FT1VUX0hFQURFUiA9ICdncnBjLXRpbWVvdXQnO1xuY29uc3QgREVBRExJTkVfUkVHRVggPSAvKFxcZHsxLDh9KVxccyooW0hNU211bl0pLztcbmNvbnN0IGRlYWRsaW5lVW5pdHNUb01zID0ge1xuICAgIEg6IDM2MDAwMDAsXG4gICAgTTogNjAwMDAsXG4gICAgUzogMTAwMCxcbiAgICBtOiAxLFxuICAgIHU6IDAuMDAxLFxuICAgIG46IDAuMDAwMDAxLFxufTtcbmNvbnN0IGRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMgPSB7XG4gICAgLy8gVE9ETyhjamlocmlnKTogUmVtb3ZlIHRoZXNlIGVuY29kaW5nIGhlYWRlcnMgZnJvbSB0aGUgZGVmYXVsdCByZXNwb25zZVxuICAgIC8vIG9uY2UgY29tcHJlc3Npb24gaXMgaW50ZWdyYXRlZC5cbiAgICBbR1JQQ19BQ0NFUFRfRU5DT0RJTkdfSEVBREVSXTogJ2lkZW50aXR5LGRlZmxhdGUsZ3ppcCcsXG4gICAgW0dSUENfRU5DT0RJTkdfSEVBREVSXTogJ2lkZW50aXR5Jyxcbn07XG5jb25zdCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzID0ge1xuICAgIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1NUQVRVU106IGh0dHAyLmNvbnN0YW50cy5IVFRQX1NUQVRVU19PSyxcbiAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdOiAnYXBwbGljYXRpb24vZ3JwYytwcm90bycsXG59O1xuY29uc3QgZGVmYXVsdFJlc3BvbnNlT3B0aW9ucyA9IHtcbiAgICB3YWl0Rm9yVHJhaWxlcnM6IHRydWUsXG59O1xuY2xhc3MgU2VydmVyVW5hcnlDYWxsSW1wbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyVW5hcnlDYWxsSW1wbCA9IFNlcnZlclVuYXJ5Q2FsbEltcGw7XG5jbGFzcyBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5SZWFkYWJsZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIGRlc2VyaWFsaXplLCBlbmNvZGluZykge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwUmVhZGFibGUodGhpcywgZW5jb2RpbmcpO1xuICAgIH1cbiAgICBfcmVhZChzaXplKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsLmNvbnN1bWVVbnB1c2hlZE1lc3NhZ2VzKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsLnJlc3VtZSgpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQYXRoKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgPSBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGw7XG5jbGFzcyBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHNlcmlhbGl6ZSwgcmVxdWVzdCkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIHRoaXMuY2FsbC5zZXR1cFN1cmZhY2VDYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGwuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuY2FsbC5zZXJpYWxpemVNZXNzYWdlKGNodW5rKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxsLndyaXRlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5vbmNlKCdkcmFpbicsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGVyciksXG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgX2ZpbmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgIGRldGFpbHM6ICdPSycsXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy50cmFpbGluZ01ldGFkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZW5kKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsID0gU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgU2VydmVyRHVwbGV4U3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGVuY29kaW5nKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwUmVhZGFibGUodGhpcywgZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGwuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVuZChtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlckR1cGxleFN0cmVhbUltcGwgPSBTZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsO1xuU2VydmVyRHVwbGV4U3RyZWFtSW1wbC5wcm90b3R5cGUuX3JlYWQgPVxuICAgIFNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbC5wcm90b3R5cGUuX3JlYWQ7XG5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsLnByb3RvdHlwZS5fd3JpdGUgPVxuICAgIFNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbC5wcm90b3R5cGUuX3dyaXRlO1xuU2VydmVyRHVwbGV4U3RyZWFtSW1wbC5wcm90b3R5cGUuX2ZpbmFsID1cbiAgICBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwucHJvdG90eXBlLl9maW5hbDtcbi8vIEludGVybmFsIGNsYXNzIHRoYXQgd3JhcHMgdGhlIEhUVFAyIHJlcXVlc3QuXG5jbGFzcyBIdHRwMlNlcnZlckNhbGxTdHJlYW0gZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNTZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy53YW50VHJhaWxlcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YVNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1RvUHVzaCA9IFtdO1xuICAgICAgICB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID0gY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAvKiBXZSBuZWVkIGFuIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgdW5jYXVnaHQgZXJyb3IgZXZlbnQgZXhjZXB0aW9ucywgYnV0XG4gICAgICAgICAgICAgKiB0aGVyZSBpcyBub3RoaW5nIHdlIGNhbiByZWFzb25hYmx5IGRvIGhlcmUuIEFueSBlcnJvciBldmVudCBzaG91bGRcbiAgICAgICAgICAgICAqIGhhdmUgYSBjb3JyZXNwb25kaW5nIGNsb3NlIGV2ZW50LCB3aGljaCBoYW5kbGVzIGVtaXR0aW5nIHRoZSBjYW5jZWxsZWRcbiAgICAgICAgICAgICAqIGV2ZW50LiBBbmQgdGhlIHN0cmVhbSBpcyBub3cgaW4gYSBiYWQgc3RhdGUsIHNvIHdlIGNhbid0IHJlYXNvbmFibHlcbiAgICAgICAgICAgICAqIGV4cGVjdCB0byBiZSBhYmxlIHRvIHNlbmQgYW4gZXJyb3Igb3ZlciBpdC4gKi9cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdHJhY2UoJ1JlcXVlc3QgdG8gbWV0aG9kICcgK1xuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLmhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSArXG4gICAgICAgICAgICAgICAgJyBzdHJlYW0gY2xvc2VkIHdpdGggcnN0Q29kZSAnICtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5yc3RDb2RlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0dXNTZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2FuY2VsbGVkJywgJ2NhbmNlbGxlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RyZWFtRW5kJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdDYW5jZWxsZWQgYnkgY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVhZGxpbmVUaW1lcilcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbignZHJhaW4nLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gb3B0aW9uc1snZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tDYW5jZWxsZWQoKSB7XG4gICAgICAgIC8qIEluIHNvbWUgY2FzZXMgdGhlIHN0cmVhbSBjYW4gYmVjb21lIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNsb3NlIGV2ZW50XG4gICAgICAgICAqIGZpcmVzLiBUaGF0IGNyZWF0ZXMgYSByYWNlIGNvbmRpdGlvbiB0aGF0IHRoaXMgY2hlY2sgd29ya3MgYXJvdW5kICovXG4gICAgICAgIGlmICh0aGlzLnN0cmVhbS5kZXN0cm95ZWQgfHwgdGhpcy5zdHJlYW0uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsbGVkO1xuICAgIH1cbiAgICBnZXREZWNvbXByZXNzZWRNZXNzYWdlKG1lc3NhZ2UsIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2RlZmxhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbGF0ZShtZXNzYWdlLnN1YmFycmF5KDUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZyA9PT0gJ2d6aXAnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW56aXAobWVzc2FnZS5zdWJhcnJheSg1KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5jb2RpbmcgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlLnN1YmFycmF5KDUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIGNvbXByZXNzZWQgd2l0aCB1bnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7ZW5jb2Rpbmd9XCJgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKGN1c3RvbU1ldGFkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YVNlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldGFkYXRhU2VudCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGN1c3RvbSA9IGN1c3RvbU1ldGFkYXRhID8gY3VzdG9tTWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKSA6IG51bGw7XG4gICAgICAgIC8vIFRPRE8oY2ppaHJpZyk6IEluY2x1ZGUgY29tcHJlc3Npb24gaGVhZGVycy5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzKSwgZGVmYXVsdENvbXByZXNzaW9uSGVhZGVycyksIGN1c3RvbSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLnJlc3BvbmQoaGVhZGVycywgZGVmYXVsdFJlc3BvbnNlT3B0aW9ucyk7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFfMS5NZXRhZGF0YS5mcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICBpZiAobG9nZ2luZy5pc1RyYWNlckVuYWJsZWQoVFJBQ0VSX05BTUUpKSB7XG4gICAgICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXIucGF0aCArXG4gICAgICAgICAgICAgICAgJyByZWNlaXZlZCBoZWFkZXJzICcgK1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhLnRvSlNPTigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhjamlocmlnKTogUmVjZWl2ZSBjb21wcmVzc2lvbiBtZXRhZGF0YS5cbiAgICAgICAgY29uc3QgdGltZW91dEhlYWRlciA9IG1ldGFkYXRhLmdldChHUlBDX1RJTUVPVVRfSEVBREVSKTtcbiAgICAgICAgaWYgKHRpbWVvdXRIZWFkZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0aW1lb3V0SGVhZGVyWzBdLnRvU3RyaW5nKCkubWF0Y2goREVBRExJTkVfUkVHRVgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJbnZhbGlkIGRlYWRsaW5lJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuT1VUX09GX1JBTkdFO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9ICgrbWF0Y2hbMV0gKiBkZWFkbGluZVVuaXRzVG9Nc1ttYXRjaFsyXV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gbm93LnNldE1pbGxpc2Vjb25kcyhub3cuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IHNldFRpbWVvdXQoaGFuZGxlRXhwaXJlZERlYWRsaW5lLCB0aW1lb3V0LCB0aGlzKTtcbiAgICAgICAgICAgIG1ldGFkYXRhLnJlbW92ZShHUlBDX1RJTUVPVVRfSEVBREVSKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgc2V2ZXJhbCBoZWFkZXJzIHRoYXQgc2hvdWxkIG5vdCBiZSBwcm9wYWdhdGVkIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9BQ0NFUFRfRU5DT0RJTkcpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9URSk7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSk7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICByZWNlaXZlVW5hcnlNZXNzYWdlKGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHN0cmVhbSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCByZWNlaXZlZExlbmd0aCA9IDA7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbGltaXQgPSB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uKCdkYXRhJywgb25EYXRhKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlbmQnLCBvbkVuZCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5vbignZXJyb3InLCBvbkVuZCk7XG4gICAgICAgICAgICBmdW5jdGlvbiBvbkRhdGEoY2h1bmspIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZExlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gLTEgJiYgcmVjZWl2ZWRMZW5ndGggPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7cmVjZWl2ZWRMZW5ndGh9IHZzLiAke2xpbWl0fSlgLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib2R5LnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gb25FbmQoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FbmQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoeyBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsIGRldGFpbHM6IGVyci5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ3JlY2VpdmVkIGVtcHR5IHVuYXJ5IG1lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsLmVtaXQoJ3JlY2VpdmVNZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdEJ5dGVzID0gQnVmZmVyLmNvbmNhdChib2R5LCByZWNlaXZlZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IHJlcXVlc3RCeXRlcy5yZWFkVUludDgoMCkgPT09IDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyA9IGNvbXByZXNzZWQgPyBlbmNvZGluZyA6ICdpZGVudGl0eSc7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb21wcmVzc2VkTWVzc2FnZSA9IGNhbGwuZ2V0RGVjb21wcmVzc2VkTWVzc2FnZShyZXF1ZXN0Qnl0ZXMsIGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGVjb21wcmVzc2VkTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjYWxsLmRlc2VyaWFsaXplTWVzc2FnZVdpdGhJbnRlcm5hbEVycm9yKGRlY29tcHJlc3NlZE1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZWRNZXNzYWdlLnRoZW4oZGVjb21wcmVzc2VkID0+IHJlc29sdmUoY2FsbC5kZXNlcmlhbGl6ZU1lc3NhZ2VXaXRoSW50ZXJuYWxFcnJvcihkZWNvbXByZXNzZWQpKSwgKGVycikgPT4gcmVqZWN0KGVyci5jb2RlXG4gICAgICAgICAgICAgICAgICAgID8gZXJyXG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIFwiZ3JwYy1lbmNvZGluZ1wiIGhlYWRlciBcIiR7ZW5jb2Rpbmd9XCIgYnV0ICR7ZW5jb2Rpbmd9IGRlY29tcHJlc3Npb24gZmFpbGVkYCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZGVzZXJpYWxpemVNZXNzYWdlV2l0aEludGVybmFsRXJyb3IoYnVmZmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZU1lc3NhZ2UoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgZGV0YWlsczogKDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnIpLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VyaWFsaXplTWVzc2FnZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlQnVmZmVyID0gdGhpcy5oYW5kbGVyLnNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgIC8vIFRPRE8oY2ppaHJpZyk6IENhbGwgY29tcHJlc3Npb24gYXdhcmUgc2VyaWFsaXplTWVzc2FnZSgpLlxuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gbWVzc2FnZUJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZUxlbmd0aCArIDUpO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50OCgwLCAwKTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDMyQkUoYnl0ZUxlbmd0aCwgMSk7XG4gICAgICAgIG1lc3NhZ2VCdWZmZXIuY29weShvdXRwdXQsIDUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBkZXNlcmlhbGl6ZU1lc3NhZ2UoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5kZXNlcmlhbGl6ZShieXRlcyk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRVbmFyeU1lc3NhZ2UoZXJyLCB2YWx1ZSwgbWV0YWRhdGEsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgJ21ldGFkYXRhJykgJiYgbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBlcnIubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5zZXJpYWxpemVNZXNzYWdlKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGUocmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk9LLCBkZXRhaWxzOiAnT0snLCBtZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRFcnJvcih7XG4gICAgICAgICAgICAgICAgZGV0YWlsczogKDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnIpLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRTdGF0dXMoc3RhdHVzT2JqKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuZW1pdCgnY2FsbEVuZCcsIHN0YXR1c09iai5jb2RlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdzdHJlYW1FbmQnLCBzdGF0dXNPYmouY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKTtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvIG1ldGhvZCAnICtcbiAgICAgICAgICAgICgoX2EgPSB0aGlzLmhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSArXG4gICAgICAgICAgICAnIGVuZGVkIHdpdGggc3RhdHVzIGNvZGU6ICcgK1xuICAgICAgICAgICAgY29uc3RhbnRzXzEuU3RhdHVzW3N0YXR1c09iai5jb2RlXSArXG4gICAgICAgICAgICAnIGRldGFpbHM6ICcgK1xuICAgICAgICAgICAgc3RhdHVzT2JqLmRldGFpbHMpO1xuICAgICAgICBpZiAodGhpcy5kZWFkbGluZVRpbWVyKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbS5oZWFkZXJzU2VudCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLndhbnRUcmFpbGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMud2FudFRyYWlsZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCd3YW50VHJhaWxlcnMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhaWxlcnNUb1NlbmQgPSBPYmplY3QuYXNzaWduKHsgW0dSUENfU1RBVFVTX0hFQURFUl06IHN0YXR1c09iai5jb2RlLCBbR1JQQ19NRVNTQUdFX0hFQURFUl06IGVuY29kZVVSSShzdGF0dXNPYmouZGV0YWlscykgfSwgKF9hID0gc3RhdHVzT2JqLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9IdHRwMkhlYWRlcnMoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnNlbmRUcmFpbGVycyh0cmFpbGVyc1RvU2VuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzU2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0uZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmFpbGVycy1vbmx5IHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCB0cmFpbGVyc1RvU2VuZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IFtHUlBDX1NUQVRVU19IRUFERVJdOiBzdGF0dXNPYmouY29kZSwgW0dSUENfTUVTU0FHRV9IRUFERVJdOiBlbmNvZGVVUkkoc3RhdHVzT2JqLmRldGFpbHMpIH0sIGRlZmF1bHRSZXNwb25zZUhlYWRlcnMpLCAoX2IgPSBzdGF0dXNPYmoubWV0YWRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0h0dHAySGVhZGVycygpKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlc3BvbmQodHJhaWxlcnNUb1NlbmQsIHsgZW5kU3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNTZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXG4gICAgICAgICAgICBkZXRhaWxzOiAnbWVzc2FnZScgaW4gZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gRXJyb3InLFxuICAgICAgICAgICAgbWV0YWRhdGE6ICdtZXRhZGF0YScgaW4gZXJyb3IgJiYgZXJyb3IubWV0YWRhdGEgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gZXJyb3IubWV0YWRhdGFcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGlmICgnY29kZScgaW4gZXJyb3IgJiZcbiAgICAgICAgICAgIHR5cGVvZiBlcnJvci5jb2RlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihlcnJvci5jb2RlKSkge1xuICAgICAgICAgICAgc3RhdHVzLmNvZGUgPSBlcnJvci5jb2RlO1xuICAgICAgICAgICAgaWYgKCdkZXRhaWxzJyBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IuZGV0YWlscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGV0YWlscyA9IGVycm9yLmRldGFpbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHN0YXR1cyk7XG4gICAgfVxuICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgIT09IC0xICYmXG4gICAgICAgICAgICBjaHVuay5sZW5ndGggPiB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFNlbnQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7Y2h1bmsubGVuZ3RofSB2cy4gJHt0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZX0pYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZE1ldGFkYXRhKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnc2VuZE1lc3NhZ2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKGNodW5rKTtcbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gICAgc2V0dXBTdXJmYWNlQ2FsbChjYWxsKSB7XG4gICAgICAgIHRoaXMub25jZSgnY2FuY2VsbGVkJywgcmVhc29uID0+IHtcbiAgICAgICAgICAgIGNhbGwuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGwuZW1pdCgnY2FuY2VsbGVkJywgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25jZSgnY2FsbEVuZCcsIHN0YXR1cyA9PiBjYWxsLmVtaXQoJ2NhbGxFbmQnLCBzdGF0dXMpKTtcbiAgICB9XG4gICAgc2V0dXBSZWFkYWJsZShyZWFkYWJsZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBzdHJlYW1fZGVjb2Rlcl8xLlN0cmVhbURlY29kZXIoKTtcbiAgICAgICAgbGV0IHJlYWRzRG9uZSA9IGZhbHNlO1xuICAgICAgICBsZXQgcGVuZGluZ01lc3NhZ2VQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBwdXNoZWRFbmQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbWF5YmVQdXNoRW5kID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwdXNoZWRFbmQgJiYgcmVhZHNEb25lICYmICFwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBwdXNoZWRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVzaE9yQnVmZmVyTWVzc2FnZShyZWFkYWJsZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdkYXRhJywgYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gZGVjb2Rlci53cml0ZShkYXRhKTtcbiAgICAgICAgICAgIHBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxlbmd0aCA+IHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7bWVzc2FnZS5sZW5ndGh9IHZzLiAke3RoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplfSlgLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlY2VpdmVNZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IG1lc3NhZ2UucmVhZFVJbnQ4KDApID09PSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcgPSBjb21wcmVzc2VkID8gZW5jb2RpbmcgOiAnaWRlbnRpdHknO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZE1lc3NhZ2UgPSBhd2FpdCB0aGlzLmdldERlY29tcHJlc3NlZE1lc3NhZ2UobWVzc2FnZSwgY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgLy8gRW5jb3VudGVyZWQgYW4gZXJyb3Igd2l0aCBkZWNvbXByZXNzaW9uOyBpdCdsbCBhbHJlYWR5IGhhdmUgYmVlbiBwcm9wb2dhdGVkIGJhY2tcbiAgICAgICAgICAgICAgICAvLyBKdXN0IHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgIGlmICghZGVjb21wcmVzc2VkTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVzaE9yQnVmZmVyTWVzc2FnZShyZWFkYWJsZSwgZGVjb21wcmVzc2VkTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICAgICAgYXdhaXQgbWF5YmVQdXNoRW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCdlbmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZWFkc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgYXdhaXQgbWF5YmVQdXNoRW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdW1lVW5wdXNoZWRNZXNzYWdlcyhyZWFkYWJsZSkge1xuICAgICAgICB0aGlzLmNhblB1c2ggPSB0cnVlO1xuICAgICAgICB3aGlsZSAodGhpcy5tZXNzYWdlc1RvUHVzaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0TWVzc2FnZSA9IHRoaXMubWVzc2FnZXNUb1B1c2guc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhblB1c2ggPSByZWFkYWJsZS5wdXNoKG5leHRNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChuZXh0TWVzc2FnZSA9PT0gbnVsbCB8fCBjYW5QdXNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhblB1c2g7XG4gICAgfVxuICAgIGFzeW5jIHB1c2hPckJ1ZmZlck1lc3NhZ2UocmVhZGFibGUsIG1lc3NhZ2VCeXRlcykge1xuICAgICAgICBpZiAodGhpcy5pc1B1c2hQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMucHVzaChtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdXNoTWVzc2FnZShyZWFkYWJsZSwgbWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwdXNoTWVzc2FnZShyZWFkYWJsZSwgbWVzc2FnZUJ5dGVzKSB7XG4gICAgICAgIGlmIChtZXNzYWdlQnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYWNlKCdSZWNlaXZlZCBlbmQgb2Ygc3RyZWFtJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5QdXNoKSB7XG4gICAgICAgICAgICAgICAgcmVhZGFibGUucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNUb1B1c2gucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUmVjZWl2ZWQgbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2VCeXRlcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkID0gYXdhaXQgdGhpcy5kZXNlcmlhbGl6ZU1lc3NhZ2UobWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhblB1c2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWRhYmxlLnB1c2goZGVzZXJpYWxpemVkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzVG9QdXNoLnB1c2goZGVzZXJpYWxpemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgcmVtYWluaW5nIG1lc3NhZ2VzIHdoZW4gZXJyb3JzIG9jY3VyLlxuICAgICAgICAgICAgdGhpcy5idWZmZXJlZE1lc3NhZ2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBsZXQgY29kZSA9ICgwLCBlcnJvcl8xLmdldEVycm9yQ29kZSkoZXJyb3IpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IG51bGwgfHwgY29kZSA8IGNvbnN0YW50c18xLlN0YXR1cy5PSyB8fCBjb2RlID4gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVVUSEVOVElDQVRFRCkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkYWJsZS5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGVycm9yKSxcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdXNoTWVzc2FnZShyZWFkYWJsZSwgdGhpcy5idWZmZXJlZE1lc3NhZ2VzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gKF9hID0gdGhpcy5zdHJlYW0uc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvY2tldDtcbiAgICAgICAgaWYgKHNvY2tldCA9PT0gbnVsbCB8fCBzb2NrZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvY2tldC5yZW1vdGVBZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoc29ja2V0LnJlbW90ZVBvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c29ja2V0LnJlbW90ZUFkZHJlc3N9OiR7c29ja2V0LnJlbW90ZVBvcnR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlYWRsaW5lO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLnBhdGg7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwMlNlcnZlckNhbGxTdHJlYW0gPSBIdHRwMlNlcnZlckNhbGxTdHJlYW07XG5mdW5jdGlvbiBoYW5kbGVFeHBpcmVkRGVhZGxpbmUoY2FsbCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignRGVhZGxpbmUgZXhjZWVkZWQnKTtcbiAgICBlcnIuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRDtcbiAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgIGNhbGwuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBjYWxsLmVtaXQoJ2NhbmNlbGxlZCcsICdkZWFkbGluZScpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtIiwiU2VydmVyRHVwbGV4U3RyZWFtSW1wbCIsIlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCIsIlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCIsIlNlcnZlclVuYXJ5Q2FsbEltcGwiLCJldmVudHNfMSIsInJlcXVpcmUiLCJodHRwMiIsInN0cmVhbV8xIiwiemxpYiIsInV0aWxfMSIsImNvbnN0YW50c18xIiwibWV0YWRhdGFfMSIsInN0cmVhbV9kZWNvZGVyXzEiLCJsb2dnaW5nIiwiZXJyb3JfMSIsIlRSQUNFUl9OQU1FIiwidW56aXAiLCJwcm9taXNpZnkiLCJpbmZsYXRlIiwidHJhY2UiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVIiLCJHUlBDX0VOQ09ESU5HX0hFQURFUiIsIkdSUENfTUVTU0FHRV9IRUFERVIiLCJHUlBDX1NUQVRVU19IRUFERVIiLCJHUlBDX1RJTUVPVVRfSEVBREVSIiwiREVBRExJTkVfUkVHRVgiLCJkZWFkbGluZVVuaXRzVG9NcyIsIkgiLCJNIiwiUyIsIm0iLCJ1IiwibiIsImRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMiLCJkZWZhdWx0UmVzcG9uc2VIZWFkZXJzIiwiY29uc3RhbnRzIiwiSFRUUDJfSEVBREVSX1NUQVRVUyIsIkhUVFBfU1RBVFVTX09LIiwiSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSIsImRlZmF1bHRSZXNwb25zZU9wdGlvbnMiLCJ3YWl0Rm9yVHJhaWxlcnMiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsImNhbGwiLCJtZXRhZGF0YSIsInJlcXVlc3QiLCJjYW5jZWxsZWQiLCJzZXR1cFN1cmZhY2VDYWxsIiwiZ2V0UGVlciIsInNlbmRNZXRhZGF0YSIsInJlc3BvbnNlTWV0YWRhdGEiLCJnZXREZWFkbGluZSIsImdldFBhdGgiLCJSZWFkYWJsZSIsImRlc2VyaWFsaXplIiwiZW5jb2RpbmciLCJvYmplY3RNb2RlIiwic2V0dXBSZWFkYWJsZSIsIl9yZWFkIiwic2l6ZSIsImNvbnN1bWVVbnB1c2hlZE1lc3NhZ2VzIiwicmVzdW1lIiwiV3JpdGFibGUiLCJzZXJpYWxpemUiLCJ0cmFpbGluZ01ldGFkYXRhIiwiTWV0YWRhdGEiLCJvbiIsImVyciIsInNlbmRFcnJvciIsImVuZCIsIl93cml0ZSIsImNodW5rIiwiY2FsbGJhY2siLCJyZXNwb25zZSIsInNlcmlhbGl6ZU1lc3NhZ2UiLCJ3cml0ZSIsIm9uY2UiLCJlbWl0IiwiZGV0YWlscyIsImdldEVycm9yTWVzc2FnZSIsImNvZGUiLCJTdGF0dXMiLCJJTlRFUk5BTCIsIl9maW5hbCIsInNlbmRTdGF0dXMiLCJPSyIsIkR1cGxleCIsInByb3RvdHlwZSIsInN0cmVhbSIsImhhbmRsZXIiLCJvcHRpb25zIiwiZGVhZGxpbmVUaW1lciIsInN0YXR1c1NlbnQiLCJkZWFkbGluZSIsIkluZmluaXR5Iiwid2FudFRyYWlsZXJzIiwibWV0YWRhdGFTZW50IiwiY2FuUHVzaCIsImlzUHVzaFBlbmRpbmciLCJidWZmZXJlZE1lc3NhZ2VzIiwibWVzc2FnZXNUb1B1c2giLCJtYXhTZW5kTWVzc2FnZVNpemUiLCJERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIIiwibWF4UmVjZWl2ZU1lc3NhZ2VTaXplIiwiREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCIsIl9hIiwicGF0aCIsInJzdENvZGUiLCJDQU5DRUxMRUQiLCJjbGVhclRpbWVvdXQiLCJjaGVja0NhbmNlbGxlZCIsImRlc3Ryb3llZCIsImNsb3NlZCIsImdldERlY29tcHJlc3NlZE1lc3NhZ2UiLCJtZXNzYWdlIiwic3ViYXJyYXkiLCJQcm9taXNlIiwicmVqZWN0IiwiVU5JTVBMRU1FTlRFRCIsImN1c3RvbU1ldGFkYXRhIiwiY3VzdG9tIiwidG9IdHRwMkhlYWRlcnMiLCJoZWFkZXJzIiwiYXNzaWduIiwicmVzcG9uZCIsInJlY2VpdmVNZXRhZGF0YSIsImZyb21IdHRwMkhlYWRlcnMiLCJpc1RyYWNlckVuYWJsZWQiLCJKU09OIiwic3RyaW5naWZ5IiwidG9KU09OIiwidGltZW91dEhlYWRlciIsImdldCIsImxlbmd0aCIsIm1hdGNoIiwidG9TdHJpbmciLCJFcnJvciIsIk9VVF9PRl9SQU5HRSIsInRpbWVvdXQiLCJub3ciLCJEYXRlIiwic2V0TWlsbGlzZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwic2V0VGltZW91dCIsImhhbmRsZUV4cGlyZWREZWFkbGluZSIsInJlbW92ZSIsIkhUVFAyX0hFQURFUl9BQ0NFUFRfRU5DT0RJTkciLCJIVFRQMl9IRUFERVJfVEUiLCJyZWNlaXZlVW5hcnlNZXNzYWdlIiwicmVzb2x2ZSIsInJlY2VpdmVkTGVuZ3RoIiwiYm9keSIsImxpbWl0Iiwib25EYXRhIiwib25FbmQiLCJieXRlTGVuZ3RoIiwicmVtb3ZlTGlzdGVuZXIiLCJSRVNPVVJDRV9FWEhBVVNURUQiLCJwdXNoIiwidW5kZWZpbmVkIiwicmVxdWVzdEJ5dGVzIiwiQnVmZmVyIiwiY29uY2F0IiwiY29tcHJlc3NlZCIsInJlYWRVSW50OCIsImNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmciLCJkZWNvbXByZXNzZWRNZXNzYWdlIiwiaXNCdWZmZXIiLCJkZXNlcmlhbGl6ZU1lc3NhZ2VXaXRoSW50ZXJuYWxFcnJvciIsInRoZW4iLCJkZWNvbXByZXNzZWQiLCJidWZmZXIiLCJkZXNlcmlhbGl6ZU1lc3NhZ2UiLCJtZXNzYWdlQnVmZmVyIiwib3V0cHV0IiwiYWxsb2NVbnNhZmUiLCJ3cml0ZVVJbnQ4Iiwid3JpdGVVSW50MzJCRSIsImNvcHkiLCJieXRlcyIsInNlbmRVbmFyeU1lc3NhZ2UiLCJmbGFncyIsImhhc093blByb3BlcnR5Iiwic3RhdHVzT2JqIiwiX2IiLCJoZWFkZXJzU2VudCIsInRyYWlsZXJzVG9TZW5kIiwiZW5jb2RlVVJJIiwic2VuZFRyYWlsZXJzIiwiZW5kU3RyZWFtIiwiZXJyb3IiLCJzdGF0dXMiLCJVTktOT1dOIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwicmVhc29uIiwicmVhZGFibGUiLCJkZWNvZGVyIiwiU3RyZWFtRGVjb2RlciIsInJlYWRzRG9uZSIsInBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyIsInB1c2hlZEVuZCIsIm1heWJlUHVzaEVuZCIsInB1c2hPckJ1ZmZlck1lc3NhZ2UiLCJkYXRhIiwibWVzc2FnZXMiLCJwYXVzZSIsIm5leHRNZXNzYWdlIiwic2hpZnQiLCJtZXNzYWdlQnl0ZXMiLCJwdXNoTWVzc2FnZSIsImRlc2VyaWFsaXplZCIsImdldEVycm9yQ29kZSIsIlVOQVVUSEVOVElDQVRFRCIsInNvY2tldCIsInNlc3Npb24iLCJyZW1vdGVBZGRyZXNzIiwicmVtb3RlUG9ydCIsIkRFQURMSU5FX0VYQ0VFREVEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ServerCredentials = void 0;\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\nclass ServerCredentials {\n    static createInsecure() {\n        return new InsecureServerCredentials();\n    }\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\n        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\n            throw new TypeError(\"rootCerts must be null or a Buffer\");\n        }\n        if (!Array.isArray(keyCertPairs)) {\n            throw new TypeError(\"keyCertPairs must be an array\");\n        }\n        if (typeof checkClientCertificate !== \"boolean\") {\n            throw new TypeError(\"checkClientCertificate must be a boolean\");\n        }\n        const cert = [];\n        const key = [];\n        for(let i = 0; i < keyCertPairs.length; i++){\n            const pair = keyCertPairs[i];\n            if (pair === null || typeof pair !== \"object\") {\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\n            }\n            if (!Buffer.isBuffer(pair.private_key)) {\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\n            }\n            if (!Buffer.isBuffer(pair.cert_chain)) {\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\n            }\n            cert.push(pair.cert_chain);\n            key.push(pair.private_key);\n        }\n        return new SecureServerCredentials({\n            ca: rootCerts || (0, tls_helpers_1.getDefaultRootsData)() || undefined,\n            cert,\n            key,\n            requestCert: checkClientCertificate,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        });\n    }\n}\nexports.ServerCredentials = ServerCredentials;\nclass InsecureServerCredentials extends ServerCredentials {\n    _isSecure() {\n        return false;\n    }\n    _getSettings() {\n        return null;\n    }\n}\nclass SecureServerCredentials extends ServerCredentials {\n    constructor(options){\n        super();\n        this.options = options;\n    }\n    _isSecure() {\n        return true;\n    }\n    _getSettings() {\n        return this.options;\n    }\n} //# sourceMappingURL=server-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUcsS0FBSztBQUNqQyxNQUFNRyxnQkFBZ0JDLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLE1BQU1GO0lBQ0YsT0FBT0csaUJBQWlCO1FBQ3BCLE9BQU8sSUFBSUM7SUFDZjtJQUNBLE9BQU9DLFVBQVVDLFNBQVMsRUFBRUMsWUFBWSxFQUFFQyx5QkFBeUIsS0FBSyxFQUFFO1FBQ3RFLElBQUlGLGNBQWMsUUFBUSxDQUFDRyxNQUFNQSxDQUFDQyxRQUFRLENBQUNKLFlBQVk7WUFDbkQsTUFBTSxJQUFJSyxVQUFVO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNOLGVBQWU7WUFDOUIsTUFBTSxJQUFJSSxVQUFVO1FBQ3hCO1FBQ0EsSUFBSSxPQUFPSCwyQkFBMkIsV0FBVztZQUM3QyxNQUFNLElBQUlHLFVBQVU7UUFDeEI7UUFDQSxNQUFNRyxPQUFPLEVBQUU7UUFDZixNQUFNQyxNQUFNLEVBQUU7UUFDZCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVQsYUFBYVUsTUFBTSxFQUFFRCxJQUFLO1lBQzFDLE1BQU1FLE9BQU9YLFlBQVksQ0FBQ1MsRUFBRTtZQUM1QixJQUFJRSxTQUFTLFFBQVEsT0FBT0EsU0FBUyxVQUFVO2dCQUMzQyxNQUFNLElBQUlQLFVBQVUsQ0FBQyxZQUFZLEVBQUVLLEVBQUUsbUJBQW1CLENBQUM7WUFDN0Q7WUFDQSxJQUFJLENBQUNQLE1BQU1BLENBQUNDLFFBQVEsQ0FBQ1EsS0FBS0MsV0FBVyxHQUFHO2dCQUNwQyxNQUFNLElBQUlSLFVBQVUsQ0FBQyxZQUFZLEVBQUVLLEVBQUUsOEJBQThCLENBQUM7WUFDeEU7WUFDQSxJQUFJLENBQUNQLE1BQU1BLENBQUNDLFFBQVEsQ0FBQ1EsS0FBS0UsVUFBVSxHQUFHO2dCQUNuQyxNQUFNLElBQUlULFVBQVUsQ0FBQyxZQUFZLEVBQUVLLEVBQUUsNkJBQTZCLENBQUM7WUFDdkU7WUFDQUYsS0FBS08sSUFBSSxDQUFDSCxLQUFLRSxVQUFVO1lBQ3pCTCxJQUFJTSxJQUFJLENBQUNILEtBQUtDLFdBQVc7UUFDN0I7UUFDQSxPQUFPLElBQUlHLHdCQUF3QjtZQUMvQkMsSUFBSWpCLGFBQWEsQ0FBQyxHQUFHTCxjQUFjdUIsbUJBQW1CLE9BQU9DO1lBQzdEWDtZQUNBQztZQUNBVyxhQUFhbEI7WUFDYm1CLFNBQVMxQixjQUFjMkIsYUFBYTtRQUN4QztJQUNKO0FBQ0o7QUFDQTlCLHlCQUF5QixHQUFHRTtBQUM1QixNQUFNSSxrQ0FBa0NKO0lBQ3BDNkIsWUFBWTtRQUNSLE9BQU87SUFDWDtJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0FBQ0o7QUFDQSxNQUFNUixnQ0FBZ0N0QjtJQUNsQytCLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLO1FBQ0wsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FILFlBQVk7UUFDUixPQUFPO0lBQ1g7SUFDQUMsZUFBZTtRQUNYLE9BQU8sSUFBSSxDQUFDRSxPQUFPO0lBQ3ZCO0FBQ0osRUFDQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY3JlZGVudGlhbHMuanM/ZGM3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXJDcmVkZW50aWFscyA9IHZvaWQgMDtcbmNvbnN0IHRsc19oZWxwZXJzXzEgPSByZXF1aXJlKFwiLi90bHMtaGVscGVyc1wiKTtcbmNsYXNzIFNlcnZlckNyZWRlbnRpYWxzIHtcbiAgICBzdGF0aWMgY3JlYXRlSW5zZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5zZWN1cmVTZXJ2ZXJDcmVkZW50aWFscygpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlU3NsKHJvb3RDZXJ0cywga2V5Q2VydFBhaXJzLCBjaGVja0NsaWVudENlcnRpZmljYXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiAhQnVmZmVyLmlzQnVmZmVyKHJvb3RDZXJ0cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jvb3RDZXJ0cyBtdXN0IGJlIG51bGwgb3IgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5Q2VydFBhaXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2V5Q2VydFBhaXJzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlcnQgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Q2VydFBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWlyID0ga2V5Q2VydFBhaXJzW2ldO1xuICAgICAgICAgICAgaWYgKHBhaXIgPT09IG51bGwgfHwgdHlwZW9mIHBhaXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0gbXVzdCBiZSBhbiBvYmplY3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhaXIucHJpdmF0ZV9rZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0ucHJpdmF0ZV9rZXkgbXVzdCBiZSBhIEJ1ZmZlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFpci5jZXJ0X2NoYWluKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dLmNlcnRfY2hhaW4gbXVzdCBiZSBhIEJ1ZmZlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VydC5wdXNoKHBhaXIuY2VydF9jaGFpbik7XG4gICAgICAgICAgICBrZXkucHVzaChwYWlyLnByaXZhdGVfa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZVNlcnZlckNyZWRlbnRpYWxzKHtcbiAgICAgICAgICAgIGNhOiByb290Q2VydHMgfHwgKDAsIHRsc19oZWxwZXJzXzEuZ2V0RGVmYXVsdFJvb3RzRGF0YSkoKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBjZXJ0LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcmVxdWVzdENlcnQ6IGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUsXG4gICAgICAgICAgICBjaXBoZXJzOiB0bHNfaGVscGVyc18xLkNJUEhFUl9TVUlURVMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSBTZXJ2ZXJDcmVkZW50aWFscztcbmNsYXNzIEluc2VjdXJlU2VydmVyQ3JlZGVudGlhbHMgZXh0ZW5kcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9nZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMgZXh0ZW5kcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNlcnZlckNyZWRlbnRpYWxzIiwidGxzX2hlbHBlcnNfMSIsInJlcXVpcmUiLCJjcmVhdGVJbnNlY3VyZSIsIkluc2VjdXJlU2VydmVyQ3JlZGVudGlhbHMiLCJjcmVhdGVTc2wiLCJyb290Q2VydHMiLCJrZXlDZXJ0UGFpcnMiLCJjaGVja0NsaWVudENlcnRpZmljYXRlIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJUeXBlRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJjZXJ0Iiwia2V5IiwiaSIsImxlbmd0aCIsInBhaXIiLCJwcml2YXRlX2tleSIsImNlcnRfY2hhaW4iLCJwdXNoIiwiU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMiLCJjYSIsImdldERlZmF1bHRSb290c0RhdGEiLCJ1bmRlZmluZWQiLCJyZXF1ZXN0Q2VydCIsImNpcGhlcnMiLCJDSVBIRVJfU1VJVEVTIiwiX2lzU2VjdXJlIiwiX2dldFNldHRpbmdzIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Server = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst server_call_1 = __webpack_require__(/*! ./server-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js\");\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst { HTTP2_HEADER_PATH } = http2.constants;\nconst TRACER_NAME = \"server\";\nfunction noop() {}\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch(handlerType){\n        case \"unary\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"clientStream\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"serverStream\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        case \"bidi\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nclass Server {\n    constructor(options){\n        var _a, _b, _c, _d;\n        this.http2ServerList = [];\n        this.handlers = new Map();\n        this.sessions = new Map();\n        this.started = false;\n        this.shutdown = false;\n        this.serverAddressString = \"null\";\n        // Channelz Info\n        this.channelzEnabled = true;\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.options = options !== null && options !== void 0 ? options : {};\n        if (this.options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzServer)(()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Server created\");\n        }\n        this.maxConnectionAgeMs = (_a = this.options[\"grpc.max_connection_age_ms\"]) !== null && _a !== void 0 ? _a : UNLIMITED_CONNECTION_AGE_MS;\n        this.maxConnectionAgeGraceMs = (_b = this.options[\"grpc.max_connection_age_grace_ms\"]) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\n        this.keepaliveTimeMs = (_c = this.options[\"grpc.keepalive_time_ms\"]) !== null && _c !== void 0 ? _c : KEEPALIVE_MAX_TIME_MS;\n        this.keepaliveTimeoutMs = (_d = this.options[\"grpc.keepalive_timeout_ms\"]) !== null && _d !== void 0 ? _d : KEEPALIVE_TIMEOUT_MS;\n        this.trace(\"Server constructed\");\n    }\n    getChannelzInfo() {\n        return {\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            listenerChildren: this.listenerChildrenTracker.getChildLists(),\n            sessionChildren: this.sessionChildrenTracker.getChildLists()\n        };\n    }\n    getChannelzSessionInfoGetter(session) {\n        return ()=>{\n            var _a, _b, _c;\n            const sessionInfo = this.sessions.get(session);\n            const sessionSocket = session.socket;\n            const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n            const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n            let tlsInfo;\n            if (session.encrypted) {\n                const tlsSocket = sessionSocket;\n                const cipherInfo = tlsSocket.getCipher();\n                const certificate = tlsSocket.getCertificate();\n                const peerCertificate = tlsSocket.getPeerCertificate();\n                tlsInfo = {\n                    cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                    cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                    localCertificate: certificate && \"raw\" in certificate ? certificate.raw : null,\n                    remoteCertificate: peerCertificate && \"raw\" in peerCertificate ? peerCertificate.raw : null\n                };\n            } else {\n                tlsInfo = null;\n            }\n            const socketInfo = {\n                remoteAddress: remoteAddress,\n                localAddress: localAddress,\n                security: tlsInfo,\n                remoteName: null,\n                streamsStarted: sessionInfo.streamTracker.callsStarted,\n                streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n                streamsFailed: sessionInfo.streamTracker.callsFailed,\n                messagesSent: sessionInfo.messagesSent,\n                messagesReceived: sessionInfo.messagesReceived,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n                lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n                lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n                localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n                remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n            };\n            return socketInfo;\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + text);\n    }\n    addProtoService() {\n        throw new Error(\"Not implemented. Use addService() instead\");\n    }\n    addService(service, implementation) {\n        if (service === null || typeof service !== \"object\" || implementation === null || typeof implementation !== \"object\") {\n            throw new Error(\"addService() requires two objects as arguments\");\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error(\"Cannot add an empty service to a server\");\n        }\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = \"bidi\";\n                } else {\n                    methodType = \"clientStream\";\n                }\n            } else {\n                if (attrs.responseStream) {\n                    methodType = \"serverStream\";\n                } else {\n                    methodType = \"unary\";\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === \"string\") {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            } else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    removeService(service) {\n        if (service === null || typeof service !== \"object\") {\n            throw new Error(\"removeService() requires object as argument\");\n        }\n        const serviceKeys = Object.keys(service);\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            this.unregister(attrs.path);\n        });\n    }\n    bind(port, creds) {\n        throw new Error(\"Not implemented. Use bindAsync() instead\");\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error(\"server is already started\");\n        }\n        if (this.shutdown) {\n            throw new Error(\"bindAsync called after shutdown\");\n        }\n        if (typeof port !== \"string\") {\n            throw new TypeError(\"port must be a string\");\n        }\n        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n            throw new TypeError(\"creds must be a ServerCredentials object\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new TypeError(\"callback must be a function\");\n        }\n        const initialPortUri = (0, uri_parser_1.parseUri)(port);\n        if (initialPortUri === null) {\n            throw new Error(`Could not parse port \"${port}\"`);\n        }\n        const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\n        if (portUri === null) {\n            throw new Error(`Could not get a default scheme for port \"${port}\"`);\n        }\n        const serverOptions = {\n            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n        };\n        if (\"grpc-node.max_session_memory\" in this.options) {\n            serverOptions.maxSessionMemory = this.options[\"grpc-node.max_session_memory\"];\n        } else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */ serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        if (\"grpc.max_concurrent_streams\" in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options[\"grpc.max_concurrent_streams\"]\n            };\n        }\n        const deferredCallback = (error, port)=>{\n            process.nextTick(()=>callback(error, port));\n        };\n        const setupServer = ()=>{\n            let http2Server;\n            if (creds._isSecure()) {\n                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n                secureServerOptions.enableTrace = this.options[\"grpc-node.tls_enable_trace\"] === 1;\n                http2Server = http2.createSecureServer(secureServerOptions);\n                http2Server.on(\"secureConnection\", (socket)=>{\n                    /* These errors need to be handled by the user of Http2SecureServer,\n                     * according to https://github.com/nodejs/node/issues/35824 */ socket.on(\"error\", (e)=>{\n                        this.trace(\"An incoming TLS connection closed with error: \" + e.message);\n                    });\n                });\n            } else {\n                http2Server = http2.createServer(serverOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server);\n            return http2Server;\n        };\n        const bindSpecificPort = (addressList, portNum, previousCount)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: portNum,\n                    count: previousCount\n                });\n            }\n            return Promise.all(addressList.map((address)=>{\n                this.trace(\"Attempting to bind \" + (0, subchannel_address_1.subchannelAddressToString)(address));\n                let addr;\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n                    addr = {\n                        host: address.host,\n                        port: portNum\n                    };\n                } else {\n                    addr = address;\n                }\n                const http2Server = setupServer();\n                return new Promise((resolve, reject)=>{\n                    const onError = (err)=>{\n                        this.trace(\"Failed to bind \" + (0, subchannel_address_1.subchannelAddressToString)(address) + \" with error \" + err.message);\n                        resolve(err);\n                    };\n                    http2Server.once(\"error\", onError);\n                    http2Server.listen(addr, ()=>{\n                        if (this.shutdown) {\n                            http2Server.close();\n                            resolve(new Error(\"bindAsync failed because server is shutdown\"));\n                            return;\n                        }\n                        const boundAddress = http2Server.address();\n                        let boundSubchannelAddress;\n                        if (typeof boundAddress === \"string\") {\n                            boundSubchannelAddress = {\n                                path: boundAddress\n                            };\n                        } else {\n                            boundSubchannelAddress = {\n                                host: boundAddress.address,\n                                port: boundAddress.port\n                            };\n                        }\n                        const channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), ()=>{\n                            return {\n                                localAddress: boundSubchannelAddress,\n                                remoteAddress: null,\n                                security: null,\n                                remoteName: null,\n                                streamsStarted: 0,\n                                streamsSucceeded: 0,\n                                streamsFailed: 0,\n                                messagesSent: 0,\n                                messagesReceived: 0,\n                                keepAlivesSent: 0,\n                                lastLocalStreamCreatedTimestamp: null,\n                                lastRemoteStreamCreatedTimestamp: null,\n                                lastMessageSentTimestamp: null,\n                                lastMessageReceivedTimestamp: null,\n                                localFlowControlWindow: null,\n                                remoteFlowControlWindow: null\n                            };\n                        }, this.channelzEnabled);\n                        if (this.channelzEnabled) {\n                            this.listenerChildrenTracker.refChild(channelzRef);\n                        }\n                        this.http2ServerList.push({\n                            server: http2Server,\n                            channelzRef: channelzRef\n                        });\n                        this.trace(\"Successfully bound \" + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                        resolve(\"port\" in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n                        http2Server.removeListener(\"error\", onError);\n                    });\n                });\n            })).then((results)=>{\n                let count = 0;\n                for (const result of results){\n                    if (typeof result === \"number\") {\n                        count += 1;\n                        if (result !== portNum) {\n                            throw new Error(\"Invalid state: multiple port numbers added from single address\");\n                        }\n                    }\n                }\n                return {\n                    port: portNum,\n                    count: count + previousCount\n                };\n            });\n        };\n        const bindWildcardPort = (addressList)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: 0,\n                    count: 0\n                });\n            }\n            const address = addressList[0];\n            const http2Server = setupServer();\n            return new Promise((resolve, reject)=>{\n                const onError = (err)=>{\n                    this.trace(\"Failed to bind \" + (0, subchannel_address_1.subchannelAddressToString)(address) + \" with error \" + err.message);\n                    resolve(bindWildcardPort(addressList.slice(1)));\n                };\n                http2Server.once(\"error\", onError);\n                http2Server.listen(address, ()=>{\n                    if (this.shutdown) {\n                        http2Server.close();\n                        resolve({\n                            port: 0,\n                            count: 0\n                        });\n                        return;\n                    }\n                    const boundAddress = http2Server.address();\n                    const boundSubchannelAddress = {\n                        host: boundAddress.address,\n                        port: boundAddress.port\n                    };\n                    const channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), ()=>{\n                        return {\n                            localAddress: boundSubchannelAddress,\n                            remoteAddress: null,\n                            security: null,\n                            remoteName: null,\n                            streamsStarted: 0,\n                            streamsSucceeded: 0,\n                            streamsFailed: 0,\n                            messagesSent: 0,\n                            messagesReceived: 0,\n                            keepAlivesSent: 0,\n                            lastLocalStreamCreatedTimestamp: null,\n                            lastRemoteStreamCreatedTimestamp: null,\n                            lastMessageSentTimestamp: null,\n                            lastMessageReceivedTimestamp: null,\n                            localFlowControlWindow: null,\n                            remoteFlowControlWindow: null\n                        };\n                    }, this.channelzEnabled);\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.refChild(channelzRef);\n                    }\n                    this.http2ServerList.push({\n                        server: http2Server,\n                        channelzRef: channelzRef\n                    });\n                    this.trace(\"Successfully bound \" + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                    resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n                    http2Server.removeListener(\"error\", onError);\n                });\n            });\n        };\n        const resolverListener = {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError)=>{\n                // We only want one resolution result. Discard all future results\n                resolverListener.onSuccessfulResolution = ()=>{};\n                if (this.shutdown) {\n                    deferredCallback(new Error(`bindAsync failed because server is shutdown`), 0);\n                }\n                if (addressList.length === 0) {\n                    deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n                    return;\n                }\n                let bindResultPromise;\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0])) {\n                    if (addressList[0].port === 0) {\n                        bindResultPromise = bindWildcardPort(addressList);\n                    } else {\n                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n                    }\n                } else {\n                    // Use an arbitrary non-zero port for non-TCP addresses\n                    bindResultPromise = bindSpecificPort(addressList, 1, 0);\n                }\n                bindResultPromise.then((bindResult)=>{\n                    if (bindResult.count === 0) {\n                        const errorString = `No address added out of total ${addressList.length} resolved`;\n                        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                        deferredCallback(new Error(errorString), 0);\n                    } else {\n                        if (bindResult.count < addressList.length) {\n                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                        }\n                        deferredCallback(null, bindResult.port);\n                    }\n                }, (error)=>{\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                    deferredCallback(new Error(errorString), 0);\n                });\n            },\n            onError: (error)=>{\n                deferredCallback(new Error(error.details), 0);\n            }\n        };\n        const resolver = (0, resolver_1.createResolver)(portUri, resolverListener, this.options);\n        resolver.updateResolution();\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        (0, channelz_1.unregisterChannelzRef)(ref);\n                    }\n                });\n            }\n        }\n        this.started = false;\n        this.shutdown = true;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach((channelzInfo, session)=>{\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n        if (this.channelzEnabled) {\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        }\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n            path: name\n        });\n        return true;\n    }\n    unregister(name) {\n        return this.handlers.delete(name);\n    }\n    start() {\n        if (this.http2ServerList.length === 0 || this.http2ServerList.every(({ server: http2Server })=>http2Server.listening !== true)) {\n            throw new Error(\"server must be bound in order to start\");\n        }\n        if (this.started === true) {\n            throw new Error(\"server is already started\");\n        }\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Starting\");\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        const wrappedCallback = (error)=>{\n            if (this.channelzEnabled) {\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            }\n            callback(error);\n        };\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                wrappedCallback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        this.shutdown = true;\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                pendingChecks++;\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        (0, channelz_1.unregisterChannelzRef)(ref);\n                    }\n                    maybeCallback();\n                });\n            }\n        }\n        this.sessions.forEach((channelzInfo, session)=>{\n            if (!session.closed) {\n                pendingChecks += 1;\n                session.close(maybeCallback);\n            }\n        });\n        if (pendingChecks === 0) {\n            wrappedCallback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error(\"Not yet implemented\");\n    }\n    /**\n     * Get the channelz reference object for this server. The returned value is\n     * garbage if channelz is disabled for this server.\n     * @returns\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    _verifyContentType(stream, headers) {\n        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n        if (typeof contentType !== \"string\" || !contentType.startsWith(\"application/grpc\")) {\n            stream.respond({\n                [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n            }, {\n                endStream: true\n            });\n            return false;\n        }\n        return true;\n    }\n    _retrieveHandler(path) {\n        this.trace(\"Received call to method \" + path + \" at address \" + this.serverAddressString);\n        const handler = this.handlers.get(path);\n        if (handler === undefined) {\n            this.trace(\"No handler registered for method \" + path + \". Sending UNIMPLEMENTED status.\");\n            return null;\n        }\n        return handler;\n    }\n    _respondWithError(err, stream, channelzSessionInfo = null) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n        if (err.code === undefined) {\n            err.code = constants_1.Status.INTERNAL;\n        }\n        if (this.channelzEnabled) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        }\n        call.sendError(err);\n    }\n    _channelzHandler(stream, headers) {\n        const channelzSessionInfo = this.sessions.get(stream.session);\n        this.callTracker.addCallStarted();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n        if (!this._verifyContentType(stream, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            return;\n        }\n        const path = headers[HTTP2_HEADER_PATH];\n        const handler = this._retrieveHandler(path);\n        if (!handler) {\n            this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        call.once(\"callEnd\", (code)=>{\n            if (code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            } else {\n                this.callTracker.addCallFailed();\n            }\n        });\n        if (channelzSessionInfo) {\n            call.once(\"streamEnd\", (success)=>{\n                if (success) {\n                    channelzSessionInfo.streamTracker.addCallSucceeded();\n                } else {\n                    channelzSessionInfo.streamTracker.addCallFailed();\n                }\n            });\n            call.on(\"sendMessage\", ()=>{\n                channelzSessionInfo.messagesSent += 1;\n                channelzSessionInfo.lastMessageSentTimestamp = new Date();\n            });\n            call.on(\"receiveMessage\", ()=>{\n                channelzSessionInfo.messagesReceived += 1;\n                channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n            });\n        }\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _streamHandler(stream, headers) {\n        if (this._verifyContentType(stream, headers) !== true) {\n            return;\n        }\n        const path = headers[HTTP2_HEADER_PATH];\n        const handler = this._retrieveHandler(path);\n        if (!handler) {\n            this._respondWithError(getUnimplementedStatusResponse(path), stream, null);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _runHandlerForCall(call, handler, headers) {\n        var _a;\n        const metadata = call.receiveMetadata(headers);\n        const encoding = (_a = metadata.get(\"grpc-encoding\")[0]) !== null && _a !== void 0 ? _a : \"identity\";\n        metadata.remove(\"grpc-encoding\");\n        const { type } = handler;\n        if (type === \"unary\") {\n            handleUnary(call, handler, metadata, encoding);\n        } else if (type === \"clientStream\") {\n            handleClientStreaming(call, handler, metadata, encoding);\n        } else if (type === \"serverStream\") {\n            handleServerStreaming(call, handler, metadata, encoding);\n        } else if (type === \"bidi\") {\n            handleBidiStreaming(call, handler, metadata, encoding);\n        } else {\n            return false;\n        }\n        return true;\n    }\n    _setupHandlers(http2Server) {\n        if (http2Server === null) {\n            return;\n        }\n        const serverAddress = http2Server.address();\n        let serverAddressString = \"null\";\n        if (serverAddress) {\n            if (typeof serverAddress === \"string\") {\n                serverAddressString = serverAddress;\n            } else {\n                serverAddressString = serverAddress.address + \":\" + serverAddress.port;\n            }\n        }\n        this.serverAddressString = serverAddressString;\n        const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n        http2Server.on(\"stream\", handler.bind(this));\n        http2Server.on(\"session\", (session)=>{\n            var _a, _b, _c, _d, _e;\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            const channelzRef = (0, channelz_1.registerChannelzSocket)((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : \"unknown\", this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n            const channelzSessionInfo = {\n                ref: channelzRef,\n                streamTracker: new channelz_1.ChannelzCallTracker(),\n                messagesSent: 0,\n                messagesReceived: 0,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null\n            };\n            this.sessions.set(session, channelzSessionInfo);\n            const clientAddress = session.socket.remoteAddress;\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Connection established by client \" + clientAddress);\n                this.sessionChildrenTracker.refChild(channelzRef);\n            }\n            let connectionAgeTimer = null;\n            let connectionAgeGraceTimer = null;\n            let sessionClosedByServer = false;\n            if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                // Apply a random jitter within a +/-10% range\n                const jitterMagnitude = this.maxConnectionAgeMs / 10;\n                const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n                connectionAgeTimer = (_c = (_b = setTimeout(()=>{\n                    var _a, _b;\n                    sessionClosedByServer = true;\n                    if (this.channelzEnabled) {\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by max connection age from \" + clientAddress);\n                    }\n                    try {\n                        session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), Buffer.from(\"max_age\"));\n                    } catch (e) {\n                        // The goaway can't be sent because the session is already closed\n                        session.destroy();\n                        return;\n                    }\n                    session.close();\n                    /* Allow a grace period after sending the GOAWAY before forcibly\n                     * closing the connection. */ if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                        connectionAgeGraceTimer = (_b = (_a = setTimeout(()=>{\n                            session.destroy();\n                        }, this.maxConnectionAgeGraceMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    }\n                }, this.maxConnectionAgeMs + jitter)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n            }\n            const keeapliveTimeTimer = (_e = (_d = setInterval(()=>{\n                var _a, _b;\n                const timeoutTImer = (_b = (_a = setTimeout(()=>{\n                    sessionClosedByServer = true;\n                    if (this.channelzEnabled) {\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by keepalive timeout from \" + clientAddress);\n                    }\n                    session.close();\n                }, this.keepaliveTimeoutMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n                try {\n                    session.ping((err, duration, payload)=>{\n                        clearTimeout(timeoutTImer);\n                    });\n                } catch (e) {\n                    // The ping can't be sent because the session is already closed\n                    session.destroy();\n                }\n            }, this.keepaliveTimeMs)).unref) === null || _e === void 0 ? void 0 : _e.call(_d);\n            session.on(\"close\", ()=>{\n                if (this.channelzEnabled) {\n                    if (!sessionClosedByServer) {\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by client \" + clientAddress);\n                    }\n                    this.sessionChildrenTracker.unrefChild(channelzRef);\n                    (0, channelz_1.unregisterChannelzRef)(channelzRef);\n                }\n                if (connectionAgeTimer) {\n                    clearTimeout(connectionAgeTimer);\n                }\n                if (connectionAgeGraceTimer) {\n                    clearTimeout(connectionAgeGraceTimer);\n                }\n                if (keeapliveTimeTimer) {\n                    clearTimeout(keeapliveTimeTimer);\n                }\n                this.sessions.delete(session);\n            });\n        });\n    }\n}\nexports.Server = Server;\nasync function handleUnary(call, handler, metadata, encoding) {\n    try {\n        const request = await call.receiveUnaryMessage(encoding);\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n        handler.func(emitter, (err, value, trailer, flags)=>{\n            call.sendUnaryMessage(err, value, trailer, flags);\n        });\n    } catch (err) {\n        call.sendError(err);\n    }\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on(\"error\", respond);\n    handler.func(stream, respond);\n}\nasync function handleServerStreaming(call, handler, metadata, encoding) {\n    try {\n        const request = await call.receiveUnaryMessage(encoding);\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n        handler.func(stream);\n    } catch (err) {\n        call.sendError(err);\n    }\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n} //# sourceMappingURL=server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLmpzIiwibWFwcGluZ3MiOiI7O0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLE1BQU1HLFFBQVFDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQzdCLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLGdCQUFnQkYsbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0MsTUFBTUcsdUJBQXVCSCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUksYUFBYUosbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTU0sdUJBQXVCTixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVEsYUFBYVIsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTVMsOEJBQThCLENBQUUsTUFBSyxFQUFDO0FBQzVDLE1BQU1DLHdCQUF3QixDQUFFLE1BQUssRUFBQztBQUN0QyxNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTSxFQUFFQyxpQkFBaUIsRUFBRSxHQUFHYixNQUFNYyxTQUFTO0FBQzdDLE1BQU1DLGNBQWM7QUFDcEIsU0FBU0MsUUFBUztBQUNsQixTQUFTQywrQkFBK0JDLFVBQVU7SUFDOUMsT0FBTztRQUNIQyxNQUFNakIsWUFBWWtCLE1BQU0sQ0FBQ0MsYUFBYTtRQUN0Q0MsU0FBUyxDQUFDLHlDQUF5QyxFQUFFSixXQUFXLENBQUM7SUFDckU7QUFDSjtBQUNBLFNBQVNLLGtCQUFrQkMsV0FBVyxFQUFFTixVQUFVO0lBQzlDLE1BQU1PLDhCQUE4QlIsK0JBQStCQztJQUNuRSxPQUFRTTtRQUNKLEtBQUs7WUFDRCxPQUFPLENB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O0lBQzFELE1BQU16QixTQUFTLElBQUlwUCxjQUFjbVQsc0JBQXNCLENBQUM1UixNQUFNb1AsVUFBVXpDLFFBQVFDLFNBQVMsRUFBRUQsUUFBUUUsV0FBVyxFQUFFeUM7SUFDaEgsSUFBSXRQLEtBQUtvUixTQUFTLEVBQUU7UUFDaEI7SUFDSjtJQUNBekUsUUFBUU0sSUFBSSxDQUFDWTtBQUNqQixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZlci5qcz9hODgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBzZXJ2ZXJfY2FsbF8xID0gcmVxdWlyZShcIi4vc2VydmVyLWNhbGxcIik7XG5jb25zdCBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TID0gfigxIDw8IDMxKTtcbmNvbnN0IEtFRVBBTElWRV9NQVhfVElNRV9NUyA9IH4oMSA8PCAzMSk7XG5jb25zdCBLRUVQQUxJVkVfVElNRU9VVF9NUyA9IDIwMDAwO1xuY29uc3QgeyBIVFRQMl9IRUFERVJfUEFUSCB9ID0gaHR0cDIuY29uc3RhbnRzO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc2VydmVyJztcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmZ1bmN0aW9uIGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsXG4gICAgICAgIGRldGFpbHM6IGBUaGUgc2VydmVyIGRvZXMgbm90IGltcGxlbWVudCB0aGUgbWV0aG9kICR7bWV0aG9kTmFtZX1gLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0SGFuZGxlcihoYW5kbGVyVHlwZSwgbWV0aG9kTmFtZSkge1xuICAgIGNvbnN0IHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSA9IGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShtZXRob2ROYW1lKTtcbiAgICBzd2l0Y2ggKGhhbmRsZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3VuYXJ5JzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UsIG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnY2xpZW50U3RyZWFtJzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UsIG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnc2VydmVyU3RyZWFtJzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGwuZW1pdCgnZXJyb3InLCB1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYmlkaSc6XG4gICAgICAgICAgICByZXR1cm4gKGNhbGwpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsLmVtaXQoJ2Vycm9yJywgdW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaGFuZGxlclR5cGUgJHtoYW5kbGVyVHlwZX1gKTtcbiAgICB9XG59XG5jbGFzcyBTZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLmh0dHAyU2VydmVyTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNlc3Npb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaHV0ZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlcnZlckFkZHJlc3NTdHJpbmcgPSAnbnVsbCc7XG4gICAgICAgIC8vIENoYW5uZWx6IEluZm9cbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlKCk7XG4gICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNlcnZlcikoKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTZXJ2ZXIgY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zID1cbiAgICAgICAgICAgIChfYSA9IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfbXMnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TO1xuICAgICAgICB0aGlzLm1heENvbm5lY3Rpb25BZ2VHcmFjZU1zID1cbiAgICAgICAgICAgIChfYiA9IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfZ3JhY2VfbXMnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA9XG4gICAgICAgICAgICAoX2MgPSB0aGlzLm9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogS0VFUEFMSVZFX01BWF9USU1FX01TO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9XG4gICAgICAgICAgICAoX2QgPSB0aGlzLm9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogS0VFUEFMSVZFX1RJTUVPVVRfTVM7XG4gICAgICAgIHRoaXMudHJhY2UoJ1NlcnZlciBjb25zdHJ1Y3RlZCcpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFjZTogdGhpcy5jaGFubmVselRyYWNlLFxuICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXG4gICAgICAgICAgICBsaXN0ZW5lckNoaWxkcmVuOiB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKSxcbiAgICAgICAgICAgIHNlc3Npb25DaGlsZHJlbjogdGhpcy5zZXNzaW9uQ2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpTZXNzaW9uSW5mb0dldHRlcihzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0gdGhpcy5zZXNzaW9ucy5nZXQoc2Vzc2lvbik7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uU29ja2V0ID0gc2Vzc2lvbi5zb2NrZXQ7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVBZGRyZXNzID0gc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzXG4gICAgICAgICAgICAgICAgPyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcykoc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzLCBzZXNzaW9uU29ja2V0LnJlbW90ZVBvcnQpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxBZGRyZXNzID0gc2Vzc2lvblNvY2tldC5sb2NhbEFkZHJlc3NcbiAgICAgICAgICAgICAgICA/ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKShzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzcywgc2Vzc2lvblNvY2tldC5sb2NhbFBvcnQpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgbGV0IHRsc0luZm87XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bHNTb2NrZXQgPSBzZXNzaW9uU29ja2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpcGhlckluZm8gPSB0bHNTb2NrZXQuZ2V0Q2lwaGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0Q2VydGlmaWNhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZWVyQ2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICAgICAgdGxzSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWU6IChfYSA9IGNpcGhlckluZm8uc3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZU90aGVyTmFtZTogY2lwaGVySW5mby5zdGFuZGFyZE5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjaXBoZXJJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQ2VydGlmaWNhdGU6IGNlcnRpZmljYXRlICYmICdyYXcnIGluIGNlcnRpZmljYXRlID8gY2VydGlmaWNhdGUucmF3IDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlQ2VydGlmaWNhdGU6IHBlZXJDZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBwZWVyQ2VydGlmaWNhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGVlckNlcnRpZmljYXRlLnJhd1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bHNJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvY2tldEluZm8gPSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogcmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzZWN1cml0eTogdGxzSW5mbyxcbiAgICAgICAgICAgICAgICByZW1vdGVOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IHNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNTZW50OiBzZXNzaW9uSW5mby5tZXNzYWdlc1NlbnQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogc2Vzc2lvbkluZm8ubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogMCxcbiAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IHNlc3Npb25JbmZvLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IChfYiA9IHNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiAoX2MgPSBzZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHNvY2tldEluZm87XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArIHRleHQpO1xuICAgIH1cbiAgICBhZGRQcm90b1NlcnZpY2UoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLiBVc2UgYWRkU2VydmljZSgpIGluc3RlYWQnKTtcbiAgICB9XG4gICAgYWRkU2VydmljZShzZXJ2aWNlLCBpbXBsZW1lbnRhdGlvbikge1xuICAgICAgICBpZiAoc2VydmljZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIHNlcnZpY2UgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIGltcGxlbWVudGF0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRTZXJ2aWNlKCkgcmVxdWlyZXMgdHdvIG9iamVjdHMgYXMgYXJndW1lbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VydmljZUtleXMgPSBPYmplY3Qua2V5cyhzZXJ2aWNlKTtcbiAgICAgICAgaWYgKHNlcnZpY2VLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGFuIGVtcHR5IHNlcnZpY2UgdG8gYSBzZXJ2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJ2aWNlS2V5cy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBzZXJ2aWNlW25hbWVdO1xuICAgICAgICAgICAgbGV0IG1ldGhvZFR5cGU7XG4gICAgICAgICAgICBpZiAoYXR0cnMucmVxdWVzdFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ2JpZGknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdjbGllbnRTdHJlYW0nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3NlcnZlclN0cmVhbSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3VuYXJ5JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW1wbEZuID0gaW1wbGVtZW50YXRpb25bbmFtZV07XG4gICAgICAgICAgICBsZXQgaW1wbDtcbiAgICAgICAgICAgIGlmIChpbXBsRm4gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYXR0cnMub3JpZ2luYWxOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGltcGxGbiA9IGltcGxlbWVudGF0aW9uW2F0dHJzLm9yaWdpbmFsTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1wbEZuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbXBsID0gaW1wbEZuLmJpbmQoaW1wbGVtZW50YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1wbCA9IGdldERlZmF1bHRIYW5kbGVyKG1ldGhvZFR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHRoaXMucmVnaXN0ZXIoYXR0cnMucGF0aCwgaW1wbCwgYXR0cnMucmVzcG9uc2VTZXJpYWxpemUsIGF0dHJzLnJlcXVlc3REZXNlcmlhbGl6ZSwgbWV0aG9kVHlwZSk7XG4gICAgICAgICAgICBpZiAoc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ldGhvZCBoYW5kbGVyIGZvciAke2F0dHJzLnBhdGh9IGFscmVhZHkgcHJvdmlkZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgICAgICAgaWYgKHNlcnZpY2UgPT09IG51bGwgfHwgdHlwZW9mIHNlcnZpY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZVNlcnZpY2UoKSByZXF1aXJlcyBvYmplY3QgYXMgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2aWNlS2V5cyA9IE9iamVjdC5rZXlzKHNlcnZpY2UpO1xuICAgICAgICBzZXJ2aWNlS2V5cy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBzZXJ2aWNlW25hbWVdO1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKGF0dHJzLnBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmluZChwb3J0LCBjcmVkcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4gVXNlIGJpbmRBc3luYygpIGluc3RlYWQnKTtcbiAgICB9XG4gICAgYmluZEFzeW5jKHBvcnQsIGNyZWRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcnZlciBpcyBhbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaHV0ZG93bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQXN5bmMgY2FsbGVkIGFmdGVyIHNodXRkb3duJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwb3J0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncG9ydCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNyZWRzID09PSBudWxsIHx8ICEoY3JlZHMgaW5zdGFuY2VvZiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5TZXJ2ZXJDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NyZWRzIG11c3QgYmUgYSBTZXJ2ZXJDcmVkZW50aWFscyBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0aWFsUG9ydFVyaSA9ICgwLCB1cmlfcGFyc2VyXzEucGFyc2VVcmkpKHBvcnQpO1xuICAgICAgICBpZiAoaW5pdGlhbFBvcnRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHBvcnQgXCIke3BvcnR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3J0VXJpID0gKDAsIHJlc29sdmVyXzEubWFwVXJpRGVmYXVsdFNjaGVtZSkoaW5pdGlhbFBvcnRVcmkpO1xuICAgICAgICBpZiAocG9ydFVyaSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0IGEgZGVmYXVsdCBzY2hlbWUgZm9yIHBvcnQgXCIke3BvcnR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgbWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHNlcnZlck9wdGlvbnMubWF4U2Vzc2lvbk1lbW9yeSA9XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zWydncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5J107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBCeSBkZWZhdWx0LCBzZXQgYSB2ZXJ5IGxhcmdlIG1heCBzZXNzaW9uIG1lbW9yeSBsaW1pdCwgdG8gZWZmZWN0aXZlbHlcbiAgICAgICAgICAgICAqIGRpc2FibGUgZW5mb3JjZW1lbnQgb2YgdGhlIGxpbWl0LiBTb21lIHRlc3RpbmcgaW5kaWNhdGVzIHRoYXQgTm9kZSdzXG4gICAgICAgICAgICAgKiBiZWhhdmlvciBkZWdyYWRlcyBiYWRseSB3aGVuIHRoaXMgbGltaXQgaXMgcmVhY2hlZCwgc28gd2Ugc29sdmUgdGhhdFxuICAgICAgICAgICAgICogYnkgZGlzYWJsaW5nIHRoZSBjaGVjayBlbnRpcmVseS4gKi9cbiAgICAgICAgICAgIHNlcnZlck9wdGlvbnMubWF4U2Vzc2lvbk1lbW9yeSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHNlcnZlck9wdGlvbnMuc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgbWF4Q29uY3VycmVudFN0cmVhbXM6IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmVycmVkQ2FsbGJhY2sgPSAoZXJyb3IsIHBvcnQpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gY2FsbGJhY2soZXJyb3IsIHBvcnQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0dXBTZXJ2ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgaHR0cDJTZXJ2ZXI7XG4gICAgICAgICAgICBpZiAoY3JlZHMuX2lzU2VjdXJlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN1cmVTZXJ2ZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbihzZXJ2ZXJPcHRpb25zLCBjcmVkcy5fZ2V0U2V0dGluZ3MoKSk7XG4gICAgICAgICAgICAgICAgc2VjdXJlU2VydmVyT3B0aW9ucy5lbmFibGVUcmFjZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1snZ3JwYy1ub2RlLnRsc19lbmFibGVfdHJhY2UnXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlciA9IGh0dHAyLmNyZWF0ZVNlY3VyZVNlcnZlcihzZWN1cmVTZXJ2ZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbignc2VjdXJlQ29ubmVjdGlvbicsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogVGhlc2UgZXJyb3JzIG5lZWQgdG8gYmUgaGFuZGxlZCBieSB0aGUgdXNlciBvZiBIdHRwMlNlY3VyZVNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgICogYWNjb3JkaW5nIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzU4MjQgKi9cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdBbiBpbmNvbWluZyBUTFMgY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBlcnJvcjogJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIgPSBodHRwMi5jcmVhdGVTZXJ2ZXIoc2VydmVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodHRwMlNlcnZlci5zZXRUaW1lb3V0KDAsIG5vb3ApO1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBIYW5kbGVycyhodHRwMlNlcnZlcik7XG4gICAgICAgICAgICByZXR1cm4gaHR0cDJTZXJ2ZXI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJpbmRTcGVjaWZpY1BvcnQgPSAoYWRkcmVzc0xpc3QsIHBvcnROdW0sIHByZXZpb3VzQ291bnQpID0+IHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgcG9ydDogcG9ydE51bSwgY291bnQ6IHByZXZpb3VzQ291bnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0F0dGVtcHRpbmcgdG8gYmluZCAnICsgKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkcjtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBhZGRyZXNzLmhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBwb3J0TnVtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkciA9IGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGh0dHAyU2VydmVyID0gc2V0dXBTZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIGJpbmQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5saXN0ZW4oYWRkciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2h1dGRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEVycm9yKCdiaW5kQXN5bmMgZmFpbGVkIGJlY2F1c2Ugc2VydmVyIGlzIHNodXRkb3duJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kQWRkcmVzcyA9IGh0dHAyU2VydmVyLmFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBib3VuZFN1YmNoYW5uZWxBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBib3VuZEFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRTdWJjaGFubmVsQWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYm91bmRBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZFN1YmNoYW5uZWxBZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBib3VuZEFkZHJlc3MuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogYm91bmRBZGRyZXNzLnBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCkoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBib3VuZFN1YmNoYW5uZWxBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVBZGRyZXNzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN1cml0eTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N0YXJ0ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdWNjZWVkZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlcjogaHR0cDJTZXJ2ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpSZWY6IGNoYW5uZWx6UmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdTdWNjZXNzZnVsbHkgYm91bmQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ3BvcnQnIGluIGJvdW5kU3ViY2hhbm5lbEFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MucG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcG9ydE51bSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gcG9ydE51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogbXVsdGlwbGUgcG9ydCBudW1iZXJzIGFkZGVkIGZyb20gc2luZ2xlIGFkZHJlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwb3J0OiBwb3J0TnVtLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnQgKyBwcmV2aW91c0NvdW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYmluZFdpbGRjYXJkUG9ydCA9IChhZGRyZXNzTGlzdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFkZHJlc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBwb3J0OiAwLCBjb3VudDogMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhZGRyZXNzTGlzdFswXTtcbiAgICAgICAgICAgIGNvbnN0IGh0dHAyU2VydmVyID0gc2V0dXBTZXJ2ZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIGJpbmQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYWRkcmVzcykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJpbmRXaWxkY2FyZFBvcnQoYWRkcmVzc0xpc3Quc2xpY2UoMSkpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLm9uY2UoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIubGlzdGVuKGFkZHJlc3MsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2h1dGRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgcG9ydDogMCwgY291bnQ6IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRBZGRyZXNzID0gaHR0cDJTZXJ2ZXIuYWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZFN1YmNoYW5uZWxBZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogYm91bmRBZGRyZXNzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBib3VuZEFkZHJlc3MucG9ydCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U29ja2V0KSgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYm91bmRTdWJjaGFubmVsQWRkcmVzcyksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBib3VuZFN1YmNoYW5uZWxBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdXJpdHk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3RhcnRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNTZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZsb3dDb250cm9sV2luZG93OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyOiBodHRwMlNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6UmVmOiBjaGFubmVselJlZixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1N1Y2Nlc3NmdWxseSBib3VuZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShib3VuZFN1YmNoYW5uZWxBZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYmluZFNwZWNpZmljUG9ydChhZGRyZXNzTGlzdC5zbGljZSgxKSwgYm91bmRBZGRyZXNzLnBvcnQsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXJMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb246IChhZGRyZXNzTGlzdCwgc2VydmljZUNvbmZpZywgc2VydmljZUNvbmZpZ0Vycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IG9uZSByZXNvbHV0aW9uIHJlc3VsdC4gRGlzY2FyZCBhbGwgZnV0dXJlIHJlc3VsdHNcbiAgICAgICAgICAgICAgICByZXNvbHZlckxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24gPSAoKSA9PiB7IH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2h1dGRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDYWxsYmFjayhuZXcgRXJyb3IoYGJpbmRBc3luYyBmYWlsZWQgYmVjYXVzZSBzZXJ2ZXIgaXMgc2h1dGRvd25gKSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDYWxsYmFjayhuZXcgRXJyb3IoYE5vIGFkZHJlc3NlcyByZXNvbHZlZCBmb3IgcG9ydCAke3BvcnR9YCksIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiaW5kUmVzdWx0UHJvbWlzZTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKGFkZHJlc3NMaXN0WzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzc0xpc3RbMF0ucG9ydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UgPSBiaW5kV2lsZGNhcmRQb3J0KGFkZHJlc3NMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRSZXN1bHRQcm9taXNlID0gYmluZFNwZWNpZmljUG9ydChhZGRyZXNzTGlzdCwgYWRkcmVzc0xpc3RbMF0ucG9ydCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhbiBhcmJpdHJhcnkgbm9uLXplcm8gcG9ydCBmb3Igbm9uLVRDUCBhZGRyZXNzZXNcbiAgICAgICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UgPSBiaW5kU3BlY2lmaWNQb3J0KGFkZHJlc3NMaXN0LCAxLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UudGhlbihiaW5kUmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmRSZXN1bHQuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yU3RyaW5nID0gYE5vIGFkZHJlc3MgYWRkZWQgb3V0IG9mIHRvdGFsICR7YWRkcmVzc0xpc3QubGVuZ3RofSByZXNvbHZlZGA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGVycm9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobmV3IEVycm9yKGVycm9yU3RyaW5nKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluZFJlc3VsdC5jb3VudCA8IGFkZHJlc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPLCBgV0FSTklORyBPbmx5ICR7YmluZFJlc3VsdC5jb3VudH0gYWRkcmVzc2VzIGFkZGVkIG91dCBvZiB0b3RhbCAke2FkZHJlc3NMaXN0Lmxlbmd0aH0gcmVzb2x2ZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobnVsbCwgYmluZFJlc3VsdC5wb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JTdHJpbmcgPSBgTm8gYWRkcmVzcyBhZGRlZCBvdXQgb2YgdG90YWwgJHthZGRyZXNzTGlzdC5sZW5ndGh9IHJlc29sdmVkYDtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBlcnJvclN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobmV3IEVycm9yKGVycm9yU3RyaW5nKSwgMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25FcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobmV3IEVycm9yKGVycm9yLmRldGFpbHMpLCAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gKDAsIHJlc29sdmVyXzEuY3JlYXRlUmVzb2x2ZXIpKHBvcnRVcmksIHJlc29sdmVyTGlzdGVuZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHJlc29sdmVyLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICB9XG4gICAgZm9yY2VTaHV0ZG93bigpIHtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIHNlcnZlciBpZiBpdCBpcyBzdGlsbCBydW5uaW5nLlxuICAgICAgICBmb3IgKGNvbnN0IHsgc2VydmVyOiBodHRwMlNlcnZlciwgY2hhbm5lbHpSZWY6IHJlZiB9IG9mIHRoaXNcbiAgICAgICAgICAgIC5odHRwMlNlcnZlckxpc3QpIHtcbiAgICAgICAgICAgIGlmIChodHRwMlNlcnZlci5saXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaHV0ZG93biA9IHRydWU7XG4gICAgICAgIC8vIEFsd2F5cyBkZXN0cm95IGFueSBhdmFpbGFibGUgc2Vzc2lvbnMuIEl0J3MgcG9zc2libGUgdGhhdCBvbmUgb3IgbW9yZVxuICAgICAgICAvLyB0cnlTaHV0ZG93bigpIGNhbGxzIGFyZSBpbiBwcm9ncmVzcy4gRG9uJ3Qgd2FpdCBvbiB0aGVtIHRvIGZpbmlzaC5cbiAgICAgICAgdGhpcy5zZXNzaW9ucy5mb3JFYWNoKChjaGFubmVsekluZm8sIHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgIC8vIENhc3QgTkdIVFRQMl9DQU5DRUwgdG8gYW55IGJlY2F1c2UgVHlwZVNjcmlwdCBkb2Vzbid0IHNlZW0gdG9cbiAgICAgICAgICAgIC8vIHJlY29nbml6ZSBkZXN0cm95KGNvZGUpIGFzIGEgdmFsaWQgc2lnbmF0dXJlLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveShodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXNzaW9ucy5jbGVhcigpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXIobmFtZSwgaGFuZGxlciwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgdHlwZSkge1xuICAgICAgICBpZiAodGhpcy5oYW5kbGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZXJzLnNldChuYW1lLCB7XG4gICAgICAgICAgICBmdW5jOiBoYW5kbGVyLFxuICAgICAgICAgICAgc2VyaWFsaXplLFxuICAgICAgICAgICAgZGVzZXJpYWxpemUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGF0aDogbmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaHR0cDJTZXJ2ZXJMaXN0Lmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgdGhpcy5odHRwMlNlcnZlckxpc3QuZXZlcnkoKHsgc2VydmVyOiBodHRwMlNlcnZlciB9KSA9PiBodHRwMlNlcnZlci5saXN0ZW5pbmcgIT09IHRydWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcnZlciBtdXN0IGJlIGJvdW5kIGluIG9yZGVyIHRvIHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXJ2ZXIgaXMgYWxyZWFkeSBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU3RhcnRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0cnlTaHV0ZG93bihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwZW5kaW5nQ2hlY2tzID0gMDtcbiAgICAgICAgZnVuY3Rpb24gbWF5YmVDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHBlbmRpbmdDaGVja3MtLTtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nQ2hlY2tzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvc2UgdGhlIHNlcnZlciBpZiBuZWNlc3NhcnkuXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNodXRkb3duID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCB7IHNlcnZlcjogaHR0cDJTZXJ2ZXIsIGNoYW5uZWx6UmVmOiByZWYgfSBvZiB0aGlzXG4gICAgICAgICAgICAuaHR0cDJTZXJ2ZXJMaXN0KSB7XG4gICAgICAgICAgICBpZiAoaHR0cDJTZXJ2ZXIubGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0NoZWNrcysrO1xuICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXliZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9ucy5mb3JFYWNoKChjaGFubmVsekluZm8sIHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nQ2hlY2tzICs9IDE7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZShtYXliZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwZW5kaW5nQ2hlY2tzID09PSAwKSB7XG4gICAgICAgICAgICB3cmFwcGVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIdHRwMlBvcnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5uZWx6IHJlZmVyZW5jZSBvYmplY3QgZm9yIHRoaXMgc2VydmVyLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXNcbiAgICAgKiBnYXJiYWdlIGlmIGNoYW5uZWx6IGlzIGRpc2FibGVkIGZvciB0aGlzIHNlcnZlci5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcbiAgICB9XG4gICAgX3ZlcmlmeUNvbnRlbnRUeXBlKHN0cmVhbSwgaGVhZGVycykge1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnNbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRUeXBlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgIWNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL2dycGMnKSkge1xuICAgICAgICAgICAgc3RyZWFtLnJlc3BvbmQoe1xuICAgICAgICAgICAgICAgIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1NUQVRVU106IGh0dHAyLmNvbnN0YW50cy5IVFRQX1NUQVRVU19VTlNVUFBPUlRFRF9NRURJQV9UWVBFLFxuICAgICAgICAgICAgfSwgeyBlbmRTdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9yZXRyaWV2ZUhhbmRsZXIocGF0aCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBjYWxsIHRvIG1ldGhvZCAnICtcbiAgICAgICAgICAgIHBhdGggK1xuICAgICAgICAgICAgJyBhdCBhZGRyZXNzICcgK1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnMuZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdObyBoYW5kbGVyIHJlZ2lzdGVyZWQgZm9yIG1ldGhvZCAnICtcbiAgICAgICAgICAgICAgICBwYXRoICtcbiAgICAgICAgICAgICAgICAnLiBTZW5kaW5nIFVOSU1QTEVNRU5URUQgc3RhdHVzLicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuICAgIF9yZXNwb25kV2l0aEVycm9yKGVyciwgc3RyZWFtLCBjaGFubmVselNlc3Npb25JbmZvID0gbnVsbCkge1xuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHNlcnZlcl9jYWxsXzEuSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtKHN0cmVhbSwgbnVsbCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVyci5jb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbC5zZW5kRXJyb3IoZXJyKTtcbiAgICB9XG4gICAgX2NoYW5uZWx6SGFuZGxlcihzdHJlYW0sIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbHpTZXNzaW9uSW5mbyA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHN0cmVhbS5zZXNzaW9uKTtcbiAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvbnRlbnRUeXBlKHN0cmVhbSwgaGVhZGVycykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gbnVsbCB8fCBjaGFubmVselNlc3Npb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX3JldHJpZXZlSGFuZGxlcihwYXRoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kV2l0aEVycm9yKGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShwYXRoKSwgc3RyZWFtLCBjaGFubmVselNlc3Npb25JbmZvKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHNlcnZlcl9jYWxsXzEuSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtKHN0cmVhbSwgaGFuZGxlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgY2FsbC5vbmNlKCdjYWxsRW5kJywgKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNoYW5uZWx6U2Vzc2lvbkluZm8pIHtcbiAgICAgICAgICAgIGNhbGwub25jZSgnc3RyZWFtRW5kJywgKHN1Y2Nlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGwub24oJ3NlbmRNZXNzYWdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubWVzc2FnZXNTZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWxsLm9uKCdyZWNlaXZlTWVzc2FnZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLm1lc3NhZ2VzUmVjZWl2ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9ydW5IYW5kbGVyRm9yQ2FsbChjYWxsLCBoYW5kbGVyLCBoZWFkZXJzKSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICBjYWxsLnNlbmRFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBVbmtub3duIGhhbmRsZXIgdHlwZTogJHtoYW5kbGVyLnR5cGV9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zdHJlYW1IYW5kbGVyKHN0cmVhbSwgaGVhZGVycykge1xuICAgICAgICBpZiAodGhpcy5fdmVyaWZ5Q29udGVudFR5cGUoc3RyZWFtLCBoZWFkZXJzKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX3JldHJpZXZlSGFuZGxlcihwYXRoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kV2l0aEVycm9yKGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShwYXRoKSwgc3RyZWFtLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHNlcnZlcl9jYWxsXzEuSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtKHN0cmVhbSwgaGFuZGxlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ydW5IYW5kbGVyRm9yQ2FsbChjYWxsLCBoYW5kbGVyLCBoZWFkZXJzKSkge1xuICAgICAgICAgICAgY2FsbC5zZW5kRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgVW5rbm93biBoYW5kbGVyIHR5cGU6ICR7aGFuZGxlci50eXBlfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcnVuSGFuZGxlckZvckNhbGwoY2FsbCwgaGFuZGxlciwgaGVhZGVycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY2FsbC5yZWNlaXZlTWV0YWRhdGEoaGVhZGVycyk7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gKF9hID0gbWV0YWRhdGEuZ2V0KCdncnBjLWVuY29kaW5nJylbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdpZGVudGl0eSc7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IGhhbmRsZXI7XG4gICAgICAgIGlmICh0eXBlID09PSAndW5hcnknKSB7XG4gICAgICAgICAgICBoYW5kbGVVbmFyeShjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdjbGllbnRTdHJlYW0nKSB7XG4gICAgICAgICAgICBoYW5kbGVDbGllbnRTdHJlYW1pbmcoY2FsbCwgaGFuZGxlciwgbWV0YWRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2VydmVyU3RyZWFtJykge1xuICAgICAgICAgICAgaGFuZGxlU2VydmVyU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2JpZGknKSB7XG4gICAgICAgICAgICBoYW5kbGVCaWRpU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9zZXR1cEhhbmRsZXJzKGh0dHAyU2VydmVyKSB7XG4gICAgICAgIGlmIChodHRwMlNlcnZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZlckFkZHJlc3MgPSBodHRwMlNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgIGxldCBzZXJ2ZXJBZGRyZXNzU3RyaW5nID0gJ251bGwnO1xuICAgICAgICBpZiAoc2VydmVyQWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJ2ZXJBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VydmVyQWRkcmVzc1N0cmluZyA9IHNlcnZlckFkZHJlc3MuYWRkcmVzcyArICc6JyArIHNlcnZlckFkZHJlc3MucG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzU3RyaW5nO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5jaGFubmVsekVuYWJsZWRcbiAgICAgICAgICAgID8gdGhpcy5fY2hhbm5lbHpIYW5kbGVyXG4gICAgICAgICAgICA6IHRoaXMuX3N0cmVhbUhhbmRsZXI7XG4gICAgICAgIGh0dHAyU2VydmVyLm9uKCdzdHJlYW0nLCBoYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICBodHRwMlNlcnZlci5vbignc2Vzc2lvbicsIHNlc3Npb24gPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U29ja2V0KSgoX2EgPSBzZXNzaW9uLnNvY2tldC5yZW1vdGVBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAndW5rbm93bicsIHRoaXMuZ2V0Q2hhbm5lbHpTZXNzaW9uSW5mb0dldHRlcihzZXNzaW9uKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbHpTZXNzaW9uSW5mbyA9IHtcbiAgICAgICAgICAgICAgICByZWY6IGNoYW5uZWx6UmVmLFxuICAgICAgICAgICAgICAgIHN0cmVhbVRyYWNrZXI6IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogMCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25zLnNldChzZXNzaW9uLCBjaGFubmVselNlc3Npb25JbmZvKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudEFkZHJlc3MgPSBzZXNzaW9uLnNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpb24gZXN0YWJsaXNoZWQgYnkgY2xpZW50ICcgKyBjbGllbnRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25BZ2VUaW1lciA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY29ubmVjdGlvbkFnZUdyYWNlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zICE9PSBVTkxJTUlURURfQ09OTkVDVElPTl9BR0VfTVMpIHtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBhIHJhbmRvbSBqaXR0ZXIgd2l0aGluIGEgKy8tMTAlIHJhbmdlXG4gICAgICAgICAgICAgICAgY29uc3Qgaml0dGVyTWFnbml0dWRlID0gdGhpcy5tYXhDb25uZWN0aW9uQWdlTXMgLyAxMDtcbiAgICAgICAgICAgICAgICBjb25zdCBqaXR0ZXIgPSBNYXRoLnJhbmRvbSgpICogaml0dGVyTWFnbml0dWRlICogMiAtIGppdHRlck1hZ25pdHVkZTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWdlVGltZXIgPSAoX2MgPSAoX2IgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNsb3NlZEJ5U2VydmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IG1heCBjb25uZWN0aW9uIGFnZSBmcm9tICcgKyBjbGllbnRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5nb2F3YXkoaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1IsIH4oMSA8PCAzMSksIEJ1ZmZlci5mcm9tKCdtYXhfYWdlJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZ29hd2F5IGNhbid0IGJlIHNlbnQgYmVjYXVzZSB0aGUgc2Vzc2lvbiBpcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAvKiBBbGxvdyBhIGdyYWNlIHBlcmlvZCBhZnRlciBzZW5kaW5nIHRoZSBHT0FXQVkgYmVmb3JlIGZvcmNpYmx5XG4gICAgICAgICAgICAgICAgICAgICAqIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24uICovXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heENvbm5lY3Rpb25BZ2VHcmFjZU1zICE9PSBVTkxJTUlURURfQ09OTkVDVElPTl9BR0VfTVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyID0gKF9iID0gKF9hID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1heENvbm5lY3Rpb25BZ2VHcmFjZU1zKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zICsgaml0dGVyKSkudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtlZWFwbGl2ZVRpbWVUaW1lciA9IChfZSA9IChfZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRUSW1lciA9IChfYiA9IChfYSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aW9uIGRyb3BwZWQgYnkga2VlcGFsaXZlIHRpbWVvdXQgZnJvbSAnICsgY2xpZW50QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZW91dE1zKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnBpbmcoKGVyciwgZHVyYXRpb24sIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VEltZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHBpbmcgY2FuJ3QgYmUgc2VudCBiZWNhdXNlIHRoZSBzZXNzaW9uIGlzIGFscmVhZHkgY2xvc2VkXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZU1zKSkudW5yZWYpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKTtcbiAgICAgICAgICAgIHNlc3Npb24ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25DbG9zZWRCeVNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpb24gZHJvcHBlZCBieSBjbGllbnQgJyArIGNsaWVudEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKShjaGFubmVselJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uQWdlVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BZ2VUaW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uQWdlR3JhY2VUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbkFnZUdyYWNlVGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2VlYXBsaXZlVGltZVRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChrZWVhcGxpdmVUaW1lVGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25zLmRlbGV0ZShzZXNzaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVVuYXJ5KGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBjYWxsLnJlY2VpdmVVbmFyeU1lc3NhZ2UoZW5jb2RpbmcpO1xuICAgICAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkIHx8IGNhbGwuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlclVuYXJ5Q2FsbEltcGwoY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpO1xuICAgICAgICBoYW5kbGVyLmZ1bmMoZW1pdHRlciwgKGVyciwgdmFsdWUsIHRyYWlsZXIsIGZsYWdzKSA9PiB7XG4gICAgICAgICAgICBjYWxsLnNlbmRVbmFyeU1lc3NhZ2UoZXJyLCB2YWx1ZSwgdHJhaWxlciwgZmxhZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUNsaWVudFN0cmVhbWluZyhjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgc2VydmVyX2NhbGxfMS5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwoY2FsbCwgbWV0YWRhdGEsIGhhbmRsZXIuZGVzZXJpYWxpemUsIGVuY29kaW5nKTtcbiAgICBmdW5jdGlvbiByZXNwb25kKGVyciwgdmFsdWUsIHRyYWlsZXIsIGZsYWdzKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIGNhbGwuc2VuZFVuYXJ5TWVzc2FnZShlcnIsIHZhbHVlLCB0cmFpbGVyLCBmbGFncyk7XG4gICAgfVxuICAgIGlmIChjYWxsLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0cmVhbS5vbignZXJyb3InLCByZXNwb25kKTtcbiAgICBoYW5kbGVyLmZ1bmMoc3RyZWFtLCByZXNwb25kKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVNlcnZlclN0cmVhbWluZyhjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgY2FsbC5yZWNlaXZlVW5hcnlNZXNzYWdlKGVuY29kaW5nKTtcbiAgICAgICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCB8fCBjYWxsLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbChjYWxsLCBtZXRhZGF0YSwgaGFuZGxlci5zZXJpYWxpemUsIHJlcXVlc3QpO1xuICAgICAgICBoYW5kbGVyLmZ1bmMoc3RyZWFtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUJpZGlTdHJlYW1pbmcoY2FsbCwgaGFuZGxlciwgbWV0YWRhdGEsIGVuY29kaW5nKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IHNlcnZlcl9jYWxsXzEuU2VydmVyRHVwbGV4U3RyZWFtSW1wbChjYWxsLCBtZXRhZGF0YSwgaGFuZGxlci5zZXJpYWxpemUsIGhhbmRsZXIuZGVzZXJpYWxpemUsIGVuY29kaW5nKTtcbiAgICBpZiAoY2FsbC5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVyLmZ1bmMoc3RyZWFtKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTZXJ2ZXIiLCJodHRwMiIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsInNlcnZlcl9jYWxsXzEiLCJzZXJ2ZXJfY3JlZGVudGlhbHNfMSIsInJlc29sdmVyXzEiLCJsb2dnaW5nIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJ1cmlfcGFyc2VyXzEiLCJjaGFubmVsel8xIiwiVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TIiwiS0VFUEFMSVZFX01BWF9USU1FX01TIiwiS0VFUEFMSVZFX1RJTUVPVVRfTVMiLCJIVFRQMl9IRUFERVJfUEFUSCIsImNvbnN0YW50cyIsIlRSQUNFUl9OQU1FIiwibm9vcCIsImdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSIsIm1ldGhvZE5hbWUiLCJjb2RlIiwiU3RhdHVzIiwiVU5JTVBMRU1FTlRFRCIsImRldGFpbHMiLCJnZXREZWZhdWx0SGFuZGxlciIsImhhbmRsZXJUeXBlIiwidW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlIiwiY2FsbCIsImNhbGxiYWNrIiwiZW1pdCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJodHRwMlNlcnZlckxpc3QiLCJoYW5kbGVycyIsIk1hcCIsInNlc3Npb25zIiwic3RhcnRlZCIsInNodXRkb3duIiwic2VydmVyQWRkcmVzc1N0cmluZyIsImNoYW5uZWx6RW5hYmxlZCIsImNoYW5uZWx6VHJhY2UiLCJDaGFubmVselRyYWNlIiwiY2FsbFRyYWNrZXIiLCJDaGFubmVsekNhbGxUcmFja2VyIiwibGlzdGVuZXJDaGlsZHJlblRyYWNrZXIiLCJDaGFubmVsekNoaWxkcmVuVHJhY2tlciIsInNlc3Npb25DaGlsZHJlblRyYWNrZXIiLCJjaGFubmVselJlZiIsInJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXIiLCJnZXRDaGFubmVsekluZm8iLCJhZGRUcmFjZSIsIm1heENvbm5lY3Rpb25BZ2VNcyIsIm1heENvbm5lY3Rpb25BZ2VHcmFjZU1zIiwia2VlcGFsaXZlVGltZU1zIiwia2VlcGFsaXZlVGltZW91dE1zIiwidHJhY2UiLCJsaXN0ZW5lckNoaWxkcmVuIiwiZ2V0Q2hpbGRMaXN0cyIsInNlc3Npb25DaGlsZHJlbiIsImdldENoYW5uZWx6U2Vzc2lvbkluZm9HZXR0ZXIiLCJzZXNzaW9uIiwic2Vzc2lvbkluZm8iLCJnZXQiLCJzZXNzaW9uU29ja2V0Iiwic29ja2V0IiwicmVtb3RlQWRkcmVzcyIsInN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MiLCJyZW1vdGVQb3J0IiwibG9jYWxBZGRyZXNzIiwibG9jYWxQb3J0IiwidGxzSW5mbyIsImVuY3J5cHRlZCIsInRsc1NvY2tldCIsImNpcGhlckluZm8iLCJnZXRDaXBoZXIiLCJjZXJ0aWZpY2F0ZSIsImdldENlcnRpZmljYXRlIiwicGVlckNlcnRpZmljYXRlIiwiZ2V0UGVlckNlcnRpZmljYXRlIiwiY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJjaXBoZXJTdWl0ZU90aGVyTmFtZSIsIm5hbWUiLCJsb2NhbENlcnRpZmljYXRlIiwicmF3IiwicmVtb3RlQ2VydGlmaWNhdGUiLCJzb2NrZXRJbmZvIiwic2VjdXJpdHkiLCJyZW1vdGVOYW1lIiwic3RyZWFtc1N0YXJ0ZWQiLCJzdHJlYW1UcmFja2VyIiwiY2FsbHNTdGFydGVkIiwic3RyZWFtc1N1Y2NlZWRlZCIsImNhbGxzU3VjY2VlZGVkIiwic3RyZWFtc0ZhaWxlZCIsImNhbGxzRmFpbGVkIiwibWVzc2FnZXNTZW50IiwibWVzc2FnZXNSZWNlaXZlZCIsImtlZXBBbGl2ZXNTZW50IiwibGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCIsImxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibGFzdENhbGxTdGFydGVkVGltZXN0YW1wIiwibGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wIiwibGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCIsImxvY2FsRmxvd0NvbnRyb2xXaW5kb3ciLCJzdGF0ZSIsImxvY2FsV2luZG93U2l6ZSIsInJlbW90ZUZsb3dDb250cm9sV2luZG93IiwicmVtb3RlV2luZG93U2l6ZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsImlkIiwiYWRkUHJvdG9TZXJ2aWNlIiwiYWRkU2VydmljZSIsInNlcnZpY2UiLCJpbXBsZW1lbnRhdGlvbiIsInNlcnZpY2VLZXlzIiwia2V5cyIsImxlbmd0aCIsImZvckVhY2giLCJhdHRycyIsIm1ldGhvZFR5cGUiLCJyZXF1ZXN0U3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJpbXBsRm4iLCJpbXBsIiwidW5kZWZpbmVkIiwib3JpZ2luYWxOYW1lIiwiYmluZCIsInN1Y2Nlc3MiLCJyZWdpc3RlciIsInBhdGgiLCJyZXNwb25zZVNlcmlhbGl6ZSIsInJlcXVlc3REZXNlcmlhbGl6ZSIsInJlbW92ZVNlcnZpY2UiLCJ1bnJlZ2lzdGVyIiwicG9ydCIsImNyZWRzIiwiYmluZEFzeW5jIiwiVHlwZUVycm9yIiwiU2VydmVyQ3JlZGVudGlhbHMiLCJpbml0aWFsUG9ydFVyaSIsInBhcnNlVXJpIiwicG9ydFVyaSIsIm1hcFVyaURlZmF1bHRTY2hlbWUiLCJzZXJ2ZXJPcHRpb25zIiwibWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIm1heFNlc3Npb25NZW1vcnkiLCJzZXR0aW5ncyIsIm1heENvbmN1cnJlbnRTdHJlYW1zIiwiZGVmZXJyZWRDYWxsYmFjayIsImVycm9yIiwicHJvY2VzcyIsIm5leHRUaWNrIiwic2V0dXBTZXJ2ZXIiLCJodHRwMlNlcnZlciIsIl9pc1NlY3VyZSIsInNlY3VyZVNlcnZlck9wdGlvbnMiLCJhc3NpZ24iLCJfZ2V0U2V0dGluZ3MiLCJlbmFibGVUcmFjZSIsImNyZWF0ZVNlY3VyZVNlcnZlciIsIm9uIiwiZSIsIm1lc3NhZ2UiLCJjcmVhdGVTZXJ2ZXIiLCJzZXRUaW1lb3V0IiwiX3NldHVwSGFuZGxlcnMiLCJiaW5kU3BlY2lmaWNQb3J0IiwiYWRkcmVzc0xpc3QiLCJwb3J0TnVtIiwicHJldmlvdXNDb3VudCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY291bnQiLCJhbGwiLCJtYXAiLCJhZGRyZXNzIiwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyIsImFkZHIiLCJpc1RjcFN1YmNoYW5uZWxBZGRyZXNzIiwiaG9zdCIsInJlamVjdCIsIm9uRXJyb3IiLCJlcnIiLCJvbmNlIiwibGlzdGVuIiwiY2xvc2UiLCJib3VuZEFkZHJlc3MiLCJib3VuZFN1YmNoYW5uZWxBZGRyZXNzIiwicmVnaXN0ZXJDaGFubmVselNvY2tldCIsInJlZkNoaWxkIiwicHVzaCIsInNlcnZlciIsInJlbW92ZUxpc3RlbmVyIiwidGhlbiIsInJlc3VsdHMiLCJyZXN1bHQiLCJiaW5kV2lsZGNhcmRQb3J0Iiwic2xpY2UiLCJyZXNvbHZlckxpc3RlbmVyIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsInNlcnZpY2VDb25maWciLCJzZXJ2aWNlQ29uZmlnRXJyb3IiLCJiaW5kUmVzdWx0UHJvbWlzZSIsImJpbmRSZXN1bHQiLCJlcnJvclN0cmluZyIsImxvZyIsIkVSUk9SIiwiSU5GTyIsInJlc29sdmVyIiwiY3JlYXRlUmVzb2x2ZXIiLCJ1cGRhdGVSZXNvbHV0aW9uIiwiZm9yY2VTaHV0ZG93biIsInJlZiIsImxpc3RlbmluZyIsInVucmVmQ2hpbGQiLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJjaGFubmVsekluZm8iLCJkZXN0cm95IiwiTkdIVFRQMl9DQU5DRUwiLCJjbGVhciIsImhhbmRsZXIiLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsInR5cGUiLCJoYXMiLCJzZXQiLCJmdW5jIiwiZGVsZXRlIiwic3RhcnQiLCJldmVyeSIsInRyeVNodXRkb3duIiwid3JhcHBlZENhbGxiYWNrIiwicGVuZGluZ0NoZWNrcyIsIm1heWJlQ2FsbGJhY2siLCJjbG9zZWQiLCJhZGRIdHRwMlBvcnQiLCJnZXRDaGFubmVselJlZiIsIl92ZXJpZnlDb250ZW50VHlwZSIsInN0cmVhbSIsImhlYWRlcnMiLCJjb250ZW50VHlwZSIsIkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUiLCJzdGFydHNXaXRoIiwicmVzcG9uZCIsIkhUVFAyX0hFQURFUl9TVEFUVVMiLCJIVFRQX1NUQVRVU19VTlNVUFBPUlRFRF9NRURJQV9UWVBFIiwiZW5kU3RyZWFtIiwiX3JldHJpZXZlSGFuZGxlciIsIl9yZXNwb25kV2l0aEVycm9yIiwiY2hhbm5lbHpTZXNzaW9uSW5mbyIsIkh0dHAyU2VydmVyQ2FsbFN0cmVhbSIsIklOVEVSTkFMIiwiYWRkQ2FsbEZhaWxlZCIsInNlbmRFcnJvciIsIl9jaGFubmVsekhhbmRsZXIiLCJhZGRDYWxsU3RhcnRlZCIsIk9LIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsIkRhdGUiLCJfcnVuSGFuZGxlckZvckNhbGwiLCJfc3RyZWFtSGFuZGxlciIsIm1ldGFkYXRhIiwicmVjZWl2ZU1ldGFkYXRhIiwiZW5jb2RpbmciLCJyZW1vdmUiLCJoYW5kbGVVbmFyeSIsImhhbmRsZUNsaWVudFN0cmVhbWluZyIsImhhbmRsZVNlcnZlclN0cmVhbWluZyIsImhhbmRsZUJpZGlTdHJlYW1pbmciLCJzZXJ2ZXJBZGRyZXNzIiwiX2UiLCJjbGllbnRBZGRyZXNzIiwiY29ubmVjdGlvbkFnZVRpbWVyIiwiY29ubmVjdGlvbkFnZUdyYWNlVGltZXIiLCJzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIiLCJqaXR0ZXJNYWduaXR1ZGUiLCJqaXR0ZXIiLCJNYXRoIiwicmFuZG9tIiwiZ29hd2F5IiwiTkdIVFRQMl9OT19FUlJPUiIsIkJ1ZmZlciIsImZyb20iLCJ1bnJlZiIsImtlZWFwbGl2ZVRpbWVUaW1lciIsInNldEludGVydmFsIiwidGltZW91dFRJbWVyIiwicGluZyIsImR1cmF0aW9uIiwicGF5bG9hZCIsImNsZWFyVGltZW91dCIsInJlcXVlc3QiLCJyZWNlaXZlVW5hcnlNZXNzYWdlIiwiY2FuY2VsbGVkIiwiZW1pdHRlciIsIlNlcnZlclVuYXJ5Q2FsbEltcGwiLCJ0cmFpbGVyIiwiZmxhZ3MiLCJzZW5kVW5hcnlNZXNzYWdlIiwiU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsIiwiU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsIiwiU2VydmVyRHVwbGV4U3RyZWFtSW1wbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/service-config.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.extractAndSelectServiceConfig = exports.validateServiceConfig = exports.validateRetryThrottling = void 0;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */ /* The any type is purposely used here. All functions validate their input at\n * runtime */ /* eslint-disable @typescript-eslint/no-explicit-any */ const os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */ const DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */ const CLIENT_LANGUAGE_STRING = \"node\";\nfunction validateName(obj) {\n    // In this context, and unset field and '' are considered the same\n    if (\"service\" in obj && obj.service !== \"\") {\n        if (typeof obj.service !== \"string\") {\n            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);\n        }\n        if (\"method\" in obj && obj.method !== \"\") {\n            if (typeof obj.method !== \"string\") {\n                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);\n            }\n            return {\n                service: obj.service,\n                method: obj.method\n            };\n        } else {\n            return {\n                service: obj.service\n            };\n        }\n    } else {\n        if (\"method\" in obj && obj.method !== undefined) {\n            throw new Error(`Invalid method config name: method set with empty or unset service`);\n        }\n        return {};\n    }\n}\nfunction validateRetryPolicy(obj) {\n    if (!(\"maxAttempts\" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n        throw new Error(\"Invalid method config retry policy: maxAttempts must be an integer at least 2\");\n    }\n    if (!(\"initialBackoff\" in obj) || typeof obj.initialBackoff !== \"string\" || !DURATION_REGEX.test(obj.initialBackoff)) {\n        throw new Error(\"Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer followed by s\");\n    }\n    if (!(\"maxBackoff\" in obj) || typeof obj.maxBackoff !== \"string\" || !DURATION_REGEX.test(obj.maxBackoff)) {\n        throw new Error(\"Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer followed by s\");\n    }\n    if (!(\"backoffMultiplier\" in obj) || typeof obj.backoffMultiplier !== \"number\" || obj.backoffMultiplier <= 0) {\n        throw new Error(\"Invalid method config retry policy: backoffMultiplier must be a number greater than 0\");\n    }\n    if (!(\"retryableStatusCodes\" in obj && Array.isArray(obj.retryableStatusCodes))) {\n        throw new Error(\"Invalid method config retry policy: retryableStatusCodes is required\");\n    }\n    if (obj.retryableStatusCodes.length === 0) {\n        throw new Error(\"Invalid method config retry policy: retryableStatusCodes must be non-empty\");\n    }\n    for (const value of obj.retryableStatusCodes){\n        if (typeof value === \"number\") {\n            if (!Object.values(constants_1.Status).includes(value)) {\n                throw new Error(\"Invalid method config retry policy: retryableStatusCodes value not in status code range\");\n            }\n        } else if (typeof value === \"string\") {\n            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                throw new Error(\"Invalid method config retry policy: retryableStatusCodes value not a status code name\");\n            }\n        } else {\n            throw new Error(\"Invalid method config retry policy: retryableStatusCodes value must be a string or number\");\n        }\n    }\n    return {\n        maxAttempts: obj.maxAttempts,\n        initialBackoff: obj.initialBackoff,\n        maxBackoff: obj.maxBackoff,\n        backoffMultiplier: obj.backoffMultiplier,\n        retryableStatusCodes: obj.retryableStatusCodes\n    };\n}\nfunction validateHedgingPolicy(obj) {\n    if (!(\"maxAttempts\" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n        throw new Error(\"Invalid method config hedging policy: maxAttempts must be an integer at least 2\");\n    }\n    if (\"hedgingDelay\" in obj && (typeof obj.hedgingDelay !== \"string\" || !DURATION_REGEX.test(obj.hedgingDelay))) {\n        throw new Error(\"Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s\");\n    }\n    if (\"nonFatalStatusCodes\" in obj && Array.isArray(obj.nonFatalStatusCodes)) {\n        for (const value of obj.nonFatalStatusCodes){\n            if (typeof value === \"number\") {\n                if (!Object.values(constants_1.Status).includes(value)) {\n                    throw new Error(\"Invlid method config hedging policy: nonFatalStatusCodes value not in status code range\");\n                }\n            } else if (typeof value === \"string\") {\n                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                    throw new Error(\"Invlid method config hedging policy: nonFatalStatusCodes value not a status code name\");\n                }\n            } else {\n                throw new Error(\"Invlid method config hedging policy: nonFatalStatusCodes value must be a string or number\");\n            }\n        }\n    }\n    const result = {\n        maxAttempts: obj.maxAttempts\n    };\n    if (obj.hedgingDelay) {\n        result.hedgingDelay = obj.hedgingDelay;\n    }\n    if (obj.nonFatalStatusCodes) {\n        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\n    }\n    return result;\n}\nfunction validateMethodConfig(obj) {\n    var _a;\n    const result = {\n        name: []\n    };\n    if (!(\"name\" in obj) || !Array.isArray(obj.name)) {\n        throw new Error(\"Invalid method config: invalid name array\");\n    }\n    for (const name of obj.name){\n        result.name.push(validateName(name));\n    }\n    if (\"waitForReady\" in obj) {\n        if (typeof obj.waitForReady !== \"boolean\") {\n            throw new Error(\"Invalid method config: invalid waitForReady\");\n        }\n        result.waitForReady = obj.waitForReady;\n    }\n    if (\"timeout\" in obj) {\n        if (typeof obj.timeout === \"object\") {\n            if (!(\"seconds\" in obj.timeout) || !(typeof obj.timeout.seconds === \"number\")) {\n                throw new Error(\"Invalid method config: invalid timeout.seconds\");\n            }\n            if (!(\"nanos\" in obj.timeout) || !(typeof obj.timeout.nanos === \"number\")) {\n                throw new Error(\"Invalid method config: invalid timeout.nanos\");\n            }\n            result.timeout = obj.timeout;\n        } else if (typeof obj.timeout === \"string\" && DURATION_REGEX.test(obj.timeout)) {\n            const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split(\".\");\n            result.timeout = {\n                seconds: timeoutParts[0] | 0,\n                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0\n            };\n        } else {\n            throw new Error(\"Invalid method config: invalid timeout\");\n        }\n    }\n    if (\"maxRequestBytes\" in obj) {\n        if (typeof obj.maxRequestBytes !== \"number\") {\n            throw new Error(\"Invalid method config: invalid maxRequestBytes\");\n        }\n        result.maxRequestBytes = obj.maxRequestBytes;\n    }\n    if (\"maxResponseBytes\" in obj) {\n        if (typeof obj.maxResponseBytes !== \"number\") {\n            throw new Error(\"Invalid method config: invalid maxRequestBytes\");\n        }\n        result.maxResponseBytes = obj.maxResponseBytes;\n    }\n    if (\"retryPolicy\" in obj) {\n        if (\"hedgingPolicy\" in obj) {\n            throw new Error(\"Invalid method config: retryPolicy and hedgingPolicy cannot both be specified\");\n        } else {\n            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\n        }\n    } else if (\"hedgingPolicy\" in obj) {\n        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\n    }\n    return result;\n}\nfunction validateRetryThrottling(obj) {\n    if (!(\"maxTokens\" in obj) || typeof obj.maxTokens !== \"number\" || obj.maxTokens <= 0 || obj.maxTokens > 1000) {\n        throw new Error(\"Invalid retryThrottling: maxTokens must be a number in (0, 1000]\");\n    }\n    if (!(\"tokenRatio\" in obj) || typeof obj.tokenRatio !== \"number\" || obj.tokenRatio <= 0) {\n        throw new Error(\"Invalid retryThrottling: tokenRatio must be a number greater than 0\");\n    }\n    return {\n        maxTokens: +obj.maxTokens.toFixed(3),\n        tokenRatio: +obj.tokenRatio.toFixed(3)\n    };\n}\nexports.validateRetryThrottling = validateRetryThrottling;\nfunction validateServiceConfig(obj) {\n    const result = {\n        loadBalancingConfig: [],\n        methodConfig: []\n    };\n    if (\"loadBalancingPolicy\" in obj) {\n        if (typeof obj.loadBalancingPolicy === \"string\") {\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\n        } else {\n            throw new Error(\"Invalid service config: invalid loadBalancingPolicy\");\n        }\n    }\n    if (\"loadBalancingConfig\" in obj) {\n        if (Array.isArray(obj.loadBalancingConfig)) {\n            for (const config of obj.loadBalancingConfig){\n                result.loadBalancingConfig.push((0, load_balancer_1.validateLoadBalancingConfig)(config));\n            }\n        } else {\n            throw new Error(\"Invalid service config: invalid loadBalancingConfig\");\n        }\n    }\n    if (\"methodConfig\" in obj) {\n        if (Array.isArray(obj.methodConfig)) {\n            for (const methodConfig of obj.methodConfig){\n                result.methodConfig.push(validateMethodConfig(methodConfig));\n            }\n        }\n    }\n    if (\"retryThrottling\" in obj) {\n        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\n    }\n    // Validate method name uniqueness\n    const seenMethodNames = [];\n    for (const methodConfig of result.methodConfig){\n        for (const name of methodConfig.name){\n            for (const seenName of seenMethodNames){\n                if (name.service === seenName.service && name.method === seenName.method) {\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n                }\n            }\n            seenMethodNames.push(name);\n        }\n    }\n    return result;\n}\nexports.validateServiceConfig = validateServiceConfig;\nfunction validateCanaryConfig(obj) {\n    if (!(\"serviceConfig\" in obj)) {\n        throw new Error(\"Invalid service config choice: missing service config\");\n    }\n    const result = {\n        serviceConfig: validateServiceConfig(obj.serviceConfig)\n    };\n    if (\"clientLanguage\" in obj) {\n        if (Array.isArray(obj.clientLanguage)) {\n            result.clientLanguage = [];\n            for (const lang of obj.clientLanguage){\n                if (typeof lang === \"string\") {\n                    result.clientLanguage.push(lang);\n                } else {\n                    throw new Error(\"Invalid service config choice: invalid clientLanguage\");\n                }\n            }\n        } else {\n            throw new Error(\"Invalid service config choice: invalid clientLanguage\");\n        }\n    }\n    if (\"clientHostname\" in obj) {\n        if (Array.isArray(obj.clientHostname)) {\n            result.clientHostname = [];\n            for (const lang of obj.clientHostname){\n                if (typeof lang === \"string\") {\n                    result.clientHostname.push(lang);\n                } else {\n                    throw new Error(\"Invalid service config choice: invalid clientHostname\");\n                }\n            }\n        } else {\n            throw new Error(\"Invalid service config choice: invalid clientHostname\");\n        }\n    }\n    if (\"percentage\" in obj) {\n        if (typeof obj.percentage === \"number\" && 0 <= obj.percentage && obj.percentage <= 100) {\n            result.percentage = obj.percentage;\n        } else {\n            throw new Error(\"Invalid service config choice: invalid percentage\");\n        }\n    }\n    // Validate that no unexpected fields are present\n    const allowedFields = [\n        \"clientLanguage\",\n        \"percentage\",\n        \"clientHostname\",\n        \"serviceConfig\"\n    ];\n    for(const field in obj){\n        if (!allowedFields.includes(field)) {\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\n        }\n    }\n    return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n    if (!Array.isArray(obj)) {\n        throw new Error(\"Invalid service config list\");\n    }\n    for (const config of obj){\n        const validatedConfig = validateCanaryConfig(config);\n        /* For each field, we check if it is present, then only discard the\n         * config if the field value does not match the current client */ if (typeof validatedConfig.percentage === \"number\" && percentage > validatedConfig.percentage) {\n            continue;\n        }\n        if (Array.isArray(validatedConfig.clientHostname)) {\n            let hostnameMatched = false;\n            for (const hostname of validatedConfig.clientHostname){\n                if (hostname === os.hostname()) {\n                    hostnameMatched = true;\n                }\n            }\n            if (!hostnameMatched) {\n                continue;\n            }\n        }\n        if (Array.isArray(validatedConfig.clientLanguage)) {\n            let languageMatched = false;\n            for (const language of validatedConfig.clientLanguage){\n                if (language === CLIENT_LANGUAGE_STRING) {\n                    languageMatched = true;\n                }\n            }\n            if (!languageMatched) {\n                continue;\n            }\n        }\n        return validatedConfig.serviceConfig;\n    }\n    throw new Error(\"No matching service config found\");\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */ function extractAndSelectServiceConfig(txtRecord, percentage) {\n    for (const record of txtRecord){\n        if (record.length > 0 && record[0].startsWith(\"grpc_config=\")) {\n            /* Treat the list of strings in this record as a single string and remove\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */ const recordString = record.join(\"\").substring(\"grpc_config=\".length);\n            const recordJson = JSON.parse(recordString);\n            return validateAndSelectCanaryConfig(recordJson, percentage);\n        }\n    }\n    return null;\n}\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig; //# sourceMappingURL=service-config.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFDQUFxQyxHQUFHQSw2QkFBNkIsR0FBR0EsK0JBQStCLEdBQUcsS0FBSztBQUMvRzs7Ozs7b0JBS29CLEdBQ3BCO1dBQ1csR0FDWCxxREFBcUQsR0FDckQsTUFBTUssS0FBS0MsbUJBQU9BLENBQUMsY0FBSTtBQUN2QixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxrQkFBa0JGLG1CQUFPQSxDQUFDLHNGQUFpQjtBQUNqRDs7O0NBR0MsR0FDRCxNQUFNRyxpQkFBaUI7QUFDdkI7OztDQUdDLEdBQ0QsTUFBTUMseUJBQXlCO0FBQy9CLFNBQVNDLGFBQWFDLEdBQUc7SUFDckIsa0VBQWtFO0lBQ2xFLElBQUksYUFBYUEsT0FBT0EsSUFBSUMsT0FBTyxLQUFLLElBQUk7UUFDeEMsSUFBSSxPQUFPRCxJQUFJQyxPQUFPLEtBQUssVUFBVTtZQUNqQyxNQUFNLElBQUlDLE1BQU0sQ0FBQyx1RUFBdUUsRUFBRSxPQUFPRixJQUFJQyxPQUFPLENBQUMsQ0FBQztRQUNsSDtRQUNBLElBQUksWUFBWUQsT0FBT0EsSUFBSUcsTUFBTSxLQUFLLElBQUk7WUFDdEMsSUFBSSxPQUFPSCxJQUFJRyxNQUFNLEtBQUssVUFBVTtnQkFDaEMsTUFBTSxJQUFJRCxNQUFNLENBQUMsc0VBQXNFLEVBQUUsT0FBT0YsSUFBSUMsT0FBTyxDQUFDLENBQUM7WUFDakg7WUFDQSxPQUFPO2dCQUNIQSxTQUFTRCxJQUFJQyxPQUFPO2dCQUNwQkUsUUFBUUgsSUFBSUcsTUFBTTtZQUN0QjtRQUNKLE9BQ0s7WUFDRCxPQUFPO2dCQUNIRixTQUFTRCxJQUFJQyxPQUFPO1lBQ3hCO1FBQ0o7SUFDSixPQUNL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Q0o7UUFDSjtRQUNBLE9BQU9ILGdCQUFnQlIsYUFBYTtJQUN4QztJQUNBLE1BQU0sSUFBSWxELE1BQU07QUFDcEI7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNaLDhCQUE4QjJFLFNBQVMsRUFBRVQsVUFBVTtJQUN4RCxLQUFLLE1BQU1VLFVBQVVELFVBQVc7UUFDNUIsSUFBSUMsT0FBT2xELE1BQU0sR0FBRyxLQUFLa0QsTUFBTSxDQUFDLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDLGlCQUFpQjtZQUMzRDttRkFDdUUsR0FDdkUsTUFBTUMsZUFBZUYsT0FBT0csSUFBSSxDQUFDLElBQUluQyxTQUFTLENBQUMsZUFBZWxCLE1BQU07WUFDcEUsTUFBTXNELGFBQWFDLEtBQUtDLEtBQUssQ0FBQ0o7WUFDOUIsT0FBT1QsOEJBQThCVyxZQUFZZDtRQUNyRDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0FwRSxxQ0FBcUMsR0FBR0UsK0JBQ3hDLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZpY2UtY29uZmlnLmpzPzZjNDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcgPSBleHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IGV4cG9ydHMudmFsaWRhdGVSZXRyeVRocm90dGxpbmcgPSB2b2lkIDA7XG4vKiBUaGlzIGZpbGUgaW1wbGVtZW50cyBnUkZDIEEyIGFuZCB0aGUgc2VydmljZSBjb25maWcgc3BlYzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0EyLXNlcnZpY2UtY29uZmlncy1pbi1kbnMubWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9tYXN0ZXIvZG9jL3NlcnZpY2VfY29uZmlnLm1kLiBFYWNoXG4gKiBmdW5jdGlvbiBoZXJlIHRha2VzIGFuIG9iamVjdCB3aXRoIHVua25vd24gc3RydWN0dXJlIGFuZCByZXR1cm5zIGl0c1xuICogc3BlY2lmaWMgb2JqZWN0IHR5cGUgaWYgdGhlIGlucHV0IGhhcyB0aGUgcmlnaHQgc3RydWN0dXJlLCBhbmQgdGhyb3dzIGFuXG4gKiBlcnJvciBvdGhlcndpc2UuICovXG4vKiBUaGUgYW55IHR5cGUgaXMgcHVycG9zZWx5IHVzZWQgaGVyZS4gQWxsIGZ1bmN0aW9ucyB2YWxpZGF0ZSB0aGVpciBpbnB1dCBhdFxuICogcnVudGltZSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG4vKipcbiAqIFJlY29nbml6ZXMgYSBudW1iZXIgd2l0aCB1cCB0byA5IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgZm9sbG93ZWQgYnlcbiAqIGFuIFwic1wiLCByZXByZXNlbnRpbmcgYSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAqL1xuY29uc3QgRFVSQVRJT05fUkVHRVggPSAvXlxcZCsoXFwuXFxkezEsOX0pP3MkLztcbi8qKlxuICogQ2xpZW50IGxhbmd1YWdlIG5hbWUgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGlzIGNsaWVudCBtYXRjaGVzIGFcbiAqIGBTZXJ2aWNlQ29uZmlnQ2FuYXJ5Q29uZmlnYCdzIGBjbGllbnRMYW5ndWFnZWAgbGlzdC5cbiAqL1xuY29uc3QgQ0xJRU5UX0xBTkdVQUdFX1NUUklORyA9ICdub2RlJztcbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZShvYmopIHtcbiAgICAvLyBJbiB0aGlzIGNvbnRleHQsIGFuZCB1bnNldCBmaWVsZCBhbmQgJycgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAgICBpZiAoJ3NlcnZpY2UnIGluIG9iaiAmJiBvYmouc2VydmljZSAhPT0gJycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmouc2VydmljZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IGludmFsaWQgc2VydmljZTogZXhwZWN0ZWQgdHlwZSBzdHJpbmcsIGdvdCAke3R5cGVvZiBvYmouc2VydmljZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ21ldGhvZCcgaW4gb2JqICYmIG9iai5tZXRob2QgIT09ICcnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iai5tZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1ldGhvZCBjb25maWcgbmFtZTogaW52YWxpZCBtZXRob2Q6IGV4cGVjdGVkIHR5cGUgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygb2JqLnNlcnZpY2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IG9iai5zZXJ2aWNlLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogb2JqLm1ldGhvZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IG9iai5zZXJ2aWNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCdtZXRob2QnIGluIG9iaiAmJiBvYmoubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IG1ldGhvZCBzZXQgd2l0aCBlbXB0eSBvciB1bnNldCBzZXJ2aWNlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmV0cnlQb2xpY3kob2JqKSB7XG4gICAgaWYgKCEoJ21heEF0dGVtcHRzJyBpbiBvYmopIHx8XG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9iai5tYXhBdHRlbXB0cykgfHxcbiAgICAgICAgb2JqLm1heEF0dGVtcHRzIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IG1heEF0dGVtcHRzIG11c3QgYmUgYW4gaW50ZWdlciBhdCBsZWFzdCAyJyk7XG4gICAgfVxuICAgIGlmICghKCdpbml0aWFsQmFja29mZicgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLmluaXRpYWxCYWNrb2ZmICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhRFVSQVRJT05fUkVHRVgudGVzdChvYmouaW5pdGlhbEJhY2tvZmYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogaW5pdGlhbEJhY2tvZmYgbXVzdCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIG9mIGEgcG9zaXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieSBzJyk7XG4gICAgfVxuICAgIGlmICghKCdtYXhCYWNrb2ZmJyBpbiBvYmopIHx8XG4gICAgICAgIHR5cGVvZiBvYmoubWF4QmFja29mZiAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIURVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLm1heEJhY2tvZmYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogbWF4QmFja29mZiBtdXN0IGJlIGEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5IHMnKTtcbiAgICB9XG4gICAgaWYgKCEoJ2JhY2tvZmZNdWx0aXBsaWVyJyBpbiBvYmopIHx8XG4gICAgICAgIHR5cGVvZiBvYmouYmFja29mZk11bHRpcGxpZXIgIT09ICdudW1iZXInIHx8XG4gICAgICAgIG9iai5iYWNrb2ZmTXVsdGlwbGllciA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogYmFja29mZk11bHRpcGxpZXIgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cbiAgICBpZiAoISgncmV0cnlhYmxlU3RhdHVzQ29kZXMnIGluIG9iaiAmJiBBcnJheS5pc0FycmF5KG9iai5yZXRyeWFibGVTdGF0dXNDb2RlcykpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKG9iai5yZXRyeWFibGVTdGF0dXNDb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyBtdXN0IGJlIG5vbi1lbXB0eScpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iai5yZXRyeWFibGVTdGF0dXNDb2Rlcykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyB2YWx1ZSBub3QgaW4gc3RhdHVzIGNvZGUgcmFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC52YWx1ZXMoY29uc3RhbnRzXzEuU3RhdHVzKS5pbmNsdWRlcyh2YWx1ZS50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgdmFsdWUgbm90IGEgc3RhdHVzIGNvZGUgbmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1heEF0dGVtcHRzOiBvYmoubWF4QXR0ZW1wdHMsXG4gICAgICAgIGluaXRpYWxCYWNrb2ZmOiBvYmouaW5pdGlhbEJhY2tvZmYsXG4gICAgICAgIG1heEJhY2tvZmY6IG9iai5tYXhCYWNrb2ZmLFxuICAgICAgICBiYWNrb2ZmTXVsdGlwbGllcjogb2JqLmJhY2tvZmZNdWx0aXBsaWVyLFxuICAgICAgICByZXRyeWFibGVTdGF0dXNDb2Rlczogb2JqLnJldHJ5YWJsZVN0YXR1c0NvZGVzLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUhlZGdpbmdQb2xpY3kob2JqKSB7XG4gICAgaWYgKCEoJ21heEF0dGVtcHRzJyBpbiBvYmopIHx8XG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9iai5tYXhBdHRlbXB0cykgfHxcbiAgICAgICAgb2JqLm1heEF0dGVtcHRzIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbWF4QXR0ZW1wdHMgbXVzdCBiZSBhbiBpbnRlZ2VyIGF0IGxlYXN0IDInKTtcbiAgICB9XG4gICAgaWYgKCdoZWRnaW5nRGVsYXknIGluIG9iaiAmJlxuICAgICAgICAodHlwZW9mIG9iai5oZWRnaW5nRGVsYXkgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAhRFVSQVRJT05fUkVHRVgudGVzdChvYmouaGVkZ2luZ0RlbGF5KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IGhlZGdpbmdEZWxheSBtdXN0IGJlIGEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5IHMnKTtcbiAgICB9XG4gICAgaWYgKCdub25GYXRhbFN0YXR1c0NvZGVzJyBpbiBvYmogJiYgQXJyYXkuaXNBcnJheShvYmoubm9uRmF0YWxTdGF0dXNDb2RlcykpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBvYmoubm9uRmF0YWxTdGF0dXNDb2Rlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC52YWx1ZXMoY29uc3RhbnRzXzEuU3RhdHVzKS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBub3QgaW4gc3RhdHVzIGNvZGUgcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBub3QgYSBzdGF0dXMgY29kZSBuYW1lJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbWF4QXR0ZW1wdHM6IG9iai5tYXhBdHRlbXB0cyxcbiAgICB9O1xuICAgIGlmIChvYmouaGVkZ2luZ0RlbGF5KSB7XG4gICAgICAgIHJlc3VsdC5oZWRnaW5nRGVsYXkgPSBvYmouaGVkZ2luZ0RlbGF5O1xuICAgIH1cbiAgICBpZiAob2JqLm5vbkZhdGFsU3RhdHVzQ29kZXMpIHtcbiAgICAgICAgcmVzdWx0Lm5vbkZhdGFsU3RhdHVzQ29kZXMgPSBvYmoubm9uRmF0YWxTdGF0dXNDb2RlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kQ29uZmlnKG9iaikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6IFtdLFxuICAgIH07XG4gICAgaWYgKCEoJ25hbWUnIGluIG9iaikgfHwgIUFycmF5LmlzQXJyYXkob2JqLm5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG5hbWUgYXJyYXknKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG9iai5uYW1lKSB7XG4gICAgICAgIHJlc3VsdC5uYW1lLnB1c2godmFsaWRhdGVOYW1lKG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKCd3YWl0Rm9yUmVhZHknIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai53YWl0Rm9yUmVhZHkgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgd2FpdEZvclJlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LndhaXRGb3JSZWFkeSA9IG9iai53YWl0Rm9yUmVhZHk7XG4gICAgfVxuICAgIGlmICgndGltZW91dCcgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnRpbWVvdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoISgnc2Vjb25kcycgaW4gb2JqLnRpbWVvdXQpIHx8XG4gICAgICAgICAgICAgICAgISh0eXBlb2Ygb2JqLnRpbWVvdXQuc2Vjb25kcyA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgdGltZW91dC5zZWNvbmRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISgnbmFub3MnIGluIG9iai50aW1lb3V0KSB8fFxuICAgICAgICAgICAgICAgICEodHlwZW9mIG9iai50aW1lb3V0Lm5hbm9zID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0Lm5hbm9zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQudGltZW91dCA9IG9iai50aW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmoudGltZW91dCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIERVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLnRpbWVvdXQpKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0UGFydHMgPSBvYmoudGltZW91dFxuICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMCwgb2JqLnRpbWVvdXQubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHJlc3VsdC50aW1lb3V0ID0ge1xuICAgICAgICAgICAgICAgIHNlY29uZHM6IHRpbWVvdXRQYXJ0c1swXSB8IDAsXG4gICAgICAgICAgICAgICAgbmFub3M6ICgoX2EgPSB0aW1lb3V0UGFydHNbMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIHwgMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdtYXhSZXF1ZXN0Qnl0ZXMnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5tYXhSZXF1ZXN0Qnl0ZXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCBtYXhSZXF1ZXN0Qnl0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQubWF4UmVxdWVzdEJ5dGVzID0gb2JqLm1heFJlcXVlc3RCeXRlcztcbiAgICB9XG4gICAgaWYgKCdtYXhSZXNwb25zZUJ5dGVzJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubWF4UmVzcG9uc2VCeXRlcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG1heFJlcXVlc3RCeXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5tYXhSZXNwb25zZUJ5dGVzID0gb2JqLm1heFJlc3BvbnNlQnl0ZXM7XG4gICAgfVxuICAgIGlmICgncmV0cnlQb2xpY3knIGluIG9iaikge1xuICAgICAgICBpZiAoJ2hlZGdpbmdQb2xpY3knIGluIG9iaikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IHJldHJ5UG9saWN5IGFuZCBoZWRnaW5nUG9saWN5IGNhbm5vdCBib3RoIGJlIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnJldHJ5UG9saWN5ID0gdmFsaWRhdGVSZXRyeVBvbGljeShvYmoucmV0cnlQb2xpY3kpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCdoZWRnaW5nUG9saWN5JyBpbiBvYmopIHtcbiAgICAgICAgcmVzdWx0LmhlZGdpbmdQb2xpY3kgPSB2YWxpZGF0ZUhlZGdpbmdQb2xpY3kob2JqLmhlZGdpbmdQb2xpY3kpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZXRyeVRocm90dGxpbmcob2JqKSB7XG4gICAgaWYgKCEoJ21heFRva2VucycgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLm1heFRva2VucyAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgb2JqLm1heFRva2VucyA8PSAwIHx8XG4gICAgICAgIG9iai5tYXhUb2tlbnMgPiAxMDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXRyeVRocm90dGxpbmc6IG1heFRva2VucyBtdXN0IGJlIGEgbnVtYmVyIGluICgwLCAxMDAwXScpO1xuICAgIH1cbiAgICBpZiAoISgndG9rZW5SYXRpbycgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLnRva2VuUmF0aW8gIT09ICdudW1iZXInIHx8XG4gICAgICAgIG9iai50b2tlblJhdGlvIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJldHJ5VGhyb3R0bGluZzogdG9rZW5SYXRpbyBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1heFRva2VuczogK29iai5tYXhUb2tlbnMudG9GaXhlZCgzKSxcbiAgICAgICAgdG9rZW5SYXRpbzogK29iai50b2tlblJhdGlvLnRvRml4ZWQoMyksXG4gICAgfTtcbn1cbmV4cG9ydHMudmFsaWRhdGVSZXRyeVRocm90dGxpbmcgPSB2YWxpZGF0ZVJldHJ5VGhyb3R0bGluZztcbmZ1bmN0aW9uIHZhbGlkYXRlU2VydmljZUNvbmZpZyhvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGxvYWRCYWxhbmNpbmdDb25maWc6IFtdLFxuICAgICAgICBtZXRob2RDb25maWc6IFtdLFxuICAgIH07XG4gICAgaWYgKCdsb2FkQmFsYW5jaW5nUG9saWN5JyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubG9hZEJhbGFuY2luZ1BvbGljeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5sb2FkQmFsYW5jaW5nUG9saWN5ID0gb2JqLmxvYWRCYWxhbmNpbmdQb2xpY3k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWc6IGludmFsaWQgbG9hZEJhbGFuY2luZ1BvbGljeScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbG9hZEJhbGFuY2luZ0NvbmZpZycgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5sb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2Ygb2JqLmxvYWRCYWxhbmNpbmdDb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubG9hZEJhbGFuY2luZ0NvbmZpZy5wdXNoKCgwLCBsb2FkX2JhbGFuY2VyXzEudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKShjb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogaW52YWxpZCBsb2FkQmFsYW5jaW5nQ29uZmlnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdtZXRob2RDb25maWcnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoubWV0aG9kQ29uZmlnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXRob2RDb25maWcgb2Ygb2JqLm1ldGhvZENvbmZpZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tZXRob2RDb25maWcucHVzaCh2YWxpZGF0ZU1ldGhvZENvbmZpZyhtZXRob2RDb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3JldHJ5VGhyb3R0bGluZycgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdC5yZXRyeVRocm90dGxpbmcgPSB2YWxpZGF0ZVJldHJ5VGhyb3R0bGluZyhvYmoucmV0cnlUaHJvdHRsaW5nKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgbWV0aG9kIG5hbWUgdW5pcXVlbmVzc1xuICAgIGNvbnN0IHNlZW5NZXRob2ROYW1lcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbWV0aG9kQ29uZmlnIG9mIHJlc3VsdC5tZXRob2RDb25maWcpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1ldGhvZENvbmZpZy5uYW1lKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZW5OYW1lIG9mIHNlZW5NZXRob2ROYW1lcykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlZW5OYW1lLnNlcnZpY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgbmFtZS5tZXRob2QgPT09IHNlZW5OYW1lLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VydmljZSBjb25maWc6IGR1cGxpY2F0ZSBuYW1lICR7bmFtZS5zZXJ2aWNlfS8ke25hbWUubWV0aG9kfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5NZXRob2ROYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IHZhbGlkYXRlU2VydmljZUNvbmZpZztcbmZ1bmN0aW9uIHZhbGlkYXRlQ2FuYXJ5Q29uZmlnKG9iaikge1xuICAgIGlmICghKCdzZXJ2aWNlQ29uZmlnJyBpbiBvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IG1pc3Npbmcgc2VydmljZSBjb25maWcnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzZXJ2aWNlQ29uZmlnOiB2YWxpZGF0ZVNlcnZpY2VDb25maWcob2JqLnNlcnZpY2VDb25maWcpLFxuICAgIH07XG4gICAgaWYgKCdjbGllbnRMYW5ndWFnZScgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5jbGllbnRMYW5ndWFnZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jbGllbnRMYW5ndWFnZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5nIG9mIG9iai5jbGllbnRMYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFuZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNsaWVudExhbmd1YWdlLnB1c2gobGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudExhbmd1YWdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRMYW5ndWFnZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnY2xpZW50SG9zdG5hbWUnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmouY2xpZW50SG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY2xpZW50SG9zdG5hbWUgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFuZyBvZiBvYmouY2xpZW50SG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jbGllbnRIb3N0bmFtZS5wdXNoKGxhbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRIb3N0bmFtZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgY2xpZW50SG9zdG5hbWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3BlcmNlbnRhZ2UnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5wZXJjZW50YWdlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgMCA8PSBvYmoucGVyY2VudGFnZSAmJlxuICAgICAgICAgICAgb2JqLnBlcmNlbnRhZ2UgPD0gMTAwKSB7XG4gICAgICAgICAgICByZXN1bHQucGVyY2VudGFnZSA9IG9iai5wZXJjZW50YWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBwZXJjZW50YWdlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgdGhhdCBubyB1bmV4cGVjdGVkIGZpZWxkcyBhcmUgcHJlc2VudFxuICAgIGNvbnN0IGFsbG93ZWRGaWVsZHMgPSBbXG4gICAgICAgICdjbGllbnRMYW5ndWFnZScsXG4gICAgICAgICdwZXJjZW50YWdlJyxcbiAgICAgICAgJ2NsaWVudEhvc3RuYW1lJyxcbiAgICAgICAgJ3NlcnZpY2VDb25maWcnLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBmaWVsZCBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFhbGxvd2VkRmllbGRzLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogdW5leHBlY3RlZCBmaWVsZCAke2ZpZWxkfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFNlbGVjdENhbmFyeUNvbmZpZyhvYmosIHBlcmNlbnRhZ2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgbGlzdCcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBvYmopIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkQ29uZmlnID0gdmFsaWRhdGVDYW5hcnlDb25maWcoY29uZmlnKTtcbiAgICAgICAgLyogRm9yIGVhY2ggZmllbGQsIHdlIGNoZWNrIGlmIGl0IGlzIHByZXNlbnQsIHRoZW4gb25seSBkaXNjYXJkIHRoZVxuICAgICAgICAgKiBjb25maWcgaWYgdGhlIGZpZWxkIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IGNsaWVudCAqL1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlZENvbmZpZy5wZXJjZW50YWdlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgcGVyY2VudGFnZSA+IHZhbGlkYXRlZENvbmZpZy5wZXJjZW50YWdlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0ZWRDb25maWcuY2xpZW50SG9zdG5hbWUpKSB7XG4gICAgICAgICAgICBsZXQgaG9zdG5hbWVNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhvc3RuYW1lIG9mIHZhbGlkYXRlZENvbmZpZy5jbGllbnRIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChob3N0bmFtZSA9PT0gb3MuaG9zdG5hbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaG9zdG5hbWVNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdGVkQ29uZmlnLmNsaWVudExhbmd1YWdlKSkge1xuICAgICAgICAgICAgbGV0IGxhbmd1YWdlTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5ndWFnZSBvZiB2YWxpZGF0ZWRDb25maWcuY2xpZW50TGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2UgPT09IENMSUVOVF9MQU5HVUFHRV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxhbmd1YWdlTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRDb25maWcuc2VydmljZUNvbmZpZztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBtYXRjaGluZyBzZXJ2aWNlIGNvbmZpZyBmb3VuZCcpO1xufVxuLyoqXG4gKiBGaW5kIHRoZSBcImdycGNfY29uZmlnXCIgcmVjb3JkIGFtb25nIHRoZSBUWFQgcmVjb3JkcywgcGFyc2UgaXRzIHZhbHVlIGFzIEpTT04sIHZhbGlkYXRlIGl0cyBjb250ZW50cyxcbiAqIGFuZCBzZWxlY3QgYSBzZXJ2aWNlIGNvbmZpZyB3aXRoIHNlbGVjdGlvbiBmaWVsZHMgdGhhdCBhbGwgbWF0Y2ggdGhpcyBjbGllbnQuIE1vc3Qgb2YgdGhlc2Ugc3RlcHNcbiAqIGNhbiBmYWlsIHdpdGggYW4gZXJyb3I7IHRoZSBjYWxsZXIgbXVzdCBoYW5kbGUgYW55IGVycm9ycyB0aHJvd24gdGhpcyB3YXkuXG4gKiBAcGFyYW0gdHh0UmVjb3JkIFRoZSBUWFQgcmVjb3JkIGFycmF5IHRoYXQgaXMgb3V0cHV0IGZyb20gYSBzdWNjZXNzZnVsIGNhbGwgdG8gZG5zLnJlc29sdmVUeHRcbiAqIEBwYXJhbSBwZXJjZW50YWdlIEEgbnVtYmVyIGNob3NlbiBmcm9tIHRoZSByYW5nZSBbMCwgMTAwKSB0aGF0IGlzIHVzZWQgdG8gc2VsZWN0IHdoaWNoIGNvbmZpZyB0byB1c2VcbiAqIEByZXR1cm4gVGhlIHNlcnZpY2UgY29uZmlndXJhdGlvbiB0byB1c2UsIGdpdmVuIHRoZSBwZXJjZW50YWdlIHZhbHVlLCBvciBudWxsIGlmIHRoZSBzZXJ2aWNlIGNvbmZpZ1xuICogICAgIGRhdGEgaGFzIGEgdmFsaWQgZm9ybWF0IGJ1dCBub25lIG9mIHRoZSBvcHRpb25zIG1hdGNoIHRoZSBjdXJyZW50IGNsaWVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcodHh0UmVjb3JkLCBwZXJjZW50YWdlKSB7XG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgdHh0UmVjb3JkKSB7XG4gICAgICAgIGlmIChyZWNvcmQubGVuZ3RoID4gMCAmJiByZWNvcmRbMF0uc3RhcnRzV2l0aCgnZ3JwY19jb25maWc9JykpIHtcbiAgICAgICAgICAgIC8qIFRyZWF0IHRoZSBsaXN0IG9mIHN0cmluZ3MgaW4gdGhpcyByZWNvcmQgYXMgYSBzaW5nbGUgc3RyaW5nIGFuZCByZW1vdmVcbiAgICAgICAgICAgICAqIFwiZ3JwY19jb25maWc9XCIgZnJvbSB0aGUgYmVnaW5uaW5nLiBUaGUgcmVzdCBzaG91bGQgYmUgYSBKU09OIHN0cmluZyAqL1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkU3RyaW5nID0gcmVjb3JkLmpvaW4oJycpLnN1YnN0cmluZygnZ3JwY19jb25maWc9Jy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkSnNvbiA9IEpTT04ucGFyc2UocmVjb3JkU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUFuZFNlbGVjdENhbmFyeUNvbmZpZyhyZWNvcmRKc29uLCBwZXJjZW50YWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcgPSBleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZpY2UtY29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnIiwidmFsaWRhdGVTZXJ2aWNlQ29uZmlnIiwidmFsaWRhdGVSZXRyeVRocm90dGxpbmciLCJvcyIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsImxvYWRfYmFsYW5jZXJfMSIsIkRVUkFUSU9OX1JFR0VYIiwiQ0xJRU5UX0xBTkdVQUdFX1NUUklORyIsInZhbGlkYXRlTmFtZSIsIm9iaiIsInNlcnZpY2UiLCJFcnJvciIsIm1ldGhvZCIsInVuZGVmaW5lZCIsInZhbGlkYXRlUmV0cnlQb2xpY3kiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJtYXhBdHRlbXB0cyIsImluaXRpYWxCYWNrb2ZmIiwidGVzdCIsIm1heEJhY2tvZmYiLCJiYWNrb2ZmTXVsdGlwbGllciIsIkFycmF5IiwiaXNBcnJheSIsInJldHJ5YWJsZVN0YXR1c0NvZGVzIiwibGVuZ3RoIiwidmFsdWVzIiwiU3RhdHVzIiwiaW5jbHVkZXMiLCJ0b1VwcGVyQ2FzZSIsInZhbGlkYXRlSGVkZ2luZ1BvbGljeSIsImhlZGdpbmdEZWxheSIsIm5vbkZhdGFsU3RhdHVzQ29kZXMiLCJyZXN1bHQiLCJ2YWxpZGF0ZU1ldGhvZENvbmZpZyIsIl9hIiwibmFtZSIsInB1c2giLCJ3YWl0Rm9yUmVhZHkiLCJ0aW1lb3V0Iiwic2Vjb25kcyIsIm5hbm9zIiwidGltZW91dFBhcnRzIiwic3Vic3RyaW5nIiwic3BsaXQiLCJtYXhSZXF1ZXN0Qnl0ZXMiLCJtYXhSZXNwb25zZUJ5dGVzIiwicmV0cnlQb2xpY3kiLCJoZWRnaW5nUG9saWN5IiwibWF4VG9rZW5zIiwidG9rZW5SYXRpbyIsInRvRml4ZWQiLCJsb2FkQmFsYW5jaW5nQ29uZmlnIiwibWV0aG9kQ29uZmlnIiwibG9hZEJhbGFuY2luZ1BvbGljeSIsImNvbmZpZyIsInZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyIsInJldHJ5VGhyb3R0bGluZyIsInNlZW5NZXRob2ROYW1lcyIsInNlZW5OYW1lIiwidmFsaWRhdGVDYW5hcnlDb25maWciLCJzZXJ2aWNlQ29uZmlnIiwiY2xpZW50TGFuZ3VhZ2UiLCJsYW5nIiwiY2xpZW50SG9zdG5hbWUiLCJwZXJjZW50YWdlIiwiYWxsb3dlZEZpZWxkcyIsImZpZWxkIiwidmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWciLCJ2YWxpZGF0ZWRDb25maWciLCJob3N0bmFtZU1hdGNoZWQiLCJob3N0bmFtZSIsImxhbmd1YWdlTWF0Y2hlZCIsImxhbmd1YWdlIiwidHh0UmVjb3JkIiwicmVjb3JkIiwic3RhcnRzV2l0aCIsInJlY29yZFN0cmluZyIsImpvaW4iLCJyZWNvcmRKc29uIiwiSlNPTiIsInBhcnNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/status-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StatusBuilder = void 0;\n/**\n * A builder for gRPC status objects.\n */ class StatusBuilder {\n    constructor(){\n        this.code = null;\n        this.details = null;\n        this.metadata = null;\n    }\n    /**\n     * Adds a status code to the builder.\n     */ withCode(code) {\n        this.code = code;\n        return this;\n    }\n    /**\n     * Adds details to the builder.\n     */ withDetails(details) {\n        this.details = details;\n        return this;\n    }\n    /**\n     * Adds metadata to the builder.\n     */ withMetadata(metadata) {\n        this.metadata = metadata;\n        return this;\n    }\n    /**\n     * Builds the status object.\n     */ build() {\n        const status = {};\n        if (this.code !== null) {\n            status.code = this.code;\n        }\n        if (this.details !== null) {\n            status.details = this.details;\n        }\n        if (this.metadata !== null) {\n            status.metadata = this.metadata;\n        }\n        return status;\n    }\n}\nexports.StatusBuilder = StatusBuilder; //# sourceMappingURL=status-builder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0I7O0NBRUMsR0FDRCxNQUFNRTtJQUNGQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ3BCO0lBQ0E7O0tBRUMsR0FDREMsU0FBU0gsSUFBSSxFQUFFO1FBQ1gsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNESSxZQUFZSCxPQUFPLEVBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNESSxhQUFhSCxRQUFRLEVBQUU7UUFDbkIsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO1FBQ2hCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7O0tBRUMsR0FDREksUUFBUTtRQUNKLE1BQU1DLFNBQVMsQ0FBQztRQUNoQixJQUFJLElBQUksQ0FBQ1AsSUFBSSxLQUFLLE1BQU07WUFDcEJPLE9BQU9QLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7UUFDM0I7UUFDQSxJQUFJLElBQUksQ0FBQ0MsT0FBTyxLQUFLLE1BQU07WUFDdkJNLE9BQU9OLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU87UUFDakM7UUFDQSxJQUFJLElBQUksQ0FBQ0MsUUFBUSxLQUFLLE1BQU07WUFDeEJLLE9BQU9MLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7UUFDbkM7UUFDQSxPQUFPSztJQUNYO0FBQ0o7QUFDQVgscUJBQXFCLEdBQUdFLGVBQ3hCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N0YXR1cy1idWlsZGVyLmpzP2QyOTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IHZvaWQgMDtcbi8qKlxuICogQSBidWlsZGVyIGZvciBnUlBDIHN0YXR1cyBvYmplY3RzLlxuICovXG5jbGFzcyBTdGF0dXNCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdGF0dXMgY29kZSB0byB0aGUgYnVpbGRlci5cbiAgICAgKi9cbiAgICB3aXRoQ29kZShjb2RlKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGRldGFpbHMgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgd2l0aERldGFpbHMoZGV0YWlscykge1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBtZXRhZGF0YSB0byB0aGUgYnVpbGRlci5cbiAgICAgKi9cbiAgICB3aXRoTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBzdGF0dXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGJ1aWxkKCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuY29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdHVzLmNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGV0YWlscyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgPSB0aGlzLmRldGFpbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXR1cy5tZXRhZGF0YSA9IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLlN0YXR1c0J1aWxkZXIgPSBTdGF0dXNCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdHVzLWJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3RhdHVzQnVpbGRlciIsImNvbnN0cnVjdG9yIiwiY29kZSIsImRldGFpbHMiLCJtZXRhZGF0YSIsIndpdGhDb2RlIiwid2l0aERldGFpbHMiLCJ3aXRoTWV0YWRhdGEiLCJidWlsZCIsInN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/stream-decoder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function(ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n    constructor(){\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n    }\n    write(data) {\n        let readHead = 0;\n        let toRead;\n        const result = [];\n        while(readHead < data.length){\n            switch(this.readState){\n                case ReadState.NO_DATA:\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\n                    readHead += 1;\n                    this.readState = ReadState.READING_SIZE;\n                    this.readPartialSize.fill(0);\n                    this.readSizeRemaining = 4;\n                    this.readMessageSize = 0;\n                    this.readMessageRemaining = 0;\n                    this.readPartialMessage = [];\n                    break;\n                case ReadState.READING_SIZE:\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                    this.readSizeRemaining -= toRead;\n                    readHead += toRead;\n                    // readSizeRemaining >=0 here\n                    if (this.readSizeRemaining === 0) {\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                        this.readMessageRemaining = this.readMessageSize;\n                        if (this.readMessageRemaining > 0) {\n                            this.readState = ReadState.READING_MESSAGE;\n                        } else {\n                            const message = Buffer.concat([\n                                this.readCompressFlag,\n                                this.readPartialSize\n                            ], 5);\n                            this.readState = ReadState.NO_DATA;\n                            result.push(message);\n                        }\n                    }\n                    break;\n                case ReadState.READING_MESSAGE:\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                    this.readMessageRemaining -= toRead;\n                    readHead += toRead;\n                    // readMessageRemaining >=0 here\n                    if (this.readMessageRemaining === 0) {\n                        // At this point, we have read a full message\n                        const framedMessageBuffers = [\n                            this.readCompressFlag,\n                            this.readPartialSize\n                        ].concat(this.readPartialMessage);\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                        this.readState = ReadState.NO_DATA;\n                        result.push(framedMessage);\n                    }\n                    break;\n                default:\n                    throw new Error(\"Unexpected read state\");\n            }\n        }\n        return result;\n    }\n}\nexports.StreamDecoder = StreamDecoder; //# sourceMappingURL=stream-decoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RyZWFtLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBRyxLQUFLO0FBQzdCLElBQUlHO0FBQ0gsVUFBVUEsU0FBUztJQUNoQkEsU0FBUyxDQUFDQSxTQUFTLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUN0Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUMzQ0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsa0JBQWtCLEdBQUcsRUFBRSxHQUFHO0FBQ2xELEdBQUdBLGFBQWNBLENBQUFBLFlBQVksQ0FBQztBQUM5QixNQUFNRDtJQUNGRSxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxTQUFTLEdBQUdGLFVBQVVHLE9BQU87UUFDbEMsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0MsTUFBTUEsQ0FBQ0MsS0FBSyxDQUFDO1FBQ3JDLElBQUksQ0FBQ0MsZUFBZSxHQUFHRixNQUFNQSxDQUFDQyxLQUFLLENBQUM7UUFDcEMsSUFBSSxDQUFDRSxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNDLGtCQUFrQixHQUFHLEVBQUU7UUFDNUIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztJQUNoQztJQUNBQyxNQUFNQyxJQUFJLEVBQUU7UUFDUixJQUFJQyxXQUFXO1FBQ2YsSUFBSUM7UUFDSixNQUFNQyxTQUFTLEVBQUU7UUFDakIsTUFBT0YsV0FBV0QsS0FBS0ksTUFBTSxDQUFFO1lBQzNCLE9BQVEsSUFBSSxDQUFDZixTQUFTO2dCQUNsQixLQUFLRixVQUFVRyxPQUFPO29CQUNsQixJQUFJLENBQUNDLGdCQUFnQixHQUFHUyxLQUFLSyxLQUFLLENBQUNKLFVBQVVBLFdBQVc7b0JBQ3hEQSxZQUFZO29CQUNaLElBQUksQ0FBQ1osU0FBUyxHQUFHRixVQUFVbUIsWUFBWTtvQkFDdkMsSUFBSSxDQUFDWixlQUFlLENBQUNhLElBQUksQ0FBQztvQkFDMUIsSUFBSSxDQUFDWixpQkFBaUIsR0FBRztvQkFDekIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7b0JBQ3ZCLElBQUksQ0FBQ0Usb0JBQW9CLEdBQUc7b0JBQzVCLElBQUksQ0FBQ0Qsa0JBQWtCLEdBQUcsRUFBRTtvQkFDNUI7Z0JBQ0osS0FBS1YsVUFBVW1CLFlBQVk7b0JBQ3ZCSixTQUFTTSxLQUFLQyxHQUFHLENBQUNULEtBQUtJLE1BQU0sR0FBR0gsVUFBVSxJQUFJLENBQUNOLGlCQUFpQjtvQkFDaEVLLEtBQUtVLElBQUksQ0FBQyxJQUFJLENBQUNoQixlQUFlLEVBQUUsSUFBSSxJQUFJLENBQUNDLGlCQUFpQixFQUFFTSxVQUFVQSxXQUFXQztvQkFDakYsSUFBSSxDQUFDUCxpQkFBaUIsSUFBSU87b0JBQzFCRCxZQUFZQztvQkFDWiw2QkFBNkI7b0JBQzdCLElBQUksSUFBSSxDQUFDUCxpQkFBaUIsS0FBSyxHQUFHO3dCQUM5QixJQUFJLENBQUNDLGVBQWUsR0FBRyxJQUFJLENBQUNGLGVBQWUsQ0FBQ2lCLFlBQVksQ0FBQzt3QkFDekQsSUFBSSxDQUFDYixvQkFBb0IsR0FBRyxJQUFJLENBQUNGLGVBQWU7d0JBQ2hELElBQUksSUFBSSxDQUFDRSxvQkFBb0IsR0FBRyxHQUFHOzRCQUMvQixJQUFJLENBQUNULFNBQVMsR0FBR0YsVUFBVXlCLGVBQWU7d0JBQzlDLE9BQ0s7NEJBQ0QsTUFBTUMsVUFBVXJCLE1BQU1BLENBQUNzQixNQUFNLENBQUM7Z0NBQUMsSUFBSSxDQUFDdkIsZ0JBQWdCO2dDQUFFLElBQUksQ0FBQ0csZUFBZTs2QkFBQyxFQUFFOzRCQUM3RSxJQUFJLENBQUNMLFNBQVMsR0FBR0YsVUFBVUcsT0FBTzs0QkFDbENhLE9BQU9ZLElBQUksQ0FBQ0Y7d0JBQ2hCO29CQUNKO29CQUNBO2dCQUNKLEtBQUsxQixVQUFVeUIsZUFBZTtvQkFDMUJWLFNBQVNNLEtBQUtDLEdBQUcsQ0FBQ1QsS0FBS0ksTUFBTSxHQUFHSCxVQUFVLElBQUksQ0FBQ0gsb0JBQW9CO29CQUNuRSxJQUFJLENBQUNELGtCQUFrQixDQUFDa0IsSUFBSSxDQUFDZixLQUFLSyxLQUFLLENBQUNKLFVBQVVBLFdBQVdDO29CQUM3RCxJQUFJLENBQUNKLG9CQUFvQixJQUFJSTtvQkFDN0JELFlBQVlDO29CQUNaLGdDQUFnQztvQkFDaEMsSUFBSSxJQUFJLENBQUNKLG9CQUFvQixLQUFLLEdBQUc7d0JBQ2pDLDZDQUE2Qzt3QkFDN0MsTUFBTWtCLHVCQUF1Qjs0QkFDekIsSUFBSSxDQUFDekIsZ0JBQWdCOzRCQUNyQixJQUFJLENBQUNHLGVBQWU7eUJBQ3ZCLENBQUNvQixNQUFNLENBQUMsSUFBSSxDQUFDakIsa0JBQWtCO3dCQUNoQyxNQUFNb0IsZ0JBQWdCekIsTUFBTUEsQ0FBQ3NCLE1BQU0sQ0FBQ0Usc0JBQXNCLElBQUksQ0FBQ3BCLGVBQWUsR0FBRzt3QkFDakYsSUFBSSxDQUFDUCxTQUFTLEdBQUdGLFVBQVVHLE9BQU87d0JBQ2xDYSxPQUFPWSxJQUFJLENBQUNFO29CQUNoQjtvQkFDQTtnQkFDSjtvQkFDSSxNQUFNLElBQUlDLE1BQU07WUFDeEI7UUFDSjtRQUNBLE9BQU9mO0lBQ1g7QUFDSjtBQUNBbkIscUJBQXFCLEdBQUdFLGVBQ3hCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N0cmVhbS1kZWNvZGVyLmpzPzZjYjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RyZWFtRGVjb2RlciA9IHZvaWQgMDtcbnZhciBSZWFkU3RhdGU7XG4oZnVuY3Rpb24gKFJlYWRTdGF0ZSkge1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJOT19EQVRBXCJdID0gMF0gPSBcIk5PX0RBVEFcIjtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiUkVBRElOR19TSVpFXCJdID0gMV0gPSBcIlJFQURJTkdfU0laRVwiO1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJSRUFESU5HX01FU1NBR0VcIl0gPSAyXSA9IFwiUkVBRElOR19NRVNTQUdFXCI7XG59KShSZWFkU3RhdGUgfHwgKFJlYWRTdGF0ZSA9IHt9KSk7XG5jbGFzcyBTdHJlYW1EZWNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZSA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyA9IDQ7XG4gICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gMDtcbiAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UgPSBbXTtcbiAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IDA7XG4gICAgfVxuICAgIHdyaXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlYWRIZWFkID0gMDtcbiAgICAgICAgbGV0IHRvUmVhZDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChyZWFkSGVhZCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucmVhZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuTk9fREFUQTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gZGF0YS5zbGljZShyZWFkSGVhZCwgcmVhZEhlYWQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEhlYWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuUkVBRElOR19TSVpFO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZS5maWxsKDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTaXplUmVtYWluaW5nID0gNDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuUkVBRElOR19TSVpFOlxuICAgICAgICAgICAgICAgICAgICB0b1JlYWQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIHJlYWRIZWFkLCB0aGlzLnJlYWRTaXplUmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jb3B5KHRoaXMucmVhZFBhcnRpYWxTaXplLCA0IC0gdGhpcy5yZWFkU2l6ZVJlbWFpbmluZywgcmVhZEhlYWQsIHJlYWRIZWFkICsgdG9SZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyAtPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZFNpemVSZW1haW5pbmcgPj0wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZFNpemVSZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gdGhpcy5yZWFkUGFydGlhbFNpemUucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IHRoaXMucmVhZE1lc3NhZ2VTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuUkVBRElOR19NRVNTQUdFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMucmVhZENvbXByZXNzRmxhZywgdGhpcy5yZWFkUGFydGlhbFNpemVdLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5OT19EQVRBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVhZFN0YXRlLlJFQURJTkdfTUVTU0FHRTpcbiAgICAgICAgICAgICAgICAgICAgdG9SZWFkID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSByZWFkSGVhZCwgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlLnB1c2goZGF0YS5zbGljZShyZWFkSGVhZCwgcmVhZEhlYWQgKyB0b1JlYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyAtPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZE1lc3NhZ2VSZW1haW5pbmcgPj0wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgcmVhZCBhIGZ1bGwgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJhbWVkTWVzc2FnZUJ1ZmZlcnMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQodGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJhbWVkTWVzc2FnZSA9IEJ1ZmZlci5jb25jYXQoZnJhbWVkTWVzc2FnZUJ1ZmZlcnMsIHRoaXMucmVhZE1lc3NhZ2VTaXplICsgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5OT19EQVRBO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHJlYWQgc3RhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyZWFtRGVjb2RlciA9IFN0cmVhbURlY29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJlYW0tZGVjb2Rlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdHJlYW1EZWNvZGVyIiwiUmVhZFN0YXRlIiwiY29uc3RydWN0b3IiLCJyZWFkU3RhdGUiLCJOT19EQVRBIiwicmVhZENvbXByZXNzRmxhZyIsIkJ1ZmZlciIsImFsbG9jIiwicmVhZFBhcnRpYWxTaXplIiwicmVhZFNpemVSZW1haW5pbmciLCJyZWFkTWVzc2FnZVNpemUiLCJyZWFkUGFydGlhbE1lc3NhZ2UiLCJyZWFkTWVzc2FnZVJlbWFpbmluZyIsIndyaXRlIiwiZGF0YSIsInJlYWRIZWFkIiwidG9SZWFkIiwicmVzdWx0IiwibGVuZ3RoIiwic2xpY2UiLCJSRUFESU5HX1NJWkUiLCJmaWxsIiwiTWF0aCIsIm1pbiIsImNvcHkiLCJyZWFkVUludDMyQkUiLCJSRUFESU5HX01FU1NBR0UiLCJtZXNzYWdlIiwiY29uY2F0IiwicHVzaCIsImZyYW1lZE1lc3NhZ2VCdWZmZXJzIiwiZnJhbWVkTWVzc2FnZSIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.stringToSubchannelAddress = exports.subchannelAddressToString = exports.subchannelAddressEqual = exports.isTcpSubchannelAddress = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction isTcpSubchannelAddress(address) {\n    return \"port\" in address;\n}\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nfunction subchannelAddressEqual(address1, address2) {\n    if (!address1 && !address2) {\n        return true;\n    }\n    if (!address1 || !address2) {\n        return false;\n    }\n    if (isTcpSubchannelAddress(address1)) {\n        return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;\n    } else {\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n    }\n}\nexports.subchannelAddressEqual = subchannelAddressEqual;\nfunction subchannelAddressToString(address) {\n    if (isTcpSubchannelAddress(address)) {\n        return address.host + \":\" + address.port;\n    } else {\n        return address.path;\n    }\n}\nexports.subchannelAddressToString = subchannelAddressToString;\nconst DEFAULT_PORT = 443;\nfunction stringToSubchannelAddress(addressString, port) {\n    if ((0, net_1.isIP)(addressString)) {\n        return {\n            host: addressString,\n            port: port !== null && port !== void 0 ? port : DEFAULT_PORT\n        };\n    } else {\n        return {\n            path: addressString\n        };\n    }\n}\nexports.stringToSubchannelAddress = stringToSubchannelAddress; //# sourceMappingURL=subchannel-address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQ0FBaUMsR0FBR0EsaUNBQWlDLEdBQUdBLDhCQUE4QixHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQy9JLE1BQU1NLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLFNBQVNGLHVCQUF1QkcsT0FBTztJQUNuQyxPQUFPLFVBQVVBO0FBQ3JCO0FBQ0FSLDhCQUE4QixHQUFHSztBQUNqQyxTQUFTRCx1QkFBdUJLLFFBQVEsRUFBRUMsUUFBUTtJQUM5QyxJQUFJLENBQUNELFlBQVksQ0FBQ0MsVUFBVTtRQUN4QixPQUFPO0lBQ1g7SUFDQSxJQUFJLENBQUNELFlBQVksQ0FBQ0MsVUFBVTtRQUN4QixPQUFPO0lBQ1g7SUFDQSxJQUFJTCx1QkFBdUJJLFdBQVc7UUFDbEMsT0FBUUosdUJBQXVCSyxhQUMzQkQsU0FBU0UsSUFBSSxLQUFLRCxTQUFTQyxJQUFJLElBQy9CRixTQUFTRyxJQUFJLEtBQUtGLFNBQVNFLElBQUk7SUFDdkMsT0FDSztRQUNELE9BQU8sQ0FBQ1AsdUJBQXVCSyxhQUFhRCxTQUFTSSxJQUFJLEtBQUtILFNBQVNHLElBQUk7SUFDL0U7QUFDSjtBQUNBYiw4QkFBOEIsR0FBR0k7QUFDakMsU0FBU0QsMEJBQTBCSyxPQUFPO0lBQ3RDLElBQUlILHVCQUF1QkcsVUFBVTtRQUNqQyxPQUFPQSxRQUFRRyxJQUFJLEdBQUcsTUFBTUgsUUFBUUksSUFBSTtJQUM1QyxPQUNLO1FBQ0QsT0FBT0osUUFBUUssSUFBSTtJQUN2QjtBQUNKO0FBQ0FiLGlDQUFpQyxHQUFHRztBQUNwQyxNQUFNVyxlQUFlO0FBQ3JCLFNBQVNaLDBCQUEwQmEsYUFBYSxFQUFFSCxJQUFJO0lBQ2xELElBQUksQ0FBQyxHQUFHTixNQUFNVSxJQUFJLEVBQUVELGdCQUFnQjtRQUNoQyxPQUFPO1lBQ0hKLE1BQU1JO1lBQ05ILE1BQU1BLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUlBLE9BQU9FO1FBQ3BEO0lBQ0osT0FDSztRQUNELE9BQU87WUFDSEQsTUFBTUU7UUFDVjtJQUNKO0FBQ0o7QUFDQWYsaUNBQWlDLEdBQUdFLDJCQUNwQyw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWFkZHJlc3MuanM/YmEzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc0VxdWFsID0gZXhwb3J0cy5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuZnVuY3Rpb24gaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgcmV0dXJuICdwb3J0JyBpbiBhZGRyZXNzO1xufVxuZXhwb3J0cy5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzID0gaXNUY3BTdWJjaGFubmVsQWRkcmVzcztcbmZ1bmN0aW9uIHN1YmNoYW5uZWxBZGRyZXNzRXF1YWwoYWRkcmVzczEsIGFkZHJlc3MyKSB7XG4gICAgaWYgKCFhZGRyZXNzMSAmJiAhYWRkcmVzczIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYWRkcmVzczEgfHwgIWFkZHJlc3MyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzczEpKSB7XG4gICAgICAgIHJldHVybiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMikgJiZcbiAgICAgICAgICAgIGFkZHJlc3MxLmhvc3QgPT09IGFkZHJlc3MyLmhvc3QgJiZcbiAgICAgICAgICAgIGFkZHJlc3MxLnBvcnQgPT09IGFkZHJlc3MyLnBvcnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICFpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MyKSAmJiBhZGRyZXNzMS5wYXRoID09PSBhZGRyZXNzMi5wYXRoO1xuICAgIH1cbn1cbmV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NFcXVhbCA9IHN1YmNoYW5uZWxBZGRyZXNzRXF1YWw7XG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpIHtcbiAgICBpZiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5ob3N0ICsgJzonICsgYWRkcmVzcy5wb3J0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3MucGF0aDtcbiAgICB9XG59XG5leHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcgPSBzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nO1xuY29uc3QgREVGQVVMVF9QT1JUID0gNDQzO1xuZnVuY3Rpb24gc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzU3RyaW5nLCBwb3J0KSB7XG4gICAgaWYgKCgwLCBuZXRfMS5pc0lQKShhZGRyZXNzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9zdDogYWRkcmVzc1N0cmluZyxcbiAgICAgICAgICAgIHBvcnQ6IHBvcnQgIT09IG51bGwgJiYgcG9ydCAhPT0gdm9pZCAwID8gcG9ydCA6IERFRkFVTFRfUE9SVCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoOiBhZGRyZXNzU3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyA9IHN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJzdWJjaGFubmVsQWRkcmVzc0VxdWFsIiwiaXNUY3BTdWJjaGFubmVsQWRkcmVzcyIsIm5ldF8xIiwicmVxdWlyZSIsImFkZHJlc3MiLCJhZGRyZXNzMSIsImFkZHJlc3MyIiwiaG9zdCIsInBvcnQiLCJwYXRoIiwiREVGQVVMVF9QT1JUIiwiYWRkcmVzc1N0cmluZyIsImlzSVAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-call.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2SubchannelCall = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"subchannel_call\";\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */ function getSystemErrorName(errno) {\n    for (const [name, num] of Object.entries(os.constants.errno)){\n        if (num === errno) {\n            return name;\n        }\n    }\n    return \"Unknown system error \" + errno;\n}\nclass Http2SubchannelCall {\n    constructor(http2Stream, callEventTracker, listener, transport, callId){\n        this.http2Stream = http2Stream;\n        this.callEventTracker = callEventTracker;\n        this.listener = listener;\n        this.transport = transport;\n        this.callId = callId;\n        this.decoder = new stream_decoder_1.StreamDecoder();\n        this.isReadFilterPending = false;\n        this.isPushPending = false;\n        this.canPush = false;\n        /**\n         * Indicates that an 'end' event has come from the http2 stream, so there\n         * will be no more data events.\n         */ this.readsClosed = false;\n        this.statusOutput = false;\n        this.unpushedReadMessages = [];\n        // Status code mapped from :status. To be used if grpc-status is not received\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.internalError = null;\n        http2Stream.on(\"response\", (headers, flags)=>{\n            let headersString = \"\";\n            for (const header of Object.keys(headers)){\n                headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n            }\n            this.trace(\"Received server headers:\\n\" + headersString);\n            switch(headers[\":status\"]){\n                // TODO(murgatroid99): handle 100 and 101\n                case 400:\n                    this.mappedStatusCode = constants_1.Status.INTERNAL;\n                    break;\n                case 401:\n                    this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n                    break;\n                case 403:\n                    this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n                    break;\n                case 404:\n                    this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n                    break;\n                case 429:\n                case 502:\n                case 503:\n                case 504:\n                    this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n                    break;\n                default:\n                    this.mappedStatusCode = constants_1.Status.UNKNOWN;\n            }\n            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                this.handleTrailers(headers);\n            } else {\n                let metadata;\n                try {\n                    metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                } catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNKNOWN,\n                        details: error.message,\n                        metadata: new metadata_1.Metadata()\n                    });\n                    return;\n                }\n                this.listener.onReceiveMetadata(metadata);\n            }\n        });\n        http2Stream.on(\"trailers\", (headers)=>{\n            this.handleTrailers(headers);\n        });\n        http2Stream.on(\"data\", (data)=>{\n            /* If the status has already been output, allow the http2 stream to\n             * drain without processing the data. */ if (this.statusOutput) {\n                return;\n            }\n            this.trace(\"receive HTTP/2 data frame of length \" + data.length);\n            const messages = this.decoder.write(data);\n            for (const message of messages){\n                this.trace(\"parsed message of length \" + message.length);\n                this.callEventTracker.addMessageReceived();\n                this.tryPush(message);\n            }\n        });\n        http2Stream.on(\"end\", ()=>{\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n        });\n        http2Stream.on(\"close\", ()=>{\n            /* Use process.next tick to ensure that this code happens after any\n             * \"error\" event that may be emitted at about the same time, so that\n             * we can bubble up the error message from that event. */ process.nextTick(()=>{\n                var _a;\n                this.trace(\"HTTP/2 stream closed with code \" + http2Stream.rstCode);\n                /* If we have a final status with an OK status code, that means that\n                 * we have received all of the messages and we have processed the\n                 * trailers and the call completed successfully, so it doesn't matter\n                 * how the stream ends after that */ if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                    return;\n                }\n                let code;\n                let details = \"\";\n                switch(http2Stream.rstCode){\n                    case http2.constants.NGHTTP2_NO_ERROR:\n                        /* If we get a NO_ERROR code and we already have a status, the\n                         * stream completed properly and we just haven't fully processed\n                         * it yet */ if (this.finalStatus !== null) {\n                            return;\n                        }\n                        code = constants_1.Status.INTERNAL;\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n                        break;\n                    case http2.constants.NGHTTP2_REFUSED_STREAM:\n                        code = constants_1.Status.UNAVAILABLE;\n                        details = \"Stream refused by server\";\n                        break;\n                    case http2.constants.NGHTTP2_CANCEL:\n                        code = constants_1.Status.CANCELLED;\n                        details = \"Call cancelled\";\n                        break;\n                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                        code = constants_1.Status.RESOURCE_EXHAUSTED;\n                        details = \"Bandwidth exhausted or memory limit exceeded\";\n                        break;\n                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                        code = constants_1.Status.PERMISSION_DENIED;\n                        details = \"Protocol not secure enough\";\n                        break;\n                    case http2.constants.NGHTTP2_INTERNAL_ERROR:\n                        code = constants_1.Status.INTERNAL;\n                        if (this.internalError === null) {\n                            /* This error code was previously handled in the default case, and\n                             * there are several instances of it online, so I wanted to\n                             * preserve the original error message so that people find existing\n                             * information in searches, but also include the more recognizable\n                             * \"Internal server error\" message. */ details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n                        } else {\n                            if (this.internalError.code === \"ECONNRESET\" || this.internalError.code === \"ETIMEDOUT\") {\n                                code = constants_1.Status.UNAVAILABLE;\n                                details = this.internalError.message;\n                            } else {\n                                /* The \"Received RST_STREAM with code ...\" error is preserved\n                                 * here for continuity with errors reported online, but the\n                                 * error message at the end will probably be more relevant in\n                                 * most cases. */ details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                            }\n                        }\n                        break;\n                    default:\n                        code = constants_1.Status.INTERNAL;\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n                }\n                // This is a no-op if trailers were received at all.\n                // This is OK, because status codes emitted here correspond to more\n                // catastrophic issues that prevent us from receiving trailers in the\n                // first place.\n                this.endCall({\n                    code,\n                    details,\n                    metadata: new metadata_1.Metadata(),\n                    rstCode: http2Stream.rstCode\n                });\n            });\n        });\n        http2Stream.on(\"error\", (err)=>{\n            /* We need an error handler here to stop \"Uncaught Error\" exceptions\n             * from bubbling up. However, errors here should all correspond to\n             * \"close\" events, where we will handle the error more granularly */ /* Specifically looking for stream errors that were *not* constructed\n             * from a RST_STREAM response here:\n             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n             */ if (err.code !== \"ERR_HTTP2_STREAM_ERROR\") {\n                this.trace(\"Node error event: message=\" + err.message + \" code=\" + err.code + \" errno=\" + getSystemErrorName(err.errno) + \" syscall=\" + err.syscall);\n                this.internalError = err;\n            }\n            this.callEventTracker.onStreamEnd(false);\n        });\n    }\n    onDisconnect() {\n        this.endCall({\n            code: constants_1.Status.UNAVAILABLE,\n            details: \"Connection dropped\",\n            metadata: new metadata_1.Metadata()\n        });\n    }\n    outputStatus() {\n        /* Precondition: this.finalStatus !== null */ if (!this.statusOutput) {\n            this.statusOutput = true;\n            this.trace(\"ended with status: code=\" + this.finalStatus.code + ' details=\"' + this.finalStatus.details + '\"');\n            this.callEventTracker.onCallEnd(this.finalStatus);\n            /* We delay the actual action of bubbling up the status to insulate the\n             * cleanup code in this class from any errors that may be thrown in the\n             * upper layers as a result of bubbling up the status. In particular,\n             * if the status is not OK, the \"error\" event may be emitted\n             * synchronously at the top level, which will result in a thrown error if\n             * the user does not handle that event. */ process.nextTick(()=>{\n                this.listener.onReceiveStatus(this.finalStatus);\n            });\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\n             * ensure that the stream closure completes. The call stream already does\n             * not push more messages after the status is output, so the messages go\n             * nowhere either way. */ this.http2Stream.resume();\n        }\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callId + \"] \" + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */ endCall(status) {\n        /* If the status is OK and a new status comes in (e.g. from a\n         * deserialization failure), that new status takes priority */ if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n            this.finalStatus = status;\n            this.maybeOutputStatus();\n        }\n        this.destroyHttp2Stream();\n    }\n    maybeOutputStatus() {\n        if (this.finalStatus !== null) {\n            /* The combination check of readsClosed and that the two message buffer\n             * arrays are empty checks that there all incoming data has been fully\n             * processed */ if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending && !this.isPushPending) {\n                this.outputStatus();\n            }\n        }\n    }\n    push(message) {\n        this.trace(\"pushing to reader message of length \" + (message instanceof Buffer ? message.length : null));\n        this.canPush = false;\n        this.isPushPending = true;\n        process.nextTick(()=>{\n            this.isPushPending = false;\n            /* If we have already output the status any later messages should be\n             * ignored, and can cause out-of-order operation errors higher up in the\n             * stack. Checking as late as possible here to avoid any race conditions.\n             */ if (this.statusOutput) {\n                return;\n            }\n            this.listener.onReceiveMessage(message);\n            this.maybeOutputStatus();\n        });\n    }\n    tryPush(messageBytes) {\n        if (this.canPush) {\n            this.http2Stream.pause();\n            this.push(messageBytes);\n        } else {\n            this.trace(\"unpushedReadMessages.push message of length \" + messageBytes.length);\n            this.unpushedReadMessages.push(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        this.callEventTracker.onStreamEnd(true);\n        let headersString = \"\";\n        for (const header of Object.keys(headers)){\n            headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n        }\n        this.trace(\"Received server trailers:\\n\" + headersString);\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        } catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const metadataMap = metadata.getMap();\n        let code = this.mappedStatusCode;\n        if (code === constants_1.Status.UNKNOWN && typeof metadataMap[\"grpc-status\"] === \"string\") {\n            const receivedStatus = Number(metadataMap[\"grpc-status\"]);\n            if (receivedStatus in constants_1.Status) {\n                code = receivedStatus;\n                this.trace(\"received status code \" + receivedStatus + \" from server\");\n            }\n            metadata.remove(\"grpc-status\");\n        }\n        let details = \"\";\n        if (typeof metadataMap[\"grpc-message\"] === \"string\") {\n            try {\n                details = decodeURI(metadataMap[\"grpc-message\"]);\n            } catch (e) {\n                details = metadataMap[\"grpc-message\"];\n            }\n            metadata.remove(\"grpc-message\");\n            this.trace('received status details string \"' + details + '\" from server');\n        }\n        const status = {\n            code,\n            details,\n            metadata\n        };\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall(status);\n    }\n    destroyHttp2Stream() {\n        var _a;\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (!this.http2Stream.destroyed) {\n            /* If the call has ended with an OK status, communicate that when closing\n             * the stream, partly to avoid a situation in which we detect an error\n             * RST_STREAM as a result after we have the status */ let code;\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                code = http2.constants.NGHTTP2_NO_ERROR;\n            } else {\n                code = http2.constants.NGHTTP2_CANCEL;\n            }\n            this.trace(\"close http2 stream with code \" + code);\n            this.http2Stream.close(code);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        this.endCall({\n            code: status,\n            details,\n            metadata: new metadata_1.Metadata()\n        });\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        return this.transport.getPeerName();\n    }\n    getCallNumber() {\n        return this.callId;\n    }\n    startRead() {\n        /* If the stream has ended with an error, we should not emit any more\n         * messages and we should communicate that the stream has ended */ if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n            return;\n        }\n        this.canPush = true;\n        if (this.unpushedReadMessages.length > 0) {\n            const nextMessage = this.unpushedReadMessages.shift();\n            this.push(nextMessage);\n            return;\n        }\n        /* Only resume reading from the http2Stream if we don't have any pending\n         * messages to emit */ this.http2Stream.resume();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace(\"write() called with message of length \" + message.length);\n        const cb = (error)=>{\n            /* nextTick here ensures that no stream action can be taken in the call\n             * stack of the write callback, in order to hopefully work around\n             * https://github.com/nodejs/node/issues/49147 */ process.nextTick(()=>{\n                var _a;\n                let code = constants_1.Status.UNAVAILABLE;\n                if ((error === null || error === void 0 ? void 0 : error.code) === \"ERR_STREAM_WRITE_AFTER_END\") {\n                    code = constants_1.Status.INTERNAL;\n                }\n                if (error) {\n                    this.cancelWithStatus(code, `Write error: ${error.message}`);\n                }\n                (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            });\n        };\n        this.trace(\"sending data chunk of length \" + message.length);\n        this.callEventTracker.addMessageSent();\n        try {\n            this.http2Stream.write(message, cb);\n        } catch (error) {\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Write failed with error ${error.message}`,\n                metadata: new metadata_1.Metadata()\n            });\n        }\n    }\n    halfClose() {\n        this.trace(\"end() called\");\n        this.trace(\"calling end() on HTTP/2 stream\");\n        this.http2Stream.end();\n    }\n}\nexports.Http2SubchannelCall = Http2SubchannelCall; //# sourceMappingURL=subchannel-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1jYWxsLmpzIiwibWFwcGluZ3MiOiI7O0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHLEtBQUs7QUFDbkMsTUFBTUcsUUFBUUMsbUJBQU9BLENBQUMsb0JBQU87QUFDN0IsTUFBTUMsS0FBS0QsbUJBQU9BLENBQUMsY0FBSTtBQUN2QixNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSSxtQkFBbUJKLG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNuRCxNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTSxjQUFjTixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNTyxjQUFjO0FBQ3BCOzs7OztDQUtDLEdBQ0QsU0FBU0MsbUJBQW1CQyxLQUFLO0lBQzdCLEtBQUssTUFBTSxDQUFDQyxNQUFNQyxJQUFJLElBQUlqQixPQUFPa0IsT0FBTyxDQUFDWCxHQUFHWSxTQUFTLENBQUNKLEtBQUssRUFBRztRQUMxRCxJQUFJRSxRQUFRRixPQUFPO1lBQ2YsT0FBT0M7UUFDWDtJQUNKO0lBQ0EsT0FBTywwQkFBMEJEO0FBQ3JDO0FBQ0EsTUFBTVg7SUFDRmdCLFlBQVlDLFdBQVcsRUFBRUMsZ0JBQWdCLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxNQUFNLENBQUU7UUFDcEUsSUFBSSxDQUFDSixXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdBO1FBQ3hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxPQUFPLEdB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LWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWNhbGwuanM/MDA1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDYWxsID0gdm9pZCAwO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3Qgc3RyZWFtX2RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS1kZWNvZGVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3N1YmNoYW5uZWxfY2FsbCc7XG4vKipcbiAqIFNob3VsZCBkbyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHRoaW5nIGFzIHV0aWwuZ2V0U3lzdGVtRXJyb3JOYW1lIGJ1dCB0aGVcbiAqIFR5cGVTY3JpcHQgdHlwZXMgZG9uJ3QgaGF2ZSB0aGF0IGZ1bmN0aW9uIGZvciBzb21lIHJlYXNvbiBzbyBJIGp1c3QgbWFkZSBteVxuICogb3duLlxuICogQHBhcmFtIGVycm5vXG4gKi9cbmZ1bmN0aW9uIGdldFN5c3RlbUVycm9yTmFtZShlcnJubykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIG51bV0gb2YgT2JqZWN0LmVudHJpZXMob3MuY29uc3RhbnRzLmVycm5vKSkge1xuICAgICAgICBpZiAobnVtID09PSBlcnJubykge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duIHN5c3RlbSBlcnJvciAnICsgZXJybm87XG59XG5jbGFzcyBIdHRwMlN1YmNoYW5uZWxDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihodHRwMlN0cmVhbSwgY2FsbEV2ZW50VHJhY2tlciwgbGlzdGVuZXIsIHRyYW5zcG9ydCwgY2FsbElkKSB7XG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0gPSBodHRwMlN0cmVhbTtcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyID0gY2FsbEV2ZW50VHJhY2tlcjtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5jYWxsSWQgPSBjYWxsSWQ7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBzdHJlYW1fZGVjb2Rlcl8xLlN0cmVhbURlY29kZXIoKTtcbiAgICAgICAgdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IGFuICdlbmQnIGV2ZW50IGhhcyBjb21lIGZyb20gdGhlIGh0dHAyIHN0cmVhbSwgc28gdGhlcmVcbiAgICAgICAgICogd2lsbCBiZSBubyBtb3JlIGRhdGEgZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXR1c091dHB1dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzID0gW107XG4gICAgICAgIC8vIFN0YXR1cyBjb2RlIG1hcHBlZCBmcm9tIDpzdGF0dXMuIFRvIGJlIHVzZWQgaWYgZ3JwYy1zdGF0dXMgaXMgbm90IHJlY2VpdmVkXG4gICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOO1xuICAgICAgICAvLyBUaGlzIGlzIHBvcHVsYXRlZCAobm9uLW51bGwpIGlmIGFuZCBvbmx5IGlmIHRoZSBjYWxsIGhhcyBlbmRlZFxuICAgICAgICB0aGlzLmZpbmFsU3RhdHVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gbnVsbDtcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ3Jlc3BvbnNlJywgKGhlYWRlcnMsIGZsYWdzKSA9PiB7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xuICAgICAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzU3RyaW5nICs9ICdcXHRcXHQnICsgaGVhZGVyICsgJzogJyArIGhlYWRlcnNbaGVhZGVyXSArICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc2VydmVyIGhlYWRlcnM6XFxuJyArIGhlYWRlcnNTdHJpbmcpO1xuICAgICAgICAgICAgc3dpdGNoIChoZWFkZXJzWyc6c3RhdHVzJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IGhhbmRsZSAxMDAgYW5kIDEwMVxuICAgICAgICAgICAgICAgIGNhc2UgNDAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVVRIRU5USUNBVEVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlBFUk1JU1NJT05fREVOSUVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDI5OlxuICAgICAgICAgICAgICAgIGNhc2UgNTAyOlxuICAgICAgICAgICAgICAgIGNhc2UgNTAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzICYgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRkxBR19FTkRfU1RSRUFNKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbigndHJhaWxlcnMnLCAoaGVhZGVycykgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGVycyhoZWFkZXJzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIC8qIElmIHRoZSBzdGF0dXMgaGFzIGFscmVhZHkgYmVlbiBvdXRwdXQsIGFsbG93IHRoZSBodHRwMiBzdHJlYW0gdG9cbiAgICAgICAgICAgICAqIGRyYWluIHdpdGhvdXQgcHJvY2Vzc2luZyB0aGUgZGF0YS4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c091dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmUgSFRUUC8yIGRhdGEgZnJhbWUgb2YgbGVuZ3RoICcgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMuZGVjb2Rlci53cml0ZShkYXRhKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3BhcnNlZCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5hZGRNZXNzYWdlUmVjZWl2ZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAvKiBVc2UgcHJvY2Vzcy5uZXh0IHRpY2sgdG8gZW5zdXJlIHRoYXQgdGhpcyBjb2RlIGhhcHBlbnMgYWZ0ZXIgYW55XG4gICAgICAgICAgICAgKiBcImVycm9yXCIgZXZlbnQgdGhhdCBtYXkgYmUgZW1pdHRlZCBhdCBhYm91dCB0aGUgc2FtZSB0aW1lLCBzbyB0aGF0XG4gICAgICAgICAgICAgKiB3ZSBjYW4gYnViYmxlIHVwIHRoZSBlcnJvciBtZXNzYWdlIGZyb20gdGhhdCBldmVudC4gKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdIVFRQLzIgc3RyZWFtIGNsb3NlZCB3aXRoIGNvZGUgJyArIGh0dHAyU3RyZWFtLnJzdENvZGUpO1xuICAgICAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgYSBmaW5hbCBzdGF0dXMgd2l0aCBhbiBPSyBzdGF0dXMgY29kZSwgdGhhdCBtZWFucyB0aGF0XG4gICAgICAgICAgICAgICAgICogd2UgaGF2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIG1lc3NhZ2VzIGFuZCB3ZSBoYXZlIHByb2Nlc3NlZCB0aGVcbiAgICAgICAgICAgICAgICAgKiB0cmFpbGVycyBhbmQgdGhlIGNhbGwgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgc28gaXQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAgICAgICAgKiBob3cgdGhlIHN0cmVhbSBlbmRzIGFmdGVyIHRoYXQgKi9cbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuZmluYWxTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICAgICAgICAgbGV0IGRldGFpbHMgPSAnJztcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGh0dHAyU3RyZWFtLnJzdENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9OT19FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHdlIGdldCBhIE5PX0VSUk9SIGNvZGUgYW5kIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXR1cywgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzdHJlYW0gY29tcGxldGVkIHByb3Blcmx5IGFuZCB3ZSBqdXN0IGhhdmVuJ3QgZnVsbHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCB5ZXQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtodHRwMlN0cmVhbS5yc3RDb2RlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9SRUZVU0VEX1NUUkVBTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1N0cmVhbSByZWZ1c2VkIGJ5IHNlcnZlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUw6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQ2FsbCBjYW5jZWxsZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE06XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQmFuZHdpZHRoIGV4aGF1c3RlZCBvciBtZW1vcnkgbGltaXQgZXhjZWVkZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfSU5BREVRVUFURV9TRUNVUklUWTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUEVSTUlTU0lPTl9ERU5JRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1Byb3RvY29sIG5vdCBzZWN1cmUgZW5vdWdoJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0lOVEVSTkFMX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsRXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGVycm9yIGNvZGUgd2FzIHByZXZpb3VzbHkgaGFuZGxlZCBpbiB0aGUgZGVmYXVsdCBjYXNlLCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGVyZSBhcmUgc2V2ZXJhbCBpbnN0YW5jZXMgb2YgaXQgb25saW5lLCBzbyBJIHdhbnRlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIHNvIHRoYXQgcGVvcGxlIGZpbmQgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBpbmZvcm1hdGlvbiBpbiBzZWFyY2hlcywgYnV0IGFsc28gaW5jbHVkZSB0aGUgbW9yZSByZWNvZ25pemFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiIG1lc3NhZ2UuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke2h0dHAyU3RyZWFtLnJzdENvZGV9IChJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsRXJyb3IuY29kZSA9PT0gJ0VDT05OUkVTRVQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxFcnJvci5jb2RlID09PSAnRVRJTUVET1VUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gdGhpcy5pbnRlcm5hbEVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGUgXCJSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAuLi5cIiBlcnJvciBpcyBwcmVzZXJ2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaGVyZSBmb3IgY29udGludWl0eSB3aXRoIGVycm9ycyByZXBvcnRlZCBvbmxpbmUsIGJ1dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZXJyb3IgbWVzc2FnZSBhdCB0aGUgZW5kIHdpbGwgcHJvYmFibHkgYmUgbW9yZSByZWxldmFudCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBtb3N0IGNhc2VzLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX0gdHJpZ2dlcmVkIGJ5IGludGVybmFsIGNsaWVudCBlcnJvcjogJHt0aGlzLmludGVybmFsRXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtodHRwMlN0cmVhbS5yc3RDb2RlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiB0cmFpbGVycyB3ZXJlIHJlY2VpdmVkIGF0IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIE9LLCBiZWNhdXNlIHN0YXR1cyBjb2RlcyBlbWl0dGVkIGhlcmUgY29ycmVzcG9uZCB0byBtb3JlXG4gICAgICAgICAgICAgICAgLy8gY2F0YXN0cm9waGljIGlzc3VlcyB0aGF0IHByZXZlbnQgdXMgZnJvbSByZWNlaXZpbmcgdHJhaWxlcnMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgcGxhY2UuXG4gICAgICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIHJzdENvZGU6IGh0dHAyU3RyZWFtLnJzdENvZGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgIC8qIFdlIG5lZWQgYW4gZXJyb3IgaGFuZGxlciBoZXJlIHRvIHN0b3AgXCJVbmNhdWdodCBFcnJvclwiIGV4Y2VwdGlvbnNcbiAgICAgICAgICAgICAqIGZyb20gYnViYmxpbmcgdXAuIEhvd2V2ZXIsIGVycm9ycyBoZXJlIHNob3VsZCBhbGwgY29ycmVzcG9uZCB0b1xuICAgICAgICAgICAgICogXCJjbG9zZVwiIGV2ZW50cywgd2hlcmUgd2Ugd2lsbCBoYW5kbGUgdGhlIGVycm9yIG1vcmUgZ3JhbnVsYXJseSAqL1xuICAgICAgICAgICAgLyogU3BlY2lmaWNhbGx5IGxvb2tpbmcgZm9yIHN0cmVhbSBlcnJvcnMgdGhhdCB3ZXJlICpub3QqIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgKiBmcm9tIGEgUlNUX1NUUkVBTSByZXNwb25zZSBoZXJlOlxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvOGI4NjIwZDU4MDMxNDA1MDE3NTk4MzQwMmRmZGRmMjY3NGU4ZTIyYS9saWIvaW50ZXJuYWwvaHR0cDIvY29yZS5qcyNMMjI2N1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFUlJfSFRUUDJfU1RSRUFNX0VSUk9SJykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ05vZGUgZXJyb3IgZXZlbnQ6IG1lc3NhZ2U9JyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlICtcbiAgICAgICAgICAgICAgICAgICAgJyBjb2RlPScgK1xuICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSArXG4gICAgICAgICAgICAgICAgICAgICcgZXJybm89JyArXG4gICAgICAgICAgICAgICAgICAgIGdldFN5c3RlbUVycm9yTmFtZShlcnIuZXJybm8pICtcbiAgICAgICAgICAgICAgICAgICAgJyBzeXNjYWxsPScgK1xuICAgICAgICAgICAgICAgICAgICBlcnIuc3lzY2FsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uRGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgIGRldGFpbHM6ICdDb25uZWN0aW9uIGRyb3BwZWQnLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvdXRwdXRTdGF0dXMoKSB7XG4gICAgICAgIC8qIFByZWNvbmRpdGlvbjogdGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAqL1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c091dHB1dCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgK1xuICAgICAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMuZGV0YWlscyArXG4gICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25DYWxsRW5kKHRoaXMuZmluYWxTdGF0dXMpO1xuICAgICAgICAgICAgLyogV2UgZGVsYXkgdGhlIGFjdHVhbCBhY3Rpb24gb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cyB0byBpbnN1bGF0ZSB0aGVcbiAgICAgICAgICAgICAqIGNsZWFudXAgY29kZSBpbiB0aGlzIGNsYXNzIGZyb20gYW55IGVycm9ycyB0aGF0IG1heSBiZSB0aHJvd24gaW4gdGhlXG4gICAgICAgICAgICAgKiB1cHBlciBsYXllcnMgYXMgYSByZXN1bHQgb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cy4gSW4gcGFydGljdWxhcixcbiAgICAgICAgICAgICAqIGlmIHRoZSBzdGF0dXMgaXMgbm90IE9LLCB0aGUgXCJlcnJvclwiIGV2ZW50IG1heSBiZSBlbWl0dGVkXG4gICAgICAgICAgICAgKiBzeW5jaHJvbm91c2x5IGF0IHRoZSB0b3AgbGV2ZWwsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgdGhyb3duIGVycm9yIGlmXG4gICAgICAgICAgICAgKiB0aGUgdXNlciBkb2VzIG5vdCBoYW5kbGUgdGhhdCBldmVudC4gKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHRoaXMuZmluYWxTdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKiBMZWF2ZSB0aGUgaHR0cDIgc3RyZWFtIGluIGZsb3dpbmcgc3RhdGUgdG8gZHJhaW4gaW5jb21pbmcgbWVzc2FnZXMsIHRvXG4gICAgICAgICAgICAgKiBlbnN1cmUgdGhhdCB0aGUgc3RyZWFtIGNsb3N1cmUgY29tcGxldGVzLiBUaGUgY2FsbCBzdHJlYW0gYWxyZWFkeSBkb2VzXG4gICAgICAgICAgICAgKiBub3QgcHVzaCBtb3JlIG1lc3NhZ2VzIGFmdGVyIHRoZSBzdGF0dXMgaXMgb3V0cHV0LCBzbyB0aGUgbWVzc2FnZXMgZ29cbiAgICAgICAgICAgICAqIG5vd2hlcmUgZWl0aGVyIHdheS4gKi9cbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbElkICsgJ10gJyArIHRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiBmaXJzdCBjYWxsLCBlbWl0cyBhICdzdGF0dXMnIGV2ZW50IHdpdGggdGhlIGdpdmVuIFN0YXR1c09iamVjdC5cbiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIGFyZSBuby1vcHMuXG4gICAgICogQHBhcmFtIHN0YXR1cyBUaGUgc3RhdHVzIG9mIHRoZSBjYWxsLlxuICAgICAqL1xuICAgIGVuZENhbGwoc3RhdHVzKSB7XG4gICAgICAgIC8qIElmIHRoZSBzdGF0dXMgaXMgT0sgYW5kIGEgbmV3IHN0YXR1cyBjb21lcyBpbiAoZS5nLiBmcm9tIGFcbiAgICAgICAgICogZGVzZXJpYWxpemF0aW9uIGZhaWx1cmUpLCB0aGF0IG5ldyBzdGF0dXMgdGFrZXMgcHJpb3JpdHkgKi9cbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgPT09IG51bGwgfHwgdGhpcy5maW5hbFN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95SHR0cDJTdHJlYW0oKTtcbiAgICB9XG4gICAgbWF5YmVPdXRwdXRTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvKiBUaGUgY29tYmluYXRpb24gY2hlY2sgb2YgcmVhZHNDbG9zZWQgYW5kIHRoYXQgdGhlIHR3byBtZXNzYWdlIGJ1ZmZlclxuICAgICAgICAgICAgICogYXJyYXlzIGFyZSBlbXB0eSBjaGVja3MgdGhhdCB0aGVyZSBhbGwgaW5jb21pbmcgZGF0YSBoYXMgYmVlbiBmdWxseVxuICAgICAgICAgICAgICogcHJvY2Vzc2VkICovXG4gICAgICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0sgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5yZWFkc0Nsb3NlZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzUHVzaFBlbmRpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgncHVzaGluZyB0byByZWFkZXIgbWVzc2FnZSBvZiBsZW5ndGggJyArXG4gICAgICAgICAgICAobWVzc2FnZSBpbnN0YW5jZW9mIEJ1ZmZlciA/IG1lc3NhZ2UubGVuZ3RoIDogbnVsbCkpO1xuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgYWxyZWFkeSBvdXRwdXQgdGhlIHN0YXR1cyBhbnkgbGF0ZXIgbWVzc2FnZXMgc2hvdWxkIGJlXG4gICAgICAgICAgICAgKiBpZ25vcmVkLCBhbmQgY2FuIGNhdXNlIG91dC1vZi1vcmRlciBvcGVyYXRpb24gZXJyb3JzIGhpZ2hlciB1cCBpbiB0aGVcbiAgICAgICAgICAgICAqIHN0YWNrLiBDaGVja2luZyBhcyBsYXRlIGFzIHBvc3NpYmxlIGhlcmUgdG8gYXZvaWQgYW55IHJhY2UgY29uZGl0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJ5UHVzaChtZXNzYWdlQnl0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuUHVzaCkge1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoKG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCd1bnB1c2hlZFJlYWRNZXNzYWdlcy5wdXNoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlQnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMucHVzaChtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKHRydWUpO1xuICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgaGVhZGVyc1N0cmluZyArPSAnXFx0XFx0JyArIGhlYWRlciArICc6ICcgKyBoZWFkZXJzW2hlYWRlcl0gKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzZXJ2ZXIgdHJhaWxlcnM6XFxuJyArIGhlYWRlcnNTdHJpbmcpO1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTWFwID0gbWV0YWRhdGEuZ2V0TWFwKCk7XG4gICAgICAgIGxldCBjb2RlID0gdGhpcy5tYXBwZWRTdGF0dXNDb2RlO1xuICAgICAgICBpZiAoY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04gJiZcbiAgICAgICAgICAgIHR5cGVvZiBtZXRhZGF0YU1hcFsnZ3JwYy1zdGF0dXMnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkU3RhdHVzID0gTnVtYmVyKG1ldGFkYXRhTWFwWydncnBjLXN0YXR1cyddKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cyBpbiBjb25zdGFudHNfMS5TdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gcmVjZWl2ZWRTdGF0dXM7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGNvZGUgJyArIHJlY2VpdmVkU3RhdHVzICsgJyBmcm9tIHNlcnZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLXN0YXR1cycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXRhaWxzID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gZGVjb2RlVVJJKG1ldGFkYXRhTWFwWydncnBjLW1lc3NhZ2UnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMgPSBtZXRhZGF0YU1hcFsnZ3JwYy1tZXNzYWdlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtbWVzc2FnZScpO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGRldGFpbHMgc3RyaW5nIFwiJyArIGRldGFpbHMgKyAnXCIgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSB7IGNvZGUsIGRldGFpbHMsIG1ldGFkYXRhIH07XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiB0aGUgY2FsbCB3YXMgYWxyZWFkeSBlbmRlZCB3aGVuIGhhbmRsaW5nIGhlYWRlcnMuXG4gICAgICAgIHRoaXMuZW5kQ2FsbChzdGF0dXMpO1xuICAgIH1cbiAgICBkZXN0cm95SHR0cDJTdHJlYW0oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gVGhlIGh0dHAyIHN0cmVhbSBjb3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBkZXN0cm95ZWQgaWYgY2FuY2VsV2l0aFN0YXR1c1xuICAgICAgICAvLyBpcyBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJuYWwgaHR0cDIgZXJyb3IuXG4gICAgICAgIGlmICghdGhpcy5odHRwMlN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIC8qIElmIHRoZSBjYWxsIGhhcyBlbmRlZCB3aXRoIGFuIE9LIHN0YXR1cywgY29tbXVuaWNhdGUgdGhhdCB3aGVuIGNsb3NpbmdcbiAgICAgICAgICAgICAqIHRoZSBzdHJlYW0sIHBhcnRseSB0byBhdm9pZCBhIHNpdHVhdGlvbiBpbiB3aGljaCB3ZSBkZXRlY3QgYW4gZXJyb3JcbiAgICAgICAgICAgICAqIFJTVF9TVFJFQU0gYXMgYSByZXN1bHQgYWZ0ZXIgd2UgaGF2ZSB0aGUgc3RhdHVzICovXG4gICAgICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5maW5hbFN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfQ0FOQ0VMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2xvc2UgaHR0cDIgc3RyZWFtIHdpdGggY29kZSAnICsgY29kZSk7XG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLmNsb3NlKGNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xuICAgICAgICB0aGlzLmVuZENhbGwoeyBjb2RlOiBzdGF0dXMsIGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0pO1xuICAgIH1cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmFsU3RhdHVzO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuZ2V0UGVlck5hbWUoKTtcbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkO1xuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIC8qIElmIHRoZSBzdHJlYW0gaGFzIGVuZGVkIHdpdGggYW4gZXJyb3IsIHdlIHNob3VsZCBub3QgZW1pdCBhbnkgbW9yZVxuICAgICAgICAgKiBtZXNzYWdlcyBhbmQgd2Ugc2hvdWxkIGNvbW11bmljYXRlIHRoYXQgdGhlIHN0cmVhbSBoYXMgZW5kZWQgKi9cbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwgJiYgdGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMucmVhZHNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRNZXNzYWdlID0gdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoKG5leHRNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBPbmx5IHJlc3VtZSByZWFkaW5nIGZyb20gdGhlIGh0dHAyU3RyZWFtIGlmIHdlIGRvbid0IGhhdmUgYW55IHBlbmRpbmdcbiAgICAgICAgICogbWVzc2FnZXMgdG8gZW1pdCAqL1xuICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjYiA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLyogbmV4dFRpY2sgaGVyZSBlbnN1cmVzIHRoYXQgbm8gc3RyZWFtIGFjdGlvbiBjYW4gYmUgdGFrZW4gaW4gdGhlIGNhbGxcbiAgICAgICAgICAgICAqIHN0YWNrIG9mIHRoZSB3cml0ZSBjYWxsYmFjaywgaW4gb3JkZXIgdG8gaG9wZWZ1bGx5IHdvcmsgYXJvdW5kXG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MTQ3ICovXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgaWYgKChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuY29kZSkgPT09XG4gICAgICAgICAgICAgICAgICAgICdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb2RlLCBgV3JpdGUgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9hID0gY29udGV4dC5jYWxsYmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY29udGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFjZSgnc2VuZGluZyBkYXRhIGNodW5rIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIuYWRkTWVzc2FnZVNlbnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ud3JpdGUobWVzc2FnZSwgY2IpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFdyaXRlIGZhaWxlZCB3aXRoIGVycm9yICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdlbmQoKSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy50cmFjZSgnY2FsbGluZyBlbmQoKSBvbiBIVFRQLzIgc3RyZWFtJyk7XG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0uZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDYWxsID0gSHR0cDJTdWJjaGFubmVsQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtY2FsbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJIdHRwMlN1YmNoYW5uZWxDYWxsIiwiaHR0cDIiLCJyZXF1aXJlIiwib3MiLCJjb25zdGFudHNfMSIsIm1ldGFkYXRhXzEiLCJzdHJlYW1fZGVjb2Rlcl8xIiwibG9nZ2luZyIsImNvbnN0YW50c18yIiwiVFJBQ0VSX05BTUUiLCJnZXRTeXN0ZW1FcnJvck5hbWUiLCJlcnJubyIsIm5hbWUiLCJudW0iLCJlbnRyaWVzIiwiY29uc3RhbnRzIiwiY29uc3RydWN0b3IiLCJodHRwMlN0cmVhbSIsImNhbGxFdmVudFRyYWNrZXIiLCJsaXN0ZW5lciIsInRyYW5zcG9ydCIsImNhbGxJZCIsImRlY29kZXIiLCJTdHJlYW1EZWNvZGVyIiwiaXNSZWFkRmlsdGVyUGVuZGluZyIsImlzUHVzaFBlbmRpbmciLCJjYW5QdXNoIiwicmVhZHNDbG9zZWQiLCJzdGF0dXNPdXRwdXQiLCJ1bnB1c2hlZFJlYWRNZXNzYWdlcyIsIm1hcHBlZFN0YXR1c0NvZGUiLCJTdGF0dXMiLCJVTktOT1dOIiwiZmluYWxTdGF0dXMiLCJpbnRlcm5hbEVycm9yIiwib24iLCJoZWFkZXJzIiwiZmxhZ3MiLCJoZWFkZXJzU3RyaW5nIiwiaGVhZGVyIiwia2V5cyIsInRyYWNlIiwiSU5URVJOQUwiLCJVTkFVVEhFTlRJQ0FURUQiLCJQRVJNSVNTSU9OX0RFTklFRCIsIlVOSU1QTEVNRU5URUQiLCJVTkFWQUlMQUJMRSIsIk5HSFRUUDJfRkxBR19FTkRfU1RSRUFNIiwiaGFuZGxlVHJhaWxlcnMiLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwiZnJvbUh0dHAySGVhZGVycyIsImVycm9yIiwiZW5kQ2FsbCIsImNvZGUiLCJkZXRhaWxzIiwibWVzc2FnZSIsIm9uUmVjZWl2ZU1ldGFkYXRhIiwiZGF0YSIsImxlbmd0aCIsIm1lc3NhZ2VzIiwid3JpdGUiLCJhZGRNZXNzYWdlUmVjZWl2ZWQiLCJ0cnlQdXNoIiwibWF5YmVPdXRwdXRTdGF0dXMiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJfYSIsInJzdENvZGUiLCJPSyIsIk5HSFRUUDJfTk9fRVJST1IiLCJOR0hUVFAyX1JFRlVTRURfU1RSRUFNIiwiTkdIVFRQMl9DQU5DRUwiLCJDQU5DRUxMRUQiLCJOR0hUVFAyX0VOSEFOQ0VfWU9VUl9DQUxNIiwiUkVTT1VSQ0VfRVhIQVVTVEVEIiwiTkdIVFRQMl9JTkFERVFVQVRFX1NFQ1VSSVRZIiwiTkdIVFRQMl9JTlRFUk5BTF9FUlJPUiIsImVyciIsInN5c2NhbGwiLCJvblN0cmVhbUVuZCIsIm9uRGlzY29ubmVjdCIsIm91dHB1dFN0YXR1cyIsIm9uQ2FsbEVuZCIsIm9uUmVjZWl2ZVN0YXR1cyIsInJlc3VtZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsInN0YXR1cyIsImRlc3Ryb3lIdHRwMlN0cmVhbSIsInB1c2giLCJCdWZmZXIiLCJvblJlY2VpdmVNZXNzYWdlIiwibWVzc2FnZUJ5dGVzIiwicGF1c2UiLCJlIiwibWV0YWRhdGFNYXAiLCJnZXRNYXAiLCJyZWNlaXZlZFN0YXR1cyIsIk51bWJlciIsInJlbW92ZSIsImRlY29kZVVSSSIsImRlc3Ryb3llZCIsImNsb3NlIiwiY2FuY2VsV2l0aFN0YXR1cyIsImdldFN0YXR1cyIsImdldFBlZXIiLCJnZXRQZWVyTmFtZSIsImdldENhbGxOdW1iZXIiLCJzdGFydFJlYWQiLCJuZXh0TWVzc2FnZSIsInNoaWZ0Iiwic2VuZE1lc3NhZ2VXaXRoQ29udGV4dCIsImNvbnRleHQiLCJjYiIsImNhbGxiYWNrIiwiY2FsbCIsImFkZE1lc3NhZ2VTZW50IiwiaGFsZkNsb3NlIiwiZW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseSubchannelWrapper = void 0;\nclass BaseSubchannelWrapper {\n    constructor(child){\n        this.child = child;\n    }\n    getConnectivityState() {\n        return this.child.getConnectivityState();\n    }\n    addConnectivityStateListener(listener) {\n        this.child.addConnectivityStateListener(listener);\n    }\n    removeConnectivityStateListener(listener) {\n        this.child.removeConnectivityStateListener(listener);\n    }\n    startConnecting() {\n        this.child.startConnecting();\n    }\n    getAddress() {\n        return this.child.getAddress();\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        this.child.throttleKeepalive(newKeepaliveTime);\n    }\n    ref() {\n        this.child.ref();\n    }\n    unref() {\n        this.child.unref();\n    }\n    getChannelzRef() {\n        return this.child.getChannelzRef();\n    }\n    getRealSubchannel() {\n        return this.child.getRealSubchannel();\n    }\n    realSubchannelEquals(other) {\n        return this.getRealSubchannel() === other.getRealSubchannel();\n    }\n}\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper; //# sourceMappingURL=subchannel-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUU7SUFDRkMsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0FDLHVCQUF1QjtRQUNuQixPQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxvQkFBb0I7SUFDMUM7SUFDQUMsNkJBQTZCQyxRQUFRLEVBQUU7UUFDbkMsSUFBSSxDQUFDSCxLQUFLLENBQUNFLDRCQUE0QixDQUFDQztJQUM1QztJQUNBQyxnQ0FBZ0NELFFBQVEsRUFBRTtRQUN0QyxJQUFJLENBQUNILEtBQUssQ0FBQ0ksK0JBQStCLENBQUNEO0lBQy9DO0lBQ0FFLGtCQUFrQjtRQUNkLElBQUksQ0FBQ0wsS0FBSyxDQUFDSyxlQUFlO0lBQzlCO0lBQ0FDLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ04sS0FBSyxDQUFDTSxVQUFVO0lBQ2hDO0lBQ0FDLGtCQUFrQkMsZ0JBQWdCLEVBQUU7UUFDaEMsSUFBSSxDQUFDUixLQUFLLENBQUNPLGlCQUFpQixDQUFDQztJQUNqQztJQUNBQyxNQUFNO1FBQ0YsSUFBSSxDQUFDVCxLQUFLLENBQUNTLEdBQUc7SUFDbEI7SUFDQUMsUUFBUTtRQUNKLElBQUksQ0FBQ1YsS0FBSyxDQUFDVSxLQUFLO0lBQ3BCO0lBQ0FDLGlCQUFpQjtRQUNiLE9BQU8sSUFBSSxDQUFDWCxLQUFLLENBQUNXLGNBQWM7SUFDcEM7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU8sSUFBSSxDQUFDWixLQUFLLENBQUNZLGlCQUFpQjtJQUN2QztJQUNBQyxxQkFBcUJDLEtBQUssRUFBRTtRQUN4QixPQUFPLElBQUksQ0FBQ0YsaUJBQWlCLE9BQU9FLE1BQU1GLGlCQUFpQjtJQUMvRDtBQUNKO0FBQ0FoQiw2QkFBNkIsR0FBR0UsdUJBQ2hDLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL2lzdHJ1Y3RlcGFwZXJzX3YyLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtaW50ZXJmYWNlLmpzPzI4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVN1YmNoYW5uZWxXcmFwcGVyID0gdm9pZCAwO1xuY2xhc3MgQmFzZVN1YmNoYW5uZWxXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZCkge1xuICAgICAgICB0aGlzLmNoaWxkID0gY2hpbGQ7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgIH1cbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuY2hpbGQuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgc3RhcnRDb25uZWN0aW5nKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpIHtcbiAgICAgICAgdGhpcy5jaGlsZC50aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKTtcbiAgICB9XG4gICAgcmVmKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnJlZigpO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC51bnJlZigpO1xuICAgIH1cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0Q2hhbm5lbHpSZWYoKTtcbiAgICB9XG4gICAgZ2V0UmVhbFN1YmNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldFJlYWxTdWJjaGFubmVsKCk7XG4gICAgfVxuICAgIHJlYWxTdWJjaGFubmVsRXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlYWxTdWJjaGFubmVsKCkgPT09IG90aGVyLmdldFJlYWxTdWJjaGFubmVsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlU3ViY2hhbm5lbFdyYXBwZXIgPSBCYXNlU3ViY2hhbm5lbFdyYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYXNlU3ViY2hhbm5lbFdyYXBwZXIiLCJjb25zdHJ1Y3RvciIsImNoaWxkIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwibGlzdGVuZXIiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwic3RhcnRDb25uZWN0aW5nIiwiZ2V0QWRkcmVzcyIsInRocm90dGxlS2VlcGFsaXZlIiwibmV3S2VlcGFsaXZlVGltZSIsInJlZiIsInVucmVmIiwiZ2V0Q2hhbm5lbHpSZWYiLCJnZXRSZWFsU3ViY2hhbm5lbCIsInJlYWxTdWJjaGFubmVsRXF1YWxzIiwib3RoZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\nconst channel_options_1 = __webpack_require__(/*! ./channel-options */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\");\nconst subchannel_1 = __webpack_require__(/*! ./subchannel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */ const REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n    /**\n     * A pool of subchannels use for making connections. Subchannels with the\n     * exact same parameters will be reused.\n     */ constructor(){\n        this.pool = Object.create(null);\n        /**\n         * A timer of a task performing a periodic subchannel cleanup.\n         */ this.cleanupTimer = null;\n    }\n    /**\n     * Unrefs all unused subchannels and cancels the cleanup task if all\n     * subchannels have been unrefed.\n     */ unrefUnusedSubchannels() {\n        let allSubchannelsUnrefed = true;\n        /* These objects are created with Object.create(null), so they do not\n         * have a prototype, which means that for (... in ...) loops over them\n         * do not need to be filtered */ // eslint-disable-disable-next-line:forin\n        for(const channelTarget in this.pool){\n            const subchannelObjArray = this.pool[channelTarget];\n            const refedSubchannels = subchannelObjArray.filter((value)=>!value.subchannel.unrefIfOneRef());\n            if (refedSubchannels.length > 0) {\n                allSubchannelsUnrefed = false;\n            }\n            /* For each subchannel in the pool, try to unref it if it has\n             * exactly one ref (which is the ref from the pool itself). If that\n             * does happen, remove the subchannel from the pool */ this.pool[channelTarget] = refedSubchannels;\n        }\n        /* Currently we do not delete keys with empty values. If that results\n         * in significant memory usage we should change it. */ // Cancel the cleanup task if all subchannels have been unrefed.\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */ ensureCleanupTask() {\n        var _a, _b;\n        if (this.cleanupTimer === null) {\n            this.cleanupTimer = setInterval(()=>{\n                this.unrefUnusedSubchannels();\n            }, REF_CHECK_INTERVAL);\n            // Unref because this timer should not keep the event loop running.\n            // Call unref only if it exists to address electron/electron#21162\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */ getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n        this.ensureCleanupTask();\n        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);\n        if (channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            for (const subchannelObj of subchannelObjArray){\n                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) && (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n                    return subchannelObj.subchannel;\n                }\n            }\n        }\n        // If we get here, no matching subchannel was found\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));\n        if (!(channelTarget in this.pool)) {\n            this.pool[channelTarget] = [];\n        }\n        this.pool[channelTarget].push({\n            subchannelAddress: subchannelTarget,\n            channelArguments,\n            channelCredentials,\n            subchannel\n        });\n        subchannel.ref();\n        return subchannel;\n    }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */ function getSubchannelPool(global) {\n    if (global) {\n        return globalSubchannelPool;\n    } else {\n        return new SubchannelPool();\n    }\n}\nexports.getSubchannelPool = getSubchannelPool; //# sourceMappingURL=subchannel-pool.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUMxRCxNQUFNSSxvQkFBb0JDLG1CQUFPQSxDQUFDLDBGQUFtQjtBQUNyRCxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNSSxjQUFjSixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6Qyx1REFBdUQ7QUFDdkQ7OztDQUdDLEdBQ0QsTUFBTUsscUJBQXFCO0FBQzNCLE1BQU1QO0lBQ0Y7OztLQUdDLEdBQ0RRLGFBQWM7UUFDVixJQUFJLENBQUNDLElBQUksR0FBR2QsT0FBT2UsTUFBTSxDQUFDO1FBQzFCOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxZQUFZLEdBQUc7SUFDeEI7SUFDQTs7O0tBR0MsR0FDREMseUJBQXlCO1FBQ3JCLElBQUlDLHdCQUF3QjtRQUM1Qjs7c0NBRThCLEdBQzlCLHlDQUF5QztRQUN6QyxJQUFLLE1BQU1DLGlCQUFpQixJQUFJLENBQUNMLElBQUksQ0FBRTtZQUNuQyxNQUFNTSxxQkFBcUIsSUFBSSxDQUFDTixJQUFJLENBQUNLLGNBQWM7WUFDbkQsTUFBTUUsbUJBQW1CRCxtQkFBbUJFLE1BQU0sQ0FBQ25CLENBQUFBLFFBQVMsQ0FBQ0EsTUFBTW9CLFVBQVUsQ0FBQ0MsYUFBYTtZQUMzRixJQUFJSCxpQkFBaUJJLE1BQU0sR0FBRyxHQUFHO2dCQUM3QlAsd0JBQXdCO1lBQzVCO1lBQ0E7O2dFQUVvRCxHQUNwRCxJQUFJLENBQUNKLElBQUksQ0FBQ0ssY0FBYyxHQUFHRTtRQUMvQjtRQUNBOzREQUNvRCxHQUNwRCxnRUFBZ0U7UUFDaEUsSUFBSUgseUJBQXlCLElBQUksQ0FBQ0YsWUFBWSxLQUFLLE1BQU07WUFDckRVLGNBQWMsSUFBSSxDQUFDVixZQUFZO1lBQy9CLElBQUksQ0FBQ0EsWUFBWSxHQUFHO1FBQ3hCO0lBQ0o7SUFDQTs7S0FFQyxHQUNEVyxvQkFBb0I7UUFDaEIsSUFBSUMsSUFBSUM7UUFDUixJQUFJLElBQUksQ0FBQ2IsWUFBWSxLQUFLLE1BQU07WUFDNUIsSUFBSSxDQUFDQSxZQUFZLEdBQUdjLFlBQVk7Z0JBQzVCLElBQUksQ0FBQ2Isc0JBQXNCO1lBQy9CLEdBQUdMO1lBQ0gsbUVBQW1FO1lBQ25FLGtFQUFrRTtZQUNqRWlCLENBQUFBLEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNaLFlBQVksRUFBRWUsS0FBSyxNQUFNLFFBQVFGLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0csSUFBSSxDQUFDSjtRQUN2RjtJQUNKO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNESyxzQkFBc0JDLGdCQUFnQixFQUFFQyxnQkFBZ0IsRUFBRUMsZ0JBQWdCLEVBQUVDLGtCQUFrQixFQUFFO1FBQzVGLElBQUksQ0FBQ1YsaUJBQWlCO1FBQ3RCLE1BQU1SLGdCQUFnQixDQUFDLEdBQUdULGFBQWE0QixXQUFXLEVBQUVKO1FBQ3BELElBQUlmLGlCQUFpQixJQUFJLENBQUNMLElBQUksRUFBRTtZQUM1QixNQUFNTSxxQkFBcUIsSUFBSSxDQUFDTixJQUFJLENBQUNLLGNBQWM7WUFDbkQsS0FBSyxNQUFNb0IsaUJBQWlCbkIsbUJBQW9CO2dCQUM1QyxJQUFJLENBQUMsR0FBR1gscUJBQXFCK0Isc0JBQXNCLEVBQUVMLGtCQUFrQkksY0FBY0UsaUJBQWlCLEtBQ2xHLENBQUMsR0FBR25DLGtCQUFrQm9DLG1CQUFtQixFQUFFTixrQkFBa0JHLGNBQWNILGdCQUFnQixLQUMzRkMsbUJBQW1CTSxPQUFPLENBQUNKLGNBQWNGLGtCQUFrQixHQUFHO29CQUM5RCxPQUFPRSxjQUFjaEIsVUFBVTtnQkFDbkM7WUFDSjtRQUNKO1FBQ0EsbURBQW1EO1FBQ25ELE1BQU1BLGFBQWEsSUFBSWYsYUFBYW9DLFVBQVUsQ0FBQ1Ysa0JBQWtCQyxrQkFBa0JDLGtCQUFrQkMsb0JBQW9CLElBQUkxQixZQUFZa0Msd0JBQXdCLENBQUNYO1FBQ2xLLElBQUksQ0FBRWYsQ0FBQUEsaUJBQWlCLElBQUksQ0FBQ0wsSUFBSSxHQUFHO1lBQy9CLElBQUksQ0FBQ0EsSUFBSSxDQUFDSyxjQUFjLEdBQUcsRUFBRTtRQUNqQztRQUNBLElBQUksQ0FBQ0wsSUFBSSxDQUFDSyxjQUFjLENBQUMyQixJQUFJLENBQUM7WUFDMUJMLG1CQUFtQk47WUFDbkJDO1lBQ0FDO1lBQ0FkO1FBQ0o7UUFDQUEsV0FBV3dCLEdBQUc7UUFDZCxPQUFPeEI7SUFDWDtBQUNKO0FBQ0FyQixzQkFBc0IsR0FBR0c7QUFDekIsTUFBTTJDLHVCQUF1QixJQUFJM0M7QUFDakM7OztDQUdDLEdBQ0QsU0FBU0Qsa0JBQWtCNkMsTUFBTTtJQUM3QixJQUFJQSxRQUFRO1FBQ1IsT0FBT0Q7SUFDWCxPQUNLO1FBQ0QsT0FBTyxJQUFJM0M7SUFDZjtBQUNKO0FBQ0FILHlCQUF5QixHQUFHRSxtQkFDNUIsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzP2M1NjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U3ViY2hhbm5lbFBvb2wgPSBleHBvcnRzLlN1YmNoYW5uZWxQb29sID0gdm9pZCAwO1xuY29uc3QgY2hhbm5lbF9vcHRpb25zXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLW9wdGlvbnNcIik7XG5jb25zdCBzdWJjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRcIik7XG4vLyAxMCBzZWNvbmRzIGluIG1pbGxpc2Vjb25kcy4gVGhpcyB2YWx1ZSBpcyBhcmJpdHJhcnkuXG4vKipcbiAqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBiZXR3ZWVuIGNoZWNrcyBmb3IgZHJvcHBpbmcgc3ViY2hhbm5lbHMgdGhhdCBoYXZlIG5vXG4gKiBvdGhlciByZWZlcmVuY2VzXG4gKi9cbmNvbnN0IFJFRl9DSEVDS19JTlRFUlZBTCA9IDEwMDAwO1xuY2xhc3MgU3ViY2hhbm5lbFBvb2wge1xuICAgIC8qKlxuICAgICAqIEEgcG9vbCBvZiBzdWJjaGFubmVscyB1c2UgZm9yIG1ha2luZyBjb25uZWN0aW9ucy4gU3ViY2hhbm5lbHMgd2l0aCB0aGVcbiAgICAgKiBleGFjdCBzYW1lIHBhcmFtZXRlcnMgd2lsbCBiZSByZXVzZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucG9vbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHRpbWVyIG9mIGEgdGFzayBwZXJmb3JtaW5nIGEgcGVyaW9kaWMgc3ViY2hhbm5lbCBjbGVhbnVwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlZnMgYWxsIHVudXNlZCBzdWJjaGFubmVscyBhbmQgY2FuY2VscyB0aGUgY2xlYW51cCB0YXNrIGlmIGFsbFxuICAgICAqIHN1YmNoYW5uZWxzIGhhdmUgYmVlbiB1bnJlZmVkLlxuICAgICAqL1xuICAgIHVucmVmVW51c2VkU3ViY2hhbm5lbHMoKSB7XG4gICAgICAgIGxldCBhbGxTdWJjaGFubmVsc1VucmVmZWQgPSB0cnVlO1xuICAgICAgICAvKiBUaGVzZSBvYmplY3RzIGFyZSBjcmVhdGVkIHdpdGggT2JqZWN0LmNyZWF0ZShudWxsKSwgc28gdGhleSBkbyBub3RcbiAgICAgICAgICogaGF2ZSBhIHByb3RvdHlwZSwgd2hpY2ggbWVhbnMgdGhhdCBmb3IgKC4uLiBpbiAuLi4pIGxvb3BzIG92ZXIgdGhlbVxuICAgICAgICAgKiBkbyBub3QgbmVlZCB0byBiZSBmaWx0ZXJlZCAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1kaXNhYmxlLW5leHQtbGluZTpmb3JpblxuICAgICAgICBmb3IgKGNvbnN0IGNoYW5uZWxUYXJnZXQgaW4gdGhpcy5wb29sKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsT2JqQXJyYXkgPSB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF07XG4gICAgICAgICAgICBjb25zdCByZWZlZFN1YmNoYW5uZWxzID0gc3ViY2hhbm5lbE9iakFycmF5LmZpbHRlcih2YWx1ZSA9PiAhdmFsdWUuc3ViY2hhbm5lbC51bnJlZklmT25lUmVmKCkpO1xuICAgICAgICAgICAgaWYgKHJlZmVkU3ViY2hhbm5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFsbFN1YmNoYW5uZWxzVW5yZWZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogRm9yIGVhY2ggc3ViY2hhbm5lbCBpbiB0aGUgcG9vbCwgdHJ5IHRvIHVucmVmIGl0IGlmIGl0IGhhc1xuICAgICAgICAgICAgICogZXhhY3RseSBvbmUgcmVmICh3aGljaCBpcyB0aGUgcmVmIGZyb20gdGhlIHBvb2wgaXRzZWxmKS4gSWYgdGhhdFxuICAgICAgICAgICAgICogZG9lcyBoYXBwZW4sIHJlbW92ZSB0aGUgc3ViY2hhbm5lbCBmcm9tIHRoZSBwb29sICovXG4gICAgICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0gPSByZWZlZFN1YmNoYW5uZWxzO1xuICAgICAgICB9XG4gICAgICAgIC8qIEN1cnJlbnRseSB3ZSBkbyBub3QgZGVsZXRlIGtleXMgd2l0aCBlbXB0eSB2YWx1ZXMuIElmIHRoYXQgcmVzdWx0c1xuICAgICAgICAgKiBpbiBzaWduaWZpY2FudCBtZW1vcnkgdXNhZ2Ugd2Ugc2hvdWxkIGNoYW5nZSBpdC4gKi9cbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBjbGVhbnVwIHRhc2sgaWYgYWxsIHN1YmNoYW5uZWxzIGhhdmUgYmVlbiB1bnJlZmVkLlxuICAgICAgICBpZiAoYWxsU3ViY2hhbm5lbHNVbnJlZmVkICYmIHRoaXMuY2xlYW51cFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGNsZWFudXAgdGFzayBpcyBzcGF3bmVkLlxuICAgICAqL1xuICAgIGVuc3VyZUNsZWFudXBUYXNrKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudW5yZWZVbnVzZWRTdWJjaGFubmVscygpO1xuICAgICAgICAgICAgfSwgUkVGX0NIRUNLX0lOVEVSVkFMKTtcbiAgICAgICAgICAgIC8vIFVucmVmIGJlY2F1c2UgdGhpcyB0aW1lciBzaG91bGQgbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgcnVubmluZy5cbiAgICAgICAgICAgIC8vIENhbGwgdW5yZWYgb25seSBpZiBpdCBleGlzdHMgdG8gYWRkcmVzcyBlbGVjdHJvbi9lbGVjdHJvbiMyMTE2MlxuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jbGVhbnVwVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc3ViY2hhbm5lbCBpZiBvbmUgYWxyZWFkeSBleGlzdHMgd2l0aCBleGFjdGx5IG1hdGNoaW5nIHBhcmFtZXRlcnMuXG4gICAgICogT3RoZXJ3aXNlLCBjcmVhdGUgYW5kIHNhdmUgYSBzdWJjaGFubmVsIHdpdGggdGhvc2UgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbFRhcmdldFxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsVGFyZ2V0XG4gICAgICogQHBhcmFtIGNoYW5uZWxBcmd1bWVudHNcbiAgICAgKiBAcGFyYW0gY2hhbm5lbENyZWRlbnRpYWxzXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVTdWJjaGFubmVsKGNoYW5uZWxUYXJnZXRVcmksIHN1YmNoYW5uZWxUYXJnZXQsIGNoYW5uZWxBcmd1bWVudHMsIGNoYW5uZWxDcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmVuc3VyZUNsZWFudXBUYXNrKCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxUYXJnZXQgPSAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKShjaGFubmVsVGFyZ2V0VXJpKTtcbiAgICAgICAgaWYgKGNoYW5uZWxUYXJnZXQgaW4gdGhpcy5wb29sKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsT2JqQXJyYXkgPSB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxPYmogb2Ygc3ViY2hhbm5lbE9iakFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc0VxdWFsKShzdWJjaGFubmVsVGFyZ2V0LCBzdWJjaGFubmVsT2JqLnN1YmNoYW5uZWxBZGRyZXNzKSAmJlxuICAgICAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbF9vcHRpb25zXzEuY2hhbm5lbE9wdGlvbnNFcXVhbCkoY2hhbm5lbEFyZ3VtZW50cywgc3ViY2hhbm5lbE9iai5jaGFubmVsQXJndW1lbnRzKSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ3JlZGVudGlhbHMuX2VxdWFscyhzdWJjaGFubmVsT2JqLmNoYW5uZWxDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWxPYmouc3ViY2hhbm5lbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIG5vIG1hdGNoaW5nIHN1YmNoYW5uZWwgd2FzIGZvdW5kXG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWwgPSBuZXcgc3ViY2hhbm5lbF8xLlN1YmNoYW5uZWwoY2hhbm5lbFRhcmdldFVyaSwgc3ViY2hhbm5lbFRhcmdldCwgY2hhbm5lbEFyZ3VtZW50cywgY2hhbm5lbENyZWRlbnRpYWxzLCBuZXcgdHJhbnNwb3J0XzEuSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXRVcmkpKTtcbiAgICAgICAgaWYgKCEoY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpKSB7XG4gICAgICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0ucHVzaCh7XG4gICAgICAgICAgICBzdWJjaGFubmVsQWRkcmVzczogc3ViY2hhbm5lbFRhcmdldCxcbiAgICAgICAgICAgIGNoYW5uZWxBcmd1bWVudHMsXG4gICAgICAgICAgICBjaGFubmVsQ3JlZGVudGlhbHMsXG4gICAgICAgICAgICBzdWJjaGFubmVsLFxuICAgICAgICB9KTtcbiAgICAgICAgc3ViY2hhbm5lbC5yZWYoKTtcbiAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWw7XG4gICAgfVxufVxuZXhwb3J0cy5TdWJjaGFubmVsUG9vbCA9IFN1YmNoYW5uZWxQb29sO1xuY29uc3QgZ2xvYmFsU3ViY2hhbm5lbFBvb2wgPSBuZXcgU3ViY2hhbm5lbFBvb2woKTtcbi8qKlxuICogR2V0IGVpdGhlciB0aGUgZ2xvYmFsIHN1YmNoYW5uZWwgcG9vbCwgb3IgYSBuZXcgc3ViY2hhbm5lbCBwb29sLlxuICogQHBhcmFtIGdsb2JhbFxuICovXG5mdW5jdGlvbiBnZXRTdWJjaGFubmVsUG9vbChnbG9iYWwpIHtcbiAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxTdWJjaGFubmVsUG9vbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ViY2hhbm5lbFBvb2woKTtcbiAgICB9XG59XG5leHBvcnRzLmdldFN1YmNoYW5uZWxQb29sID0gZ2V0U3ViY2hhbm5lbFBvb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLXBvb2wuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0U3ViY2hhbm5lbFBvb2wiLCJTdWJjaGFubmVsUG9vbCIsImNoYW5uZWxfb3B0aW9uc18xIiwicmVxdWlyZSIsInN1YmNoYW5uZWxfMSIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwidXJpX3BhcnNlcl8xIiwidHJhbnNwb3J0XzEiLCJSRUZfQ0hFQ0tfSU5URVJWQUwiLCJjb25zdHJ1Y3RvciIsInBvb2wiLCJjcmVhdGUiLCJjbGVhbnVwVGltZXIiLCJ1bnJlZlVudXNlZFN1YmNoYW5uZWxzIiwiYWxsU3ViY2hhbm5lbHNVbnJlZmVkIiwiY2hhbm5lbFRhcmdldCIsInN1YmNoYW5uZWxPYmpBcnJheSIsInJlZmVkU3ViY2hhbm5lbHMiLCJmaWx0ZXIiLCJzdWJjaGFubmVsIiwidW5yZWZJZk9uZVJlZiIsImxlbmd0aCIsImNsZWFySW50ZXJ2YWwiLCJlbnN1cmVDbGVhbnVwVGFzayIsIl9hIiwiX2IiLCJzZXRJbnRlcnZhbCIsInVucmVmIiwiY2FsbCIsImdldE9yQ3JlYXRlU3ViY2hhbm5lbCIsImNoYW5uZWxUYXJnZXRVcmkiLCJzdWJjaGFubmVsVGFyZ2V0IiwiY2hhbm5lbEFyZ3VtZW50cyIsImNoYW5uZWxDcmVkZW50aWFscyIsInVyaVRvU3RyaW5nIiwic3ViY2hhbm5lbE9iaiIsInN1YmNoYW5uZWxBZGRyZXNzRXF1YWwiLCJzdWJjaGFubmVsQWRkcmVzcyIsImNoYW5uZWxPcHRpb25zRXF1YWwiLCJfZXF1YWxzIiwiU3ViY2hhbm5lbCIsIkh0dHAyU3ViY2hhbm5lbENvbm5lY3RvciIsInB1c2giLCJyZWYiLCJnbG9iYWxTdWJjaGFubmVsUG9vbCIsImdsb2JhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Subchannel = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst TRACER_NAME = \"subchannel\";\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */ const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nclass Subchannel {\n    /**\n     * A class representing a connection to a single backend.\n     * @param channelTarget The target string for the channel as a whole\n     * @param subchannelAddress The address for the backend that this subchannel\n     *     will connect to\n     * @param options The channel options, plus any specific subchannel options\n     *     for this subchannel\n     * @param credentials The channel credentials used to establish this\n     *     connection\n     */ constructor(channelTarget, subchannelAddress, options, credentials, connector){\n        var _a;\n        this.channelTarget = channelTarget;\n        this.subchannelAddress = subchannelAddress;\n        this.options = options;\n        this.credentials = credentials;\n        this.connector = connector;\n        /**\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n         */ this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The underlying http2 session used to make requests.\n         */ this.transport = null;\n        /**\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n         * CONNECTING instead of IDLE when the backoff timeout ends.\n         */ this.continueConnecting = false;\n        /**\n         * A list of listener functions that will be called whenever the connectivity\n         * state changes. Will be modified by `addConnectivityStateListener` and\n         * `removeConnectivityStateListener`\n         */ this.stateListeners = new Set();\n        /**\n         * Tracks channels and subchannel pools with references to this subchannel\n         */ this.refcount = 0;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        // Channelz socket info\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        const backoffOptions = {\n            initialDelay: options[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: options[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(()=>{\n            this.handleBackoffTimer();\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        this.keepaliveTime = (_a = options[\"grpc.keepalive_time_ms\"]) !== null && _a !== void 0 ? _a : -1;\n        if (options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Subchannel created\");\n        }\n        this.trace(\"Subchannel constructed with options \" + JSON.stringify(options, undefined, 2));\n    }\n    getChannelzInfo() {\n        return {\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n            target: this.subchannelAddressString\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    refTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"subchannel_refcount\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    handleBackoffTimer() {\n        if (this.continueConnecting) {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.CONNECTING);\n        } else {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.IDLE);\n        }\n    }\n    /**\n     * Start a backoff timer with the current nextBackoff timeout\n     */ startBackoff() {\n        this.backoffTimeout.runOnce();\n    }\n    stopBackoff() {\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n    }\n    startConnectingInternal() {\n        let options = this.options;\n        if (options[\"grpc.keepalive_time_ms\"]) {\n            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n            options = Object.assign(Object.assign({}, options), {\n                \"grpc.keepalive_time_ms\": adjustedKeepaliveTime\n            });\n        }\n        this.connector.connect(this.subchannelAddress, this.credentials, options).then((transport)=>{\n            if (this.transitionToState([\n                connectivity_state_1.ConnectivityState.CONNECTING\n            ], connectivity_state_1.ConnectivityState.READY)) {\n                this.transport = transport;\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(transport.getChannelzRef());\n                }\n                transport.addDisconnectListener((tooManyPings)=>{\n                    this.transitionToState([\n                        connectivity_state_1.ConnectivityState.READY\n                    ], connectivity_state_1.ConnectivityState.IDLE);\n                    if (tooManyPings && this.keepaliveTime > 0) {\n                        this.keepaliveTime *= 2;\n                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\n                    }\n                });\n            }\n        }, (error)=>{\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.CONNECTING\n            ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);\n        });\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */ transitionToState(oldStates, newState, errorMessage) {\n        var _a, _b;\n        if (oldStates.indexOf(this.connectivityState) === -1) {\n            return false;\n        }\n        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Connectivity state change to \" + connectivity_state_1.ConnectivityState[newState]);\n        }\n        const previousState = this.connectivityState;\n        this.connectivityState = newState;\n        switch(newState){\n            case connectivity_state_1.ConnectivityState.READY:\n                this.stopBackoff();\n                break;\n            case connectivity_state_1.ConnectivityState.CONNECTING:\n                this.startBackoff();\n                this.startConnectingInternal();\n                this.continueConnecting = false;\n                break;\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\n                this.transport = null;\n                /* If the backoff timer has already ended by the time we get to the\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */ if (!this.backoffTimeout.isRunning()) {\n                    process.nextTick(()=>{\n                        this.handleBackoffTimer();\n                    });\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.IDLE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\n                this.transport = null;\n                break;\n            default:\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n        }\n        for (const listener of this.stateListeners){\n            listener(this, previousState, newState, this.keepaliveTime, errorMessage);\n        }\n        return true;\n    }\n    ref() {\n        this.refTrace(\"refcount \" + this.refcount + \" -> \" + (this.refcount + 1));\n        this.refcount += 1;\n    }\n    unref() {\n        this.refTrace(\"refcount \" + this.refcount + \" -> \" + (this.refcount - 1));\n        this.refcount -= 1;\n        if (this.refcount === 0) {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Shutting down\");\n            }\n            if (this.channelzEnabled) {\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            }\n            process.nextTick(()=>{\n                this.transitionToState([\n                    connectivity_state_1.ConnectivityState.CONNECTING,\n                    connectivity_state_1.ConnectivityState.READY\n                ], connectivity_state_1.ConnectivityState.IDLE);\n            });\n        }\n    }\n    unrefIfOneRef() {\n        if (this.refcount === 1) {\n            this.unref();\n            return true;\n        }\n        return false;\n    }\n    createCall(metadata, host, method, listener) {\n        if (!this.transport) {\n            throw new Error(\"Cannot create call, subchannel not READY\");\n        }\n        let statsTracker;\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            this.streamTracker.addCallStarted();\n            statsTracker = {\n                onCallEnd: (status)=>{\n                    if (status.code === constants_1.Status.OK) {\n                        this.callTracker.addCallSucceeded();\n                    } else {\n                        this.callTracker.addCallFailed();\n                    }\n                }\n            };\n        } else {\n            statsTracker = {};\n        }\n        return this.transport.createCall(metadata, host, method, listener, statsTracker);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */ startConnecting() {\n        process.nextTick(()=>{\n            /* First, try to transition from IDLE to connecting. If that doesn't happen\n             * because the state is not currently IDLE, check if it is\n             * TRANSIENT_FAILURE, and if so indicate that it should go back to\n             * connecting after the backoff timer ends. Otherwise do nothing */ if (!this.transitionToState([\n                connectivity_state_1.ConnectivityState.IDLE\n            ], connectivity_state_1.ConnectivityState.CONNECTING)) {\n                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    this.continueConnecting = true;\n                }\n            }\n        });\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */ getConnectivityState() {\n        return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */ addConnectivityStateListener(listener) {\n        this.stateListeners.add(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */ removeConnectivityStateListener(listener) {\n        this.stateListeners.delete(listener);\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */ resetBackoff() {\n        process.nextTick(()=>{\n            this.backoffTimeout.reset();\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.CONNECTING);\n        });\n    }\n    getAddress() {\n        return this.subchannelAddressString;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getRealSubchannel() {\n        return this;\n    }\n    realSubchannelEquals(other) {\n        return other.getRealSubchannel() === this;\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n        }\n    }\n}\nexports.Subchannel = Subchannel; //# sourceMappingURL=subchannel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHLEtBQUs7QUFDMUIsTUFBTUcsdUJBQXVCQyxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUMsb0JBQW9CRCxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTUcsY0FBY0gsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUksZUFBZUosbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTUssdUJBQXVCTCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTU0sYUFBYU4sbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTU8sY0FBYztBQUNwQjs7bUJBRW1CLEdBQ25CLE1BQU1DLHdCQUF3QixDQUFFLE1BQUssRUFBQztBQUN0QyxNQUFNVjtJQUNGOzs7Ozs7Ozs7S0FTQyxHQUNEVyxZQUFZQyxhQUFhLEVBQUVDLGlCQUFpQixFQUFFQyxPQUFPLEVBQUVDLFdBQVcsRUFBRUMsU0FBUyxDQUFFO1FBQzNFLElBQUlDO1FBQ0osSUFBSSxDQUFDTCxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdBO1FBQ3pCLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakI7OztTQUdDLEdBQ0QsSUFBSSxDQUFDRSxpQkFBaUIsR0FBR2pCLHFCQUFxQmtCLGlCQUFpQixDQUFDQyxJQUFJO1FBQ3BFOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakI7OztTQUdDLEdBQ0QsSUFBSSxDQUFDQyxr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Q3JGLElBQUksQ0FBQ3hDLGtCQUFrQixHQUFHO2dCQUM5QjtZQUNKO1FBQ0o7SUFDSjtJQUNBOztLQUVDLEdBQ0Q2Rix1QkFBdUI7UUFDbkIsT0FBTyxJQUFJLENBQUNqRyxpQkFBaUI7SUFDakM7SUFDQTs7OztLQUlDLEdBQ0RrRyw2QkFBNkJuQixRQUFRLEVBQUU7UUFDbkMsSUFBSSxDQUFDMUUsY0FBYyxDQUFDOEYsR0FBRyxDQUFDcEI7SUFDNUI7SUFDQTs7OztLQUlDLEdBQ0RxQixnQ0FBZ0NyQixRQUFRLEVBQUU7UUFDdEMsSUFBSSxDQUFDMUUsY0FBYyxDQUFDZ0csTUFBTSxDQUFDdEI7SUFDL0I7SUFDQTs7S0FFQyxHQUNEdUIsZUFBZTtRQUNYMUIsT0FBT0EsQ0FBQ0MsUUFBUSxDQUFDO1lBQ2IsSUFBSSxDQUFDNUQsY0FBYyxDQUFDaUMsS0FBSztZQUN6QixJQUFJLENBQUNQLGlCQUFpQixDQUFDO2dCQUFDNUQscUJBQXFCa0IsaUJBQWlCLENBQUMyQyxpQkFBaUI7YUFBQyxFQUFFN0QscUJBQXFCa0IsaUJBQWlCLENBQUM0QyxVQUFVO1FBQ3hJO0lBQ0o7SUFDQTBELGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ2xGLHVCQUF1QjtJQUN2QztJQUNBdUMsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUNsQyxXQUFXO0lBQzNCO0lBQ0E4RSxvQkFBb0I7UUFDaEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMscUJBQXFCQyxLQUFLLEVBQUU7UUFDeEIsT0FBT0EsTUFBTUYsaUJBQWlCLE9BQU8sSUFBSTtJQUM3QztJQUNBRyxrQkFBa0JDLGdCQUFnQixFQUFFO1FBQ2hDLElBQUlBLG1CQUFtQixJQUFJLENBQUNyRixhQUFhLEVBQUU7WUFDdkMsSUFBSSxDQUFDQSxhQUFhLEdBQUdxRjtRQUN6QjtJQUNKO0FBQ0o7QUFDQWhJLGtCQUFrQixHQUFHRSxZQUNyQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLmpzPzg4NzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3ViY2hhbm5lbCA9IHZvaWQgMDtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc3ViY2hhbm5lbCc7XG4vKiBzZXRJbnRlcnZhbCBhbmQgc2V0VGltZW91dCBvbmx5IGFjY2VwdCBzaWduZWQgMzIgYml0IGludGVnZXJzLiBKUyBkb2Vzbid0XG4gKiBoYXZlIGEgY29uc3RhbnQgZm9yIHRoZSBtYXggc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLCBzbyB0aGlzIGlzIGEgc2ltcGxlIHdheVxuICogdG8gY2FsY3VsYXRlIGl0ICovXG5jb25zdCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMgPSB+KDEgPDwgMzEpO1xuY2xhc3MgU3ViY2hhbm5lbCB7XG4gICAgLyoqXG4gICAgICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBjb25uZWN0aW9uIHRvIGEgc2luZ2xlIGJhY2tlbmQuXG4gICAgICogQHBhcmFtIGNoYW5uZWxUYXJnZXQgVGhlIHRhcmdldCBzdHJpbmcgZm9yIHRoZSBjaGFubmVsIGFzIGEgd2hvbGVcbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbEFkZHJlc3MgVGhlIGFkZHJlc3MgZm9yIHRoZSBiYWNrZW5kIHRoYXQgdGhpcyBzdWJjaGFubmVsXG4gICAgICogICAgIHdpbGwgY29ubmVjdCB0b1xuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjaGFubmVsIG9wdGlvbnMsIHBsdXMgYW55IHNwZWNpZmljIHN1YmNoYW5uZWwgb3B0aW9uc1xuICAgICAqICAgICBmb3IgdGhpcyBzdWJjaGFubmVsXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxzIFRoZSBjaGFubmVsIGNyZWRlbnRpYWxzIHVzZWQgdG8gZXN0YWJsaXNoIHRoaXNcbiAgICAgKiAgICAgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxUYXJnZXQsIHN1YmNoYW5uZWxBZGRyZXNzLCBvcHRpb25zLCBjcmVkZW50aWFscywgY29ubmVjdG9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5jaGFubmVsVGFyZ2V0ID0gY2hhbm5lbFRhcmdldDtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzcyA9IHN1YmNoYW5uZWxBZGRyZXNzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN1YmNoYW5uZWwncyBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZS4gSW52YXJpYW50OiBgc2Vzc2lvbmAgPT09IGBudWxsYFxuICAgICAgICAgKiBpZiBhbmQgb25seSBpZiBgY29ubmVjdGl2aXR5U3RhdGVgIGlzIElETEUgb3IgVFJBTlNJRU5UX0ZBSUxVUkUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmRlcmx5aW5nIGh0dHAyIHNlc3Npb24gdXNlZCB0byBtYWtlIHJlcXVlc3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHN1YmNoYW5uZWwgc2hvdWxkIHRyYW5zaXRpb24gZnJvbSBUUkFOU0lFTlRfRkFJTFVSRSB0b1xuICAgICAgICAgKiBDT05ORUNUSU5HIGluc3RlYWQgb2YgSURMRSB3aGVuIHRoZSBiYWNrb2ZmIHRpbWVvdXQgZW5kcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGludWVDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIGNvbm5lY3Rpdml0eVxuICAgICAgICAgKiBzdGF0ZSBjaGFuZ2VzLiBXaWxsIGJlIG1vZGlmaWVkIGJ5IGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYCBhbmRcbiAgICAgICAgICogYHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tzIGNoYW5uZWxzIGFuZCBzdWJjaGFubmVsIHBvb2xzIHdpdGggcmVmZXJlbmNlcyB0byB0aGlzIHN1YmNoYW5uZWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVmY291bnQgPSAwO1xuICAgICAgICAvLyBDaGFubmVseiBpbmZvXG4gICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxsVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICAvLyBDaGFubmVseiBzb2NrZXQgaW5mb1xuICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBvcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBvcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0ID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmFja29mZlRpbWVyKCk7XG4gICAgICAgIH0sIGJhY2tvZmZPcHRpb25zKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC51bnJlZigpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKHN1YmNoYW5uZWxBZGRyZXNzKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gKF9hID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTtcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwpKHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcsICgpID0+IHRoaXMuZ2V0Q2hhbm5lbHpJbmZvKCksIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU3ViY2hhbm5lbCBjcmVhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnU3ViY2hhbm5lbCBjb25zdHJ1Y3RlZCB3aXRoIG9wdGlvbnMgJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShvcHRpb25zLCB1bmRlZmluZWQsIDIpKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY29ubmVjdGl2aXR5U3RhdGUsXG4gICAgICAgICAgICB0cmFjZTogdGhpcy5jaGFubmVselRyYWNlLFxuICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpLFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAgcmVmVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ3N1YmNoYW5uZWxfcmVmY291bnQnLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICBoYW5kbGVCYWNrb2ZmVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRpbnVlQ29ubmVjdGluZykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBiYWNrb2ZmIHRpbWVyIHdpdGggdGhlIGN1cnJlbnQgbmV4dEJhY2tvZmYgdGltZW91dFxuICAgICAqL1xuICAgIHN0YXJ0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5ydW5PbmNlKCk7XG4gICAgfVxuICAgIHN0b3BCYWNrb2ZmKCkge1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmdJbnRlcm5hbCgpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ10pIHtcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkS2VlcGFsaXZlVGltZSA9IE1hdGgubWluKHRoaXMua2VlcGFsaXZlVGltZSwgS0VFUEFMSVZFX01BWF9USU1FX01TKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7ICdncnBjLmtlZXBhbGl2ZV90aW1lX21zJzogYWRqdXN0ZWRLZWVwYWxpdmVUaW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdG9yXG4gICAgICAgICAgICAuY29ubmVjdCh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzLCB0aGlzLmNyZWRlbnRpYWxzLCBvcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4odHJhbnNwb3J0ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKHRyYW5zcG9ydC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmFkZERpc2Nvbm5lY3RMaXN0ZW5lcih0b29NYW55UGluZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vTWFueVBpbmdzICYmIHRoaXMua2VlcGFsaXZlVGltZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSAqPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgQ29ubmVjdGlvbiB0byAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMuY2hhbm5lbFRhcmdldCl9IGF0ICR7dGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZ30gcmVqZWN0ZWQgYnkgc2VydmVyIGJlY2F1c2Ugb2YgZXhjZXNzIHBpbmdzLiBJbmNyZWFzaW5nIHBpbmcgaW50ZXJ2YWwgdG8gJHt0aGlzLmtlZXBhbGl2ZVRpbWV9IG1zYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR10sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBgJHtlcnJvcn1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgc3RhdGUgdHJhbnNpdGlvbiBmcm9tIGFueSBlbGVtZW50IG9mIG9sZFN0YXRlcyB0byB0aGUgbmV3XG4gICAgICogc3RhdGUuIElmIHRoZSBjdXJyZW50IGNvbm5lY3Rpdml0eVN0YXRlIGlzIG5vdCBpbiBvbGRTdGF0ZXMsIGRvIG5vdGhpbmcuXG4gICAgICogQHBhcmFtIG9sZFN0YXRlcyBUaGUgc2V0IG9mIHN0YXRlcyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICAgKiBAcGFyYW0gbmV3U3RhdGUgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdGF0ZSBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uVG9TdGF0ZShvbGRTdGF0ZXMsIG5ld1N0YXRlLCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKG9sZFN0YXRlcy5pbmRleE9mKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UgdG8gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgc3dpdGNoIChuZXdTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWTpcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BCYWNrb2ZmKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZ0ludGVybmFsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkICYmIHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQodGhpcy50cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIGJhY2tvZmYgdGltZXIgaGFzIGFscmVhZHkgZW5kZWQgYnkgdGhlIHRpbWUgd2UgZ2V0IHRvIHRoZVxuICAgICAgICAgICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFIHN0YXRlLCB3ZSB3YW50IHRvIGltbWVkaWF0ZWx5IHRyYW5zaXRpb24gb3V0IG9mXG4gICAgICAgICAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUgYXMgdGhvdWdoIHRoZSBiYWNrb2ZmIHRpbWVyIGlzIGVuZGluZyByaWdodCBub3cgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmFja29mZlRpbWVvdXQuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJhY2tvZmZUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkICYmIHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQodGhpcy50cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZTogdW5rbm93biBDb25uZWN0aXZpdHlTdGF0ZSAke25ld1N0YXRlfWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIHRoaXMua2VlcGFsaXZlVGltZSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVmKCkge1xuICAgICAgICB0aGlzLnJlZlRyYWNlKCdyZWZjb3VudCAnICsgdGhpcy5yZWZjb3VudCArICcgLT4gJyArICh0aGlzLnJlZmNvdW50ICsgMSkpO1xuICAgICAgICB0aGlzLnJlZmNvdW50ICs9IDE7XG4gICAgfVxuICAgIHVucmVmKCkge1xuICAgICAgICB0aGlzLnJlZlRyYWNlKCdyZWZjb3VudCAnICsgdGhpcy5yZWZjb3VudCArICcgLT4gJyArICh0aGlzLnJlZmNvdW50IC0gMSkpO1xuICAgICAgICB0aGlzLnJlZmNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLnJlZmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU2h1dHRpbmcgZG93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKSh0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnJlZklmT25lUmVmKCkge1xuICAgICAgICBpZiAodGhpcy5yZWZjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy51bnJlZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsKG1ldGFkYXRhLCBob3N0LCBtZXRob2QsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBjYWxsLCBzdWJjaGFubmVsIG5vdCBSRUFEWScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0c1RyYWNrZXI7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgICAgICBzdGF0c1RyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgb25DYWxsRW5kOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdHNUcmFja2VyID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmNyZWF0ZUNhbGwobWV0YWRhdGEsIGhvc3QsIG1ldGhvZCwgbGlzdGVuZXIsIHN0YXRzVHJhY2tlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzdWJjaGFubmVsIGlzIGN1cnJlbnRseSBJRExFLCBzdGFydCBjb25uZWN0aW5nIGFuZCBzd2l0Y2ggdG8gdGhlXG4gICAgICogQ09OTkVDVElORyBzdGF0ZS4gSWYgdGhlIHN1YmNoYW5uZWwgaXMgY3VycmVudCBpbiBUUkFOU0lFTlRfRkFJTFVSRSxcbiAgICAgKiB0aGUgbmV4dCB0aW1lIGl0IHdvdWxkIHRyYW5zaXRpb24gdG8gSURMRSwgc3RhcnQgY29ubmVjdGluZyBhZ2FpbiBpbnN0ZWFkLlxuICAgICAqIE90aGVyd2lzZSwgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgLyogRmlyc3QsIHRyeSB0byB0cmFuc2l0aW9uIGZyb20gSURMRSB0byBjb25uZWN0aW5nLiBJZiB0aGF0IGRvZXNuJ3QgaGFwcGVuXG4gICAgICAgICAgICAgKiBiZWNhdXNlIHRoZSBzdGF0ZSBpcyBub3QgY3VycmVudGx5IElETEUsIGNoZWNrIGlmIGl0IGlzXG4gICAgICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRSwgYW5kIGlmIHNvIGluZGljYXRlIHRoYXQgaXQgc2hvdWxkIGdvIGJhY2sgdG9cbiAgICAgICAgICAgICAqIGNvbm5lY3RpbmcgYWZ0ZXIgdGhlIGJhY2tvZmYgdGltZXIgZW5kcy4gT3RoZXJ3aXNlIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVDb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN1YmNoYW5uZWwncyBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZS5cbiAgICAgKi9cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc3ViY2hhbm5lbCdzXG4gICAgICogY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIHByZXZpb3VzbHkgYWRkZWQgd2l0aCBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQSByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHBhc3NlZCB0b1xuICAgICAqICAgICBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKi9cbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGJhY2tvZmYgdGltZW91dCwgYW5kIGltbWVkaWF0ZWx5IHN0YXJ0IGNvbm5lY3RpbmcgaWYgaW4gYmFja29mZi5cbiAgICAgKi9cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nO1xuICAgIH1cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XG4gICAgfVxuICAgIGdldFJlYWxTdWJjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVhbFN1YmNoYW5uZWxFcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLmdldFJlYWxTdWJjaGFubmVsKCkgPT09IHRoaXM7XG4gICAgfVxuICAgIHRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpIHtcbiAgICAgICAgaWYgKG5ld0tlZXBhbGl2ZVRpbWUgPiB0aGlzLmtlZXBhbGl2ZVRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IG5ld0tlZXBhbGl2ZVRpbWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlN1YmNoYW5uZWwgPSBTdWJjaGFubmVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdWJjaGFubmVsIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJyZXF1aXJlIiwiYmFja29mZl90aW1lb3V0XzEiLCJsb2dnaW5nIiwiY29uc3RhbnRzXzEiLCJ1cmlfcGFyc2VyXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsImNoYW5uZWx6XzEiLCJUUkFDRVJfTkFNRSIsIktFRVBBTElWRV9NQVhfVElNRV9NUyIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbFRhcmdldCIsInN1YmNoYW5uZWxBZGRyZXNzIiwib3B0aW9ucyIsImNyZWRlbnRpYWxzIiwiY29ubmVjdG9yIiwiX2EiLCJjb25uZWN0aXZpdHlTdGF0ZSIsIkNvbm5lY3Rpdml0eVN0YXRlIiwiSURMRSIsInRyYW5zcG9ydCIsImNvbnRpbnVlQ29ubmVjdGluZyIsInN0YXRlTGlzdGVuZXJzIiwiU2V0IiwicmVmY291bnQiLCJjaGFubmVsekVuYWJsZWQiLCJjYWxsVHJhY2tlciIsIkNoYW5uZWx6Q2FsbFRyYWNrZXIiLCJjaGlsZHJlblRyYWNrZXIiLCJDaGFubmVsekNoaWxkcmVuVHJhY2tlciIsInN0cmVhbVRyYWNrZXIiLCJiYWNrb2ZmT3B0aW9ucyIsImluaXRpYWxEZWxheSIsIm1heERlbGF5IiwiYmFja29mZlRpbWVvdXQiLCJCYWNrb2ZmVGltZW91dCIsImhhbmRsZUJhY2tvZmZUaW1lciIsInVucmVmIiwic3ViY2hhbm5lbEFkZHJlc3NTdHJpbmciLCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nIiwia2VlcGFsaXZlVGltZSIsImNoYW5uZWx6VHJhY2UiLCJDaGFubmVselRyYWNlIiwiY2hhbm5lbHpSZWYiLCJyZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCIsImdldENoYW5uZWx6SW5mbyIsImFkZFRyYWNlIiwidHJhY2UiLCJKU09OIiwic3RyaW5naWZ5IiwidW5kZWZpbmVkIiwic3RhdGUiLCJjaGlsZHJlbiIsImdldENoaWxkTGlzdHMiLCJ0YXJnZXQiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJpZCIsInJlZlRyYWNlIiwidHJhbnNpdGlvblRvU3RhdGUiLCJUUkFOU0lFTlRfRkFJTFVSRSIsIkNPTk5FQ1RJTkciLCJzdGFydEJhY2tvZmYiLCJydW5PbmNlIiwic3RvcEJhY2tvZmYiLCJzdG9wIiwicmVzZXQiLCJzdGFydENvbm5lY3RpbmdJbnRlcm5hbCIsImFkanVzdGVkS2VlcGFsaXZlVGltZSIsIk1hdGgiLCJtaW4iLCJhc3NpZ24iLCJjb25uZWN0IiwidGhlbiIsIlJFQURZIiwicmVmQ2hpbGQiLCJnZXRDaGFubmVselJlZiIsImFkZERpc2Nvbm5lY3RMaXN0ZW5lciIsInRvb01hbnlQaW5ncyIsImxvZyIsIkVSUk9SIiwidXJpVG9TdHJpbmciLCJlcnJvciIsIm9sZFN0YXRlcyIsIm5ld1N0YXRlIiwiZXJyb3JNZXNzYWdlIiwiX2IiLCJpbmRleE9mIiwicHJldmlvdXNTdGF0ZSIsInVucmVmQ2hpbGQiLCJzaHV0ZG93biIsImlzUnVubmluZyIsInByb2Nlc3MiLCJuZXh0VGljayIsIkVycm9yIiwibGlzdGVuZXIiLCJyZWYiLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJ1bnJlZklmT25lUmVmIiwiY3JlYXRlQ2FsbCIsIm1ldGFkYXRhIiwiaG9zdCIsIm1ldGhvZCIsInN0YXRzVHJhY2tlciIsImFkZENhbGxTdGFydGVkIiwib25DYWxsRW5kIiwic3RhdHVzIiwiY29kZSIsIlN0YXR1cyIsIk9LIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsImFkZENhbGxGYWlsZWQiLCJzdGFydENvbm5lY3RpbmciLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsImFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJhZGQiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwiZGVsZXRlIiwicmVzZXRCYWNrb2ZmIiwiZ2V0QWRkcmVzcyIsImdldFJlYWxTdWJjaGFubmVsIiwicmVhbFN1YmNoYW5uZWxFcXVhbHMiLCJvdGhlciIsInRocm90dGxlS2VlcGFsaXZlIiwibmV3S2VlcGFsaXZlVGltZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/tls-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDefaultRootsData = exports.CIPHER_SUITES = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\nlet defaultRootsData = null;\nfunction getDefaultRootsData() {\n    if (DEFAULT_ROOTS_FILE_PATH) {\n        if (defaultRootsData === null) {\n            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\n        }\n        return defaultRootsData;\n    }\n    return null;\n}\nexports.getDefaultRootsData = getDefaultRootsData; //# sourceMappingURL=tls-helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUMzRCxNQUFNSSxLQUFLQyxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCTCxxQkFBcUIsR0FBR00sT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxzQkFBc0I7QUFDMUQsTUFBTUMsMEJBQTBCSCxPQUFPQSxDQUFDQyxHQUFHLENBQUNHLGdDQUFnQztBQUM1RSxJQUFJQyxtQkFBbUI7QUFDdkIsU0FBU1Q7SUFDTCxJQUFJTyx5QkFBeUI7UUFDekIsSUFBSUUscUJBQXFCLE1BQU07WUFDM0JBLG1CQUFtQlAsR0FBR1EsWUFBWSxDQUFDSDtRQUN2QztRQUNBLE9BQU9FO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQVgsMkJBQTJCLEdBQUdFLHFCQUM5Qix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy90bHMtaGVscGVycy5qcz8wZWQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERlZmF1bHRSb290c0RhdGEgPSBleHBvcnRzLkNJUEhFUl9TVUlURVMgPSB2b2lkIDA7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmV4cG9ydHMuQ0lQSEVSX1NVSVRFUyA9IHByb2Nlc3MuZW52LkdSUENfU1NMX0NJUEhFUl9TVUlURVM7XG5jb25zdCBERUZBVUxUX1JPT1RTX0ZJTEVfUEFUSCA9IHByb2Nlc3MuZW52LkdSUENfREVGQVVMVF9TU0xfUk9PVFNfRklMRV9QQVRIO1xubGV0IGRlZmF1bHRSb290c0RhdGEgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFJvb3RzRGF0YSgpIHtcbiAgICBpZiAoREVGQVVMVF9ST09UU19GSUxFX1BBVEgpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRSb290c0RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRSb290c0RhdGEgPSBmcy5yZWFkRmlsZVN5bmMoREVGQVVMVF9ST09UU19GSUxFX1BBVEgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Um9vdHNEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZ2V0RGVmYXVsdFJvb3RzRGF0YSA9IGdldERlZmF1bHRSb290c0RhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10bHMtaGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXREZWZhdWx0Um9vdHNEYXRhIiwiQ0lQSEVSX1NVSVRFUyIsImZzIiwicmVxdWlyZSIsInByb2Nlc3MiLCJlbnYiLCJHUlBDX1NTTF9DSVBIRVJfU1VJVEVTIiwiREVGQVVMVF9ST09UU19GSUxFX1BBVEgiLCJHUlBDX0RFRkFVTFRfU1NMX1JPT1RTX0ZJTEVfUEFUSCIsImRlZmF1bHRSb290c0RhdGEiLCJyZWFkRmlsZVN5bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/transport.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2SubchannelConnector = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst subchannel_call_1 = __webpack_require__(/*! ./subchannel-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst TRACER_NAME = \"transport\";\nconst FLOW_CONTROL_TRACER_NAME = \"transport_flowctrl\";\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst tooManyPingsData = Buffer.from(\"too_many_pings\", \"ascii\");\nclass Http2Transport {\n    constructor(session, subchannelAddress, options, /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */ remoteName){\n        this.session = session;\n        this.remoteName = remoteName;\n        /**\n         * The amount of time in between sending pings\n         */ this.keepaliveTimeMs = -1;\n        /**\n         * The amount of time to wait for an acknowledgement after sending a ping\n         */ this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n        /**\n         * Timer reference for timeout that indicates when to send the next ping\n         */ this.keepaliveTimerId = null;\n        /**\n         * Indicates that the keepalive timer ran out while there were no active\n         * calls, and a ping should be sent the next time a call starts.\n         */ this.pendingSendKeepalivePing = false;\n        /**\n         * Timer reference tracking when the most recent ping will be considered lost\n         */ this.keepaliveTimeoutId = null;\n        /**\n         * Indicates whether keepalive pings should be sent without any active calls\n         */ this.keepaliveWithoutCalls = false;\n        this.activeCalls = new Set();\n        this.disconnectListeners = [];\n        this.disconnectHandled = false;\n        this.channelzEnabled = true;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n        /* Populate subchannelAddressString and channelzRef before doing anything\n         * else, because they are used in the trace methods. */ this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        if (options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        // Build user-agent string.\n        this.userAgent = [\n            options[\"grpc.primary_user_agent\"],\n            `grpc-node-js/${clientVersion}`,\n            options[\"grpc.secondary_user_agent\"]\n        ].filter((e)=>e).join(\" \"); // remove falsey values first\n        if (\"grpc.keepalive_time_ms\" in options) {\n            this.keepaliveTimeMs = options[\"grpc.keepalive_time_ms\"];\n        }\n        if (\"grpc.keepalive_timeout_ms\" in options) {\n            this.keepaliveTimeoutMs = options[\"grpc.keepalive_timeout_ms\"];\n        }\n        if (\"grpc.keepalive_permit_without_calls\" in options) {\n            this.keepaliveWithoutCalls = options[\"grpc.keepalive_permit_without_calls\"] === 1;\n        } else {\n            this.keepaliveWithoutCalls = false;\n        }\n        session.once(\"close\", ()=>{\n            this.trace(\"session closed\");\n            this.stopKeepalivePings();\n            this.handleDisconnect();\n        });\n        session.once(\"goaway\", (errorCode, lastStreamID, opaqueData)=>{\n            let tooManyPings = false;\n            /* See the last paragraph of\n             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */ if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData && opaqueData.equals(tooManyPingsData)) {\n                tooManyPings = true;\n            }\n            this.trace(\"connection closed by GOAWAY with code \" + errorCode + \" and data \" + (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));\n            this.reportDisconnectToOwner(tooManyPings);\n        });\n        session.once(\"error\", (error)=>{\n            /* Do nothing here. Any error should also trigger a close event, which is\n             * where we want to handle that.  */ this.trace(\"connection closed with error \" + error.message);\n        });\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            session.on(\"remoteSettings\", (settings)=>{\n                this.trace(\"new settings received\" + (this.session !== session ? \" on the old connection\" : \"\") + \": \" + JSON.stringify(settings));\n            });\n            session.on(\"localSettings\", (settings)=>{\n                this.trace(\"local settings acknowledged by remote\" + (this.session !== session ? \" on the old connection\" : \"\") + \": \" + JSON.stringify(settings));\n            });\n        }\n        /* Start the keepalive timer last, because this can trigger trace logs,\n         * which should only happen after everything else is set up. */ if (this.keepaliveWithoutCalls) {\n            this.maybeStartKeepalivePingTimer();\n        }\n    }\n    getChannelzInfo() {\n        var _a, _b, _c;\n        const sessionSocket = this.session.socket;\n        const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n        const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n        let tlsInfo;\n        if (this.session.encrypted) {\n            const tlsSocket = sessionSocket;\n            const cipherInfo = tlsSocket.getCipher();\n            const certificate = tlsSocket.getCertificate();\n            const peerCertificate = tlsSocket.getPeerCertificate();\n            tlsInfo = {\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                localCertificate: certificate && \"raw\" in certificate ? certificate.raw : null,\n                remoteCertificate: peerCertificate && \"raw\" in peerCertificate ? peerCertificate.raw : null\n            };\n        } else {\n            tlsInfo = null;\n        }\n        const socketInfo = {\n            remoteAddress: remoteAddress,\n            localAddress: localAddress,\n            security: tlsInfo,\n            remoteName: this.remoteName,\n            streamsStarted: this.streamTracker.callsStarted,\n            streamsSucceeded: this.streamTracker.callsSucceeded,\n            streamsFailed: this.streamTracker.callsFailed,\n            messagesSent: this.messagesSent,\n            messagesReceived: this.messagesReceived,\n            keepAlivesSent: this.keepalivesSent,\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n            lastRemoteStreamCreatedTimestamp: null,\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n        };\n        return socketInfo;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    keepaliveTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"keepalive\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    flowControlTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    internalsTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"transport_internals\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    /**\n     * Indicate to the owner of this object that this transport should no longer\n     * be used. That happens if the connection drops, or if the server sends a\n     * GOAWAY.\n     * @param tooManyPings If true, this was triggered by a GOAWAY with data\n     * indicating that the session was closed becaues the client sent too many\n     * pings.\n     * @returns\n     */ reportDisconnectToOwner(tooManyPings) {\n        if (this.disconnectHandled) {\n            return;\n        }\n        this.disconnectHandled = true;\n        this.disconnectListeners.forEach((listener)=>listener(tooManyPings));\n    }\n    /**\n     * Handle connection drops, but not GOAWAYs.\n     */ handleDisconnect() {\n        this.reportDisconnectToOwner(false);\n        /* Give calls an event loop cycle to finish naturally before reporting the\n         * disconnnection to them. */ setImmediate(()=>{\n            for (const call of this.activeCalls){\n                call.onDisconnect();\n            }\n        });\n    }\n    addDisconnectListener(listener) {\n        this.disconnectListeners.push(listener);\n    }\n    clearKeepaliveTimer() {\n        if (!this.keepaliveTimerId) {\n            return;\n        }\n        clearTimeout(this.keepaliveTimerId);\n        this.keepaliveTimerId = null;\n    }\n    clearKeepaliveTimeout() {\n        if (!this.keepaliveTimeoutId) {\n            return;\n        }\n        clearTimeout(this.keepaliveTimeoutId);\n        this.keepaliveTimeoutId = null;\n    }\n    canSendPing() {\n        return this.keepaliveTimeMs > 0 && (this.keepaliveWithoutCalls || this.activeCalls.size > 0);\n    }\n    maybeSendPing() {\n        var _a, _b;\n        this.clearKeepaliveTimer();\n        if (!this.canSendPing()) {\n            this.pendingSendKeepalivePing = true;\n            return;\n        }\n        if (this.channelzEnabled) {\n            this.keepalivesSent += 1;\n        }\n        this.keepaliveTrace(\"Sending ping with timeout \" + this.keepaliveTimeoutMs + \"ms\");\n        if (!this.keepaliveTimeoutId) {\n            this.keepaliveTimeoutId = setTimeout(()=>{\n                this.keepaliveTrace(\"Ping timeout passed without response\");\n                this.handleDisconnect();\n            }, this.keepaliveTimeoutMs);\n            (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n        try {\n            this.session.ping((err, duration, payload)=>{\n                if (err) {\n                    this.keepaliveTrace(\"Ping failed with error \" + err.message);\n                    this.handleDisconnect();\n                }\n                this.keepaliveTrace(\"Received ping response\");\n                this.clearKeepaliveTimeout();\n                this.maybeStartKeepalivePingTimer();\n            });\n        } catch (e) {\n            /* If we fail to send a ping, the connection is no longer functional, so\n             * we should discard it. */ this.handleDisconnect();\n        }\n    }\n    /**\n     * Starts the keepalive ping timer if appropriate. If the timer already ran\n     * out while there were no active requests, instead send a ping immediately.\n     * If the ping timer is already running or a ping is currently in flight,\n     * instead do nothing and wait for them to resolve.\n     */ maybeStartKeepalivePingTimer() {\n        var _a, _b;\n        if (!this.canSendPing()) {\n            return;\n        }\n        if (this.pendingSendKeepalivePing) {\n            this.pendingSendKeepalivePing = false;\n            this.maybeSendPing();\n        } else if (!this.keepaliveTimerId && !this.keepaliveTimeoutId) {\n            this.keepaliveTrace(\"Starting keepalive timer for \" + this.keepaliveTimeMs + \"ms\");\n            this.keepaliveTimerId = (_b = (_a = setTimeout(()=>{\n                this.maybeSendPing();\n            }, this.keepaliveTimeMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    /* Otherwise, there is already either a keepalive timer or a ping pending,\n         * wait for those to resolve. */ }\n    stopKeepalivePings() {\n        if (this.keepaliveTimerId) {\n            clearTimeout(this.keepaliveTimerId);\n            this.keepaliveTimerId = null;\n        }\n        this.clearKeepaliveTimeout();\n    }\n    removeActiveCall(call) {\n        this.activeCalls.delete(call);\n        if (this.activeCalls.size === 0) {\n            this.session.unref();\n        }\n    }\n    addActiveCall(call) {\n        this.activeCalls.add(call);\n        if (this.activeCalls.size === 1) {\n            this.session.ref();\n            if (!this.keepaliveWithoutCalls) {\n                this.maybeStartKeepalivePingTimer();\n            }\n        }\n    }\n    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\n        const headers = metadata.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = host;\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = \"application/grpc\";\n        headers[HTTP2_HEADER_METHOD] = \"POST\";\n        headers[HTTP2_HEADER_PATH] = method;\n        headers[HTTP2_HEADER_TE] = \"trailers\";\n        let http2Stream;\n        /* In theory, if an error is thrown by session.request because session has\n         * become unusable (e.g. because it has received a goaway), this subchannel\n         * should soon see the corresponding close or goaway event anyway and leave\n         * READY. But we have seen reports that this does not happen\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n         * so for defense in depth, we just discard the session when we see an\n         * error here.\n         */ try {\n            http2Stream = this.session.request(headers);\n        } catch (e) {\n            this.handleDisconnect();\n            throw e;\n        }\n        this.flowControlTrace(\"local window size: \" + this.session.state.localWindowSize + \" remote window size: \" + this.session.state.remoteWindowSize);\n        this.internalsTrace(\"session.closed=\" + this.session.closed + \" session.destroyed=\" + this.session.destroyed + \" session.socket.destroyed=\" + this.session.socket.destroyed);\n        let eventTracker;\n        // eslint-disable-next-line prefer-const\n        let call;\n        if (this.channelzEnabled) {\n            this.streamTracker.addCallStarted();\n            eventTracker = {\n                addMessageSent: ()=>{\n                    var _a;\n                    this.messagesSent += 1;\n                    this.lastMessageSentTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: ()=>{\n                    var _a;\n                    this.messagesReceived += 1;\n                    this.lastMessageReceivedTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: (status)=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: (success)=>{\n                    var _a;\n                    if (success) {\n                        this.streamTracker.addCallSucceeded();\n                    } else {\n                        this.streamTracker.addCallFailed();\n                    }\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                }\n            };\n        } else {\n            eventTracker = {\n                addMessageSent: ()=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: ()=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: (status)=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: (success)=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                }\n            };\n        }\n        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n        this.addActiveCall(call);\n        return call;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getPeerName() {\n        return this.subchannelAddressString;\n    }\n    shutdown() {\n        this.session.close();\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n    }\n}\nclass Http2SubchannelConnector {\n    constructor(channelTarget){\n        this.channelTarget = channelTarget;\n        this.session = null;\n        this.isShutdown = false;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + \" \" + text);\n    }\n    createSession(address, credentials, options, proxyConnectionResult) {\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        return new Promise((resolve, reject)=>{\n            var _a, _b, _c;\n            let remoteName;\n            if (proxyConnectionResult.realTarget) {\n                remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);\n                this.trace(\"creating HTTP/2 session through proxy to \" + (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));\n            } else {\n                remoteName = null;\n                this.trace(\"creating HTTP/2 session to \" + (0, subchannel_address_1.subchannelAddressToString)(address));\n            }\n            const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n            let connectionOptions = credentials._getConnectionOptions() || {};\n            connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n            if (\"grpc-node.max_session_memory\" in options) {\n                connectionOptions.maxSessionMemory = options[\"grpc-node.max_session_memory\"];\n            } else {\n                /* By default, set a very large max session memory limit, to effectively\n                 * disable enforcement of the limit. Some testing indicates that Node's\n                 * behavior degrades badly when this limit is reached, so we solve that\n                 * by disabling the check entirely. */ connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n            }\n            let addressScheme = \"http://\";\n            if (\"secureContext\" in connectionOptions) {\n                addressScheme = \"https://\";\n                // If provided, the value of grpc.ssl_target_name_override should be used\n                // to override the target hostname when checking server identity.\n                // This option is used for testing only.\n                if (options[\"grpc.ssl_target_name_override\"]) {\n                    const sslTargetNameOverride = options[\"grpc.ssl_target_name_override\"];\n                    connectionOptions.checkServerIdentity = (host, cert)=>{\n                        return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n                    };\n                    connectionOptions.servername = sslTargetNameOverride;\n                } else {\n                    const authorityHostname = (_c = (_b = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : \"localhost\";\n                    // We want to always set servername to support SNI\n                    connectionOptions.servername = authorityHostname;\n                }\n                if (proxyConnectionResult.socket) {\n                    /* This is part of the workaround for\n                     * https://github.com/nodejs/node/issues/32922. Without that bug,\n                     * proxyConnectionResult.socket would always be a plaintext socket and\n                     * this would say\n                     * connectionOptions.socket = proxyConnectionResult.socket; */ connectionOptions.createConnection = (authority, option)=>{\n                        return proxyConnectionResult.socket;\n                    };\n                }\n            } else {\n                /* In all but the most recent versions of Node, http2.connect does not use\n                 * the options when establishing plaintext connections, so we need to\n                 * establish that connection explicitly. */ connectionOptions.createConnection = (authority, option)=>{\n                    if (proxyConnectionResult.socket) {\n                        return proxyConnectionResult.socket;\n                    } else {\n                        /* net.NetConnectOpts is declared in a way that is more restrictive\n                         * than what net.connect will actually accept, so we use the type\n                         * assertion to work around that. */ return net.connect(address);\n                    }\n                };\n            }\n            connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), {\n                enableTrace: options[\"grpc-node.tls_enable_trace\"] === 1\n            });\n            /* http2.connect uses the options here:\n             * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n             * The spread operator overides earlier values with later ones, so any port\n             * or host values in the options will be used rather than any values extracted\n             * from the first argument. In addition, the path overrides the host and port,\n             * as documented for plaintext connections here:\n             * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n             * and for TLS connections here:\n             * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n             * earlier versions of Node, http2.connect passes these options to\n             * tls.connect but not net.connect, so in the insecure case we still need\n             * to set the createConnection option above to create the connection\n             * explicitly. We cannot do that in the TLS case because http2.connect\n             * passes necessary additional options to tls.connect.\n             * The first argument just needs to be parseable as a URL and the scheme\n             * determines whether the connection will be established over TLS or not.\n             */ const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n            this.session = session;\n            let errorMessage = \"Failed to connect\";\n            session.unref();\n            session.once(\"connect\", ()=>{\n                session.removeAllListeners();\n                resolve(new Http2Transport(session, address, options, remoteName));\n                this.session = null;\n            });\n            session.once(\"close\", ()=>{\n                this.session = null;\n                // Leave time for error event to happen before rejecting\n                setImmediate(()=>{\n                    reject(`${errorMessage} (${new Date().toISOString()})`);\n                });\n            });\n            session.once(\"error\", (error)=>{\n                errorMessage = error.message;\n                this.trace(\"connection failed with error \" + errorMessage);\n            });\n        });\n    }\n    connect(address, credentials, options) {\n        var _a, _b;\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        /* Pass connection options through to the proxy so that it's able to\n         * upgrade it's connection to support tls if needed.\n         * This is a workaround for https://github.com/nodejs/node/issues/32922\n         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */ const connectionOptions = credentials._getConnectionOptions() || {};\n        if (\"secureContext\" in connectionOptions) {\n            connectionOptions.ALPNProtocols = [\n                \"h2\"\n            ];\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (options[\"grpc.ssl_target_name_override\"]) {\n                const sslTargetNameOverride = options[\"grpc.ssl_target_name_override\"];\n                connectionOptions.checkServerIdentity = (host, cert)=>{\n                    return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            } else {\n                if (\"grpc.http_connect_target\" in options) {\n                    /* This is more or less how servername will be set in createSession\n                     * if a connection is successfully established through the proxy.\n                     * If the proxy is not used, these connectionOptions are discarded\n                     * anyway */ const targetPath = (0, resolver_1.getDefaultAuthority)((_a = (0, uri_parser_1.parseUri)(options[\"grpc.http_connect_target\"])) !== null && _a !== void 0 ? _a : {\n                        path: \"localhost\"\n                    });\n                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n                    connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n                }\n            }\n            if (options[\"grpc-node.tls_enable_trace\"]) {\n                connectionOptions.enableTrace = true;\n            }\n        }\n        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then((result)=>this.createSession(address, credentials, options, result));\n    }\n    shutdown() {\n        var _a;\n        this.isShutdown = true;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\n        this.session = null;\n    }\n}\nexports.Http2SubchannelConnector = Http2SubchannelConnector; //# sourceMappingURL=transport.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0NBQWdDLEdBQUcsS0FBSztBQUN4QyxNQUFNRyxRQUFRQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNSSxlQUFlSixtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTSxhQUFhTixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNTyx1QkFBdUJQLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNUSxlQUFlUixtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNUyxNQUFNVCxtQkFBT0EsQ0FBQyxnQkFBSztBQUN6QixNQUFNVSxvQkFBb0JWLG1CQUFPQSxDQUFDLDBGQUFtQjtBQUNyRCxNQUFNVyxnQkFBZ0JYLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLE1BQU1ZLGNBQWM7QUFDcEIsTUFBTUMsMkJBQTJCO0FBQ2pDLE1BQU1DLGdCQUFnQmQsMEdBQXFDO0FBQzNELE1BQU0sRUFBRWdCLHNCQUFzQixFQUFFQyx5QkFBeUIsRUFBRUMsbUJBQW1CLEVBQUVDLGlCQUFpQixFQUFFQyxlQUFlLEVBQUVDLHVCQUF1QixFQUFHLEdBQUd0QixNQUFNdUIsU0FBUztBQUNoSyxNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsbUJBQW1CQyxNQUFNQSxDQUFDQyxJQUFJLENBQUMsa0JBQWtCO0FBQ3ZELE1BQU1DO0lBQ0ZDLFlBQVlDLE9BQU8sRUFB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LElBQUksQ0FBQ25ELE9BQU8sTUFBTSxRQUFRbUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHcUcsS0FBSztRQUNqRSxJQUFJLENBQUN4SixPQUFPLEdBQUc7SUFDbkI7QUFDSjtBQUNBakMsZ0NBQWdDLEdBQUdFLDBCQUNuQyxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3RydWN0ZXBhcGVyc192Mi8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy90cmFuc3BvcnQuanM/NmIwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDb25uZWN0b3IgPSB2b2lkIDA7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcbmNvbnN0IHRsc18xID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgaHR0cF9wcm94eV8xID0gcmVxdWlyZShcIi4vaHR0cF9wcm94eVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbmV0ID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfY2FsbF8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1jYWxsXCIpO1xuY29uc3QgY2FsbF9udW1iZXJfMSA9IHJlcXVpcmUoXCIuL2NhbGwtbnVtYmVyXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAndHJhbnNwb3J0JztcbmNvbnN0IEZMT1dfQ09OVFJPTF9UUkFDRVJfTkFNRSA9ICd0cmFuc3BvcnRfZmxvd2N0cmwnO1xuY29uc3QgY2xpZW50VmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5jb25zdCB7IEhUVFAyX0hFQURFUl9BVVRIT1JJVFksIEhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUsIEhUVFAyX0hFQURFUl9NRVRIT0QsIEhUVFAyX0hFQURFUl9QQVRILCBIVFRQMl9IRUFERVJfVEUsIEhUVFAyX0hFQURFUl9VU0VSX0FHRU5ULCB9ID0gaHR0cDIuY29uc3RhbnRzO1xuY29uc3QgS0VFUEFMSVZFX1RJTUVPVVRfTVMgPSAyMDAwMDtcbmNvbnN0IHRvb01hbnlQaW5nc0RhdGEgPSBCdWZmZXIuZnJvbSgndG9vX21hbnlfcGluZ3MnLCAnYXNjaWknKTtcbmNsYXNzIEh0dHAyVHJhbnNwb3J0IHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uLCBzdWJjaGFubmVsQWRkcmVzcywgb3B0aW9ucywgXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgcmVtb3RlIHNlcnZlciwgaWYgaXQgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBzdWJjaGFubmVsXG4gICAgICogYWRkcmVzcywgaS5lLiBpZiBjb25uZWN0aW5nIHRocm91Z2ggYW4gSFRUUCBDT05ORUNUIHByb3h5LlxuICAgICAqL1xuICAgIHJlbW90ZU5hbWUpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5yZW1vdGVOYW1lID0gcmVtb3RlTmFtZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBiZXR3ZWVuIHNlbmRpbmcgcGluZ3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IGFmdGVyIHNlbmRpbmcgYSBwaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9IEtFRVBBTElWRV9USU1FT1VUX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGltZXIgcmVmZXJlbmNlIGZvciB0aW1lb3V0IHRoYXQgaW5kaWNhdGVzIHdoZW4gdG8gc2VuZCB0aGUgbmV4dCBwaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVySWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIGtlZXBhbGl2ZSB0aW1lciByYW4gb3V0IHdoaWxlIHRoZXJlIHdlcmUgbm8gYWN0aXZlXG4gICAgICAgICAqIGNhbGxzLCBhbmQgYSBwaW5nIHNob3VsZCBiZSBzZW50IHRoZSBuZXh0IHRpbWUgYSBjYWxsIHN0YXJ0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lciByZWZlcmVuY2UgdHJhY2tpbmcgd2hlbiB0aGUgbW9zdCByZWNlbnQgcGluZyB3aWxsIGJlIGNvbnNpZGVyZWQgbG9zdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIga2VlcGFsaXZlIHBpbmdzIHNob3VsZCBiZSBzZW50IHdpdGhvdXQgYW55IGFjdGl2ZSBjYWxsc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYWxscyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdEhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlc1NlbnQgPSAwO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzU2VudCA9IDA7XG4gICAgICAgIHRoaXMubWVzc2FnZXNSZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgLyogUG9wdWxhdGUgc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgYW5kIGNoYW5uZWx6UmVmIGJlZm9yZSBkb2luZyBhbnl0aGluZ1xuICAgICAgICAgKiBlbHNlLCBiZWNhdXNlIHRoZXkgYXJlIHVzZWQgaW4gdGhlIHRyYWNlIG1ldGhvZHMuICovXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgPSAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoc3ViY2hhbm5lbEFkZHJlc3MpO1xuICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCkodGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZywgKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAvLyBCdWlsZCB1c2VyLWFnZW50IHN0cmluZy5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQgPSBbXG4gICAgICAgICAgICBvcHRpb25zWydncnBjLnByaW1hcnlfdXNlcl9hZ2VudCddLFxuICAgICAgICAgICAgYGdycGMtbm9kZS1qcy8ke2NsaWVudFZlcnNpb259YCxcbiAgICAgICAgICAgIG9wdGlvbnNbJ2dycGMuc2Vjb25kYXJ5X3VzZXJfYWdlbnQnXSxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUpXG4gICAgICAgICAgICAuam9pbignICcpOyAvLyByZW1vdmUgZmFsc2V5IHZhbHVlcyBmaXJzdFxuICAgICAgICBpZiAoJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5rZWVwYWxpdmVfdGltZW91dF9tcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgPVxuICAgICAgICAgICAgICAgIG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3Blcm1pdF93aXRob3V0X2NhbGxzJ10gPT09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNlc3Npb24ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdzZXNzaW9uIGNsb3NlZCcpO1xuICAgICAgICAgICAgdGhpcy5zdG9wS2VlcGFsaXZlUGluZ3MoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdnb2F3YXknLCAoZXJyb3JDb2RlLCBsYXN0U3RyZWFtSUQsIG9wYXF1ZURhdGEpID0+IHtcbiAgICAgICAgICAgIGxldCB0b29NYW55UGluZ3MgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qIFNlZSB0aGUgbGFzdCBwYXJhZ3JhcGggb2ZcbiAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0E4LWNsaWVudC1zaWRlLWtlZXBhbGl2ZS5tZCNiYXNpYy1rZWVwYWxpdmUgKi9cbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09IGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0VOSEFOQ0VfWU9VUl9DQUxNICYmXG4gICAgICAgICAgICAgICAgb3BhcXVlRGF0YSAmJlxuICAgICAgICAgICAgICAgIG9wYXF1ZURhdGEuZXF1YWxzKHRvb01hbnlQaW5nc0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgdG9vTWFueVBpbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkIGJ5IEdPQVdBWSB3aXRoIGNvZGUgJyArIGVycm9yQ29kZSArICcgYW5kIGRhdGEgJyArIChvcGFxdWVEYXRhID09PSBudWxsIHx8IG9wYXF1ZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wYXF1ZURhdGEudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnREaXNjb25uZWN0VG9Pd25lcih0b29NYW55UGluZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICAgIC8qIERvIG5vdGhpbmcgaGVyZS4gQW55IGVycm9yIHNob3VsZCBhbHNvIHRyaWdnZXIgYSBjbG9zZSBldmVudCwgd2hpY2ggaXNcbiAgICAgICAgICAgICAqIHdoZXJlIHdlIHdhbnQgdG8gaGFuZGxlIHRoYXQuICAqL1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBlcnJvciAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobG9nZ2luZy5pc1RyYWNlckVuYWJsZWQoVFJBQ0VSX05BTUUpKSB7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKCdyZW1vdGVTZXR0aW5ncycsIChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ25ldyBzZXR0aW5ncyByZWNlaXZlZCcgK1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5zZXNzaW9uICE9PSBzZXNzaW9uID8gJyBvbiB0aGUgb2xkIGNvbm5lY3Rpb24nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlc3Npb24ub24oJ2xvY2FsU2V0dGluZ3MnLCAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdsb2NhbCBzZXR0aW5ncyBhY2tub3dsZWRnZWQgYnkgcmVtb3RlJyArXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnNlc3Npb24gIT09IHNlc3Npb24gPyAnIG9uIHRoZSBvbGQgY29ubmVjdGlvbicgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qIFN0YXJ0IHRoZSBrZWVwYWxpdmUgdGltZXIgbGFzdCwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyIHRyYWNlIGxvZ3MsXG4gICAgICAgICAqIHdoaWNoIHNob3VsZCBvbmx5IGhhcHBlbiBhZnRlciBldmVyeXRoaW5nIGVsc2UgaXMgc2V0IHVwLiAqL1xuICAgICAgICBpZiAodGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMpIHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENoYW5uZWx6SW5mbygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHNlc3Npb25Tb2NrZXQgPSB0aGlzLnNlc3Npb24uc29ja2V0O1xuICAgICAgICBjb25zdCByZW1vdGVBZGRyZXNzID0gc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzXG4gICAgICAgICAgICA/ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKShzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3MsIHNlc3Npb25Tb2NrZXQucmVtb3RlUG9ydClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgY29uc3QgbG9jYWxBZGRyZXNzID0gc2Vzc2lvblNvY2tldC5sb2NhbEFkZHJlc3NcbiAgICAgICAgICAgID8gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MpKHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzLCBzZXNzaW9uU29ja2V0LmxvY2FsUG9ydClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgbGV0IHRsc0luZm87XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB0bHNTb2NrZXQgPSBzZXNzaW9uU29ja2V0O1xuICAgICAgICAgICAgY29uc3QgY2lwaGVySW5mbyA9IHRsc1NvY2tldC5nZXRDaXBoZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldENlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBwZWVyQ2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICB0bHNJbmZvID0ge1xuICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlU3RhbmRhcmROYW1lOiAoX2EgPSBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZU90aGVyTmFtZTogY2lwaGVySW5mby5zdGFuZGFyZE5hbWUgPyBudWxsIDogY2lwaGVySW5mby5uYW1lLFxuICAgICAgICAgICAgICAgIGxvY2FsQ2VydGlmaWNhdGU6IGNlcnRpZmljYXRlICYmICdyYXcnIGluIGNlcnRpZmljYXRlID8gY2VydGlmaWNhdGUucmF3IDogbnVsbCxcbiAgICAgICAgICAgICAgICByZW1vdGVDZXJ0aWZpY2F0ZTogcGVlckNlcnRpZmljYXRlICYmICdyYXcnIGluIHBlZXJDZXJ0aWZpY2F0ZVxuICAgICAgICAgICAgICAgICAgICA/IHBlZXJDZXJ0aWZpY2F0ZS5yYXdcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRsc0luZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldEluZm8gPSB7XG4gICAgICAgICAgICByZW1vdGVBZGRyZXNzOiByZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbEFkZHJlc3MsXG4gICAgICAgICAgICBzZWN1cml0eTogdGxzSW5mbyxcbiAgICAgICAgICAgIHJlbW90ZU5hbWU6IHRoaXMucmVtb3RlTmFtZSxcbiAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgc3RyZWFtc1N1Y2NlZWRlZDogdGhpcy5zdHJlYW1UcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgc3RyZWFtc0ZhaWxlZDogdGhpcy5zdHJlYW1UcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbWVzc2FnZXNTZW50OiB0aGlzLm1lc3NhZ2VzU2VudCxcbiAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IHRoaXMubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiB0aGlzLmtlZXBhbGl2ZXNTZW50LFxuICAgICAgICAgICAgbGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogdGhpcy5zdHJlYW1UcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiB0aGlzLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IChfYiA9IHRoaXMuc2Vzc2lvbi5zdGF0ZS5sb2NhbFdpbmRvd1NpemUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwsXG4gICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogKF9jID0gdGhpcy5zZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzb2NrZXRJbmZvO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAga2VlcGFsaXZlVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2tlZXBhbGl2ZScsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgdGV4dCk7XG4gICAgfVxuICAgIGZsb3dDb250cm9sVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgRkxPV19DT05UUk9MX1RSQUNFUl9OQU1FLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICBpbnRlcm5hbHNUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAndHJhbnNwb3J0X2ludGVybmFscycsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgdGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHRvIHRoZSBvd25lciBvZiB0aGlzIG9iamVjdCB0aGF0IHRoaXMgdHJhbnNwb3J0IHNob3VsZCBubyBsb25nZXJcbiAgICAgKiBiZSB1c2VkLiBUaGF0IGhhcHBlbnMgaWYgdGhlIGNvbm5lY3Rpb24gZHJvcHMsIG9yIGlmIHRoZSBzZXJ2ZXIgc2VuZHMgYVxuICAgICAqIEdPQVdBWS5cbiAgICAgKiBAcGFyYW0gdG9vTWFueVBpbmdzIElmIHRydWUsIHRoaXMgd2FzIHRyaWdnZXJlZCBieSBhIEdPQVdBWSB3aXRoIGRhdGFcbiAgICAgKiBpbmRpY2F0aW5nIHRoYXQgdGhlIHNlc3Npb24gd2FzIGNsb3NlZCBiZWNhdWVzIHRoZSBjbGllbnQgc2VudCB0b28gbWFueVxuICAgICAqIHBpbmdzLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcmVwb3J0RGlzY29ubmVjdFRvT3duZXIodG9vTWFueVBpbmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RIYW5kbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNjb25uZWN0SGFuZGxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKHRvb01hbnlQaW5ncykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgY29ubmVjdGlvbiBkcm9wcywgYnV0IG5vdCBHT0FXQVlzLlxuICAgICAqL1xuICAgIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RGlzY29ubmVjdFRvT3duZXIoZmFsc2UpO1xuICAgICAgICAvKiBHaXZlIGNhbGxzIGFuIGV2ZW50IGxvb3AgY3ljbGUgdG8gZmluaXNoIG5hdHVyYWxseSBiZWZvcmUgcmVwb3J0aW5nIHRoZVxuICAgICAgICAgKiBkaXNjb25ubmVjdGlvbiB0byB0aGVtLiAqL1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHRoaXMuYWN0aXZlQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICBjYWxsLm9uRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkRGlzY29ubmVjdExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgY2xlYXJLZWVwYWxpdmVUaW1lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtlZXBhbGl2ZVRpbWVySWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5rZWVwYWxpdmVUaW1lcklkKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lcklkID0gbnVsbDtcbiAgICB9XG4gICAgY2xlYXJLZWVwYWxpdmVUaW1lb3V0KCkge1xuICAgICAgICBpZiAoIXRoaXMua2VlcGFsaXZlVGltZW91dElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcGFsaXZlVGltZW91dElkKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICBjYW5TZW5kUGluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmtlZXBhbGl2ZVRpbWVNcyA+IDAgJiZcbiAgICAgICAgICAgICh0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyB8fCB0aGlzLmFjdGl2ZUNhbGxzLnNpemUgPiAwKSk7XG4gICAgfVxuICAgIG1heWJlU2VuZFBpbmcoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuY2xlYXJLZWVwYWxpdmVUaW1lcigpO1xuICAgICAgICBpZiAoIXRoaXMuY2FuU2VuZFBpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2VuZEtlZXBhbGl2ZVBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1NlbmRpbmcgcGluZyB3aXRoIHRpbWVvdXQgJyArIHRoaXMua2VlcGFsaXZlVGltZW91dE1zICsgJ21zJyk7XG4gICAgICAgIGlmICghdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyB0aW1lb3V0IHBhc3NlZCB3aXRob3V0IHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9LCB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyk7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnBpbmcoKGVyciwgZHVyYXRpb24sIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1BpbmcgZmFpbGVkIHdpdGggZXJyb3IgJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1JlY2VpdmVkIHBpbmcgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIElmIHdlIGZhaWwgdG8gc2VuZCBhIHBpbmcsIHRoZSBjb25uZWN0aW9uIGlzIG5vIGxvbmdlciBmdW5jdGlvbmFsLCBzb1xuICAgICAgICAgICAgICogd2Ugc2hvdWxkIGRpc2NhcmQgaXQuICovXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGtlZXBhbGl2ZSBwaW5nIHRpbWVyIGlmIGFwcHJvcHJpYXRlLiBJZiB0aGUgdGltZXIgYWxyZWFkeSByYW5cbiAgICAgKiBvdXQgd2hpbGUgdGhlcmUgd2VyZSBubyBhY3RpdmUgcmVxdWVzdHMsIGluc3RlYWQgc2VuZCBhIHBpbmcgaW1tZWRpYXRlbHkuXG4gICAgICogSWYgdGhlIHBpbmcgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIG9yIGEgcGluZyBpcyBjdXJyZW50bHkgaW4gZmxpZ2h0LFxuICAgICAqIGluc3RlYWQgZG8gbm90aGluZyBhbmQgd2FpdCBmb3IgdGhlbSB0byByZXNvbHZlLlxuICAgICAqL1xuICAgIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5jYW5TZW5kUGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tYXliZVNlbmRQaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMua2VlcGFsaXZlVGltZXJJZCAmJiAhdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1N0YXJ0aW5nIGtlZXBhbGl2ZSB0aW1lciBmb3IgJyArIHRoaXMua2VlcGFsaXZlVGltZU1zICsgJ21zJyk7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVySWQgPSAoX2IgPSAoX2EgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlU2VuZFBpbmcoKTtcbiAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZU1zKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBPdGhlcndpc2UsIHRoZXJlIGlzIGFscmVhZHkgZWl0aGVyIGEga2VlcGFsaXZlIHRpbWVyIG9yIGEgcGluZyBwZW5kaW5nLFxuICAgICAgICAgKiB3YWl0IGZvciB0aG9zZSB0byByZXNvbHZlLiAqL1xuICAgIH1cbiAgICBzdG9wS2VlcGFsaXZlUGluZ3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVRpbWVySWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBhbGl2ZVRpbWVySWQpO1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lcklkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xuICAgIH1cbiAgICByZW1vdmVBY3RpdmVDYWxsKGNhbGwpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVDYWxscy5kZWxldGUoY2FsbCk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUNhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi51bnJlZigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEFjdGl2ZUNhbGwoY2FsbCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUNhbGxzLmFkZChjYWxsKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2FsbHMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlZigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscykge1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUNhbGwobWV0YWRhdGEsIGhvc3QsIG1ldGhvZCwgbGlzdGVuZXIsIHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBtZXRhZGF0YS50b0h0dHAySGVhZGVycygpO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9BVVRIT1JJVFldID0gaG9zdDtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfVVNFUl9BR0VOVF0gPSB0aGlzLnVzZXJBZ2VudDtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFXSA9ICdhcHBsaWNhdGlvbi9ncnBjJztcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfTUVUSE9EXSA9ICdQT1NUJztcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfUEFUSF0gPSBtZXRob2Q7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX1RFXSA9ICd0cmFpbGVycyc7XG4gICAgICAgIGxldCBodHRwMlN0cmVhbTtcbiAgICAgICAgLyogSW4gdGhlb3J5LCBpZiBhbiBlcnJvciBpcyB0aHJvd24gYnkgc2Vzc2lvbi5yZXF1ZXN0IGJlY2F1c2Ugc2Vzc2lvbiBoYXNcbiAgICAgICAgICogYmVjb21lIHVudXNhYmxlIChlLmcuIGJlY2F1c2UgaXQgaGFzIHJlY2VpdmVkIGEgZ29hd2F5KSwgdGhpcyBzdWJjaGFubmVsXG4gICAgICAgICAqIHNob3VsZCBzb29uIHNlZSB0aGUgY29ycmVzcG9uZGluZyBjbG9zZSBvciBnb2F3YXkgZXZlbnQgYW55d2F5IGFuZCBsZWF2ZVxuICAgICAgICAgKiBSRUFEWS4gQnV0IHdlIGhhdmUgc2VlbiByZXBvcnRzIHRoYXQgdGhpcyBkb2VzIG5vdCBoYXBwZW5cbiAgICAgICAgICogKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL25vZGVqcy1maXJlc3RvcmUvaXNzdWVzLzEwMjMjaXNzdWVjb21tZW50LTY1MzIwNDA5NilcbiAgICAgICAgICogc28gZm9yIGRlZmVuc2UgaW4gZGVwdGgsIHdlIGp1c3QgZGlzY2FyZCB0aGUgc2Vzc2lvbiB3aGVuIHdlIHNlZSBhblxuICAgICAgICAgKiBlcnJvciBoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGh0dHAyU3RyZWFtID0gdGhpcy5zZXNzaW9uLnJlcXVlc3QoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsb3dDb250cm9sVHJhY2UoJ2xvY2FsIHdpbmRvdyBzaXplOiAnICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zdGF0ZS5sb2NhbFdpbmRvd1NpemUgK1xuICAgICAgICAgICAgJyByZW1vdGUgd2luZG93IHNpemU6ICcgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpO1xuICAgICAgICB0aGlzLmludGVybmFsc1RyYWNlKCdzZXNzaW9uLmNsb3NlZD0nICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5jbG9zZWQgK1xuICAgICAgICAgICAgJyBzZXNzaW9uLmRlc3Ryb3llZD0nICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5kZXN0cm95ZWQgK1xuICAgICAgICAgICAgJyBzZXNzaW9uLnNvY2tldC5kZXN0cm95ZWQ9JyArXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc29ja2V0LmRlc3Ryb3llZCk7XG4gICAgICAgIGxldCBldmVudFRyYWNrZXI7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgbGV0IGNhbGw7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgICAgICBldmVudFRyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVNlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzU2VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLmFkZE1lc3NhZ2VTZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhZGRNZXNzYWdlUmVjZWl2ZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzUmVjZWl2ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVJlY2VpdmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNhbGxFbmQ6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIub25DYWxsRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmVDYWxsKGNhbGwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TdHJlYW1FbmQ6IHN1Y2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vblN0cmVhbUVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIsIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZlbnRUcmFja2VyID0ge1xuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VTZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVNlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VSZWNlaXZlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLmFkZE1lc3NhZ2VSZWNlaXZlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25DYWxsRW5kOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uQ2FsbEVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlQ2FsbChjYWxsKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uU3RyZWFtRW5kOiBzdWNjZXNzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vblN0cmVhbUVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIsIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhbGwgPSBuZXcgc3ViY2hhbm5lbF9jYWxsXzEuSHR0cDJTdWJjaGFubmVsQ2FsbChodHRwMlN0cmVhbSwgZXZlbnRUcmFja2VyLCBsaXN0ZW5lciwgdGhpcywgKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCkpO1xuICAgICAgICB0aGlzLmFkZEFjdGl2ZUNhbGwoY2FsbCk7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XG4gICAgfVxuICAgIGdldFBlZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZztcbiAgICB9XG4gICAgc2h1dGRvd24oKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHRoaXMuY2hhbm5lbHpSZWYpO1xuICAgIH1cbn1cbmNsYXNzIEh0dHAyU3ViY2hhbm5lbENvbm5lY3RvciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbFRhcmdldCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxUYXJnZXQgPSBjaGFubmVsVGFyZ2V0O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICB0aGlzLmlzU2h1dGRvd24gPSBmYWxzZTtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMuY2hhbm5lbFRhcmdldCkgKyAnICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgY3JlYXRlU2Vzc2lvbihhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucywgcHJveHlDb25uZWN0aW9uUmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2h1dGRvd24pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGxldCByZW1vdGVOYW1lO1xuICAgICAgICAgICAgaWYgKHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlTmFtZSA9ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGluZyBIVFRQLzIgc2Vzc2lvbiB0aHJvdWdoIHByb3h5IHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKShwcm94eUNvbm5lY3Rpb25SZXN1bHQucmVhbFRhcmdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlTmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnY3JlYXRpbmcgSFRUUC8yIHNlc3Npb24gdG8gJyArICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBdXRob3JpdHkgPSAoMCwgcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KSgoX2EgPSBwcm94eUNvbm5lY3Rpb25SZXN1bHQucmVhbFRhcmdldCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5jaGFubmVsVGFyZ2V0KTtcbiAgICAgICAgICAgIGxldCBjb25uZWN0aW9uT3B0aW9ucyA9IGNyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHx8IHt9O1xuICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMubWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBpZiAoJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5tYXhTZXNzaW9uTWVtb3J5ID1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy1ub2RlLm1heF9zZXNzaW9uX21lbW9yeSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogQnkgZGVmYXVsdCwgc2V0IGEgdmVyeSBsYXJnZSBtYXggc2Vzc2lvbiBtZW1vcnkgbGltaXQsIHRvIGVmZmVjdGl2ZWx5XG4gICAgICAgICAgICAgICAgICogZGlzYWJsZSBlbmZvcmNlbWVudCBvZiB0aGUgbGltaXQuIFNvbWUgdGVzdGluZyBpbmRpY2F0ZXMgdGhhdCBOb2RlJ3NcbiAgICAgICAgICAgICAgICAgKiBiZWhhdmlvciBkZWdyYWRlcyBiYWRseSB3aGVuIHRoaXMgbGltaXQgaXMgcmVhY2hlZCwgc28gd2Ugc29sdmUgdGhhdFxuICAgICAgICAgICAgICAgICAqIGJ5IGRpc2FibGluZyB0aGUgY2hlY2sgZW50aXJlbHkuICovXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMubWF4U2Vzc2lvbk1lbW9yeSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFkZHJlc3NTY2hlbWUgPSAnaHR0cDovLyc7XG4gICAgICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1NjaGVtZSA9ICdodHRwczovLyc7XG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvdmlkZWQsIHRoZSB2YWx1ZSBvZiBncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgICAgICAgIC8vIHRvIG92ZXJyaWRlIHRoZSB0YXJnZXQgaG9zdG5hbWUgd2hlbiBjaGVja2luZyBzZXJ2ZXIgaWRlbnRpdHkuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBvcHRpb24gaXMgdXNlZCBmb3IgdGVzdGluZyBvbmx5LlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNzbFRhcmdldE5hbWVPdmVycmlkZSA9IG9wdGlvbnNbJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJ107XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPSAoaG9zdCwgY2VydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0bHNfMS5jaGVja1NlcnZlcklkZW50aXR5KShzc2xUYXJnZXROYW1lT3ZlcnJpZGUsIGNlcnQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gc3NsVGFyZ2V0TmFtZU92ZXJyaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXR5SG9zdG5hbWUgPSAoX2MgPSAoX2IgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRhcmdldEF1dGhvcml0eSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ob3N0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnbG9jYWxob3N0JztcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBhbHdheXMgc2V0IHNlcnZlcm5hbWUgdG8gc3VwcG9ydCBTTklcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IGF1dGhvcml0eUhvc3RuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGlzIHBhcnQgb2YgdGhlIHdvcmthcm91bmQgZm9yXG4gICAgICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzI5MjIuIFdpdGhvdXQgdGhhdCBidWcsXG4gICAgICAgICAgICAgICAgICAgICAqIHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQgd291bGQgYWx3YXlzIGJlIGEgcGxhaW50ZXh0IHNvY2tldCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICogdGhpcyB3b3VsZCBzYXlcbiAgICAgICAgICAgICAgICAgICAgICogY29ubmVjdGlvbk9wdGlvbnMuc29ja2V0ID0gcHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldDsgKi9cbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuY3JlYXRlQ29ubmVjdGlvbiA9IChhdXRob3JpdHksIG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogSW4gYWxsIGJ1dCB0aGUgbW9zdCByZWNlbnQgdmVyc2lvbnMgb2YgTm9kZSwgaHR0cDIuY29ubmVjdCBkb2VzIG5vdCB1c2VcbiAgICAgICAgICAgICAgICAgKiB0aGUgb3B0aW9ucyB3aGVuIGVzdGFibGlzaGluZyBwbGFpbnRleHQgY29ubmVjdGlvbnMsIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgKiBlc3RhYmxpc2ggdGhhdCBjb25uZWN0aW9uIGV4cGxpY2l0bHkuICovXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuY3JlYXRlQ29ubmVjdGlvbiA9IChhdXRob3JpdHksIG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBuZXQuTmV0Q29ubmVjdE9wdHMgaXMgZGVjbGFyZWQgaW4gYSB3YXkgdGhhdCBpcyBtb3JlIHJlc3RyaWN0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGFuIHdoYXQgbmV0LmNvbm5lY3Qgd2lsbCBhY3R1YWxseSBhY2NlcHQsIHNvIHdlIHVzZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogYXNzZXJ0aW9uIHRvIHdvcmsgYXJvdW5kIHRoYXQuICovXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV0LmNvbm5lY3QoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdGlvbk9wdGlvbnMpLCBhZGRyZXNzKSwgeyBlbmFibGVUcmFjZTogb3B0aW9uc1snZ3JwYy1ub2RlLnRsc19lbmFibGVfdHJhY2UnXSA9PT0gMSB9KTtcbiAgICAgICAgICAgIC8qIGh0dHAyLmNvbm5lY3QgdXNlcyB0aGUgb3B0aW9ucyBoZXJlOlxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvNzBjMzJhNmQxOTBlMmI1ZDdiOWZmOWQ1YjZhNDU5ZDE0ZThiN2Q1OS9saWIvaW50ZXJuYWwvaHR0cDIvY29yZS5qcyNMMzAyOC1MMzAzNlxuICAgICAgICAgICAgICogVGhlIHNwcmVhZCBvcGVyYXRvciBvdmVyaWRlcyBlYXJsaWVyIHZhbHVlcyB3aXRoIGxhdGVyIG9uZXMsIHNvIGFueSBwb3J0XG4gICAgICAgICAgICAgKiBvciBob3N0IHZhbHVlcyBpbiB0aGUgb3B0aW9ucyB3aWxsIGJlIHVzZWQgcmF0aGVyIHRoYW4gYW55IHZhbHVlcyBleHRyYWN0ZWRcbiAgICAgICAgICAgICAqIGZyb20gdGhlIGZpcnN0IGFyZ3VtZW50LiBJbiBhZGRpdGlvbiwgdGhlIHBhdGggb3ZlcnJpZGVzIHRoZSBob3N0IGFuZCBwb3J0LFxuICAgICAgICAgICAgICogYXMgZG9jdW1lbnRlZCBmb3IgcGxhaW50ZXh0IGNvbm5lY3Rpb25zIGhlcmU6XG4gICAgICAgICAgICAgKiBodHRwczovL25vZGVqcy5vcmcvYXBpL25ldC5odG1sI25ldF9zb2NrZXRfY29ubmVjdF9vcHRpb25zX2Nvbm5lY3RsaXN0ZW5lclxuICAgICAgICAgICAgICogYW5kIGZvciBUTFMgY29ubmVjdGlvbnMgaGVyZTpcbiAgICAgICAgICAgICAqIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGxzLmh0bWwjdGxzX3Rsc19jb25uZWN0X29wdGlvbnNfY2FsbGJhY2suIEluXG4gICAgICAgICAgICAgKiBlYXJsaWVyIHZlcnNpb25zIG9mIE5vZGUsIGh0dHAyLmNvbm5lY3QgcGFzc2VzIHRoZXNlIG9wdGlvbnMgdG9cbiAgICAgICAgICAgICAqIHRscy5jb25uZWN0IGJ1dCBub3QgbmV0LmNvbm5lY3QsIHNvIGluIHRoZSBpbnNlY3VyZSBjYXNlIHdlIHN0aWxsIG5lZWRcbiAgICAgICAgICAgICAqIHRvIHNldCB0aGUgY3JlYXRlQ29ubmVjdGlvbiBvcHRpb24gYWJvdmUgdG8gY3JlYXRlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgKiBleHBsaWNpdGx5LiBXZSBjYW5ub3QgZG8gdGhhdCBpbiB0aGUgVExTIGNhc2UgYmVjYXVzZSBodHRwMi5jb25uZWN0XG4gICAgICAgICAgICAgKiBwYXNzZXMgbmVjZXNzYXJ5IGFkZGl0aW9uYWwgb3B0aW9ucyB0byB0bHMuY29ubmVjdC5cbiAgICAgICAgICAgICAqIFRoZSBmaXJzdCBhcmd1bWVudCBqdXN0IG5lZWRzIHRvIGJlIHBhcnNlYWJsZSBhcyBhIFVSTCBhbmQgdGhlIHNjaGVtZVxuICAgICAgICAgICAgICogZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb25uZWN0aW9uIHdpbGwgYmUgZXN0YWJsaXNoZWQgb3ZlciBUTFMgb3Igbm90LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gaHR0cDIuY29ubmVjdChhZGRyZXNzU2NoZW1lICsgdGFyZ2V0QXV0aG9yaXR5LCBjb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdGYWlsZWQgdG8gY29ubmVjdCc7XG4gICAgICAgICAgICBzZXNzaW9uLnVucmVmKCk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBIdHRwMlRyYW5zcG9ydChzZXNzaW9uLCBhZGRyZXNzLCBvcHRpb25zLCByZW1vdGVOYW1lKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIExlYXZlIHRpbWUgZm9yIGVycm9yIGV2ZW50IHRvIGhhcHBlbiBiZWZvcmUgcmVqZWN0aW5nXG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGAke2Vycm9yTWVzc2FnZX0gKCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSlgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbmNlKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gZmFpbGVkIHdpdGggZXJyb3IgJyArIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QoYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuaXNTaHV0ZG93bikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogUGFzcyBjb25uZWN0aW9uIG9wdGlvbnMgdGhyb3VnaCB0byB0aGUgcHJveHkgc28gdGhhdCBpdCdzIGFibGUgdG9cbiAgICAgICAgICogdXBncmFkZSBpdCdzIGNvbm5lY3Rpb24gdG8gc3VwcG9ydCB0bHMgaWYgbmVlZGVkLlxuICAgICAgICAgKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjkyMlxuICAgICAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL3B1bGwvMTM2OSBmb3IgbW9yZSBpbmZvLiAqL1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uT3B0aW9ucyA9IGNyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHx8IHt9O1xuICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5BTFBOUHJvdG9jb2xzID0gWydoMiddO1xuICAgICAgICAgICAgLy8gSWYgcHJvdmlkZWQsIHRoZSB2YWx1ZSBvZiBncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgICAgLy8gdG8gb3ZlcnJpZGUgdGhlIHRhcmdldCBob3N0bmFtZSB3aGVuIGNoZWNraW5nIHNlcnZlciBpZGVudGl0eS5cbiAgICAgICAgICAgIC8vIFRoaXMgb3B0aW9uIGlzIHVzZWQgZm9yIHRlc3Rpbmcgb25seS5cbiAgICAgICAgICAgIGlmIChvcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3NsVGFyZ2V0TmFtZU92ZXJyaWRlID0gb3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID0gKGhvc3QsIGNlcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0bHNfMS5jaGVja1NlcnZlcklkZW50aXR5KShzc2xUYXJnZXROYW1lT3ZlcnJpZGUsIGNlcnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IHNzbFRhcmdldE5hbWVPdmVycmlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFRoaXMgaXMgbW9yZSBvciBsZXNzIGhvdyBzZXJ2ZXJuYW1lIHdpbGwgYmUgc2V0IGluIGNyZWF0ZVNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICogaWYgYSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCB0aHJvdWdoIHRoZSBwcm94eS5cbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIHByb3h5IGlzIG5vdCB1c2VkLCB0aGVzZSBjb25uZWN0aW9uT3B0aW9ucyBhcmUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgICAgICAqIGFueXdheSAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkoKF9hID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkob3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0J10pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnbG9jYWxob3N0JyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IChfYiA9IGhvc3RQb3J0ID09PSBudWxsIHx8IGhvc3RQb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3N0UG9ydC5ob3N0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0YXJnZXRQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zWydncnBjLW5vZGUudGxzX2VuYWJsZV90cmFjZSddKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuZW5hYmxlVHJhY2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaHR0cF9wcm94eV8xLmdldFByb3hpZWRDb25uZWN0aW9uKShhZGRyZXNzLCBvcHRpb25zLCBjb25uZWN0aW9uT3B0aW9ucykudGhlbihyZXN1bHQgPT4gdGhpcy5jcmVhdGVTZXNzaW9uKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zLCByZXN1bHQpKTtcbiAgICB9XG4gICAgc2h1dGRvd24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5pc1NodXRkb3duID0gdHJ1ZTtcbiAgICAgICAgKF9hID0gdGhpcy5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkh0dHAyU3ViY2hhbm5lbENvbm5lY3RvciA9IEh0dHAyU3ViY2hhbm5lbENvbm5lY3Rvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9ydC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJIdHRwMlN1YmNoYW5uZWxDb25uZWN0b3IiLCJodHRwMiIsInJlcXVpcmUiLCJ0bHNfMSIsImNoYW5uZWx6XzEiLCJjb25zdGFudHNfMSIsImh0dHBfcHJveHlfMSIsImxvZ2dpbmciLCJyZXNvbHZlcl8xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJ1cmlfcGFyc2VyXzEiLCJuZXQiLCJzdWJjaGFubmVsX2NhbGxfMSIsImNhbGxfbnVtYmVyXzEiLCJUUkFDRVJfTkFNRSIsIkZMT1dfQ09OVFJPTF9UUkFDRVJfTkFNRSIsImNsaWVudFZlcnNpb24iLCJ2ZXJzaW9uIiwiSFRUUDJfSEVBREVSX0FVVEhPUklUWSIsIkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUiLCJIVFRQMl9IRUFERVJfTUVUSE9EIiwiSFRUUDJfSEVBREVSX1BBVEgiLCJIVFRQMl9IRUFERVJfVEUiLCJIVFRQMl9IRUFERVJfVVNFUl9BR0VOVCIsImNvbnN0YW50cyIsIktFRVBBTElWRV9USU1FT1VUX01TIiwidG9vTWFueVBpbmdzRGF0YSIsIkJ1ZmZlciIsImZyb20iLCJIdHRwMlRyYW5zcG9ydCIsImNvbnN0cnVjdG9yIiwic2Vzc2lvbiIsInN1YmNoYW5uZWxBZGRyZXNzIiwib3B0aW9ucyIsInJlbW90ZU5hbWUiLCJrZWVwYWxpdmVUaW1lTXMiLCJrZWVwYWxpdmVUaW1lb3V0TXMiLCJrZWVwYWxpdmVUaW1lcklkIiwicGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nIiwia2VlcGFsaXZlVGltZW91dElkIiwia2VlcGFsaXZlV2l0aG91dENhbGxzIiwiYWN0aXZlQ2FsbHMiLCJTZXQiLCJkaXNjb25uZWN0TGlzdGVuZXJzIiwiZGlzY29ubmVjdEhhbmRsZWQiLCJjaGFubmVsekVuYWJsZWQiLCJzdHJlYW1UcmFja2VyIiwiQ2hhbm5lbHpDYWxsVHJhY2tlciIsImtlZXBhbGl2ZXNTZW50IiwibWVzc2FnZXNTZW50IiwibWVzc2FnZXNSZWNlaXZlZCIsImxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCIsImxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAiLCJzdWJjaGFubmVsQWRkcmVzc1N0cmluZyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJjaGFubmVselJlZiIsInJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQiLCJnZXRDaGFubmVsekluZm8iLCJ1c2VyQWdlbnQiLCJmaWx0ZXIiLCJlIiwiam9pbiIsIm9uY2UiLCJ0cmFjZSIsInN0b3BLZWVwYWxpdmVQaW5ncyIsImhhbmRsZURpc2Nvbm5lY3QiLCJlcnJvckNvZGUiLCJsYXN0U3RyZWFtSUQiLCJvcGFxdWVEYXRhIiwidG9vTWFueVBpbmdzIiwiTkdIVFRQMl9FTkhBTkNFX1lPVVJfQ0FMTSIsImVxdWFscyIsInRvU3RyaW5nIiwicmVwb3J0RGlzY29ubmVjdFRvT3duZXIiLCJlcnJvciIsIm1lc3NhZ2UiLCJpc1RyYWNlckVuYWJsZWQiLCJvbiIsInNldHRpbmdzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIiLCJfYSIsIl9iIiwiX2MiLCJzZXNzaW9uU29ja2V0Iiwic29ja2V0IiwicmVtb3RlQWRkcmVzcyIsInN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MiLCJyZW1vdGVQb3J0IiwibG9jYWxBZGRyZXNzIiwibG9jYWxQb3J0IiwidGxzSW5mbyIsImVuY3J5cHRlZCIsInRsc1NvY2tldCIsImNpcGhlckluZm8iLCJnZXRDaXBoZXIiLCJjZXJ0aWZpY2F0ZSIsImdldENlcnRpZmljYXRlIiwicGVlckNlcnRpZmljYXRlIiwiZ2V0UGVlckNlcnRpZmljYXRlIiwiY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJjaXBoZXJTdWl0ZU90aGVyTmFtZSIsIm5hbWUiLCJsb2NhbENlcnRpZmljYXRlIiwicmF3IiwicmVtb3RlQ2VydGlmaWNhdGUiLCJzb2NrZXRJbmZvIiwic2VjdXJpdHkiLCJzdHJlYW1zU3RhcnRlZCIsImNhbGxzU3RhcnRlZCIsInN0cmVhbXNTdWNjZWVkZWQiLCJjYWxsc1N1Y2NlZWRlZCIsInN0cmVhbXNGYWlsZWQiLCJjYWxsc0ZhaWxlZCIsImtlZXBBbGl2ZXNTZW50IiwibGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCIsImxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCIsImxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibG9jYWxGbG93Q29udHJvbFdpbmRvdyIsInN0YXRlIiwibG9jYWxXaW5kb3dTaXplIiwicmVtb3RlRmxvd0NvbnRyb2xXaW5kb3ciLCJyZW1vdGVXaW5kb3dTaXplIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiaWQiLCJrZWVwYWxpdmVUcmFjZSIsImZsb3dDb250cm9sVHJhY2UiLCJpbnRlcm5hbHNUcmFjZSIsImZvckVhY2giLCJsaXN0ZW5lciIsInNldEltbWVkaWF0ZSIsImNhbGwiLCJvbkRpc2Nvbm5lY3QiLCJhZGREaXNjb25uZWN0TGlzdGVuZXIiLCJwdXNoIiwiY2xlYXJLZWVwYWxpdmVUaW1lciIsImNsZWFyVGltZW91dCIsImNsZWFyS2VlcGFsaXZlVGltZW91dCIsImNhblNlbmRQaW5nIiwic2l6ZSIsIm1heWJlU2VuZFBpbmciLCJzZXRUaW1lb3V0IiwidW5yZWYiLCJwaW5nIiwiZXJyIiwiZHVyYXRpb24iLCJwYXlsb2FkIiwicmVtb3ZlQWN0aXZlQ2FsbCIsImRlbGV0ZSIsImFkZEFjdGl2ZUNhbGwiLCJhZGQiLCJyZWYiLCJjcmVhdGVDYWxsIiwibWV0YWRhdGEiLCJob3N0IiwibWV0aG9kIiwic3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIiLCJoZWFkZXJzIiwidG9IdHRwMkhlYWRlcnMiLCJodHRwMlN0cmVhbSIsInJlcXVlc3QiLCJjbG9zZWQiLCJkZXN0cm95ZWQiLCJldmVudFRyYWNrZXIiLCJhZGRDYWxsU3RhcnRlZCIsImFkZE1lc3NhZ2VTZW50IiwiRGF0ZSIsImFkZE1lc3NhZ2VSZWNlaXZlZCIsIm9uQ2FsbEVuZCIsInN0YXR1cyIsIm9uU3RyZWFtRW5kIiwic3VjY2VzcyIsImFkZENhbGxTdWNjZWVkZWQiLCJhZGRDYWxsRmFpbGVkIiwiSHR0cDJTdWJjaGFubmVsQ2FsbCIsImdldE5leHRDYWxsTnVtYmVyIiwiZ2V0Q2hhbm5lbHpSZWYiLCJnZXRQZWVyTmFtZSIsInNodXRkb3duIiwiY2xvc2UiLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJjaGFubmVsVGFyZ2V0IiwiaXNTaHV0ZG93biIsInVyaVRvU3RyaW5nIiwiY3JlYXRlU2Vzc2lvbiIsImFkZHJlc3MiLCJjcmVkZW50aWFscyIsInByb3h5Q29ubmVjdGlvblJlc3VsdCIsIlByb21pc2UiLCJyZWplY3QiLCJyZXNvbHZlIiwicmVhbFRhcmdldCIsInRhcmdldEF1dGhvcml0eSIsImdldERlZmF1bHRBdXRob3JpdHkiLCJjb25uZWN0aW9uT3B0aW9ucyIsIl9nZXRDb25uZWN0aW9uT3B0aW9ucyIsIm1heFNlbmRIZWFkZXJCbG9ja0xlbmd0aCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJtYXhTZXNzaW9uTWVtb3J5IiwiYWRkcmVzc1NjaGVtZSIsInNzbFRhcmdldE5hbWVPdmVycmlkZSIsImNoZWNrU2VydmVySWRlbnRpdHkiLCJjZXJ0Iiwic2VydmVybmFtZSIsImF1dGhvcml0eUhvc3RuYW1lIiwic3BsaXRIb3N0UG9ydCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJhdXRob3JpdHkiLCJvcHRpb24iLCJjb25uZWN0IiwiYXNzaWduIiwiZW5hYmxlVHJhY2UiLCJlcnJvck1lc3NhZ2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJ0b0lTT1N0cmluZyIsIkFMUE5Qcm90b2NvbHMiLCJ0YXJnZXRQYXRoIiwicGFyc2VVcmkiLCJwYXRoIiwiaG9zdFBvcnQiLCJnZXRQcm94aWVkQ29ubmVjdGlvbiIsInRoZW4iLCJyZXN1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/uri-parser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.uriToString = exports.splitHostPort = exports.parseUri = void 0;\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */ const URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\nfunction parseUri(uriString) {\n    const parsedUri = URI_REGEX.exec(uriString);\n    if (parsedUri === null) {\n        return null;\n    }\n    return {\n        scheme: parsedUri[1],\n        authority: parsedUri[2],\n        path: parsedUri[3]\n    };\n}\nexports.parseUri = parseUri;\nconst NUMBER_REGEX = /^\\d+$/;\nfunction splitHostPort(path) {\n    if (path.startsWith(\"[\")) {\n        const hostEnd = path.indexOf(\"]\");\n        if (hostEnd === -1) {\n            return null;\n        }\n        const host = path.substring(1, hostEnd);\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\n         * address should have at least one colon */ if (host.indexOf(\":\") === -1) {\n            return null;\n        }\n        if (path.length > hostEnd + 1) {\n            if (path[hostEnd + 1] === \":\") {\n                const portString = path.substring(hostEnd + 2);\n                if (NUMBER_REGEX.test(portString)) {\n                    return {\n                        host: host,\n                        port: +portString\n                    };\n                } else {\n                    return null;\n                }\n            } else {\n                return null;\n            }\n        } else {\n            return {\n                host\n            };\n        }\n    } else {\n        const splitPath = path.split(\":\");\n        /* Exactly one colon means that this is host:port. Zero colons means that\n         * there is no port. And multiple colons means that this is a bare IPv6\n         * address with no port */ if (splitPath.length === 2) {\n            if (NUMBER_REGEX.test(splitPath[1])) {\n                return {\n                    host: splitPath[0],\n                    port: +splitPath[1]\n                };\n            } else {\n                return null;\n            }\n        } else {\n            return {\n                host: path\n            };\n        }\n    }\n}\nexports.splitHostPort = splitHostPort;\nfunction uriToString(uri) {\n    let result = \"\";\n    if (uri.scheme !== undefined) {\n        result += uri.scheme + \":\";\n    }\n    if (uri.authority !== undefined) {\n        result += \"//\" + uri.authority + \"/\";\n    }\n    result += uri.path;\n    return result;\n}\nexports.uriToString = uriToString; //# sourceMappingURL=uri-parser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLHFCQUFxQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3RFOzs7OztDQUtDLEdBQ0QsTUFBTUssWUFBWTtBQUNsQixTQUFTRCxTQUFTRSxTQUFTO0lBQ3ZCLE1BQU1DLFlBQVlGLFVBQVVHLElBQUksQ0FBQ0Y7SUFDakMsSUFBSUMsY0FBYyxNQUFNO1FBQ3BCLE9BQU87SUFDWDtJQUNBLE9BQU87UUFDSEUsUUFBUUYsU0FBUyxDQUFDLEVBQUU7UUFDcEJHLFdBQVdILFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCSSxNQUFNSixTQUFTLENBQUMsRUFBRTtJQUN0QjtBQUNKO0FBQ0FQLGdCQUFnQixHQUFHSTtBQUNuQixNQUFNUSxlQUFlO0FBQ3JCLFNBQVNULGNBQWNRLElBQUk7SUFDdkIsSUFBSUEsS0FBS0UsVUFBVSxDQUFDLE1BQU07UUFDdEIsTUFBTUMsVUFBVUgsS0FBS0ksT0FBTyxDQUFDO1FBQzdCLElBQUlELFlBQVksQ0FBQyxHQUFHO1lBQ2hCLE9BQU87UUFDWDtRQUNBLE1BQU1FLE9BQU9MLEtBQUtNLFNBQVMsQ0FBQyxHQUFHSDtRQUMvQjtrREFDMEMsR0FDMUMsSUFBSUUsS0FBS0QsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO1lBQzFCLE9BQU87UUFDWDtRQUNBLElBQUlKLEtBQUtPLE1BQU0sR0FBR0osVUFBVSxHQUFHO1lBQzNCLElBQUlILElBQUksQ0FBQ0csVUFBVSxFQUFFLEtBQUssS0FBSztnQkFDM0IsTUFBTUssYUFBYVIsS0FBS00sU0FBUyxDQUFDSCxVQUFVO2dCQUM1QyxJQUFJRixhQUFhUSxJQUFJLENBQUNELGFBQWE7b0JBQy9CLE9BQU87d0JBQ0hILE1BQU1BO3dCQUNOSyxNQUFNLENBQUNGO29CQUNYO2dCQUNKLE9BQ0s7b0JBQ0QsT0FBTztnQkFDWDtZQUNKLE9BQ0s7Z0JBQ0QsT0FBTztZQUNYO1FBQ0osT0FDSztZQUNELE9BQU87Z0JBQ0hIO1lBQ0o7UUFDSjtJQUNKLE9BQ0s7UUFDRCxNQUFNTSxZQUFZWCxLQUFLWSxLQUFLLENBQUM7UUFDN0I7O2dDQUV3QixHQUN4QixJQUFJRCxVQUFVSixNQUFNLEtBQUssR0FBRztZQUN4QixJQUFJTixhQUFhUSxJQUFJLENBQUNFLFNBQVMsQ0FBQyxFQUFFLEdBQUc7Z0JBQ2pDLE9BQU87b0JBQ0hOLE1BQU1NLFNBQVMsQ0FBQyxFQUFFO29CQUNsQkQsTUFBTSxDQUFDQyxTQUFTLENBQUMsRUFBRTtnQkFDdkI7WUFDSixPQUNLO2dCQUNELE9BQU87WUFDWDtRQUNKLE9BQ0s7WUFDRCxPQUFPO2dCQUNITixNQUFNTDtZQUNWO1FBQ0o7SUFDSjtBQUNKO0FBQ0FYLHFCQUFxQixHQUFHRztBQUN4QixTQUFTRCxZQUFZc0IsR0FBRztJQUNwQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUQsSUFBSWYsTUFBTSxLQUFLaUIsV0FBVztRQUMxQkQsVUFBVUQsSUFBSWYsTUFBTSxHQUFHO0lBQzNCO0lBQ0EsSUFBSWUsSUFBSWQsU0FBUyxLQUFLZ0IsV0FBVztRQUM3QkQsVUFBVSxPQUFPRCxJQUFJZCxTQUFTLEdBQUc7SUFDckM7SUFDQWUsVUFBVUQsSUFBSWIsSUFBSTtJQUNsQixPQUFPYztBQUNYO0FBQ0F6QixtQkFBbUIsR0FBR0UsYUFDdEIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcz8yYWMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIwIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVyaVRvU3RyaW5nID0gZXhwb3J0cy5zcGxpdEhvc3RQb3J0ID0gZXhwb3J0cy5wYXJzZVVyaSA9IHZvaWQgMDtcbi8qXG4gKiBUaGUgZ3JvdXBzIGNvcnJlc3BvbmQgdG8gVVJJIHBhcnRzIGFzIGZvbGxvd3M6XG4gKiAxLiBzY2hlbWVcbiAqIDIuIGF1dGhvcml0eVxuICogMy4gcGF0aFxuICovXG5jb25zdCBVUklfUkVHRVggPSAvXig/OihbQS1aYS16MC05Ky4tXSspOik/KD86XFwvXFwvKFteL10qKVxcLyk/KC4rKSQvO1xuZnVuY3Rpb24gcGFyc2VVcmkodXJpU3RyaW5nKSB7XG4gICAgY29uc3QgcGFyc2VkVXJpID0gVVJJX1JFR0VYLmV4ZWModXJpU3RyaW5nKTtcbiAgICBpZiAocGFyc2VkVXJpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHBhcnNlZFVyaVsxXSxcbiAgICAgICAgYXV0aG9yaXR5OiBwYXJzZWRVcmlbMl0sXG4gICAgICAgIHBhdGg6IHBhcnNlZFVyaVszXSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZVVyaSA9IHBhcnNlVXJpO1xuY29uc3QgTlVNQkVSX1JFR0VYID0gL15cXGQrJC87XG5mdW5jdGlvbiBzcGxpdEhvc3RQb3J0KHBhdGgpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKCdbJykpIHtcbiAgICAgICAgY29uc3QgaG9zdEVuZCA9IHBhdGguaW5kZXhPZignXScpO1xuICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3QgPSBwYXRoLnN1YnN0cmluZygxLCBob3N0RW5kKTtcbiAgICAgICAgLyogT25seSBhbiBJUHY2IGFkZHJlc3Mgc2hvdWxkIGJlIGluIGJyYWNrZXRlZCBub3RhdGlvbiwgYW5kIGFuIElQdjZcbiAgICAgICAgICogYWRkcmVzcyBzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUgY29sb24gKi9cbiAgICAgICAgaWYgKGhvc3QuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gaG9zdEVuZCArIDEpIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2hvc3RFbmQgKyAxXSA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydFN0cmluZyA9IHBhdGguc3Vic3RyaW5nKGhvc3RFbmQgKyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoTlVNQkVSX1JFR0VYLnRlc3QocG9ydFN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiArcG9ydFN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3BsaXRQYXRoID0gcGF0aC5zcGxpdCgnOicpO1xuICAgICAgICAvKiBFeGFjdGx5IG9uZSBjb2xvbiBtZWFucyB0aGF0IHRoaXMgaXMgaG9zdDpwb3J0LiBaZXJvIGNvbG9ucyBtZWFucyB0aGF0XG4gICAgICAgICAqIHRoZXJlIGlzIG5vIHBvcnQuIEFuZCBtdWx0aXBsZSBjb2xvbnMgbWVhbnMgdGhhdCB0aGlzIGlzIGEgYmFyZSBJUHY2XG4gICAgICAgICAqIGFkZHJlc3Mgd2l0aCBubyBwb3J0ICovXG4gICAgICAgIGlmIChzcGxpdFBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoTlVNQkVSX1JFR0VYLnRlc3Qoc3BsaXRQYXRoWzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHNwbGl0UGF0aFswXSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogK3NwbGl0UGF0aFsxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5zcGxpdEhvc3RQb3J0ID0gc3BsaXRIb3N0UG9ydDtcbmZ1bmN0aW9uIHVyaVRvU3RyaW5nKHVyaSkge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBpZiAodXJpLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCArPSB1cmkuc2NoZW1lICsgJzonO1xuICAgIH1cbiAgICBpZiAodXJpLmF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCArPSAnLy8nICsgdXJpLmF1dGhvcml0eSArICcvJztcbiAgICB9XG4gICAgcmVzdWx0ICs9IHVyaS5wYXRoO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVyaVRvU3RyaW5nID0gdXJpVG9TdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmktcGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVyaVRvU3RyaW5nIiwic3BsaXRIb3N0UG9ydCIsInBhcnNlVXJpIiwiVVJJX1JFR0VYIiwidXJpU3RyaW5nIiwicGFyc2VkVXJpIiwiZXhlYyIsInNjaGVtZSIsImF1dGhvcml0eSIsInBhdGgiLCJOVU1CRVJfUkVHRVgiLCJzdGFydHNXaXRoIiwiaG9zdEVuZCIsImluZGV4T2YiLCJob3N0Iiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicG9ydFN0cmluZyIsInRlc3QiLCJwb3J0Iiwic3BsaXRQYXRoIiwic3BsaXQiLCJ1cmkiLCJyZXN1bHQiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer?bf1a\")[\"Buffer\"];\n\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.isAnyExtension = exports.Long = void 0;\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(rsc)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(rsc)/./node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(rsc)/./node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(rsc)/./node_modules/long/umd/index.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return \"@type\" in obj && typeof obj[\"@type\"] === \"string\";\n}\nexports.isAnyExtension = isAnyExtension;\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true\n};\nfunction joinName(baseName, name) {\n    if (baseName === \"\") {\n        return name;\n    } else {\n        return baseName + \".\" + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [\n            [\n                objName,\n                obj\n            ]\n        ];\n    } else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== \"undefined\") {\n            return Object.keys(obj.nested).map((name)=>{\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            }).reduce((accumulator, currentValue)=>accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */ const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: \"/\" + serviceName + \"/\" + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors)\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray){\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 DescriptorProto\",\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 EnumDescriptorProto\",\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */ function createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    } else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    } else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    } else {\n        throw new Error(\"Type mismatch in reflection object handling\");\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor(\"proto3\").file;\n    const bufferList = descriptorList.map((value)=>Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, \"\")){\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */ function load(filename, options) {\n    return (0, util_1.loadProtosWithOptions)(filename, options).then((loadedRoot)=>{\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n(0, util_1.addCommonProtos)(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUNBQXVDLEdBQUdBLHVDQUF1QyxHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLFlBQVksR0FBR0Esc0JBQXNCLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQ3RMLE1BQU1TLFlBQVlDLG1CQUFPQSxDQUFDLHdFQUFrQjtBQUM1QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyw0REFBWTtBQUNyQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywwRkFBMkI7QUFDdEQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMseUVBQVE7QUFDL0IsTUFBTUYsT0FBT0UsbUJBQU9BLENBQUMsb0RBQU07QUFDM0JWLFlBQVksR0FBR1E7QUFDZixTQUFTRCxlQUFlTyxHQUFHO0lBQ3ZCLE9BQU8sV0FBWUEsT0FBUyxPQUFPQSxHQUFHLENBQUMsUUFBUSxLQUFLO0FBQ3hEO0FBQ0FkLHNCQUFzQixHQUFHTztBQUN6QixNQUFNUSxvQkFBb0I7SUFDdEJDLE9BQU9DO0lBQ1BDLE9BQU9EO0lBQ1BFLE9BQU9GO0lBQ1BHLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxNQUFNO0FBQ1Y7QUFDQSxTQUFTQyxTQUFTQyxRQUFRLEVBQUVDLElBQUk7SUFDNUIsSUFBSUQsYUFBYSxJQUFJO1FBQ2pCLE9BQU9DO0lBQ1gsT0FDSztRQUNELE9BQU9ELFdBQVcsTUFBTUM7SUFDNUI7QUFDSjtBQUNBLFNBQVNDLDBCQUEwQlosR0FBRztJQUNsQyxPQUFRQSxlQUFlSCxTQUFTZ0IsT0FBTyxJQUNuQ2IsZUFBZUgsU0FBU2lCLElBQUksSUFDNUJkLGVBQWVILFNBQVNrQixJQUFJO0FBQ3BDO0FBQ0EsU0FBU0MsZ0JBQWdCaEIsR0FBRztJQUN4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O0FBQ0E3Qyx1Q0FBdUMsR0FBR0U7QUFDekMsSUFBR1csT0FBT2lHLGVBQWUsS0FDMUIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcz81ZmE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGV4cG9ydHMuZnJvbUpTT04gPSBleHBvcnRzLmxvYWRTeW5jID0gZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5pc0FueUV4dGVuc2lvbiA9IGV4cG9ydHMuTG9uZyA9IHZvaWQgMDtcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoXCJsb2Rhc2guY2FtZWxjYXNlXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmNvbnN0IGRlc2NyaXB0b3IgPSByZXF1aXJlKFwicHJvdG9idWZqcy9leHQvZGVzY3JpcHRvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBMb25nID0gcmVxdWlyZShcImxvbmdcIik7XG5leHBvcnRzLkxvbmcgPSBMb25nO1xuZnVuY3Rpb24gaXNBbnlFeHRlbnNpb24ob2JqKSB7XG4gICAgcmV0dXJuICgnQHR5cGUnIGluIG9iaikgJiYgKHR5cGVvZiBvYmpbJ0B0eXBlJ10gPT09ICdzdHJpbmcnKTtcbn1cbmV4cG9ydHMuaXNBbnlFeHRlbnNpb24gPSBpc0FueUV4dGVuc2lvbjtcbmNvbnN0IGRlc2NyaXB0b3JPcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgIG9uZW9mczogdHJ1ZSxcbiAgICBqc29uOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGpvaW5OYW1lKGJhc2VOYW1lLCBuYW1lKSB7XG4gICAgaWYgKGJhc2VOYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBiYXNlTmFtZSArICcuJyArIG5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZXNwYWNlQmFzZShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuTmFtZXNwYWNlIHx8IG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlJvb3Q7XG59XG5mdW5jdGlvbiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMob2JqLCBwYXJlbnROYW1lKSB7XG4gICAgY29uc3Qgb2JqTmFtZSA9IGpvaW5OYW1lKHBhcmVudE5hbWUsIG9iai5uYW1lKTtcbiAgICBpZiAoaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBbW29iak5hbWUsIG9ial1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlQmFzZShvYmopICYmIHR5cGVvZiBvYmoubmVzdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iai5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iai5uZXN0ZWRbbmFtZV0sIG9iak5hbWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvci5jb25jYXQoY3VycmVudFZhbHVlKSwgW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2VyaWFsaXplcihjbHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVzZXJpYWxpemUoYXJnQnVmKSB7XG4gICAgICAgIHJldHVybiBjbHMudG9PYmplY3QoY2xzLmRlY29kZShhcmdCdWYpLCBvcHRpb25zKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihjbHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VyaWFsaXplKGFyZykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXJpYWxpemUgbWVzc2FnZTogZXhwZWN0ZWQgb2JqZWN0IHdpdGggJHtjbHMubmFtZX0gc3RydWN0dXJlLCBnb3QgYXJyYXkgaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjbHMuZnJvbU9iamVjdChhcmcpO1xuICAgICAgICByZXR1cm4gY2xzLmVuY29kZShtZXNzYWdlKS5maW5pc2goKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIHNlcnZpY2VOYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICAvKiBUaGlzIGlzIG9ubHkgZXZlciBjYWxsZWQgYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgcm9vdC5yZXNvbHZlQWxsKCksIHNvIHdlXG4gICAgICogY2FuIGFzc3VtZSB0aGF0IHRoZSByZXNvbHZlZCByZXF1ZXN0IGFuZCByZXNwb25zZSB0eXBlcyBhcmUgbm9uLW51bGwgKi9cbiAgICBjb25zdCByZXF1ZXN0VHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlO1xuICAgIGNvbnN0IHJlc3BvbnNlVHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiAnLycgKyBzZXJ2aWNlTmFtZSArICcvJyArIG1ldGhvZC5uYW1lLFxuICAgICAgICByZXF1ZXN0U3RyZWFtOiAhIW1ldGhvZC5yZXF1ZXN0U3RyZWFtLFxuICAgICAgICByZXNwb25zZVN0cmVhbTogISFtZXRob2QucmVzcG9uc2VTdHJlYW0sXG4gICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVxdWVzdFR5cGUpLFxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXF1ZXN0VHlwZSwgb3B0aW9ucyksXG4gICAgICAgIHJlc3BvbnNlU2VyaWFsaXplOiBjcmVhdGVTZXJpYWxpemVyKHJlc3BvbnNlVHlwZSksXG4gICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXNwb25zZVR5cGUsIG9wdGlvbnMpLFxuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzXG4gICAgICAgIG9yaWdpbmFsTmFtZTogY2FtZWxDYXNlKG1ldGhvZC5uYW1lKSxcbiAgICAgICAgcmVxdWVzdFR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlcXVlc3RUeXBlLCBmaWxlRGVzY3JpcHRvcnMpLFxuICAgICAgICByZXNwb25zZVR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlc3BvbnNlVHlwZSwgZmlsZURlc2NyaXB0b3JzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VydmljZURlZmluaXRpb24oc2VydmljZSwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgZGVmID0ge307XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2Ygc2VydmljZS5tZXRob2RzQXJyYXkpIHtcbiAgICAgICAgZGVmW21ldGhvZC5uYW1lXSA9IGNyZWF0ZU1ldGhvZERlZmluaXRpb24obWV0aG9kLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZURlZmluaXRpb24obWVzc2FnZSwgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgbWVzc2FnZURlc2NyaXB0b3IgPSBtZXNzYWdlLnRvRGVzY3JpcHRvcigncHJvdG8zJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0OiAnUHJvdG9jb2wgQnVmZmVyIDMgRGVzY3JpcHRvclByb3RvJyxcbiAgICAgICAgdHlwZTogbWVzc2FnZURlc2NyaXB0b3IuJHR5cGUudG9PYmplY3QobWVzc2FnZURlc2NyaXB0b3IsIGRlc2NyaXB0b3JPcHRpb25zKSxcbiAgICAgICAgZmlsZURlc2NyaXB0b3JQcm90b3M6IGZpbGVEZXNjcmlwdG9ycyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRW51bURlZmluaXRpb24oZW51bVR5cGUsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IGVudW1EZXNjcmlwdG9yID0gZW51bVR5cGUudG9EZXNjcmlwdG9yKCdwcm90bzMnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXQ6ICdQcm90b2NvbCBCdWZmZXIgMyBFbnVtRGVzY3JpcHRvclByb3RvJyxcbiAgICAgICAgdHlwZTogZW51bURlc2NyaXB0b3IuJHR5cGUudG9PYmplY3QoZW51bURlc2NyaXB0b3IsIGRlc2NyaXB0b3JPcHRpb25zKSxcbiAgICAgICAgZmlsZURlc2NyaXB0b3JQcm90b3M6IGZpbGVEZXNjcmlwdG9ycyxcbiAgICB9O1xufVxuLyoqXG4gKiBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuU2VydmljZSwgbmFtZTogc3RyaW5nLCBvcHRpb25zOlxuICogT3B0aW9ucyk6IFNlcnZpY2VEZWZpbml0aW9uOyBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuVHlwZSxcbiAqIG5hbWU6IHN0cmluZywgb3B0aW9uczogT3B0aW9ucyk6IE1lc3NhZ2VUeXBlRGVmaW5pdGlvbjsgZnVuY3Rpb25cbiAqIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5FbnVtLCBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IE9wdGlvbnMpOlxuICogRW51bVR5cGVEZWZpbml0aW9uO1xuICovXG5mdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTWVzc2FnZURlZmluaXRpb24ob2JqLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbnVtRGVmaW5pdGlvbihvYmosIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgbWlzbWF0Y2ggaW4gcmVmbGVjdGlvbiBvYmplY3QgaGFuZGxpbmcnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihyb290LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmID0ge307XG4gICAgcm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgY29uc3QgZGVzY3JpcHRvckxpc3QgPSByb290LnRvRGVzY3JpcHRvcigncHJvdG8zJykuZmlsZTtcbiAgICBjb25zdCBidWZmZXJMaXN0ID0gZGVzY3JpcHRvckxpc3QubWFwKHZhbHVlID0+IEJ1ZmZlci5mcm9tKGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JQcm90by5lbmNvZGUodmFsdWUpLmZpbmlzaCgpKSk7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgb2JqXSBvZiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMocm9vdCwgJycpKSB7XG4gICAgICAgIGRlZltuYW1lXSA9IGNyZWF0ZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBidWZmZXJMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByb290ID0gUHJvdG9idWYuUm9vdC5mcm9tRGVzY3JpcHRvcihkZWNvZGVkRGVzY3JpcHRvclNldCk7XG4gICAgcm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKHJvb3QsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBMb2FkIGEgLnByb3RvIGZpbGUgd2l0aCB0aGUgc3BlY2lmaWVkIG9wdGlvbnMuXG4gKiBAcGFyYW0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGUgcGF0aHMgdG8gbG9hZC4gQ2FuIGJlIGFuIGFic29sdXRlIHBhdGhcbiAqICAgICBvciByZWxhdGl2ZSB0byBhbiBpbmNsdWRlIHBhdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5rZWVwQ2FzZSBQcmVzZXJ2ZSBmaWVsZCBuYW1lcy4gVGhlIGRlZmF1bHQgaXMgdG8gY2hhbmdlIHRoZW1cbiAqICAgICB0byBjYW1lbCBjYXNlLlxuICogQHBhcmFtIG9wdGlvbnMubG9uZ3MgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGxvbmdgIHZhbHVlcy5cbiAqICAgICBWYWxpZCBvcHRpb25zIGFyZSBgTnVtYmVyYCBhbmQgYFN0cmluZ2AuIERlZmF1bHRzIHRvIGEgYExvbmdgIG9iamVjdCB0eXBlXG4gKiAgICAgZnJvbSBhIGxpYnJhcnkuXG4gKiBAcGFyYW0gb3B0aW9ucy5lbnVtcyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgZW51bWAgdmFsdWVzLlxuICogICAgIFRoZSBvbmx5IHZhbGlkIG9wdGlvbiBpcyBgU3RyaW5nYC4gRGVmYXVsdHMgdG8gdGhlIG51bWVyaWMgdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucy5ieXRlcyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgYnl0ZXNgXG4gKiAgICAgdmFsdWVzLiBWYWxpZCBvcHRpb25zIGFyZSBgQXJyYXlgIGFuZCBgU3RyaW5nYC4gVGhlIGRlZmF1bHQgaXMgdG8gdXNlXG4gKiAgICAgYEJ1ZmZlcmAuXG4gKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0cyBTZXQgZGVmYXVsdCB2YWx1ZXMgb24gb3V0cHV0IG9iamVjdHMuIERlZmF1bHRzIHRvXG4gKiAgICAgYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLmFycmF5cyBTZXQgZW1wdHkgYXJyYXlzIGZvciBtaXNzaW5nIGFycmF5IHZhbHVlcyBldmVuIGlmXG4gKiAgICAgYGRlZmF1bHRzYCBpcyBgZmFsc2VgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMub2JqZWN0cyBTZXQgZW1wdHkgb2JqZWN0cyBmb3IgbWlzc2luZyBvYmplY3QgdmFsdWVzIGV2ZW4gaWZcbiAqICAgICBgZGVmYXVsdHNgIGlzIGBmYWxzZWAuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5vbmVvZnMgU2V0IHZpcnR1YWwgb25lb2YgcHJvcGVydGllcyB0byB0aGUgcHJlc2VudCBmaWVsZCdzXG4gKiAgICAgbmFtZVxuICogQHBhcmFtIG9wdGlvbnMuanNvbiBSZXByZXNlbnQgSW5maW5pdHkgYW5kIE5hTiBhcyBzdHJpbmdzIGluIGZsb2F0IGZpZWxkcyxcbiAqICAgICBhbmQgYXV0b21hdGljYWxseSBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLkFueSB2YWx1ZXMuXG4gKiBAcGFyYW0gb3B0aW9ucy5pbmNsdWRlRGlycyBQYXRocyB0byBzZWFyY2ggZm9yIGltcG9ydGVkIGAucHJvdG9gIGZpbGVzLlxuICovXG5mdW5jdGlvbiBsb2FkKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEubG9hZFByb3Rvc1dpdGhPcHRpb25zKShmaWxlbmFtZSwgb3B0aW9ucykudGhlbihsb2FkZWRSb290ID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9ICgwLCB1dGlsXzEubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYykoZmlsZW5hbWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubG9hZFN5bmMgPSBsb2FkU3luYztcbmZ1bmN0aW9uIGZyb21KU09OKGpzb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBsb2FkZWRSb290ID0gUHJvdG9idWYuUm9vdC5mcm9tSlNPTihqc29uKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmZyb21KU09OID0gZnJvbUpTT047XG5mdW5jdGlvbiBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyKGRlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWNvZGVkRGVzY3JpcHRvclNldCA9IGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JTZXQuZGVjb2RlKGRlc2NyaXB0b3JTZXQpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXI7XG5mdW5jdGlvbiBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0KGRlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWNvZGVkRGVzY3JpcHRvclNldCA9IGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JTZXQuZnJvbU9iamVjdChkZXNjcmlwdG9yU2V0KTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QgPSBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0O1xuKDAsIHV0aWxfMS5hZGRDb21tb25Qcm90b3MpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0IiwibG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciIsImZyb21KU09OIiwibG9hZFN5bmMiLCJsb2FkIiwiaXNBbnlFeHRlbnNpb24iLCJMb25nIiwiY2FtZWxDYXNlIiwicmVxdWlyZSIsIlByb3RvYnVmIiwiZGVzY3JpcHRvciIsInV0aWxfMSIsIm9iaiIsImRlc2NyaXB0b3JPcHRpb25zIiwibG9uZ3MiLCJTdHJpbmciLCJlbnVtcyIsImJ5dGVzIiwiZGVmYXVsdHMiLCJvbmVvZnMiLCJqc29uIiwiam9pbk5hbWUiLCJiYXNlTmFtZSIsIm5hbWUiLCJpc0hhbmRsZWRSZWZsZWN0aW9uT2JqZWN0IiwiU2VydmljZSIsIlR5cGUiLCJFbnVtIiwiaXNOYW1lc3BhY2VCYXNlIiwiTmFtZXNwYWNlIiwiUm9vdCIsImdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyIsInBhcmVudE5hbWUiLCJvYmpOYW1lIiwibmVzdGVkIiwia2V5cyIsIm1hcCIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwiY29uY2F0IiwiY3JlYXRlRGVzZXJpYWxpemVyIiwiY2xzIiwib3B0aW9ucyIsImRlc2VyaWFsaXplIiwiYXJnQnVmIiwidG9PYmplY3QiLCJkZWNvZGUiLCJjcmVhdGVTZXJpYWxpemVyIiwic2VyaWFsaXplIiwiYXJnIiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJtZXNzYWdlIiwiZnJvbU9iamVjdCIsImVuY29kZSIsImZpbmlzaCIsImNyZWF0ZU1ldGhvZERlZmluaXRpb24iLCJtZXRob2QiLCJzZXJ2aWNlTmFtZSIsImZpbGVEZXNjcmlwdG9ycyIsInJlcXVlc3RUeXBlIiwicmVzb2x2ZWRSZXF1ZXN0VHlwZSIsInJlc3BvbnNlVHlwZSIsInJlc29sdmVkUmVzcG9uc2VUeXBlIiwicGF0aCIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsInJlcXVlc3RTZXJpYWxpemUiLCJyZXF1ZXN0RGVzZXJpYWxpemUiLCJyZXNwb25zZVNlcmlhbGl6ZSIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJvcmlnaW5hbE5hbWUiLCJjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbiIsImNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uIiwic2VydmljZSIsImRlZiIsIm1ldGhvZHNBcnJheSIsIm1lc3NhZ2VEZXNjcmlwdG9yIiwidG9EZXNjcmlwdG9yIiwiZm9ybWF0IiwidHlwZSIsIiR0eXBlIiwiZmlsZURlc2NyaXB0b3JQcm90b3MiLCJjcmVhdGVFbnVtRGVmaW5pdGlvbiIsImVudW1UeXBlIiwiZW51bURlc2NyaXB0b3IiLCJjcmVhdGVEZWZpbml0aW9uIiwiY3JlYXRlUGFja2FnZURlZmluaXRpb24iLCJyb290IiwicmVzb2x2ZUFsbCIsImRlc2NyaXB0b3JMaXN0IiwiZmlsZSIsImJ1ZmZlckxpc3QiLCJCdWZmZXIiLCJmcm9tIiwiRmlsZURlc2NyaXB0b3JQcm90byIsImNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQiLCJkZWNvZGVkRGVzY3JpcHRvclNldCIsImZyb21EZXNjcmlwdG9yIiwiZmlsZW5hbWUiLCJsb2FkUHJvdG9zV2l0aE9wdGlvbnMiLCJ0aGVuIiwibG9hZGVkUm9vdCIsImxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMiLCJkZXNjcmlwdG9yU2V0IiwiRmlsZURlc2NyaXB0b3JTZXQiLCJhZGRDb21tb25Qcm90b3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(rsc)/./node_modules/process/browser.js\");\n\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(rsc)/./node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target)=>{\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths){\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            } catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error(\"The includeDirs option must be an array\"));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error(\"The includeDirs option must be an array\");\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */ function addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common(\"api\", apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"descriptor\", descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"source_context\", sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"type\", typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos; //# sourceMappingURL=util.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBR0EsaUNBQWlDLEdBQUdBLDZCQUE2QixHQUFHLEtBQUs7QUFDbkcsTUFBTUssS0FBS0MsbUJBQU9BLENBQUMsY0FBSTtBQUN2QixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyw0REFBWTtBQUNyQyxTQUFTRyx1QkFBdUJDLElBQUksRUFBRUMsWUFBWTtJQUM5QyxNQUFNQyxzQkFBc0JGLEtBQUtHLFdBQVc7SUFDNUNILEtBQUtHLFdBQVcsR0FBRyxDQUFDQyxRQUFRQztRQUN4QixJQUFJUixLQUFLUyxVQUFVLENBQUNELFNBQVM7WUFDekIsT0FBT0E7UUFDWDtRQUNBLEtBQUssTUFBTUUsYUFBYU4sYUFBYztZQUNsQyxNQUFNTyxXQUFXWCxLQUFLWSxJQUFJLENBQUNGLFdBQVdGO1lBQ3RDLElBQUk7Z0JBQ0FWLEdBQUdlLFVBQVUsQ0FBQ0YsVUFBVWIsR0FBR2dCLFNBQVMsQ0FBQ0MsSUFBSTtnQkFDekMsT0FBT0o7WUFDWCxFQUNBLE9BQU9LLEtBQUs7Z0JBQ1I7WUFDSjtRQUNKO1FBQ0FDLE9BQU9BLENBQUNDLFdBQVcsQ0FBQyxDQUFDLEVBQUVWLE9BQU8sdUNBQXVDLEVBQUVKLGFBQWEsQ0FBQztRQUNyRixPQUFPQyxvQkFBb0JFLFFBQVFDO0lBQ3ZDO0FBQ0o7QUFDQSxlQUFlWCxzQkFBc0JzQixRQUFRLEVBQUVDLE9BQU87SUFDbEQsTUFBTWpCLE9BQU8sSUFBSUYsU0FBU29CLElBQUk7SUFDOUJELFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFJLENBQUMsQ0FBQ0EsUUFBUUUsV0FBVyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSixRQUFRRSxXQUFXLEdBQUc7WUFDckMsT0FBT0csUUFBUUMsTUFBTSxDQUFDLElBQUlDLE1BQU07UUFDcEM7UUFDQXpCLHVCQUF1QkMsTUFBTWlCLFFBQVFFLFdBQVc7SUFDcEQ7SUFDQSxNQUFNTSxhQUFhLE1BQU16QixLQUFLMEIsSUFBSSxDQUFDVixVQUFVQztJQUM3Q1EsV0FBV0UsVUFBVTtJQUNyQixPQUFPRjtBQUNYO0FBQ0FuQyw2QkFBNkIsR0FBR0k7QUFDaEMsU0FBU0QsMEJBQTBCdUIsUUFBUSxFQUFFQyxPQUFPO0lBQ2hELE1BQU1qQixPQUFPLElBQUlGLFNBQVNvQixJQUFJO0lBQzlCRCxVQUFVQSxXQUFXLENBQUM7SUFDdEIsSUFBSSxDQUFDLENBQUNBLFFBQVFFLFdBQVcsRUFBRTtRQUN2QixJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0osUUFBUUUsV0FBVyxHQUFHO1lBQ3JDLE1BQU0sSUFBSUssTUFBTTtRQUNwQjtRQUNBekIsdUJBQXVCQyxNQUFNaUIsUUFBUUUsV0FBVztJQUNwRDtJQUNBLE1BQU1NLGFBQWF6QixLQUFLNEIsUUFBUSxDQUFDWixVQUFVQztJQUMzQ1EsV0FBV0UsVUFBVTtJQUNyQixPQUFPRjtBQUNYO0FBQ0FuQyxpQ0FBaUMsR0FBR0c7QUFDcEM7O0NBRUMsR0FDRCxTQUFTRDtJQUNMLDRFQUE0RTtJQUM1RSxxRUFBcUU7SUFDckUsbUVBQW1FO0lBQ25FLE1BQU1xQyxnQkFBZ0JqQyxtQkFBT0EsQ0FBQztJQUM5QixNQUFNa0MsdUJBQXVCbEMsbUJBQU9BLENBQUM7SUFDckMsTUFBTW1DLDBCQUEwQm5DLG1CQUFPQSxDQUFDO0lBQ3hDLE1BQU1vQyxpQkFBaUJwQyxtQkFBT0EsQ0FBQztJQUMvQkUsU0FBU21DLE1BQU0sQ0FBQyxPQUFPSixjQUFjSyxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07SUFDekVwQyxTQUFTbUMsTUFBTSxDQUFDLGNBQWNILHFCQUFxQkksTUFBTSxDQUFDQyxNQUFNLENBQUNELE1BQU0sQ0FBQ0UsUUFBUSxDQUFDRixNQUFNO0lBQ3ZGcEMsU0FBU21DLE1BQU0sQ0FBQyxrQkFBa0JGLHdCQUF3QkcsTUFBTSxDQUFDQyxNQUFNLENBQUNELE1BQU0sQ0FBQ0UsUUFBUSxDQUFDRixNQUFNO0lBQzlGcEMsU0FBU21DLE1BQU0sQ0FBQyxRQUFRRCxlQUFlRSxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07QUFDL0U7QUFDQTVDLHVCQUF1QixHQUFHRSxpQkFDMUIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXN0cnVjdGVwYXBlcnNfdjIvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzPzY0MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBleHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMgPSBleHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmZ1bmN0aW9uIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgaW5jbHVkZVBhdGhzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxSZXNvbHZlUGF0aCA9IHJvb3QucmVzb2x2ZVBhdGg7XG4gICAgcm9vdC5yZXNvbHZlUGF0aCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgICAgICBpZiAocGF0aC5pc0Fic29sdXRlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rvcnkgb2YgaW5jbHVkZVBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIHRhcmdldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLmFjY2Vzc1N5bmMoZnVsbFBhdGgsIGZzLmNvbnN0YW50cy5SX09LKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgJHt0YXJnZXR9IG5vdCBmb3VuZCBpbiBhbnkgb2YgdGhlIGluY2x1ZGUgcGF0aHMgJHtpbmNsdWRlUGF0aHN9YCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlc29sdmVQYXRoKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgcm9vdCA9IG5ldyBQcm90b2J1Zi5Sb290KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCEhb3B0aW9ucy5pbmNsdWRlRGlycykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlRGlycykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRSb290ID0gYXdhaXQgcm9vdC5sb2FkKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zID0gbG9hZFByb3Rvc1dpdGhPcHRpb25zO1xuZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUHJvdG9idWYuUm9vdCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZURpcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgb3B0aW9ucy5pbmNsdWRlRGlycyk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSByb290LmxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyA9IGxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmM7XG4vKipcbiAqIExvYWQgR29vZ2xlJ3Mgd2VsbC1rbm93biBwcm90byBmaWxlcyB0aGF0IGFyZW4ndCBleHBvc2VkIGJ5IFByb3RvYnVmLmpzLlxuICovXG5mdW5jdGlvbiBhZGRDb21tb25Qcm90b3MoKSB7XG4gICAgLy8gUHJvdG9idWYuanMgZXhwb3NlczogYW55LCBkdXJhdGlvbiwgZW1wdHksIGZpZWxkX21hc2ssIHN0cnVjdCwgdGltZXN0YW1wLFxuICAgIC8vIGFuZCB3cmFwcGVycy4gY29tcGlsZXIvcGx1Z2luIGlzIGV4Y2x1ZGVkIGluIFByb3RvYnVmLmpzIGFuZCBoZXJlLlxuICAgIC8vIFVzaW5nIGNvbnN0YW50IHN0cmluZ3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0b29scyBsaWtlIFdlYnBhY2tcbiAgICBjb25zdCBhcGlEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvYXBpLmpzb24nKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IuanNvbicpO1xuICAgIGNvbnN0IHNvdXJjZUNvbnRleHREZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQuanNvbicpO1xuICAgIGNvbnN0IHR5cGVEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvdHlwZS5qc29uJyk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdhcGknLCBhcGlEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdkZXNjcmlwdG9yJywgZGVzY3JpcHRvckRlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3NvdXJjZV9jb250ZXh0Jywgc291cmNlQ29udGV4dERlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3R5cGUnLCB0eXBlRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xufVxuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBhZGRDb21tb25Qcm90b3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZENvbW1vblByb3RvcyIsImxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMiLCJsb2FkUHJvdG9zV2l0aE9wdGlvbnMiLCJmcyIsInJlcXVpcmUiLCJwYXRoIiwiUHJvdG9idWYiLCJhZGRJbmNsdWRlUGF0aFJlc29sdmVyIiwicm9vdCIsImluY2x1ZGVQYXRocyIsIm9yaWdpbmFsUmVzb2x2ZVBhdGgiLCJyZXNvbHZlUGF0aCIsIm9yaWdpbiIsInRhcmdldCIsImlzQWJzb2x1dGUiLCJkaXJlY3RvcnkiLCJmdWxsUGF0aCIsImpvaW4iLCJhY2Nlc3NTeW5jIiwiY29uc3RhbnRzIiwiUl9PSyIsImVyciIsInByb2Nlc3MiLCJlbWl0V2FybmluZyIsImZpbGVuYW1lIiwib3B0aW9ucyIsIlJvb3QiLCJpbmNsdWRlRGlycyIsIkFycmF5IiwiaXNBcnJheSIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsImxvYWRlZFJvb3QiLCJsb2FkIiwicmVzb2x2ZUFsbCIsImxvYWRTeW5jIiwiYXBpRGVzY3JpcHRvciIsImRlc2NyaXB0b3JEZXNjcmlwdG9yIiwic291cmNlQ29udGV4dERlc2NyaXB0b3IiLCJ0eXBlRGVzY3JpcHRvciIsImNvbW1vbiIsIm5lc3RlZCIsImdvb2dsZSIsInByb3RvYnVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/package.json":
/*!*************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/package.json ***!
  \*************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"@grpc/grpc-js","version":"1.9.11","description":"gRPC Library for Node - pure JS implementation","homepage":"https://grpc.io/","repository":"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js","main":"build/src/index.js","engines":{"node":"^8.13.0 || >=10.10.0"},"keywords":[],"author":{"name":"Google Inc."},"types":"build/src/index.d.ts","license":"Apache-2.0","devDependencies":{"@types/gulp":"^4.0.6","@types/gulp-mocha":"0.0.32","@types/lodash":"^4.14.186","@types/mocha":"^5.2.6","@types/ncp":"^2.0.1","@types/pify":"^3.0.2","@types/semver":"^7.3.9","@typescript-eslint/eslint-plugin":"^5.59.11","@typescript-eslint/parser":"^5.59.11","@typescript-eslint/typescript-estree":"^5.59.11","clang-format":"^1.0.55","eslint":"^8.42.0","eslint-config-prettier":"^8.8.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.2.1","execa":"^2.0.3","gulp":"^4.0.2","gulp-mocha":"^6.0.0","lodash":"^4.17.4","madge":"^5.0.1","mocha-jenkins-reporter":"^0.4.1","ncp":"^2.0.0","pify":"^4.0.1","prettier":"^2.8.8","rimraf":"^3.0.2","semver":"^7.3.5","ts-node":"^10.9.1","typescript":"^5.1.3"},"contributors":[{"name":"Google Inc."}],"scripts":{"build":"npm run compile","clean":"rimraf ./build","compile":"tsc -p .","format":"clang-format -i -style=\\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\\" src/*.ts test/*.ts","lint":"eslint src/*.ts test/*.ts","prepare":"npm run generate-types && npm run compile","test":"gulp test","check":"npm run lint","fix":"eslint --fix src/*.ts test/*.ts","pretest":"npm run generate-types && npm run generate-test-types && npm run compile","posttest":"npm run check && madge -c ./build/src","generate-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto","generate-test-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"},"dependencies":{"@grpc/proto-loader":"^0.7.8","@types/node":">=12.12.47"},"files":["src/**/*.ts","build/src/**/*.{js,d.ts,js.map}","proto/*.proto","LICENSE","deps/envoy-api/envoy/api/v2/**/*.proto","deps/envoy-api/envoy/config/**/*.proto","deps/envoy-api/envoy/service/**/*.proto","deps/envoy-api/envoy/type/**/*.proto","deps/udpa/udpa/**/*.proto","deps/googleapis/google/api/*.proto","deps/googleapis/google/rpc/*.proto","deps/protoc-gen-validate/validate/**/*.proto"]}');

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/package.json":
/*!*************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/package.json ***!
  \*************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"@grpc/grpc-js","version":"1.9.11","description":"gRPC Library for Node - pure JS implementation","homepage":"https://grpc.io/","repository":"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js","main":"build/src/index.js","engines":{"node":"^8.13.0 || >=10.10.0"},"keywords":[],"author":{"name":"Google Inc."},"types":"build/src/index.d.ts","license":"Apache-2.0","devDependencies":{"@types/gulp":"^4.0.6","@types/gulp-mocha":"0.0.32","@types/lodash":"^4.14.186","@types/mocha":"^5.2.6","@types/ncp":"^2.0.1","@types/pify":"^3.0.2","@types/semver":"^7.3.9","@typescript-eslint/eslint-plugin":"^5.59.11","@typescript-eslint/parser":"^5.59.11","@typescript-eslint/typescript-estree":"^5.59.11","clang-format":"^1.0.55","eslint":"^8.42.0","eslint-config-prettier":"^8.8.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.2.1","execa":"^2.0.3","gulp":"^4.0.2","gulp-mocha":"^6.0.0","lodash":"^4.17.4","madge":"^5.0.1","mocha-jenkins-reporter":"^0.4.1","ncp":"^2.0.0","pify":"^4.0.1","prettier":"^2.8.8","rimraf":"^3.0.2","semver":"^7.3.5","ts-node":"^10.9.1","typescript":"^5.1.3"},"contributors":[{"name":"Google Inc."}],"scripts":{"build":"npm run compile","clean":"rimraf ./build","compile":"tsc -p .","format":"clang-format -i -style=\\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\\" src/*.ts test/*.ts","lint":"eslint src/*.ts test/*.ts","prepare":"npm run generate-types && npm run compile","test":"gulp test","check":"npm run lint","fix":"eslint --fix src/*.ts test/*.ts","pretest":"npm run generate-types && npm run generate-test-types && npm run compile","posttest":"npm run check && madge -c ./build/src","generate-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto","generate-test-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"},"dependencies":{"@grpc/proto-loader":"^0.7.8","@types/node":">=12.12.47"},"files":["src/**/*.ts","build/src/**/*.{js,d.ts,js.map}","proto/*.proto","LICENSE","deps/envoy-api/envoy/api/v2/**/*.proto","deps/envoy-api/envoy/config/**/*.proto","deps/envoy-api/envoy/service/**/*.proto","deps/envoy-api/envoy/type/**/*.proto","deps/udpa/udpa/**/*.proto","deps/googleapis/google/api/*.proto","deps/googleapis/google/rpc/*.proto","deps/protoc-gen-validate/validate/**/*.proto"]}');

/***/ })

};
;